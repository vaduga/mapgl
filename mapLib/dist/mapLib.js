var Jn = {}, rn = {}, Aa;
function kl() {
  if (Aa) return rn;
  Aa = 1, Object.defineProperty(rn, "__esModule", { value: !0 });
  class a {
    constructor(...i) {
      this._head = this._tail = null, this._length = 0, i.length > 0 && i.forEach((s) => {
        this.append(s);
      });
    }
    *iterator() {
      let i = this._head;
      for (; i; )
        yield i.value, i = i.next;
    }
    [Symbol.iterator]() {
      return this.iterator();
    }
    get head() {
      return this._head ? this._head.value : null;
    }
    get tail() {
      return this._tail ? this._tail.value : null;
    }
    get length() {
      return this._length;
    }
    // Adds the element at a specific position inside the linked list
    insert(i, s, n = !1) {
      if (n && this.isDuplicate(i))
        return !1;
      let r = new t(i), o = this._head;
      if (o)
        for (; ; ) {
          if (o.value === s)
            return r.next = o.next, r.prev = o, o.next = r, r.next ? r.next.prev = r : this._tail = r, this._length++, !0;
          if (o.next)
            o = o.next;
          else
            return !1;
        }
      else
        return !1;
    }
    // Adds the element at the end of the linked list
    append(i, s = !1) {
      if (s && this.isDuplicate(i))
        return !1;
      let n = new t(i);
      return this._tail ? (this._tail.next = n, n.prev = this._tail, this._tail = n) : this._head = this._tail = n, this._length++, !0;
    }
    // Add the element at the beginning of the linked list
    prepend(i, s = !1) {
      if (s && this.isDuplicate(i))
        return !1;
      let n = new t(i);
      return this._head ? (n.next = this._head, this._head.prev = n, this._head = n) : this._head = this._tail = n, this._length++, !0;
    }
    remove(i) {
      let s = this._head;
      if (s) {
        if (s.value === i)
          return this._head = s.next, this._head.prev = null, s.next = s.prev = null, this._length--, s.value;
        for (; ; ) {
          if (s.value === i)
            return s.next ? (s.prev.next = s.next, s.next.prev = s.prev, s.next = s.prev = null) : (s.prev.next = null, this._tail = s.prev, s.next = s.prev = null), this._length--, s.value;
          if (s.next)
            s = s.next;
          else
            return;
        }
      }
    }
    removeHead() {
      let i = this._head;
      if (i)
        return this._head.next ? (this._head.next.prev = null, this._head = this._head.next, i.next = i.prev = null) : (this._head = null, this._tail = null), this._length--, i.value;
    }
    removeTail() {
      let i = this._tail;
      if (i)
        return this._tail.prev ? (this._tail.prev.next = null, this._tail = this._tail.prev, i.next = i.prev = null) : (this._head = null, this._tail = null), this._length--, i.value;
    }
    first(i) {
      let s = this.iterator(), n = [], r = Math.min(i, this.length);
      for (let o = 0; o < r; o++) {
        let l = s.next();
        n.push(l.value);
      }
      return n;
    }
    toArray() {
      return [...this];
    }
    isDuplicate(i) {
      return new Set(this.toArray()).has(i);
    }
  }
  rn.LinkedList = a;
  class t {
    constructor(i) {
      this.value = i, this.next = null, this.prev = null;
    }
  }
  return rn.LinkedListItem = t, rn;
}
var Ta;
function cc() {
  if (Ta) return Jn;
  Ta = 1, Object.defineProperty(Jn, "__esModule", { value: !0 });
  const a = kl();
  class t extends a.LinkedList {
    constructor(...i) {
      super(...i);
    }
    get front() {
      return this.head;
    }
    enqueue(i) {
      this.append(i);
    }
    dequeue() {
      return this.removeHead();
    }
  }
  return Jn.Queue = t, Jn;
}
var We = cc();
let uc = class {
  //@ts-ignore
  static assert(t, e = null) {
    if (!t)
      throw e != null ? new Error(e) : new Error("condition does not hold");
  }
}, fr = class {
  static GeomObjectIndex = 0;
  static DrawingObjectIndex = 1;
  static AlgorithmDataIndex = 2;
  static ViewerIndex = 3;
  /// Extra from Mapgl
  static NodeDataIndex = 4;
  static EdgeDataIndex = 5;
}, Uo = class {
  constructor() {
    this.attrs = [], this._parent = null;
  }
  /** adds an event function */
  addEvent(t) {
    this.events.push(t);
  }
  /** trying to remove an event function */
  removeEvent(t) {
    const e = this.events.indexOf(t);
    e >= 0 && (this.events = this.events.splice(e, 1));
  }
  /** raises all available events on the given data */
  raiseEvents(t) {
    this.events.forEach((e) => e(t));
  }
  /** removes all the attributes form the entity */
  clearAttr() {
    this.attrs = [];
  }
  /** sets the attribute at the given position */
  setAttr(t, e) {
    this.attrs[t] = e;
  }
  /** gets the attribute at the given position */
  getAttr(t) {
    return this.attrs[t];
  }
  get parent() {
    return this._parent;
  }
  set parent(t) {
    this._parent = t;
  }
  *getAncestors() {
    let t = this.parent;
    for (; t != null; )
      yield t, t = t.parent;
  }
  /**  Determines if this node is a descendant of the given graph.*/
  isDescendantOf(t) {
    for (const e of this.getAncestors())
      if (e === t)
        return !0;
    return !1;
  }
};
class _l extends Uo {
  /** sets the attribute at the given position */
  setAttrProp(t, e, i) {
    const s = this.getAttr(t);
    s && (s[e] = i);
  }
}
var gn;
(function(a) {
  a[a.None = 0] = "None", a[a.FromAncestor = 1] = "FromAncestor", a[a.ToAncestor = 2] = "ToAncestor";
})(gn || (gn = {}));
let dc = class extends _l {
  _id;
  /** the unique, in the parent graph, id of the edge */
  get id() {
    return this._id;
  }
  _lineId;
  get lineId() {
    return this._lineId;
  }
  label;
  source;
  target;
  constructor(t, e, i) {
    super(), this._id = t, this.source = e, this.target = i, e !== i ? (e.outEdges.add(this), i.inEdges.add(this)) : e.selfEdges.add(this);
  }
  setLineId(t) {
    this._lineId = t;
  }
  get data() {
    return this.getAttr(fr.EdgeDataIndex);
  }
  setData(t) {
    this.setAttr(fr.EdgeDataIndex, t);
  }
  add() {
    this.source !== this.target ? (this.source.outEdges.add(this), this.target.inEdges.add(this)) : this.source.selfEdges.add(this);
  }
  remove() {
    this.source !== this.target ? (this.source.outEdges.delete(this), this.target.inEdges.delete(this)) : this.source.selfEdges.delete(this);
  }
  toString() {
    return "(" + this.source.toString() + "->" + this.target.toString() + ")";
  }
  isInterGraphEdge() {
    return this.source.parent !== this.target.parent;
  }
  EdgeToAncestor() {
    return this.source instanceof be && this.target.isDescendantOf(this.source) ? gn.FromAncestor : this.target instanceof be && this.source.isDescendantOf(this.target) ? gn.ToAncestor : gn.None;
  }
}, fc = class extends _l {
  removeOutEdge(t) {
    this.outEdges.delete(t);
  }
  removeInEdge(t) {
    this.inEdges.delete(t);
  }
  //@ts-ignore
  _id;
  /** the unique, in the parent graph, id of the node */
  get id() {
    return this._id;
  }
  set id(t) {
    this._id = t;
  }
  inEdges = /* @__PURE__ */ new Set();
  outEdges = /* @__PURE__ */ new Set();
  selfEdges = /* @__PURE__ */ new Set();
  toString() {
    return this.id;
  }
  constructor(t) {
    super(), this.id = t;
  }
  *_edges() {
    for (const t of this.inEdges)
      yield t;
    for (const t of this.outEdges)
      yield t;
    for (const t of this.selfEdges)
      yield t;
  }
  get edges() {
    return this._edges();
  }
  get outDegree() {
    return this.outEdges.size;
  }
  get inDegree() {
    return this.inEdges.size;
  }
  get selfDegree() {
    return this.selfEdges.size;
  }
  get degree() {
    return this.outDegree + this.inDegree + this.selfDegree;
  }
  get data() {
    return this.getAttr(fr.NodeDataIndex);
  }
  setData(t) {
    this.setAttr(fr.NodeDataIndex, t);
  }
};
var gc = {
  0: "Invalid value for configuration 'enforceActions', expected 'never', 'always' or 'observed'",
  1: function(t, e) {
    return "Cannot apply '" + t + "' to '" + e.toString() + "': Field not found.";
  },
  /*
  2(prop) {
      return `invalid decorator for '${prop.toString()}'`
  },
  3(prop) {
      return `Cannot decorate '${prop.toString()}': action can only be used on properties with a function value.`
  },
  4(prop) {
      return `Cannot decorate '${prop.toString()}': computed can only be used on getter properties.`
  },
  */
  5: "'keys()' can only be used on observable objects, arrays, sets and maps",
  6: "'values()' can only be used on observable objects, arrays, sets and maps",
  7: "'entries()' can only be used on observable objects, arrays and maps",
  8: "'set()' can only be used on observable objects, arrays and maps",
  9: "'remove()' can only be used on observable objects, arrays and maps",
  10: "'has()' can only be used on observable objects, arrays and maps",
  11: "'get()' can only be used on observable objects, arrays and maps",
  12: "Invalid annotation",
  13: "Dynamic observable objects cannot be frozen. If you're passing observables to 3rd party component/function that calls Object.freeze, pass copy instead: toJS(observable)",
  14: "Intercept handlers should return nothing or a change object",
  15: "Observable arrays cannot be frozen. If you're passing observables to 3rd party component/function that calls Object.freeze, pass copy instead: toJS(observable)",
  16: "Modification exception: the internal structure of an observable array was changed.",
  17: function(t, e) {
    return "[mobx.array] Index out of bounds, " + t + " is larger than " + e;
  },
  18: "mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js",
  19: function(t) {
    return "Cannot initialize from classes that inherit from Map: " + t.constructor.name;
  },
  20: function(t) {
    return "Cannot initialize map from " + t;
  },
  21: function(t) {
    return "Cannot convert to map from '" + t + "'";
  },
  22: "mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js",
  23: "It is not possible to get index atoms from arrays",
  24: function(t) {
    return "Cannot obtain administration from " + t;
  },
  25: function(t, e) {
    return "the entry '" + t + "' does not exist in the observable map '" + e + "'";
  },
  26: "please specify a property",
  27: function(t, e) {
    return "no observable property '" + t.toString() + "' found on the observable object '" + e + "'";
  },
  28: function(t) {
    return "Cannot obtain atom from " + t;
  },
  29: "Expecting some object",
  30: "invalid action stack. did you forget to finish an action?",
  31: "missing option for computed: get",
  32: function(t, e) {
    return "Cycle detected in computation " + t + ": " + e;
  },
  33: function(t) {
    return "The setter of computed value '" + t + "' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?";
  },
  34: function(t) {
    return "[ComputedValue '" + t + "'] It is not possible to assign a new value to a computed value.";
  },
  35: "There are multiple, different versions of MobX active. Make sure MobX is loaded only once or use `configure({ isolateGlobalState: true })`",
  36: "isolateGlobalState should be called before MobX is running any reactions",
  37: function(t) {
    return "[mobx] `observableArray." + t + "()` mutates the array in-place, which is not allowed inside a derivation. Use `array.slice()." + t + "()` instead";
  },
  38: "'ownKeys()' can only be used on observable objects",
  39: "'defineProperty()' can only be used on observable objects"
}, pc = gc;
function R(a) {
  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    e[i - 1] = arguments[i];
  {
    var s = typeof a == "string" ? a : pc[a];
    throw typeof s == "function" && (s = s.apply(null, e)), new Error("[MobX] " + s);
  }
}
var mc = {};
function Xo() {
  return typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : mc;
}
var Wl = Object.assign, gr = Object.getOwnPropertyDescriptor, ci = Object.defineProperty, zr = Object.prototype, pr = [];
Object.freeze(pr);
var Hl = {};
Object.freeze(Hl);
var Pc = typeof Proxy < "u", Sc = /* @__PURE__ */ Object.toString();
function zl() {
  Pc || R("`Proxy` objects are not available in the current environment. Please configure MobX to enable a fallback implementation.`");
}
function on(a) {
  A.verifyProxies && R("MobX is currently configured to be able to run in ES5 mode, but in ES5 MobX won't be able to " + a);
}
function si() {
  return ++A.mobxGuid;
}
function Qo(a) {
  var t = !1;
  return function() {
    if (!t)
      return t = !0, a.apply(this, arguments);
  };
}
var xs = function() {
};
function Lt(a) {
  return typeof a == "function";
}
function Ps(a) {
  var t = typeof a;
  switch (t) {
    case "string":
    case "symbol":
    case "number":
      return !0;
  }
  return !1;
}
function jr(a) {
  return a !== null && typeof a == "object";
}
function gi(a) {
  if (!jr(a))
    return !1;
  var t = Object.getPrototypeOf(a);
  if (t == null)
    return !0;
  var e = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return typeof e == "function" && e.toString() === Sc;
}
function jl(a) {
  var t = a?.constructor;
  return t ? t.name === "GeneratorFunction" || t.displayName === "GeneratorFunction" : !1;
}
function qr(a, t, e) {
  ci(a, t, {
    enumerable: !1,
    writable: !0,
    configurable: !0,
    value: e
  });
}
function ql(a, t, e) {
  ci(a, t, {
    enumerable: !1,
    writable: !1,
    configurable: !0,
    value: e
  });
}
function Es(a, t) {
  var e = "isMobX" + a;
  return t.prototype[e] = !0, function(i) {
    return jr(i) && i[e] === !0;
  };
}
function Zs(a) {
  return a != null && Object.prototype.toString.call(a) === "[object Map]";
}
function yc(a) {
  var t = Object.getPrototypeOf(a), e = Object.getPrototypeOf(t), i = Object.getPrototypeOf(e);
  return i === null;
}
function wi(a) {
  return a != null && Object.prototype.toString.call(a) === "[object Set]";
}
var Ul = typeof Object.getOwnPropertySymbols < "u";
function bc(a) {
  var t = Object.keys(a);
  if (!Ul)
    return t;
  var e = Object.getOwnPropertySymbols(a);
  return e.length ? [].concat(t, e.filter(function(i) {
    return zr.propertyIsEnumerable.call(a, i);
  })) : t;
}
var Ur = typeof Reflect < "u" && Reflect.ownKeys ? Reflect.ownKeys : Ul ? function(a) {
  return Object.getOwnPropertyNames(a).concat(Object.getOwnPropertySymbols(a));
} : (
  /* istanbul ignore next */
  Object.getOwnPropertyNames
);
function Ao(a) {
  return typeof a == "string" ? a : typeof a == "symbol" ? a.toString() : new String(a).toString();
}
function Xl(a) {
  return a === null ? null : typeof a == "object" ? "" + a : a;
}
function De(a, t) {
  return zr.hasOwnProperty.call(a, t);
}
var vc = Object.getOwnPropertyDescriptors || function(t) {
  var e = {};
  return Ur(t).forEach(function(i) {
    e[i] = gr(t, i);
  }), e;
};
function ve(a, t) {
  return !!(a & t);
}
function Ce(a, t, e) {
  return e ? a |= t : a &= ~t, a;
}
function Oa(a, t) {
  (t == null || t > a.length) && (t = a.length);
  for (var e = 0, i = Array(t); e < t; e++) i[e] = a[e];
  return i;
}
function Cc(a, t) {
  for (var e = 0; e < t.length; e++) {
    var i = t[e];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(a, Ec(i.key), i);
  }
}
function $s(a, t, e) {
  return t && Cc(a.prototype, t), Object.defineProperty(a, "prototype", {
    writable: !1
  }), a;
}
function Ls(a, t) {
  var e = typeof Symbol < "u" && a[Symbol.iterator] || a["@@iterator"];
  if (e) return (e = e.call(a)).next.bind(e);
  if (Array.isArray(a) || (e = wc(a)) || t) {
    e && (a = e);
    var i = 0;
    return function() {
      return i >= a.length ? {
        done: !0
      } : {
        done: !1,
        value: a[i++]
      };
    };
  }
  throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Ri() {
  return Ri = Object.assign ? Object.assign.bind() : function(a) {
    for (var t = 1; t < arguments.length; t++) {
      var e = arguments[t];
      for (var i in e) ({}).hasOwnProperty.call(e, i) && (a[i] = e[i]);
    }
    return a;
  }, Ri.apply(null, arguments);
}
function Ql(a, t) {
  a.prototype = Object.create(t.prototype), a.prototype.constructor = a, To(a, t);
}
function To(a, t) {
  return To = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, i) {
    return e.__proto__ = i, e;
  }, To(a, t);
}
function Ic(a, t) {
  if (typeof a != "object" || !a) return a;
  var e = a[Symbol.toPrimitive];
  if (e !== void 0) {
    var i = e.call(a, t);
    if (typeof i != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(a);
}
function Ec(a) {
  var t = Ic(a, "string");
  return typeof t == "symbol" ? t : t + "";
}
function wc(a, t) {
  if (a) {
    if (typeof a == "string") return Oa(a, t);
    var e = {}.toString.call(a).slice(8, -1);
    return e === "Object" && a.constructor && (e = a.constructor.name), e === "Map" || e === "Set" ? Array.from(a) : e === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e) ? Oa(a, t) : void 0;
  }
}
var he = /* @__PURE__ */ Symbol("mobx-stored-annotations");
function ui(a) {
  function t(e, i) {
    if (zn(i))
      return a.decorate_20223_(e, i);
    Hn(e, i, a);
  }
  return Object.assign(t, a);
}
function Hn(a, t, e) {
  if (De(a, he) || qr(a, he, Ri({}, a[he])), Pr(e) && !De(a[he], t)) {
    var i = a.constructor.name + ".prototype." + t.toString();
    R("'" + i + "' is decorated with 'override', but no such decorated member was found on prototype.");
  }
  Ac(a, e, t), Pr(e) || (a[he][t] = e);
}
function Ac(a, t, e) {
  if (!Pr(t) && De(a[he], e)) {
    var i = a.constructor.name + ".prototype." + e.toString(), s = a[he][e].annotationType_, n = t.annotationType_;
    R("Cannot apply '@" + n + "' to '" + i + "':" + (`
The field is already decorated with '@` + s + "'.") + `
Re-decorating fields is not allowed.
Use '@override' decorator for methods overridden by subclass.`);
  }
}
function Tc(a) {
  return De(a, he) || qr(a, he, Ri({}, a[he])), a[he];
}
function zn(a) {
  return typeof a == "object" && typeof a.kind == "string";
}
function Xr(a, t) {
  t.includes(a.kind) || R("The decorator applied to '" + String(a.name) + "' cannot be used on a " + a.kind + " element");
}
var k = /* @__PURE__ */ Symbol("mobx administration"), ts = /* @__PURE__ */ (function() {
  function a(e) {
    e === void 0 && (e = "Atom@" + si()), this.name_ = void 0, this.flags_ = 0, this.observers_ = /* @__PURE__ */ new Set(), this.lastAccessedBy_ = 0, this.lowestObserverState_ = J.NOT_TRACKING_, this.onBOL = void 0, this.onBUOL = void 0, this.name_ = e;
  }
  var t = a.prototype;
  return t.onBO = function() {
    this.onBOL && this.onBOL.forEach(function(i) {
      return i();
    });
  }, t.onBUO = function() {
    this.onBUOL && this.onBUOL.forEach(function(i) {
      return i();
    });
  }, t.reportObserved = function() {
    return hh(this);
  }, t.reportChanged = function() {
    Me(), ch(this), Fe();
  }, t.toString = function() {
    return this.name_;
  }, $s(a, [{
    key: "isBeingObserved",
    get: function() {
      return ve(this.flags_, a.isBeingObservedMask_);
    },
    set: function(i) {
      this.flags_ = Ce(this.flags_, a.isBeingObservedMask_, i);
    }
  }, {
    key: "isPendingUnobservation",
    get: function() {
      return ve(this.flags_, a.isPendingUnobservationMask_);
    },
    set: function(i) {
      this.flags_ = Ce(this.flags_, a.isPendingUnobservationMask_, i);
    }
  }, {
    key: "diffValue",
    get: function() {
      return ve(this.flags_, a.diffValueMask_) ? 1 : 0;
    },
    set: function(i) {
      this.flags_ = Ce(this.flags_, a.diffValueMask_, i === 1);
    }
  }]);
})();
ts.isBeingObservedMask_ = 1;
ts.isPendingUnobservationMask_ = 2;
ts.diffValueMask_ = 4;
var Yo = /* @__PURE__ */ Es("Atom", ts);
function Yl(a, t, e) {
  t === void 0 && (t = xs), e === void 0 && (e = xs);
  var i = new ts(a);
  return t !== xs && Du(i, t), e !== xs && mh(i, e), i;
}
function Oc(a, t) {
  return Oh(a, t);
}
function xc(a, t) {
  return Object.is ? Object.is(a, t) : a === t ? a !== 0 || 1 / a === 1 / t : a !== a && t !== t;
}
var mr = {
  structural: Oc,
  default: xc
};
function Ss(a, t, e) {
  return On(a) ? a : Array.isArray(a) ? It.array(a, {
    name: e
  }) : gi(a) ? It.object(a, void 0, {
    name: e
  }) : Zs(a) ? It.map(a, {
    name: e
  }) : wi(a) ? It.set(a, {
    name: e
  }) : typeof a == "function" && !vs(a) && !Tn(a) ? jl(a) ? Ws(a) : An(e, a) : a;
}
function Lc(a, t, e) {
  if (a == null || Xn(a) || Kr(a) || es(a) || ai(a))
    return a;
  if (Array.isArray(a))
    return It.array(a, {
      name: e,
      deep: !1
    });
  if (gi(a))
    return It.object(a, void 0, {
      name: e,
      deep: !1
    });
  if (Zs(a))
    return It.map(a, {
      name: e,
      deep: !1
    });
  if (wi(a))
    return It.set(a, {
      name: e,
      deep: !1
    });
  R("The shallow modifier / decorator can only used in combination with arrays, objects, maps and sets");
}
function Qr(a) {
  return a;
}
function Rc(a, t) {
  return On(a) && R("observable.struct should not be used with observable values"), Oh(a, t) ? t : a;
}
var Nc = "override";
function Pr(a) {
  return a.annotationType_ === Nc;
}
function jn(a, t) {
  return {
    annotationType_: a,
    options_: t,
    make_: Bc,
    extend_: Gc,
    decorate_20223_: Mc
  };
}
function Bc(a, t, e, i) {
  var s;
  if ((s = this.options_) != null && s.bound)
    return this.extend_(a, t, e, !1) === null ? 0 : 1;
  if (i === a.target_)
    return this.extend_(a, t, e, !1) === null ? 0 : 2;
  if (vs(e.value))
    return 1;
  var n = Jl(a, this, t, e, !1);
  return ci(i, t, n), 2;
}
function Gc(a, t, e, i) {
  var s = Jl(a, this, t, e);
  return a.defineProperty_(t, s, i);
}
function Mc(a, t) {
  Xr(t, ["method", "field"]);
  var e = t.kind, i = t.name, s = t.addInitializer, n = this, r = function(h) {
    var c, d, f, p;
    return ys((c = (d = n.options_) == null ? void 0 : d.name) != null ? c : i.toString(), h, (f = (p = n.options_) == null ? void 0 : p.autoAction) != null ? f : !1);
  };
  if (e == "field")
    return function(l) {
      var h, c = l;
      return vs(c) || (c = r(c)), (h = n.options_) != null && h.bound && (c = c.bind(this), c.isMobxAction = !0), c;
    };
  if (e == "method") {
    var o;
    return vs(a) || (a = r(a)), (o = this.options_) != null && o.bound && s(function() {
      var l = this, h = l[i].bind(l);
      h.isMobxAction = !0, l[i] = h;
    }), a;
  }
  R("Cannot apply '" + n.annotationType_ + "' to '" + String(i) + "' (kind: " + e + "):" + (`
'` + n.annotationType_ + "' can only be used on properties with a function value."));
}
function Fc(a, t, e, i) {
  var s = t.annotationType_, n = i.value;
  Lt(n) || R("Cannot apply '" + s + "' to '" + a.name_ + "." + e.toString() + "':" + (`
'` + s + "' can only be used on properties with a function value."));
}
function Jl(a, t, e, i, s) {
  var n, r, o, l, h, c, d;
  s === void 0 && (s = A.safeDescriptors), Fc(a, t, e, i);
  var f = i.value;
  if ((n = t.options_) != null && n.bound) {
    var p;
    f = f.bind((p = a.proxy_) != null ? p : a.target_);
  }
  return {
    value: ys(
      (r = (o = t.options_) == null ? void 0 : o.name) != null ? r : e.toString(),
      f,
      (l = (h = t.options_) == null ? void 0 : h.autoAction) != null ? l : !1,
      // https://github.com/mobxjs/mobx/discussions/3140
      (c = t.options_) != null && c.bound ? (d = a.proxy_) != null ? d : a.target_ : void 0
    ),
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: s ? a.isPlainObject_ : !0,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: !1,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: !s
  };
}
function Kl(a, t) {
  return {
    annotationType_: a,
    options_: t,
    make_: Vc,
    extend_: Dc,
    decorate_20223_: kc
  };
}
function Vc(a, t, e, i) {
  var s;
  if (i === a.target_)
    return this.extend_(a, t, e, !1) === null ? 0 : 2;
  if ((s = this.options_) != null && s.bound && (!De(a.target_, t) || !Tn(a.target_[t])) && this.extend_(a, t, e, !1) === null)
    return 0;
  if (Tn(e.value))
    return 1;
  var n = Zl(a, this, t, e, !1, !1);
  return ci(i, t, n), 2;
}
function Dc(a, t, e, i) {
  var s, n = Zl(a, this, t, e, (s = this.options_) == null ? void 0 : s.bound);
  return a.defineProperty_(t, n, i);
}
function kc(a, t) {
  var e;
  Xr(t, ["method"]);
  var i = t.name, s = t.addInitializer;
  return Tn(a) || (a = Ws(a)), (e = this.options_) != null && e.bound && s(function() {
    var n = this, r = n[i].bind(n);
    r.isMobXFlow = !0, n[i] = r;
  }), a;
}
function _c(a, t, e, i) {
  var s = t.annotationType_, n = i.value;
  Lt(n) || R("Cannot apply '" + s + "' to '" + a.name_ + "." + e.toString() + "':" + (`
'` + s + "' can only be used on properties with a generator function value."));
}
function Zl(a, t, e, i, s, n) {
  n === void 0 && (n = A.safeDescriptors), _c(a, t, e, i);
  var r = i.value;
  if (Tn(r) || (r = Ws(r)), s) {
    var o;
    r = r.bind((o = a.proxy_) != null ? o : a.target_), r.isMobXFlow = !0;
  }
  return {
    value: r,
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: n ? a.isPlainObject_ : !0,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: !1,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: !n
  };
}
function Jo(a, t) {
  return {
    annotationType_: a,
    options_: t,
    make_: Wc,
    extend_: Hc,
    decorate_20223_: zc
  };
}
function Wc(a, t, e) {
  return this.extend_(a, t, e, !1) === null ? 0 : 1;
}
function Hc(a, t, e, i) {
  return jc(a, this, t, e), a.defineComputedProperty_(t, Ri({}, this.options_, {
    get: e.get,
    set: e.set
  }), i);
}
function zc(a, t) {
  Xr(t, ["getter"]);
  var e = this, i = t.name, s = t.addInitializer;
  return s(function() {
    var n = tn(this)[k], r = Ri({}, e.options_, {
      get: a,
      context: this
    });
    r.name || (r.name = n.name_ + "." + i.toString()), n.values_.set(i, new He(r));
  }), function() {
    return this[k].getObservablePropValue_(i);
  };
}
function jc(a, t, e, i) {
  var s = t.annotationType_, n = i.get;
  n || R("Cannot apply '" + s + "' to '" + a.name_ + "." + e.toString() + "':" + (`
'` + s + "' can only be used on getter(+setter) properties."));
}
function Yr(a, t) {
  return {
    annotationType_: a,
    options_: t,
    make_: qc,
    extend_: Uc,
    decorate_20223_: Xc
  };
}
function qc(a, t, e) {
  return this.extend_(a, t, e, !1) === null ? 0 : 1;
}
function Uc(a, t, e, i) {
  var s, n;
  return Qc(a, this, t, e), a.defineObservableProperty_(t, e.value, (s = (n = this.options_) == null ? void 0 : n.enhancer) != null ? s : Ss, i);
}
function Xc(a, t) {
  {
    if (t.kind === "field")
      throw R("Please use `@observable accessor " + String(t.name) + "` instead of `@observable " + String(t.name) + "`");
    Xr(t, ["accessor"]);
  }
  var e = this, i = t.kind, s = t.name, n = /* @__PURE__ */ new WeakSet();
  function r(o, l) {
    var h, c, d = tn(o)[k], f = new ds(l, (h = (c = e.options_) == null ? void 0 : c.enhancer) != null ? h : Ss, d.name_ + "." + s.toString(), !1);
    d.values_.set(s, f), n.add(o);
  }
  if (i == "accessor")
    return {
      get: function() {
        return n.has(this) || r(this, a.get.call(this)), this[k].getObservablePropValue_(s);
      },
      set: function(l) {
        return n.has(this) || r(this, l), this[k].setObservablePropValue_(s, l);
      },
      init: function(l) {
        return n.has(this) || r(this, l), l;
      }
    };
}
function Qc(a, t, e, i) {
  var s = t.annotationType_;
  "value" in i || R("Cannot apply '" + s + "' to '" + a.name_ + "." + e.toString() + "':" + (`
'` + s + "' cannot be used on getter/setter properties"));
}
var Yc = "true", Jc = /* @__PURE__ */ $l();
function $l(a) {
  return {
    annotationType_: Yc,
    options_: a,
    make_: Kc,
    extend_: Zc,
    decorate_20223_: $c
  };
}
function Kc(a, t, e, i) {
  var s, n;
  if (e.get)
    return li.make_(a, t, e, i);
  if (e.set) {
    var r = vs(e.set) ? e.set : ys(t.toString(), e.set);
    return i === a.target_ ? a.defineProperty_(t, {
      configurable: A.safeDescriptors ? a.isPlainObject_ : !0,
      set: r
    }) === null ? 0 : 2 : (ci(i, t, {
      configurable: !0,
      set: r
    }), 2);
  }
  if (i !== a.target_ && typeof e.value == "function") {
    var o;
    if (jl(e.value)) {
      var l, h = (l = this.options_) != null && l.autoBind ? Ws.bound : Ws;
      return h.make_(a, t, e, i);
    }
    var c = (o = this.options_) != null && o.autoBind ? An.bound : An;
    return c.make_(a, t, e, i);
  }
  var d = ((s = this.options_) == null ? void 0 : s.deep) === !1 ? It.ref : It;
  if (typeof e.value == "function" && (n = this.options_) != null && n.autoBind) {
    var f;
    e.value = e.value.bind((f = a.proxy_) != null ? f : a.target_);
  }
  return d.make_(a, t, e, i);
}
function Zc(a, t, e, i) {
  var s, n;
  if (e.get)
    return li.extend_(a, t, e, i);
  if (e.set)
    return a.defineProperty_(t, {
      configurable: A.safeDescriptors ? a.isPlainObject_ : !0,
      set: ys(t.toString(), e.set)
    }, i);
  if (typeof e.value == "function" && (s = this.options_) != null && s.autoBind) {
    var r;
    e.value = e.value.bind((r = a.proxy_) != null ? r : a.target_);
  }
  var o = ((n = this.options_) == null ? void 0 : n.deep) === !1 ? It.ref : It;
  return o.extend_(a, t, e, i);
}
function $c(a, t) {
  R("'" + this.annotationType_ + "' cannot be used as a decorator");
}
var tu = "observable", eu = "observable.ref", iu = "observable.shallow", su = "observable.struct", th = {
  deep: !0,
  name: void 0,
  defaultDecorator: void 0,
  proxy: !0
};
Object.freeze(th);
function Kn(a) {
  return a || th;
}
var Oo = /* @__PURE__ */ Yr(tu), nu = /* @__PURE__ */ Yr(eu, {
  enhancer: Qr
}), ru = /* @__PURE__ */ Yr(iu, {
  enhancer: Lc
}), ou = /* @__PURE__ */ Yr(su, {
  enhancer: Rc
}), eh = /* @__PURE__ */ ui(Oo);
function Zn(a) {
  return a.deep === !0 ? Ss : a.deep === !1 ? Qr : lu(a.defaultDecorator);
}
function au(a) {
  var t;
  return a ? (t = a.defaultDecorator) != null ? t : $l(a) : void 0;
}
function lu(a) {
  var t, e;
  return a && (t = (e = a.options_) == null ? void 0 : e.enhancer) != null ? t : Ss;
}
function ih(a, t, e) {
  if (zn(t))
    return Oo.decorate_20223_(a, t);
  if (Ps(t)) {
    Hn(a, t, Oo);
    return;
  }
  return On(a) ? a : gi(a) ? It.object(a, t, e) : Array.isArray(a) ? It.array(a, t) : Zs(a) ? It.map(a, t) : wi(a) ? It.set(a, t) : typeof a == "object" && a !== null ? a : It.box(a, t);
}
Wl(ih, eh);
var hu = {
  box: function(t, e) {
    var i = Kn(e);
    return new ds(t, Zn(i), i.name, !0, i.equals);
  },
  array: function(t, e) {
    var i = Kn(e);
    return (A.useProxies === !1 || i.proxy === !1 ? ad : Ku)(t, Zn(i), i.name);
  },
  map: function(t, e) {
    var i = Kn(e);
    return new Ch(t, Zn(i), i.name);
  },
  set: function(t, e) {
    var i = Kn(e);
    return new Ih(t, Zn(i), i.name);
  },
  object: function(t, e, i) {
    return As(function() {
      return ku(A.useProxies === !1 || i?.proxy === !1 ? tn({}, i) : Qu({}, i), t, e);
    });
  },
  ref: /* @__PURE__ */ ui(nu),
  shallow: /* @__PURE__ */ ui(ru),
  deep: eh,
  struct: /* @__PURE__ */ ui(ou)
}, It = /* @__PURE__ */ Wl(ih, hu), sh = "computed", cu = "computed.struct", xo = /* @__PURE__ */ Jo(sh), uu = /* @__PURE__ */ Jo(cu, {
  equals: mr.structural
}), li = function(t, e) {
  if (zn(e))
    return xo.decorate_20223_(t, e);
  if (Ps(e))
    return Hn(t, e, xo);
  if (gi(t))
    return ui(Jo(sh, t));
  Lt(t) || R("First argument to `computed` should be an expression."), Lt(e) && R("A setter as second argument is no longer supported, use `{ set: fn }` option instead");
  var i = gi(e) ? e : {};
  return i.get = t, i.name || (i.name = t.name || ""), new He(i);
};
Object.assign(li, xo);
li.struct = /* @__PURE__ */ ui(uu);
var xa, La, Sr = 0, du = 1, fu = (xa = (La = /* @__PURE__ */ gr(function() {
}, "name")) == null ? void 0 : La.configurable) != null ? xa : !1, Ra = {
  value: "action",
  configurable: !0,
  writable: !1,
  enumerable: !1
};
function ys(a, t, e, i) {
  e === void 0 && (e = !1), Lt(t) || R("`action` can only be invoked on functions"), (typeof a != "string" || !a) && R("actions should have valid names, got: '" + a + "'");
  function s() {
    return gu(a, e, t, i || this, arguments);
  }
  return s.isMobxAction = !0, s.toString = function() {
    return t.toString();
  }, fu && (Ra.value = a, ci(s, "name", Ra)), s;
}
function gu(a, t, e, i, s) {
  var n = pu(a, t, i, s);
  try {
    return e.apply(i, s);
  } catch (r) {
    throw n.error_ = r, r;
  } finally {
    mu(n);
  }
}
function pu(a, t, e, i) {
  var s = Wt() && !!a, n = 0;
  if (s) {
    n = Date.now();
    var r = i ? Array.from(i) : pr;
    Ie({
      type: ta,
      name: a,
      object: e,
      arguments: r
    });
  }
  var o = A.trackingDerivation, l = !t || !o;
  Me();
  var h = A.allowStateChanges;
  l && (ws(), h = Ko(!0));
  var c = $o(!0), d = {
    runAsAction_: l,
    prevDerivation_: o,
    prevAllowStateChanges_: h,
    prevAllowStateReads_: c,
    notifySpy_: s,
    startTime_: n,
    actionId_: du++,
    parentActionId_: Sr
  };
  return Sr = d.actionId_, d;
}
function mu(a) {
  Sr !== a.actionId_ && R(30), Sr = a.parentActionId_, a.error_ !== void 0 && (A.suppressReactionErrors = !0), Zo(a.prevAllowStateChanges_), pn(a.prevAllowStateReads_), Fe(), a.runAsAction_ && Li(a.prevDerivation_), a.notifySpy_ && Ee({
    time: Date.now() - a.startTime_
  }), A.suppressReactionErrors = !1;
}
function Ko(a) {
  var t = A.allowStateChanges;
  return A.allowStateChanges = a, t;
}
function Zo(a) {
  A.allowStateChanges = a;
}
var Pu = "create", ds = /* @__PURE__ */ (function(a) {
  function t(i, s, n, r, o) {
    var l;
    if (n === void 0 && (n = "ObservableValue@" + si()), r === void 0 && (r = !0), o === void 0 && (o = mr.default), l = a.call(this, n) || this, l.enhancer = void 0, l.name_ = void 0, l.equals = void 0, l.hasUnreportedChange_ = !1, l.interceptors_ = void 0, l.changeListeners_ = void 0, l.value_ = void 0, l.dehancer = void 0, l.enhancer = s, l.name_ = n, l.equals = o, l.value_ = s(i, void 0, n), r && Wt()) {
      var h;
      bs({
        type: Pu,
        object: l,
        observableKind: "value",
        debugObjectName: l.name_,
        newValue: "" + ((h = l.value_) == null ? void 0 : h.toString())
      });
    }
    return l;
  }
  Ql(t, a);
  var e = t.prototype;
  return e.dehanceValue = function(s) {
    return this.dehancer !== void 0 ? this.dehancer(s) : s;
  }, e.set = function(s) {
    var n = this.value_;
    if (s = this.prepareNewValue_(s), s !== A.UNCHANGED) {
      var r = Wt();
      r && Ie({
        type: Je,
        object: this,
        observableKind: "value",
        debugObjectName: this.name_,
        newValue: s,
        oldValue: n
      }), this.setNewValue_(s), r && Ee();
    }
  }, e.prepareNewValue_ = function(s) {
    if (hi(this), Be(this)) {
      var n = Ge(this, {
        object: this,
        type: Je,
        newValue: s
      });
      if (!n)
        return A.UNCHANGED;
      s = n.newValue;
    }
    return s = this.enhancer(s, this.value_, this.name_), this.equals(this.value_, s) ? A.UNCHANGED : s;
  }, e.setNewValue_ = function(s) {
    var n = this.value_;
    this.value_ = s, this.reportChanged(), Ze(this) && $e(this, {
      type: Je,
      object: this,
      newValue: s,
      oldValue: n
    });
  }, e.get = function() {
    return this.reportObserved(), this.dehanceValue(this.value_);
  }, e.intercept_ = function(s) {
    return qn(this, s);
  }, e.observe_ = function(s, n) {
    return n && s({
      observableKind: "value",
      debugObjectName: this.name_,
      object: this,
      type: Je,
      newValue: this.value_,
      oldValue: void 0
    }), Un(this, s);
  }, e.raw = function() {
    return this.value_;
  }, e.toJSON = function() {
    return this.get();
  }, e.toString = function() {
    return this.name_ + "[" + this.value_ + "]";
  }, e.valueOf = function() {
    return Xl(this.get());
  }, e[Symbol.toPrimitive] = function() {
    return this.valueOf();
  }, t;
})(ts), He = /* @__PURE__ */ (function() {
  function a(e) {
    this.dependenciesState_ = J.NOT_TRACKING_, this.observing_ = [], this.newObserving_ = null, this.observers_ = /* @__PURE__ */ new Set(), this.runId_ = 0, this.lastAccessedBy_ = 0, this.lowestObserverState_ = J.UP_TO_DATE_, this.unboundDepsCount_ = 0, this.value_ = new yr(null), this.name_ = void 0, this.triggeredBy_ = void 0, this.flags_ = 0, this.derivation = void 0, this.setter_ = void 0, this.isTracing_ = ke.NONE, this.scope_ = void 0, this.equals_ = void 0, this.requiresReaction_ = void 0, this.keepAlive_ = void 0, this.onBOL = void 0, this.onBUOL = void 0, e.get || R(31), this.derivation = e.get, this.name_ = e.name || "ComputedValue@" + si(), e.set && (this.setter_ = ys(this.name_ + "-setter", e.set)), this.equals_ = e.equals || (e.compareStructural || e.struct ? mr.structural : mr.default), this.scope_ = e.context, this.requiresReaction_ = e.requiresReaction, this.keepAlive_ = !!e.keepAlive;
  }
  var t = a.prototype;
  return t.onBecomeStale_ = function() {
    Iu(this);
  }, t.onBO = function() {
    this.onBOL && this.onBOL.forEach(function(i) {
      return i();
    });
  }, t.onBUO = function() {
    this.onBUOL && this.onBUOL.forEach(function(i) {
      return i();
    });
  }, t.get = function() {
    if (this.isComputing && R(32, this.name_, this.derivation), A.inBatch === 0 && // !globalState.trackingDerivatpion &&
    this.observers_.size === 0 && !this.keepAlive_)
      Lo(this) && (this.warnAboutUntrackedRead_(), Me(), this.value_ = this.computeValue_(!1), Fe());
    else if (hh(this), Lo(this)) {
      var i = A.trackingContext;
      this.keepAlive_ && !i && (A.trackingContext = this), this.trackAndCompute() && Cu(this), A.trackingContext = i;
    }
    var s = this.value_;
    if (ar(s))
      throw s.cause;
    return s;
  }, t.set = function(i) {
    if (this.setter_) {
      this.isRunningSetter && R(33, this.name_), this.isRunningSetter = !0;
      try {
        this.setter_.call(this.scope_, i);
      } finally {
        this.isRunningSetter = !1;
      }
    } else
      R(34, this.name_);
  }, t.trackAndCompute = function() {
    var i = this.value_, s = (
      /* see #1208 */
      this.dependenciesState_ === J.NOT_TRACKING_
    ), n = this.computeValue_(!0), r = s || ar(i) || ar(n) || !this.equals_(i, n);
    return r && (this.value_ = n, Wt() && bs({
      observableKind: "computed",
      debugObjectName: this.name_,
      object: this.scope_,
      type: "update",
      oldValue: i,
      newValue: n
    })), r;
  }, t.computeValue_ = function(i) {
    this.isComputing = !0;
    var s = Ko(!1), n;
    if (i)
      n = nh(this, this.derivation, this.scope_);
    else if (A.disableErrorBoundaries === !0)
      n = this.derivation.call(this.scope_);
    else
      try {
        n = this.derivation.call(this.scope_);
      } catch (r) {
        n = new yr(r);
      }
    return Zo(s), this.isComputing = !1, n;
  }, t.suspend_ = function() {
    this.keepAlive_ || (Ro(this), this.value_ = void 0, this.isTracing_ !== ke.NONE && console.log("[mobx.trace] Computed value '" + this.name_ + "' was suspended and it will recompute on the next access."));
  }, t.observe_ = function(i, s) {
    var n = this, r = !0, o = void 0;
    return Bu(function() {
      var l = n.get();
      if (!r || s) {
        var h = ws();
        i({
          observableKind: "computed",
          debugObjectName: n.name_,
          type: Je,
          object: n,
          newValue: l,
          oldValue: o
        }), Li(h);
      }
      r = !1, o = l;
    });
  }, t.warnAboutUntrackedRead_ = function() {
    this.isTracing_ !== ke.NONE && console.log("[mobx.trace] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute."), (typeof this.requiresReaction_ == "boolean" ? this.requiresReaction_ : A.computedRequiresReaction) && console.warn("[mobx] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute.");
  }, t.toString = function() {
    return this.name_ + "[" + this.derivation.toString() + "]";
  }, t.valueOf = function() {
    return Xl(this.get());
  }, t[Symbol.toPrimitive] = function() {
    return this.valueOf();
  }, $s(a, [{
    key: "isComputing",
    get: function() {
      return ve(this.flags_, a.isComputingMask_);
    },
    set: function(i) {
      this.flags_ = Ce(this.flags_, a.isComputingMask_, i);
    }
  }, {
    key: "isRunningSetter",
    get: function() {
      return ve(this.flags_, a.isRunningSetterMask_);
    },
    set: function(i) {
      this.flags_ = Ce(this.flags_, a.isRunningSetterMask_, i);
    }
  }, {
    key: "isBeingObserved",
    get: function() {
      return ve(this.flags_, a.isBeingObservedMask_);
    },
    set: function(i) {
      this.flags_ = Ce(this.flags_, a.isBeingObservedMask_, i);
    }
  }, {
    key: "isPendingUnobservation",
    get: function() {
      return ve(this.flags_, a.isPendingUnobservationMask_);
    },
    set: function(i) {
      this.flags_ = Ce(this.flags_, a.isPendingUnobservationMask_, i);
    }
  }, {
    key: "diffValue",
    get: function() {
      return ve(this.flags_, a.diffValueMask_) ? 1 : 0;
    },
    set: function(i) {
      this.flags_ = Ce(this.flags_, a.diffValueMask_, i === 1);
    }
  }]);
})();
He.isComputingMask_ = 1;
He.isRunningSetterMask_ = 2;
He.isBeingObservedMask_ = 4;
He.isPendingUnobservationMask_ = 8;
He.diffValueMask_ = 16;
var Jr = /* @__PURE__ */ Es("ComputedValue", He), J;
(function(a) {
  a[a.NOT_TRACKING_ = -1] = "NOT_TRACKING_", a[a.UP_TO_DATE_ = 0] = "UP_TO_DATE_", a[a.POSSIBLY_STALE_ = 1] = "POSSIBLY_STALE_", a[a.STALE_ = 2] = "STALE_";
})(J || (J = {}));
var ke;
(function(a) {
  a[a.NONE = 0] = "NONE", a[a.LOG = 1] = "LOG", a[a.BREAK = 2] = "BREAK";
})(ke || (ke = {}));
var yr = function(t) {
  this.cause = void 0, this.cause = t;
};
function ar(a) {
  return a instanceof yr;
}
function Lo(a) {
  switch (a.dependenciesState_) {
    case J.UP_TO_DATE_:
      return !1;
    case J.NOT_TRACKING_:
    case J.STALE_:
      return !0;
    case J.POSSIBLY_STALE_: {
      for (var t = $o(!0), e = ws(), i = a.observing_, s = i.length, n = 0; n < s; n++) {
        var r = i[n];
        if (Jr(r)) {
          if (A.disableErrorBoundaries)
            r.get();
          else
            try {
              r.get();
            } catch {
              return Li(e), pn(t), !0;
            }
          if (a.dependenciesState_ === J.STALE_)
            return Li(e), pn(t), !0;
        }
      }
      return oh(a), Li(e), pn(t), !1;
    }
  }
}
function hi(a) {
  var t = a.observers_.size > 0;
  !A.allowStateChanges && (t || A.enforceActions === "always") && console.warn("[MobX] " + (A.enforceActions ? "Since strict-mode is enabled, changing (observed) observable values without using an action is not allowed. Tried to modify: " : "Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, a computed value or the render function of a React component? You can wrap side effects in 'runInAction' (or decorate functions with 'action') if needed. Tried to modify: ") + a.name_);
}
function Su(a) {
  !A.allowStateReads && A.observableRequiresReaction && console.warn("[mobx] Observable '" + a.name_ + "' being read outside a reactive context.");
}
function nh(a, t, e) {
  var i = $o(!0);
  oh(a), a.newObserving_ = new Array(
    // Reserve constant space for initial dependencies, dynamic space otherwise.
    // See https://github.com/mobxjs/mobx/pull/3833
    a.runId_ === 0 ? 100 : a.observing_.length
  ), a.unboundDepsCount_ = 0, a.runId_ = ++A.runId;
  var s = A.trackingDerivation;
  A.trackingDerivation = a, A.inBatch++;
  var n;
  if (A.disableErrorBoundaries === !0)
    n = t.call(e);
  else
    try {
      n = t.call(e);
    } catch (r) {
      n = new yr(r);
    }
  return A.inBatch--, A.trackingDerivation = s, bu(a), yu(a), pn(i), n;
}
function yu(a) {
  a.observing_.length === 0 && (typeof a.requiresObservable_ == "boolean" ? a.requiresObservable_ : A.reactionRequiresObservable) && console.warn("[mobx] Derivation '" + a.name_ + "' is created/updated without reading any observable value.");
}
function bu(a) {
  for (var t = a.observing_, e = a.observing_ = a.newObserving_, i = J.UP_TO_DATE_, s = 0, n = a.unboundDepsCount_, r = 0; r < n; r++) {
    var o = e[r];
    o.diffValue === 0 && (o.diffValue = 1, s !== r && (e[s] = o), s++), o.dependenciesState_ > i && (i = o.dependenciesState_);
  }
  for (e.length = s, a.newObserving_ = null, n = t.length; n--; ) {
    var l = t[n];
    l.diffValue === 0 && ah(l, a), l.diffValue = 0;
  }
  for (; s--; ) {
    var h = e[s];
    h.diffValue === 1 && (h.diffValue = 0, vu(h, a));
  }
  i !== J.UP_TO_DATE_ && (a.dependenciesState_ = i, a.onBecomeStale_());
}
function Ro(a) {
  var t = a.observing_;
  a.observing_ = [];
  for (var e = t.length; e--; )
    ah(t[e], a);
  a.dependenciesState_ = J.NOT_TRACKING_;
}
function rh(a) {
  var t = ws();
  try {
    return a();
  } finally {
    Li(t);
  }
}
function ws() {
  var a = A.trackingDerivation;
  return A.trackingDerivation = null, a;
}
function Li(a) {
  A.trackingDerivation = a;
}
function $o(a) {
  var t = A.allowStateReads;
  return A.allowStateReads = a, t;
}
function pn(a) {
  A.allowStateReads = a;
}
function oh(a) {
  if (a.dependenciesState_ !== J.UP_TO_DATE_) {
    a.dependenciesState_ = J.UP_TO_DATE_;
    for (var t = a.observing_, e = t.length; e--; )
      t[e].lowestObserverState_ = J.UP_TO_DATE_;
  }
}
var ao = function() {
  this.version = 6, this.UNCHANGED = {}, this.trackingDerivation = null, this.trackingContext = null, this.runId = 0, this.mobxGuid = 0, this.inBatch = 0, this.pendingUnobservations = [], this.pendingReactions = [], this.isRunningReactions = !1, this.allowStateChanges = !1, this.allowStateReads = !0, this.enforceActions = !0, this.spyListeners = [], this.globalReactionErrorHandlers = [], this.computedRequiresReaction = !1, this.reactionRequiresObservable = !1, this.observableRequiresReaction = !1, this.disableErrorBoundaries = !1, this.suppressReactionErrors = !1, this.useProxies = !0, this.verifyProxies = !1, this.safeDescriptors = !0;
}, lo = !0, A = /* @__PURE__ */ (function() {
  var a = /* @__PURE__ */ Xo();
  return a.__mobxInstanceCount > 0 && !a.__mobxGlobals && (lo = !1), a.__mobxGlobals && a.__mobxGlobals.version !== new ao().version && (lo = !1), lo ? a.__mobxGlobals ? (a.__mobxInstanceCount += 1, a.__mobxGlobals.UNCHANGED || (a.__mobxGlobals.UNCHANGED = {}), a.__mobxGlobals) : (a.__mobxInstanceCount = 1, a.__mobxGlobals = /* @__PURE__ */ new ao()) : (setTimeout(function() {
    R(35);
  }, 1), new ao());
})();
function vu(a, t) {
  a.observers_.add(t), a.lowestObserverState_ > t.dependenciesState_ && (a.lowestObserverState_ = t.dependenciesState_);
}
function ah(a, t) {
  a.observers_.delete(t), a.observers_.size === 0 && lh(a);
}
function lh(a) {
  a.isPendingUnobservation === !1 && (a.isPendingUnobservation = !0, A.pendingUnobservations.push(a));
}
function Me() {
  A.inBatch++;
}
function Fe() {
  if (--A.inBatch === 0) {
    fh();
    for (var a = A.pendingUnobservations, t = 0; t < a.length; t++) {
      var e = a[t];
      e.isPendingUnobservation = !1, e.observers_.size === 0 && (e.isBeingObserved && (e.isBeingObserved = !1, e.onBUO()), e instanceof He && e.suspend_());
    }
    A.pendingUnobservations = [];
  }
}
function hh(a) {
  Su(a);
  var t = A.trackingDerivation;
  return t !== null ? (t.runId_ !== a.lastAccessedBy_ && (a.lastAccessedBy_ = t.runId_, t.newObserving_[t.unboundDepsCount_++] = a, !a.isBeingObserved && A.trackingContext && (a.isBeingObserved = !0, a.onBO())), a.isBeingObserved) : (a.observers_.size === 0 && A.inBatch > 0 && lh(a), !1);
}
function ch(a) {
  a.lowestObserverState_ !== J.STALE_ && (a.lowestObserverState_ = J.STALE_, a.observers_.forEach(function(t) {
    t.dependenciesState_ === J.UP_TO_DATE_ && (t.isTracing_ !== ke.NONE && uh(t, a), t.onBecomeStale_()), t.dependenciesState_ = J.STALE_;
  }));
}
function Cu(a) {
  a.lowestObserverState_ !== J.STALE_ && (a.lowestObserverState_ = J.STALE_, a.observers_.forEach(function(t) {
    t.dependenciesState_ === J.POSSIBLY_STALE_ ? (t.dependenciesState_ = J.STALE_, t.isTracing_ !== ke.NONE && uh(t, a)) : t.dependenciesState_ === J.UP_TO_DATE_ && (a.lowestObserverState_ = J.UP_TO_DATE_);
  }));
}
function Iu(a) {
  a.lowestObserverState_ === J.UP_TO_DATE_ && (a.lowestObserverState_ = J.POSSIBLY_STALE_, a.observers_.forEach(function(t) {
    t.dependenciesState_ === J.UP_TO_DATE_ && (t.dependenciesState_ = J.POSSIBLY_STALE_, t.onBecomeStale_());
  }));
}
function uh(a, t) {
  if (console.log("[mobx.trace] '" + a.name_ + "' is invalidated due to a change in: '" + t.name_ + "'"), a.isTracing_ === ke.BREAK) {
    var e = [];
    dh(_u(a), e, 1), new Function(`debugger;
/*
Tracing '` + a.name_ + `'

You are entering this break point because derivation '` + a.name_ + "' is being traced and '" + t.name_ + `' is now forcing it to update.
Just follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update
The stackframe you are looking for is at least ~6-8 stack-frames up.

` + (a instanceof He ? a.derivation.toString().replace(/[*]\//g, "/") : "") + `

The dependencies for this derivation are:

` + e.join(`
`) + `
*/
    `)();
  }
}
function dh(a, t, e) {
  if (t.length >= 1e3) {
    t.push("(and many more)");
    return;
  }
  t.push("" + "	".repeat(e - 1) + a.name), a.dependencies && a.dependencies.forEach(function(i) {
    return dh(i, t, e + 1);
  });
}
var Yi = /* @__PURE__ */ (function() {
  function a(e, i, s, n) {
    e === void 0 && (e = "Reaction@" + si()), this.name_ = void 0, this.onInvalidate_ = void 0, this.errorHandler_ = void 0, this.requiresObservable_ = void 0, this.observing_ = [], this.newObserving_ = [], this.dependenciesState_ = J.NOT_TRACKING_, this.runId_ = 0, this.unboundDepsCount_ = 0, this.flags_ = 0, this.isTracing_ = ke.NONE, this.name_ = e, this.onInvalidate_ = i, this.errorHandler_ = s, this.requiresObservable_ = n;
  }
  var t = a.prototype;
  return t.onBecomeStale_ = function() {
    this.schedule_();
  }, t.schedule_ = function() {
    this.isScheduled || (this.isScheduled = !0, A.pendingReactions.push(this), fh());
  }, t.runReaction_ = function() {
    if (!this.isDisposed) {
      Me(), this.isScheduled = !1;
      var i = A.trackingContext;
      if (A.trackingContext = this, Lo(this)) {
        this.isTrackPending = !0;
        try {
          this.onInvalidate_(), this.isTrackPending && Wt() && bs({
            name: this.name_,
            type: "scheduled-reaction"
          });
        } catch (s) {
          this.reportExceptionInDerivation_(s);
        }
      }
      A.trackingContext = i, Fe();
    }
  }, t.track = function(i) {
    if (!this.isDisposed) {
      Me();
      var s = Wt(), n;
      s && (n = Date.now(), Ie({
        name: this.name_,
        type: "reaction"
      })), this.isRunning = !0;
      var r = A.trackingContext;
      A.trackingContext = this;
      var o = nh(this, i, void 0);
      A.trackingContext = r, this.isRunning = !1, this.isTrackPending = !1, this.isDisposed && Ro(this), ar(o) && this.reportExceptionInDerivation_(o.cause), s && Ee({
        time: Date.now() - n
      }), Fe();
    }
  }, t.reportExceptionInDerivation_ = function(i) {
    var s = this;
    if (this.errorHandler_) {
      this.errorHandler_(i, this);
      return;
    }
    if (A.disableErrorBoundaries)
      throw i;
    var n = "[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '" + this + "'";
    A.suppressReactionErrors ? console.warn("[mobx] (error in reaction '" + this.name_ + "' suppressed, fix error of causing action below)") : console.error(n, i), Wt() && bs({
      type: "error",
      name: this.name_,
      message: n,
      error: "" + i
    }), A.globalReactionErrorHandlers.forEach(function(r) {
      return r(i, s);
    });
  }, t.dispose = function() {
    this.isDisposed || (this.isDisposed = !0, this.isRunning || (Me(), Ro(this), Fe()));
  }, t.getDisposer_ = function(i) {
    var s = this, n = function r() {
      s.dispose(), i == null || i.removeEventListener == null || i.removeEventListener("abort", r);
    };
    return i == null || i.addEventListener == null || i.addEventListener("abort", n), n[k] = this, "dispose" in Symbol && typeof Symbol.dispose == "symbol" && (n[Symbol.dispose] = n), n;
  }, t.toString = function() {
    return "Reaction[" + this.name_ + "]";
  }, t.trace = function(i) {
    i === void 0 && (i = !1), qu(this, i);
  }, $s(a, [{
    key: "isDisposed",
    get: function() {
      return ve(this.flags_, a.isDisposedMask_);
    },
    set: function(i) {
      this.flags_ = Ce(this.flags_, a.isDisposedMask_, i);
    }
  }, {
    key: "isScheduled",
    get: function() {
      return ve(this.flags_, a.isScheduledMask_);
    },
    set: function(i) {
      this.flags_ = Ce(this.flags_, a.isScheduledMask_, i);
    }
  }, {
    key: "isTrackPending",
    get: function() {
      return ve(this.flags_, a.isTrackPendingMask_);
    },
    set: function(i) {
      this.flags_ = Ce(this.flags_, a.isTrackPendingMask_, i);
    }
  }, {
    key: "isRunning",
    get: function() {
      return ve(this.flags_, a.isRunningMask_);
    },
    set: function(i) {
      this.flags_ = Ce(this.flags_, a.isRunningMask_, i);
    }
  }, {
    key: "diffValue",
    get: function() {
      return ve(this.flags_, a.diffValueMask_) ? 1 : 0;
    },
    set: function(i) {
      this.flags_ = Ce(this.flags_, a.diffValueMask_, i === 1);
    }
  }]);
})();
Yi.isDisposedMask_ = 1;
Yi.isScheduledMask_ = 2;
Yi.isTrackPendingMask_ = 4;
Yi.isRunningMask_ = 8;
Yi.diffValueMask_ = 16;
var Na = 100, Eu = function(t) {
  return t();
};
function fh() {
  A.inBatch > 0 || A.isRunningReactions || Eu(wu);
}
function wu() {
  A.isRunningReactions = !0;
  for (var a = A.pendingReactions, t = 0; a.length > 0; ) {
    ++t === Na && (console.error("Reaction doesn't converge to a stable state after " + Na + " iterations." + (" Probably there is a cycle in the reactive function: " + a[0])), a.splice(0));
    for (var e = a.splice(0), i = 0, s = e.length; i < s; i++)
      e[i].runReaction_();
  }
  A.isRunningReactions = !1;
}
var br = /* @__PURE__ */ Es("Reaction", Yi);
function Wt() {
  return !!A.spyListeners.length;
}
function bs(a) {
  if (A.spyListeners.length)
    for (var t = A.spyListeners, e = 0, i = t.length; e < i; e++)
      t[e](a);
}
function Ie(a) {
  var t = Ri({}, a, {
    spyReportStart: !0
  });
  bs(t);
}
var Au = {
  type: "report-end",
  spyReportEnd: !0
};
function Ee(a) {
  bs(a ? Ri({}, a, {
    type: "report-end",
    spyReportEnd: !0
  }) : Au);
}
function Tu(a) {
  return A.spyListeners.push(a), Qo(function() {
    A.spyListeners = A.spyListeners.filter(function(t) {
      return t !== a;
    });
  });
}
var ta = "action", Ou = "action.bound", gh = "autoAction", xu = "autoAction.bound", Lu = "<unnamed action>", No = /* @__PURE__ */ jn(ta), Ru = /* @__PURE__ */ jn(Ou, {
  bound: !0
}), Bo = /* @__PURE__ */ jn(gh, {
  autoAction: !0
}), Nu = /* @__PURE__ */ jn(xu, {
  autoAction: !0,
  bound: !0
});
function ph(a) {
  var t = function(i, s) {
    if (Lt(i))
      return ys(i.name || Lu, i, a);
    if (Lt(s))
      return ys(i, s, a);
    if (zn(s))
      return (a ? Bo : No).decorate_20223_(i, s);
    if (Ps(s))
      return Hn(i, s, a ? Bo : No);
    if (Ps(i))
      return ui(jn(a ? gh : ta, {
        name: i,
        autoAction: a
      }));
    R("Invalid arguments for `action`");
  };
  return t;
}
var Ne = /* @__PURE__ */ ph(!1);
Object.assign(Ne, No);
var An = /* @__PURE__ */ ph(!0);
Object.assign(An, Bo);
Ne.bound = /* @__PURE__ */ ui(Ru);
An.bound = /* @__PURE__ */ ui(Nu);
function vs(a) {
  return Lt(a) && a.isMobxAction === !0;
}
function Bu(a, t) {
  var e, i, s, n;
  t === void 0 && (t = Hl), Lt(a) || R("Autorun expects a function as first argument"), vs(a) && R("Autorun does not accept actions since actions are untrackable");
  var r = (e = (i = t) == null ? void 0 : i.name) != null ? e : a.name || "Autorun@" + si(), o = !t.scheduler && !t.delay, l;
  if (o)
    l = new Yi(r, function() {
      this.track(d);
    }, t.onError, t.requiresObservable);
  else {
    var h = Mu(t), c = !1;
    l = new Yi(r, function() {
      c || (c = !0, h(function() {
        c = !1, l.isDisposed || l.track(d);
      }));
    }, t.onError, t.requiresObservable);
  }
  function d() {
    a(l);
  }
  return (s = t) != null && (s = s.signal) != null && s.aborted || l.schedule_(), l.getDisposer_((n = t) == null ? void 0 : n.signal);
}
var Gu = function(t) {
  return t();
};
function Mu(a) {
  return a.scheduler ? a.scheduler : a.delay ? function(t) {
    return setTimeout(t, a.delay);
  } : Gu;
}
var Fu = "onBO", Vu = "onBUO";
function Du(a, t, e) {
  return Ph(Fu, a, t, e);
}
function mh(a, t, e) {
  return Ph(Vu, a, t, e);
}
function Ph(a, t, e, i) {
  var s = Hs(t), n = Lt(i) ? i : e, r = a + "L";
  return s[r] ? s[r].add(n) : s[r] = /* @__PURE__ */ new Set([n]), function() {
    var o = s[r];
    o && (o.delete(n), o.size === 0 && delete s[r]);
  };
}
function ku(a, t, e, i) {
  arguments.length > 4 && R("'extendObservable' expected 2-4 arguments"), typeof a != "object" && R("'extendObservable' expects an object as first argument"), es(a) && R("'extendObservable' should not be used on maps, use map.merge instead"), gi(t) || R("'extendObservable' only accepts plain objects as second argument"), (On(t) || On(e)) && R("Extending an object with another observable (object) is not supported");
  var s = vc(t);
  return As(function() {
    var n = tn(a, i)[k];
    Ur(s).forEach(function(r) {
      n.extend_(
        r,
        s[r],
        // must pass "undefined" for { key: undefined }
        e && r in e ? e[r] : !0
      );
    });
  }), a;
}
function _u(a, t) {
  return Sh(Hs(a, t));
}
function Sh(a) {
  var t = {
    name: a.name_
  };
  return a.observing_ && a.observing_.length > 0 && (t.dependencies = Wu(a.observing_).map(Sh)), t;
}
function Wu(a) {
  return Array.from(new Set(a));
}
var Hu = 0;
function yh() {
  this.message = "FLOW_CANCELLED";
}
yh.prototype = /* @__PURE__ */ Object.create(Error.prototype);
var ho = /* @__PURE__ */ Kl("flow"), zu = /* @__PURE__ */ Kl("flow.bound", {
  bound: !0
}), Ws = /* @__PURE__ */ Object.assign(function(t, e) {
  if (zn(e))
    return ho.decorate_20223_(t, e);
  if (Ps(e))
    return Hn(t, e, ho);
  arguments.length !== 1 && R("Flow expects single argument with generator function");
  var i = t, s = i.name || "<unnamed flow>", n = function() {
    var o = this, l = arguments, h = ++Hu, c = Ne(s + " - runid: " + h + " - init", i).apply(o, l), d, f = void 0, p = new Promise(function(P, y) {
      var C = 0;
      d = y;
      function w(x) {
        f = void 0;
        var V;
        try {
          V = Ne(s + " - runid: " + h + " - yield " + C++, c.next).call(c, x);
        } catch (M) {
          return y(M);
        }
        I(V);
      }
      function N(x) {
        f = void 0;
        var V;
        try {
          V = Ne(s + " - runid: " + h + " - yield " + C++, c.throw).call(c, x);
        } catch (M) {
          return y(M);
        }
        I(V);
      }
      function I(x) {
        if (Lt(x?.then)) {
          x.then(I, y);
          return;
        }
        return x.done ? P(x.value) : (f = Promise.resolve(x.value), f.then(w, N));
      }
      w(void 0);
    });
    return p.cancel = Ne(s + " - runid: " + h + " - cancel", function() {
      try {
        f && Ba(f);
        var P = c.return(void 0), y = Promise.resolve(P.value);
        y.then(xs, xs), Ba(y), d(new yh());
      } catch (C) {
        d(C);
      }
    }), p;
  };
  return n.isMobXFlow = !0, n;
}, ho);
Ws.bound = /* @__PURE__ */ ui(zu);
function Ba(a) {
  Lt(a.cancel) && a.cancel();
}
function Tn(a) {
  return a?.isMobXFlow === !0;
}
function ju(a, t) {
  return a ? Xn(a) || !!a[k] || Yo(a) || br(a) || Jr(a) : !1;
}
function On(a) {
  return arguments.length !== 1 && R("isObservable expects only 1 argument. Use isObservableProp to inspect the observability of a property"), ju(a);
}
function qu() {
  for (var a = !1, t = arguments.length, e = new Array(t), i = 0; i < t; i++)
    e[i] = arguments[i];
  typeof e[e.length - 1] == "boolean" && (a = e.pop());
  var s = Uu(e);
  if (!s)
    return R("'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly");
  s.isTracing_ === ke.NONE && console.log("[mobx.trace] '" + s.name_ + "' tracing enabled"), s.isTracing_ = a ? ke.BREAK : ke.LOG;
}
function Uu(a) {
  switch (a.length) {
    case 0:
      return A.trackingDerivation;
    case 1:
      return Hs(a[0]);
    case 2:
      return Hs(a[0], a[1]);
  }
}
function Ai(a, t) {
  t === void 0 && (t = void 0), Me();
  try {
    return a.apply(t);
  } finally {
    Fe();
  }
}
function ss(a) {
  return a[k];
}
var Xu = {
  has: function(t, e) {
    return A.trackingDerivation && on("detect new properties using the 'in' operator. Use 'has' from 'mobx' instead."), ss(t).has_(e);
  },
  get: function(t, e) {
    return ss(t).get_(e);
  },
  set: function(t, e, i) {
    var s;
    return Ps(e) ? (ss(t).values_.has(e) || on("add a new observable property through direct assignment. Use 'set' from 'mobx' instead."), (s = ss(t).set_(e, i, !0)) != null ? s : !0) : !1;
  },
  deleteProperty: function(t, e) {
    var i;
    return on("delete properties from an observable object. Use 'remove' from 'mobx' instead."), Ps(e) ? (i = ss(t).delete_(e, !0)) != null ? i : !0 : !1;
  },
  defineProperty: function(t, e, i) {
    var s;
    return on("define property on an observable object. Use 'defineProperty' from 'mobx' instead."), (s = ss(t).defineProperty_(e, i)) != null ? s : !0;
  },
  ownKeys: function(t) {
    return A.trackingDerivation && on("iterate keys to detect added / removed properties. Use 'keys' from 'mobx' instead."), ss(t).ownKeys_();
  },
  preventExtensions: function(t) {
    R(13);
  }
};
function Qu(a, t) {
  var e, i;
  return zl(), a = tn(a, t), (i = (e = a[k]).proxy_) != null ? i : e.proxy_ = new Proxy(a, Xu);
}
function Be(a) {
  return a.interceptors_ !== void 0 && a.interceptors_.length > 0;
}
function qn(a, t) {
  var e = a.interceptors_ || (a.interceptors_ = []);
  return e.push(t), Qo(function() {
    var i = e.indexOf(t);
    i !== -1 && e.splice(i, 1);
  });
}
function Ge(a, t) {
  var e = ws();
  try {
    for (var i = [].concat(a.interceptors_ || []), s = 0, n = i.length; s < n && (t = i[s](t), t && !t.type && R(14), !!t); s++)
      ;
    return t;
  } finally {
    Li(e);
  }
}
function Ze(a) {
  return a.changeListeners_ !== void 0 && a.changeListeners_.length > 0;
}
function Un(a, t) {
  var e = a.changeListeners_ || (a.changeListeners_ = []);
  return e.push(t), Qo(function() {
    var i = e.indexOf(t);
    i !== -1 && e.splice(i, 1);
  });
}
function $e(a, t) {
  var e = ws(), i = a.changeListeners_;
  if (i) {
    i = i.slice();
    for (var s = 0, n = i.length; s < n; s++)
      i[s](t);
    Li(e);
  }
}
function bh(a, t, e) {
  return As(function() {
    var i, s = tn(a, e)[k];
    t && a[he] && R("makeObservable second arg must be nullish when using decorators. Mixing @decorator syntax with annotations is not supported."), (i = t) != null || (t = Tc(a)), Ur(t).forEach(function(n) {
      return s.make_(n, t[n]);
    });
  }), a;
}
var Ga = "splice", Je = "update", Yu = 1e4, Ju = {
  get: function(t, e) {
    var i = t[k];
    return e === k ? i : e === "length" ? i.getArrayLength_() : typeof e == "string" && !isNaN(e) ? i.get_(parseInt(e)) : De(vr, e) ? vr[e] : t[e];
  },
  set: function(t, e, i) {
    var s = t[k];
    return e === "length" && s.setArrayLength_(i), typeof e == "symbol" || isNaN(e) ? t[e] = i : s.set_(parseInt(e), i), !0;
  },
  preventExtensions: function() {
    R(15);
  }
}, ea = /* @__PURE__ */ (function() {
  function a(e, i, s, n) {
    e === void 0 && (e = "ObservableArray@" + si()), this.owned_ = void 0, this.legacyMode_ = void 0, this.atom_ = void 0, this.values_ = [], this.interceptors_ = void 0, this.changeListeners_ = void 0, this.enhancer_ = void 0, this.dehancer = void 0, this.proxy_ = void 0, this.lastKnownLength_ = 0, this.owned_ = s, this.legacyMode_ = n, this.atom_ = new ts(e), this.enhancer_ = function(r, o) {
      return i(r, o, e + "[..]");
    };
  }
  var t = a.prototype;
  return t.dehanceValue_ = function(i) {
    return this.dehancer !== void 0 ? this.dehancer(i) : i;
  }, t.dehanceValues_ = function(i) {
    return this.dehancer !== void 0 && i.length > 0 ? i.map(this.dehancer) : i;
  }, t.intercept_ = function(i) {
    return qn(this, i);
  }, t.observe_ = function(i, s) {
    return s === void 0 && (s = !1), s && i({
      observableKind: "array",
      object: this.proxy_,
      debugObjectName: this.atom_.name_,
      type: "splice",
      index: 0,
      added: this.values_.slice(),
      addedCount: this.values_.length,
      removed: [],
      removedCount: 0
    }), Un(this, i);
  }, t.getArrayLength_ = function() {
    return this.atom_.reportObserved(), this.values_.length;
  }, t.setArrayLength_ = function(i) {
    (typeof i != "number" || isNaN(i) || i < 0) && R("Out of range: " + i);
    var s = this.values_.length;
    if (i !== s)
      if (i > s) {
        for (var n = new Array(i - s), r = 0; r < i - s; r++)
          n[r] = void 0;
        this.spliceWithArray_(s, 0, n);
      } else
        this.spliceWithArray_(i, s - i);
  }, t.updateArrayLength_ = function(i, s) {
    i !== this.lastKnownLength_ && R(16), this.lastKnownLength_ += s, this.legacyMode_ && s > 0 && Ah(i + s + 1);
  }, t.spliceWithArray_ = function(i, s, n) {
    var r = this;
    hi(this.atom_);
    var o = this.values_.length;
    if (i === void 0 ? i = 0 : i > o ? i = o : i < 0 && (i = Math.max(0, o + i)), arguments.length === 1 ? s = o - i : s == null ? s = 0 : s = Math.max(0, Math.min(s, o - i)), n === void 0 && (n = pr), Be(this)) {
      var l = Ge(this, {
        object: this.proxy_,
        type: Ga,
        index: i,
        removedCount: s,
        added: n
      });
      if (!l)
        return pr;
      s = l.removedCount, n = l.added;
    }
    n = n.length === 0 ? n : n.map(function(d) {
      return r.enhancer_(d, void 0);
    }), this.legacyMode_;
    var h = n.length - s;
    this.updateArrayLength_(o, h);
    var c = this.spliceItemsIntoValues_(i, s, n);
    return (s !== 0 || n.length !== 0) && this.notifyArraySplice_(i, n, c), this.dehanceValues_(c);
  }, t.spliceItemsIntoValues_ = function(i, s, n) {
    if (n.length < Yu) {
      var r;
      return (r = this.values_).splice.apply(r, [i, s].concat(n));
    } else {
      var o = this.values_.slice(i, i + s), l = this.values_.slice(i + s);
      this.values_.length += n.length - s;
      for (var h = 0; h < n.length; h++)
        this.values_[i + h] = n[h];
      for (var c = 0; c < l.length; c++)
        this.values_[i + n.length + c] = l[c];
      return o;
    }
  }, t.notifyArrayChildUpdate_ = function(i, s, n) {
    var r = !this.owned_ && Wt(), o = Ze(this), l = o || r ? {
      observableKind: "array",
      object: this.proxy_,
      type: Je,
      debugObjectName: this.atom_.name_,
      index: i,
      newValue: s,
      oldValue: n
    } : null;
    r && Ie(l), this.atom_.reportChanged(), o && $e(this, l), r && Ee();
  }, t.notifyArraySplice_ = function(i, s, n) {
    var r = !this.owned_ && Wt(), o = Ze(this), l = o || r ? {
      observableKind: "array",
      object: this.proxy_,
      debugObjectName: this.atom_.name_,
      type: Ga,
      index: i,
      removed: n,
      added: s,
      removedCount: n.length,
      addedCount: s.length
    } : null;
    r && Ie(l), this.atom_.reportChanged(), o && $e(this, l), r && Ee();
  }, t.get_ = function(i) {
    if (this.legacyMode_ && i >= this.values_.length) {
      console.warn("[mobx.array] Attempt to read an array index (" + i + ") that is out of bounds (" + this.values_.length + "). Please check length first. Out of bound indices will not be tracked by MobX");
      return;
    }
    return this.atom_.reportObserved(), this.dehanceValue_(this.values_[i]);
  }, t.set_ = function(i, s) {
    var n = this.values_;
    if (this.legacyMode_ && i > n.length && R(17, i, n.length), i < n.length) {
      hi(this.atom_);
      var r = n[i];
      if (Be(this)) {
        var o = Ge(this, {
          type: Je,
          object: this.proxy_,
          // since "this" is the real array we need to pass its proxy
          index: i,
          newValue: s
        });
        if (!o)
          return;
        s = o.newValue;
      }
      s = this.enhancer_(s, r);
      var l = s !== r;
      l && (n[i] = s, this.notifyArrayChildUpdate_(i, s, r));
    } else {
      for (var h = new Array(i + 1 - n.length), c = 0; c < h.length - 1; c++)
        h[c] = void 0;
      h[h.length - 1] = s, this.spliceWithArray_(n.length, 0, h);
    }
  }, a;
})();
function Ku(a, t, e, i) {
  return e === void 0 && (e = "ObservableArray@" + si()), i === void 0 && (i = !1), zl(), As(function() {
    var s = new ea(e, t, i, !1);
    ql(s.values_, k, s);
    var n = new Proxy(s.values_, Ju);
    return s.proxy_ = n, a && a.length && s.spliceWithArray_(0, 0, a), n;
  });
}
var vr = {
  clear: function() {
    return this.splice(0);
  },
  replace: function(t) {
    var e = this[k];
    return e.spliceWithArray_(0, e.values_.length, t);
  },
  // Used by JSON.stringify
  toJSON: function() {
    return this.slice();
  },
  /*
   * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
   * since these functions alter the inner structure of the array, the have side effects.
   * Because the have side effects, they should not be used in computed function,
   * and for that reason the do not call dependencyState.notifyObserved
   */
  splice: function(t, e) {
    for (var i = arguments.length, s = new Array(i > 2 ? i - 2 : 0), n = 2; n < i; n++)
      s[n - 2] = arguments[n];
    var r = this[k];
    switch (arguments.length) {
      case 0:
        return [];
      case 1:
        return r.spliceWithArray_(t);
      case 2:
        return r.spliceWithArray_(t, e);
    }
    return r.spliceWithArray_(t, e, s);
  },
  spliceWithArray: function(t, e, i) {
    return this[k].spliceWithArray_(t, e, i);
  },
  push: function() {
    for (var t = this[k], e = arguments.length, i = new Array(e), s = 0; s < e; s++)
      i[s] = arguments[s];
    return t.spliceWithArray_(t.values_.length, 0, i), t.values_.length;
  },
  pop: function() {
    return this.splice(Math.max(this[k].values_.length - 1, 0), 1)[0];
  },
  shift: function() {
    return this.splice(0, 1)[0];
  },
  unshift: function() {
    for (var t = this[k], e = arguments.length, i = new Array(e), s = 0; s < e; s++)
      i[s] = arguments[s];
    return t.spliceWithArray_(0, 0, i), t.values_.length;
  },
  reverse: function() {
    return A.trackingDerivation && R(37, "reverse"), this.replace(this.slice().reverse()), this;
  },
  sort: function() {
    A.trackingDerivation && R(37, "sort");
    var t = this.slice();
    return t.sort.apply(t, arguments), this.replace(t), this;
  },
  remove: function(t) {
    var e = this[k], i = e.dehanceValues_(e.values_).indexOf(t);
    return i > -1 ? (this.splice(i, 1), !0) : !1;
  }
};
rt("at", Ae);
rt("concat", Ae);
rt("flat", Ae);
rt("includes", Ae);
rt("indexOf", Ae);
rt("join", Ae);
rt("lastIndexOf", Ae);
rt("slice", Ae);
rt("toString", Ae);
rt("toLocaleString", Ae);
rt("toSorted", Ae);
rt("toSpliced", Ae);
rt("with", Ae);
rt("every", ni);
rt("filter", ni);
rt("find", ni);
rt("findIndex", ni);
rt("findLast", ni);
rt("findLastIndex", ni);
rt("flatMap", ni);
rt("forEach", ni);
rt("map", ni);
rt("some", ni);
rt("toReversed", ni);
rt("reduce", vh);
rt("reduceRight", vh);
function rt(a, t) {
  typeof Array.prototype[a] == "function" && (vr[a] = t(a));
}
function Ae(a) {
  return function() {
    var t = this[k];
    t.atom_.reportObserved();
    var e = t.dehanceValues_(t.values_);
    return e[a].apply(e, arguments);
  };
}
function ni(a) {
  return function(t, e) {
    var i = this, s = this[k];
    s.atom_.reportObserved();
    var n = s.dehanceValues_(s.values_);
    return n[a](function(r, o) {
      return t.call(e, r, o, i);
    });
  };
}
function vh(a) {
  return function() {
    var t = this, e = this[k];
    e.atom_.reportObserved();
    var i = e.dehanceValues_(e.values_), s = arguments[0];
    return arguments[0] = function(n, r, o) {
      return s(n, r, o, t);
    }, i[a].apply(i, arguments);
  };
}
var Zu = /* @__PURE__ */ Es("ObservableArrayAdministration", ea);
function Kr(a) {
  return jr(a) && Zu(a[k]);
}
var $u = {}, Wi = "add", Cr = "delete", Ch = /* @__PURE__ */ (function() {
  function a(e, i, s) {
    var n = this;
    i === void 0 && (i = Ss), s === void 0 && (s = "ObservableMap@" + si()), this.enhancer_ = void 0, this.name_ = void 0, this[k] = $u, this.data_ = void 0, this.hasMap_ = void 0, this.keysAtom_ = void 0, this.interceptors_ = void 0, this.changeListeners_ = void 0, this.dehancer = void 0, this.enhancer_ = i, this.name_ = s, Lt(Map) || R(18), As(function() {
      n.keysAtom_ = Yl(n.name_ + ".keys()"), n.data_ = /* @__PURE__ */ new Map(), n.hasMap_ = /* @__PURE__ */ new Map(), e && n.merge(e);
    });
  }
  var t = a.prototype;
  return t.has_ = function(i) {
    return this.data_.has(i);
  }, t.has = function(i) {
    var s = this;
    if (!A.trackingDerivation)
      return this.has_(i);
    var n = this.hasMap_.get(i);
    if (!n) {
      var r = n = new ds(this.has_(i), Qr, this.name_ + "." + Ao(i) + "?", !1);
      this.hasMap_.set(i, r), mh(r, function() {
        return s.hasMap_.delete(i);
      });
    }
    return n.get();
  }, t.set = function(i, s) {
    var n = this.has_(i);
    if (Be(this)) {
      var r = Ge(this, {
        type: n ? Je : Wi,
        object: this,
        newValue: s,
        name: i
      });
      if (!r)
        return this;
      s = r.newValue;
    }
    return n ? this.updateValue_(i, s) : this.addValue_(i, s), this;
  }, t.delete = function(i) {
    var s = this;
    if (hi(this.keysAtom_), Be(this)) {
      var n = Ge(this, {
        type: Cr,
        object: this,
        name: i
      });
      if (!n)
        return !1;
    }
    if (this.has_(i)) {
      var r = Wt(), o = Ze(this), l = o || r ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: Cr,
        object: this,
        oldValue: this.data_.get(i).value_,
        name: i
      } : null;
      return r && Ie(l), Ai(function() {
        var h;
        s.keysAtom_.reportChanged(), (h = s.hasMap_.get(i)) == null || h.setNewValue_(!1);
        var c = s.data_.get(i);
        c.setNewValue_(void 0), s.data_.delete(i);
      }), o && $e(this, l), r && Ee(), !0;
    }
    return !1;
  }, t.updateValue_ = function(i, s) {
    var n = this.data_.get(i);
    if (s = n.prepareNewValue_(s), s !== A.UNCHANGED) {
      var r = Wt(), o = Ze(this), l = o || r ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: Je,
        object: this,
        oldValue: n.value_,
        name: i,
        newValue: s
      } : null;
      r && Ie(l), n.setNewValue_(s), o && $e(this, l), r && Ee();
    }
  }, t.addValue_ = function(i, s) {
    var n = this;
    hi(this.keysAtom_), Ai(function() {
      var h, c = new ds(s, n.enhancer_, n.name_ + "." + Ao(i), !1);
      n.data_.set(i, c), s = c.value_, (h = n.hasMap_.get(i)) == null || h.setNewValue_(!0), n.keysAtom_.reportChanged();
    });
    var r = Wt(), o = Ze(this), l = o || r ? {
      observableKind: "map",
      debugObjectName: this.name_,
      type: Wi,
      object: this,
      name: i,
      newValue: s
    } : null;
    r && Ie(l), o && $e(this, l), r && Ee();
  }, t.get = function(i) {
    return this.has(i) ? this.dehanceValue_(this.data_.get(i).get()) : this.dehanceValue_(void 0);
  }, t.dehanceValue_ = function(i) {
    return this.dehancer !== void 0 ? this.dehancer(i) : i;
  }, t.keys = function() {
    return this.keysAtom_.reportObserved(), this.data_.keys();
  }, t.values = function() {
    var i = this, s = this.keys();
    return Ma({
      next: function() {
        var r = s.next(), o = r.done, l = r.value;
        return {
          done: o,
          value: o ? void 0 : i.get(l)
        };
      }
    });
  }, t.entries = function() {
    var i = this, s = this.keys();
    return Ma({
      next: function() {
        var r = s.next(), o = r.done, l = r.value;
        return {
          done: o,
          value: o ? void 0 : [l, i.get(l)]
        };
      }
    });
  }, t[Symbol.iterator] = function() {
    return this.entries();
  }, t.forEach = function(i, s) {
    for (var n = Ls(this), r; !(r = n()).done; ) {
      var o = r.value, l = o[0], h = o[1];
      i.call(s, h, l, this);
    }
  }, t.merge = function(i) {
    var s = this;
    return es(i) && (i = new Map(i)), Ai(function() {
      gi(i) ? bc(i).forEach(function(n) {
        return s.set(n, i[n]);
      }) : Array.isArray(i) ? i.forEach(function(n) {
        var r = n[0], o = n[1];
        return s.set(r, o);
      }) : Zs(i) ? (yc(i) || R(19, i), i.forEach(function(n, r) {
        return s.set(r, n);
      })) : i != null && R(20, i);
    }), this;
  }, t.clear = function() {
    var i = this;
    Ai(function() {
      rh(function() {
        for (var s = Ls(i.keys()), n; !(n = s()).done; ) {
          var r = n.value;
          i.delete(r);
        }
      });
    });
  }, t.replace = function(i) {
    var s = this;
    return Ai(function() {
      for (var n = td(i), r = /* @__PURE__ */ new Map(), o = !1, l = Ls(s.data_.keys()), h; !(h = l()).done; ) {
        var c = h.value;
        if (!n.has(c)) {
          var d = s.delete(c);
          if (d)
            o = !0;
          else {
            var f = s.data_.get(c);
            r.set(c, f);
          }
        }
      }
      for (var p = Ls(n.entries()), P; !(P = p()).done; ) {
        var y = P.value, C = y[0], w = y[1], N = s.data_.has(C);
        if (s.set(C, w), s.data_.has(C)) {
          var I = s.data_.get(C);
          r.set(C, I), N || (o = !0);
        }
      }
      if (!o)
        if (s.data_.size !== r.size)
          s.keysAtom_.reportChanged();
        else
          for (var x = s.data_.keys(), V = r.keys(), M = x.next(), X = V.next(); !M.done; ) {
            if (M.value !== X.value) {
              s.keysAtom_.reportChanged();
              break;
            }
            M = x.next(), X = V.next();
          }
      s.data_ = r;
    }), this;
  }, t.toString = function() {
    return "[object ObservableMap]";
  }, t.toJSON = function() {
    return Array.from(this);
  }, t.observe_ = function(i, s) {
    return s === !0 && R("`observe` doesn't support fireImmediately=true in combination with maps."), Un(this, i);
  }, t.intercept_ = function(i) {
    return qn(this, i);
  }, $s(a, [{
    key: "size",
    get: function() {
      return this.keysAtom_.reportObserved(), this.data_.size;
    }
  }, {
    key: Symbol.toStringTag,
    get: function() {
      return "Map";
    }
  }]);
})(), es = /* @__PURE__ */ Es("ObservableMap", Ch);
function Ma(a) {
  return a[Symbol.toStringTag] = "MapIterator", sa(a);
}
function td(a) {
  if (Zs(a) || es(a))
    return a;
  if (Array.isArray(a))
    return new Map(a);
  if (gi(a)) {
    var t = /* @__PURE__ */ new Map();
    for (var e in a)
      t.set(e, a[e]);
    return t;
  } else
    return R(21, a);
}
var ed = {}, Ih = /* @__PURE__ */ (function() {
  function a(e, i, s) {
    var n = this;
    i === void 0 && (i = Ss), s === void 0 && (s = "ObservableSet@" + si()), this.name_ = void 0, this[k] = ed, this.data_ = /* @__PURE__ */ new Set(), this.atom_ = void 0, this.changeListeners_ = void 0, this.interceptors_ = void 0, this.dehancer = void 0, this.enhancer_ = void 0, this.name_ = s, Lt(Set) || R(22), this.enhancer_ = function(r, o) {
      return i(r, o, s);
    }, As(function() {
      n.atom_ = Yl(n.name_), e && n.replace(e);
    });
  }
  var t = a.prototype;
  return t.dehanceValue_ = function(i) {
    return this.dehancer !== void 0 ? this.dehancer(i) : i;
  }, t.clear = function() {
    var i = this;
    Ai(function() {
      rh(function() {
        for (var s = Ls(i.data_.values()), n; !(n = s()).done; ) {
          var r = n.value;
          i.delete(r);
        }
      });
    });
  }, t.forEach = function(i, s) {
    for (var n = Ls(this), r; !(r = n()).done; ) {
      var o = r.value;
      i.call(s, o, o, this);
    }
  }, t.add = function(i) {
    var s = this;
    if (hi(this.atom_), Be(this)) {
      var n = Ge(this, {
        type: Wi,
        object: this,
        newValue: i
      });
      if (!n)
        return this;
      i = n.newValue;
    }
    if (!this.has(i)) {
      Ai(function() {
        s.data_.add(s.enhancer_(i, void 0)), s.atom_.reportChanged();
      });
      var r = Wt(), o = Ze(this), l = o || r ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: Wi,
        object: this,
        newValue: i
      } : null;
      r && Ie(l), o && $e(this, l), r && Ee();
    }
    return this;
  }, t.delete = function(i) {
    var s = this;
    if (Be(this)) {
      var n = Ge(this, {
        type: Cr,
        object: this,
        oldValue: i
      });
      if (!n)
        return !1;
    }
    if (this.has(i)) {
      var r = Wt(), o = Ze(this), l = o || r ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: Cr,
        object: this,
        oldValue: i
      } : null;
      return r && Ie(l), Ai(function() {
        s.atom_.reportChanged(), s.data_.delete(i);
      }), o && $e(this, l), r && Ee(), !0;
    }
    return !1;
  }, t.has = function(i) {
    return this.atom_.reportObserved(), this.data_.has(this.dehanceValue_(i));
  }, t.entries = function() {
    var i = this.values();
    return Fa({
      next: function() {
        var n = i.next(), r = n.value, o = n.done;
        return o ? {
          value: void 0,
          done: o
        } : {
          value: [r, r],
          done: o
        };
      }
    });
  }, t.keys = function() {
    return this.values();
  }, t.values = function() {
    this.atom_.reportObserved();
    var i = this, s = this.data_.values();
    return Fa({
      next: function() {
        var r = s.next(), o = r.value, l = r.done;
        return l ? {
          value: void 0,
          done: l
        } : {
          value: i.dehanceValue_(o),
          done: l
        };
      }
    });
  }, t.intersection = function(i) {
    if (wi(i) && !ai(i))
      return i.intersection(this);
    var s = new Set(this);
    return s.intersection(i);
  }, t.union = function(i) {
    if (wi(i) && !ai(i))
      return i.union(this);
    var s = new Set(this);
    return s.union(i);
  }, t.difference = function(i) {
    return new Set(this).difference(i);
  }, t.symmetricDifference = function(i) {
    if (wi(i) && !ai(i))
      return i.symmetricDifference(this);
    var s = new Set(this);
    return s.symmetricDifference(i);
  }, t.isSubsetOf = function(i) {
    return new Set(this).isSubsetOf(i);
  }, t.isSupersetOf = function(i) {
    return new Set(this).isSupersetOf(i);
  }, t.isDisjointFrom = function(i) {
    if (wi(i) && !ai(i))
      return i.isDisjointFrom(this);
    var s = new Set(this);
    return s.isDisjointFrom(i);
  }, t.replace = function(i) {
    var s = this;
    return ai(i) && (i = new Set(i)), Ai(function() {
      Array.isArray(i) ? (s.clear(), i.forEach(function(n) {
        return s.add(n);
      })) : wi(i) ? (s.clear(), i.forEach(function(n) {
        return s.add(n);
      })) : i != null && R("Cannot initialize set from " + i);
    }), this;
  }, t.observe_ = function(i, s) {
    return s === !0 && R("`observe` doesn't support fireImmediately=true in combination with sets."), Un(this, i);
  }, t.intercept_ = function(i) {
    return qn(this, i);
  }, t.toJSON = function() {
    return Array.from(this);
  }, t.toString = function() {
    return "[object ObservableSet]";
  }, t[Symbol.iterator] = function() {
    return this.values();
  }, $s(a, [{
    key: "size",
    get: function() {
      return this.atom_.reportObserved(), this.data_.size;
    }
  }, {
    key: Symbol.toStringTag,
    get: function() {
      return "Set";
    }
  }]);
})(), ai = /* @__PURE__ */ Es("ObservableSet", Ih);
function Fa(a) {
  return a[Symbol.toStringTag] = "SetIterator", sa(a);
}
var Va = /* @__PURE__ */ Object.create(null), Da = "remove", Go = /* @__PURE__ */ (function() {
  function a(e, i, s, n) {
    i === void 0 && (i = /* @__PURE__ */ new Map()), n === void 0 && (n = Jc), this.target_ = void 0, this.values_ = void 0, this.name_ = void 0, this.defaultAnnotation_ = void 0, this.keysAtom_ = void 0, this.changeListeners_ = void 0, this.interceptors_ = void 0, this.proxy_ = void 0, this.isPlainObject_ = void 0, this.appliedAnnotations_ = void 0, this.pendingKeys_ = void 0, this.target_ = e, this.values_ = i, this.name_ = s, this.defaultAnnotation_ = n, this.keysAtom_ = new ts(this.name_ + ".keys"), this.isPlainObject_ = gi(this.target_), xh(this.defaultAnnotation_) || R("defaultAnnotation must be valid annotation"), this.appliedAnnotations_ = {};
  }
  var t = a.prototype;
  return t.getObservablePropValue_ = function(i) {
    return this.values_.get(i).get();
  }, t.setObservablePropValue_ = function(i, s) {
    var n = this.values_.get(i);
    if (n instanceof He)
      return n.set(s), !0;
    if (Be(this)) {
      var r = Ge(this, {
        type: Je,
        object: this.proxy_ || this.target_,
        name: i,
        newValue: s
      });
      if (!r)
        return null;
      s = r.newValue;
    }
    if (s = n.prepareNewValue_(s), s !== A.UNCHANGED) {
      var o = Ze(this), l = Wt(), h = o || l ? {
        type: Je,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        oldValue: n.value_,
        name: i,
        newValue: s
      } : null;
      l && Ie(h), n.setNewValue_(s), o && $e(this, h), l && Ee();
    }
    return !0;
  }, t.get_ = function(i) {
    return A.trackingDerivation && !De(this.target_, i) && this.has_(i), this.target_[i];
  }, t.set_ = function(i, s, n) {
    return n === void 0 && (n = !1), De(this.target_, i) ? this.values_.has(i) ? this.setObservablePropValue_(i, s) : n ? Reflect.set(this.target_, i, s) : (this.target_[i] = s, !0) : this.extend_(i, {
      value: s,
      enumerable: !0,
      writable: !0,
      configurable: !0
    }, this.defaultAnnotation_, n);
  }, t.has_ = function(i) {
    if (!A.trackingDerivation)
      return i in this.target_;
    this.pendingKeys_ || (this.pendingKeys_ = /* @__PURE__ */ new Map());
    var s = this.pendingKeys_.get(i);
    return s || (s = new ds(i in this.target_, Qr, this.name_ + "." + Ao(i) + "?", !1), this.pendingKeys_.set(i, s)), s.get();
  }, t.make_ = function(i, s) {
    if (s === !0 && (s = this.defaultAnnotation_), s !== !1) {
      if (Wa(this, s, i), !(i in this.target_)) {
        var n;
        if ((n = this.target_[he]) != null && n[i])
          return;
        R(1, s.annotationType_, this.name_ + "." + i.toString());
      }
      for (var r = this.target_; r && r !== zr; ) {
        var o = gr(r, i);
        if (o) {
          var l = s.make_(this, i, o, r);
          if (l === 0)
            return;
          if (l === 1)
            break;
        }
        r = Object.getPrototypeOf(r);
      }
      _a(this, s, i);
    }
  }, t.extend_ = function(i, s, n, r) {
    if (r === void 0 && (r = !1), n === !0 && (n = this.defaultAnnotation_), n === !1)
      return this.defineProperty_(i, s, r);
    Wa(this, n, i);
    var o = n.extend_(this, i, s, r);
    return o && _a(this, n, i), o;
  }, t.defineProperty_ = function(i, s, n) {
    n === void 0 && (n = !1), hi(this.keysAtom_);
    try {
      Me();
      var r = this.delete_(i);
      if (!r)
        return r;
      if (Be(this)) {
        var o = Ge(this, {
          object: this.proxy_ || this.target_,
          name: i,
          type: Wi,
          newValue: s.value
        });
        if (!o)
          return null;
        var l = o.newValue;
        s.value !== l && (s = Ri({}, s, {
          value: l
        }));
      }
      if (n) {
        if (!Reflect.defineProperty(this.target_, i, s))
          return !1;
      } else
        ci(this.target_, i, s);
      this.notifyPropertyAddition_(i, s.value);
    } finally {
      Fe();
    }
    return !0;
  }, t.defineObservableProperty_ = function(i, s, n, r) {
    r === void 0 && (r = !1), hi(this.keysAtom_);
    try {
      Me();
      var o = this.delete_(i);
      if (!o)
        return o;
      if (Be(this)) {
        var l = Ge(this, {
          object: this.proxy_ || this.target_,
          name: i,
          type: Wi,
          newValue: s
        });
        if (!l)
          return null;
        s = l.newValue;
      }
      var h = ka(i), c = {
        configurable: A.safeDescriptors ? this.isPlainObject_ : !0,
        enumerable: !0,
        get: h.get,
        set: h.set
      };
      if (r) {
        if (!Reflect.defineProperty(this.target_, i, c))
          return !1;
      } else
        ci(this.target_, i, c);
      var d = new ds(s, n, this.name_ + "." + i.toString(), !1);
      this.values_.set(i, d), this.notifyPropertyAddition_(i, d.value_);
    } finally {
      Fe();
    }
    return !0;
  }, t.defineComputedProperty_ = function(i, s, n) {
    n === void 0 && (n = !1), hi(this.keysAtom_);
    try {
      Me();
      var r = this.delete_(i);
      if (!r)
        return r;
      if (Be(this)) {
        var o = Ge(this, {
          object: this.proxy_ || this.target_,
          name: i,
          type: Wi,
          newValue: void 0
        });
        if (!o)
          return null;
      }
      s.name || (s.name = this.name_ + "." + i.toString()), s.context = this.proxy_ || this.target_;
      var l = ka(i), h = {
        configurable: A.safeDescriptors ? this.isPlainObject_ : !0,
        enumerable: !1,
        get: l.get,
        set: l.set
      };
      if (n) {
        if (!Reflect.defineProperty(this.target_, i, h))
          return !1;
      } else
        ci(this.target_, i, h);
      this.values_.set(i, new He(s)), this.notifyPropertyAddition_(i, void 0);
    } finally {
      Fe();
    }
    return !0;
  }, t.delete_ = function(i, s) {
    if (s === void 0 && (s = !1), hi(this.keysAtom_), !De(this.target_, i))
      return !0;
    if (Be(this)) {
      var n = Ge(this, {
        object: this.proxy_ || this.target_,
        name: i,
        type: Da
      });
      if (!n)
        return null;
    }
    try {
      var r;
      Me();
      var o = Ze(this), l = Wt(), h = this.values_.get(i), c = void 0;
      if (!h && (o || l)) {
        var d;
        c = (d = gr(this.target_, i)) == null ? void 0 : d.value;
      }
      if (s) {
        if (!Reflect.deleteProperty(this.target_, i))
          return !1;
      } else
        delete this.target_[i];
      if (delete this.appliedAnnotations_[i], h && (this.values_.delete(i), h instanceof ds && (c = h.value_), ch(h)), this.keysAtom_.reportChanged(), (r = this.pendingKeys_) == null || (r = r.get(i)) == null || r.set(i in this.target_), o || l) {
        var f = {
          type: Da,
          observableKind: "object",
          object: this.proxy_ || this.target_,
          debugObjectName: this.name_,
          oldValue: c,
          name: i
        };
        l && Ie(f), o && $e(this, f), l && Ee();
      }
    } finally {
      Fe();
    }
    return !0;
  }, t.observe_ = function(i, s) {
    return s === !0 && R("`observe` doesn't support the fire immediately property for observable objects."), Un(this, i);
  }, t.intercept_ = function(i) {
    return qn(this, i);
  }, t.notifyPropertyAddition_ = function(i, s) {
    var n, r = Ze(this), o = Wt();
    if (r || o) {
      var l = r || o ? {
        type: Wi,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        name: i,
        newValue: s
      } : null;
      o && Ie(l), r && $e(this, l), o && Ee();
    }
    (n = this.pendingKeys_) == null || (n = n.get(i)) == null || n.set(!0), this.keysAtom_.reportChanged();
  }, t.ownKeys_ = function() {
    return this.keysAtom_.reportObserved(), Ur(this.target_);
  }, t.keys_ = function() {
    return this.keysAtom_.reportObserved(), Object.keys(this.target_);
  }, a;
})();
function tn(a, t) {
  var e;
  if (t && Xn(a) && R("Options can't be provided for already observable objects."), De(a, k))
    return Th(a) instanceof Go || R("Cannot convert '" + Ir(a) + `' into observable object:
The target is already observable of different type.
Extending builtins is not supported.`), a;
  Object.isExtensible(a) || R("Cannot make the designated object observable; it is not extensible");
  var i = (e = t?.name) != null ? e : (gi(a) ? "ObservableObject" : a.constructor.name) + "@" + si(), s = new Go(a, /* @__PURE__ */ new Map(), String(i), au(t));
  return qr(a, k, s), a;
}
var id = /* @__PURE__ */ Es("ObservableObjectAdministration", Go);
function ka(a) {
  return Va[a] || (Va[a] = {
    get: function() {
      return this[k].getObservablePropValue_(a);
    },
    set: function(e) {
      return this[k].setObservablePropValue_(a, e);
    }
  });
}
function Xn(a) {
  return jr(a) ? id(a[k]) : !1;
}
function _a(a, t, e) {
  var i;
  a.appliedAnnotations_[e] = t, (i = a.target_[he]) == null || delete i[e];
}
function Wa(a, t, e) {
  if (xh(t) || R("Cannot annotate '" + a.name_ + "." + e.toString() + "': Invalid annotation."), !Pr(t) && De(a.appliedAnnotations_, e)) {
    var i = a.name_ + "." + e.toString(), s = a.appliedAnnotations_[e].annotationType_, n = t.annotationType_;
    R("Cannot apply '" + n + "' to '" + i + "':" + (`
The field is already annotated with '` + s + "'.") + `
Re-annotating fields is not allowed.
Use 'override' annotation for methods overridden by subclass.`);
  }
}
var sd = /* @__PURE__ */ wh(0), nd = /* @__PURE__ */ (function() {
  var a = !1, t = {};
  return Object.defineProperty(t, "0", {
    set: function() {
      a = !0;
    }
  }), Object.create(t)[0] = 1, a === !1;
})(), co = 0, Eh = function() {
};
function rd(a, t) {
  Object.setPrototypeOf ? Object.setPrototypeOf(a.prototype, t) : a.prototype.__proto__ !== void 0 ? a.prototype.__proto__ = t : a.prototype = t;
}
rd(Eh, Array.prototype);
var ia = /* @__PURE__ */ (function(a) {
  function t(i, s, n, r) {
    var o;
    return n === void 0 && (n = "ObservableArray@" + si()), r === void 0 && (r = !1), o = a.call(this) || this, As(function() {
      var l = new ea(n, s, r, !0);
      l.proxy_ = o, ql(o, k, l), i && i.length && o.spliceWithArray(0, 0, i), nd && Object.defineProperty(o, "0", sd);
    }), o;
  }
  Ql(t, a);
  var e = t.prototype;
  return e.concat = function() {
    this[k].atom_.reportObserved();
    for (var s = arguments.length, n = new Array(s), r = 0; r < s; r++)
      n[r] = arguments[r];
    return Array.prototype.concat.apply(
      this.slice(),
      //@ts-ignore
      n.map(function(o) {
        return Kr(o) ? o.slice() : o;
      })
    );
  }, e[Symbol.iterator] = function() {
    var i = this, s = 0;
    return sa({
      next: function() {
        return s < i.length ? {
          value: i[s++],
          done: !1
        } : {
          done: !0,
          value: void 0
        };
      }
    });
  }, $s(t, [{
    key: "length",
    get: function() {
      return this[k].getArrayLength_();
    },
    set: function(s) {
      this[k].setArrayLength_(s);
    }
  }, {
    key: Symbol.toStringTag,
    get: function() {
      return "Array";
    }
  }]);
})(Eh);
Object.entries(vr).forEach(function(a) {
  var t = a[0], e = a[1];
  t !== "concat" && qr(ia.prototype, t, e);
});
function wh(a) {
  return {
    enumerable: !1,
    configurable: !0,
    get: function() {
      return this[k].get_(a);
    },
    set: function(e) {
      this[k].set_(a, e);
    }
  };
}
function od(a) {
  ci(ia.prototype, "" + a, wh(a));
}
function Ah(a) {
  if (a > co) {
    for (var t = co; t < a + 100; t++)
      od(t);
    co = a;
  }
}
Ah(1e3);
function ad(a, t, e) {
  return new ia(a, t, e);
}
function Hs(a, t) {
  if (typeof a == "object" && a !== null) {
    if (Kr(a))
      return t !== void 0 && R(23), a[k].atom_;
    if (ai(a))
      return a.atom_;
    if (es(a)) {
      if (t === void 0)
        return a.keysAtom_;
      var e = a.data_.get(t) || a.hasMap_.get(t);
      return e || R(25, t, Ir(a)), e;
    }
    if (Xn(a)) {
      if (!t)
        return R(26);
      var i = a[k].values_.get(t);
      return i || R(27, t, Ir(a)), i;
    }
    if (Yo(a) || Jr(a) || br(a))
      return a;
  } else if (Lt(a) && br(a[k]))
    return a[k];
  R(28);
}
function Th(a, t) {
  if (a || R(29), Yo(a) || Jr(a) || br(a) || es(a) || ai(a))
    return a;
  if (a[k])
    return a[k];
  R(24, a);
}
function Ir(a, t) {
  var e;
  if (t !== void 0)
    e = Hs(a, t);
  else {
    if (vs(a))
      return a.name;
    Xn(a) || es(a) || ai(a) ? e = Th(a) : e = Hs(a);
  }
  return e.name_;
}
function As(a) {
  var t = ws(), e = Ko(!0);
  Me();
  try {
    return a();
  } finally {
    Fe(), Zo(e), Li(t);
  }
}
var Ha = zr.toString;
function Oh(a, t, e) {
  return e === void 0 && (e = -1), Mo(a, t, e);
}
function Mo(a, t, e, i, s) {
  if (a === t)
    return a !== 0 || 1 / a === 1 / t;
  if (a == null || t == null)
    return !1;
  if (a !== a)
    return t !== t;
  var n = typeof a;
  if (n !== "function" && n !== "object" && typeof t != "object")
    return !1;
  var r = Ha.call(a);
  if (r !== Ha.call(t))
    return !1;
  switch (r) {
    // Strings, numbers, regular expressions, dates, and booleans are compared by value.
    case "[object RegExp]":
    // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
    case "[object String]":
      return "" + a == "" + t;
    case "[object Number]":
      return +a != +a ? +t != +t : +a == 0 ? 1 / +a === 1 / t : +a == +t;
    case "[object Date]":
    case "[object Boolean]":
      return +a == +t;
    case "[object Symbol]":
      return typeof Symbol < "u" && Symbol.valueOf.call(a) === Symbol.valueOf.call(t);
    case "[object Map]":
    case "[object Set]":
      e >= 0 && e++;
      break;
  }
  a = za(a), t = za(t);
  var o = r === "[object Array]";
  if (!o) {
    if (typeof a != "object" || typeof t != "object")
      return !1;
    var l = a.constructor, h = t.constructor;
    if (l !== h && !(Lt(l) && l instanceof l && Lt(h) && h instanceof h) && "constructor" in a && "constructor" in t)
      return !1;
  }
  if (e === 0)
    return !1;
  e < 0 && (e = -1), i = i || [], s = s || [];
  for (var c = i.length; c--; )
    if (i[c] === a)
      return s[c] === t;
  if (i.push(a), s.push(t), o) {
    if (c = a.length, c !== t.length)
      return !1;
    for (; c--; )
      if (!Mo(a[c], t[c], e - 1, i, s))
        return !1;
  } else {
    var d = Object.keys(a), f = d.length;
    if (Object.keys(t).length !== f)
      return !1;
    for (var p = 0; p < f; p++) {
      var P = d[p];
      if (!(De(t, P) && Mo(a[P], t[P], e - 1, i, s)))
        return !1;
    }
  }
  return i.pop(), s.pop(), !0;
}
function za(a) {
  return Kr(a) ? a.slice() : Zs(a) || es(a) || wi(a) || ai(a) ? Array.from(a.entries()) : a;
}
var ja, ld = ((ja = Xo().Iterator) == null ? void 0 : ja.prototype) || {};
function sa(a) {
  return a[Symbol.iterator] = hd, Object.assign(Object.create(ld), a);
}
function hd() {
  return this;
}
function xh(a) {
  return (
    // Can be function
    a instanceof Object && typeof a.annotationType_ == "string" && Lt(a.make_) && Lt(a.extend_)
  );
}
["Symbol", "Map", "Set"].forEach(function(a) {
  var t = Xo();
  typeof t[a] > "u" && R("MobX requires global '" + a + "' to be available or polyfilled");
});
typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ == "object" && __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
  spy: Tu,
  extras: {
    getDebugName: Ir
  },
  $mobx: k
});
let qa = class {
  remove(t) {
    this.nodeMap.delete(t.id);
  }
  addEdge(t) {
    this._edgeMap[t.id] = t;
  }
  findEdge = (t) => this._edgeMap[t];
  get size() {
    return this.nodeMap.size;
  }
  get getEdgesMap() {
    return this._edgeMap;
  }
  /** List of object edges. */
  //private _edgeMap: Record<string, Edge> = {};
  _edgeMap = {};
  *nodes_() {
    for (const t of this.nodeMap.values())
      yield t;
  }
  *graphs_() {
    for (const t of this.nodes_())
      t instanceof be && (yield t);
  }
  constructor() {
    bh(this, {
      nodeMap: It,
      _edgeMap: It,
      getNodeMap: li,
      getEdgesMap: li,
      remove: Ne
    }, { autoBind: !0 }), this.findEdge = this.findEdge.bind(this);
  }
  findShallow(t) {
    return this.nodeMap.get(t);
  }
  get nodesShallow() {
    return this.nodes_();
  }
  get graphs() {
    return this.graphs_();
  }
  nodeMap = /* @__PURE__ */ new Map();
  get getNodeMap() {
    return this.nodeMap;
  }
  *_edges() {
    for (const t of this.nodeMap.values()) {
      for (const e of t.outEdges)
        yield e;
      for (const e of t.selfEdges)
        yield e;
    }
  }
  interGraphEdges() {
    throw new Error("not implemented");
  }
  get nodeShallowCount() {
    return this.nodeMap.size;
  }
  // caution: it is a linear by the number of nodes method
  get edgeCount() {
    let t = 0;
    for (const e of this.nodeMap.values())
      t += e.outDegree + e.selfDegree;
    return t;
  }
  /**  returns the edges of shallow nodes */
  get edges() {
    return this._edges();
  }
  addNode(t) {
    this.nodeMap.set(t.id, t);
  }
  nodeIsConsistent(t) {
    for (const e of t.outEdges)
      if (e.source !== t || e.source === e.target)
        return !1;
    for (const e of t.inEdges)
      if (e.target !== t || e.source === e.target)
        return !1;
    for (const e of t.selfEdges)
      if (e.target !== e.source || e.source !== t)
        return !1;
    return !0;
  }
  isConsistent() {
    for (const t of this.nodeMap.values())
      if (!this.nodeIsConsistent(t))
        return !1;
    return !0;
  }
};
class Lh {
  /** this in the index of where the attribute is positioned in the attribute array of the entity */
  bind(t) {
    this.entity && this.entity.setAttr(t, this);
  }
  /** The arguments are the underlying entity and the attribute index in the attribute array */
  constructor(t, e) {
    this.entity = t, this.bind(e);
  }
}
class _e {
}
_e.GeomObjectIndex = 0;
_e.DrawingObjectIndex = 1;
_e.AlgorithmDataIndex = 2;
_e.ViewerIndex = 3;
class $ extends Lh {
  constructor(t) {
    super(t, _e.GeomObjectIndex);
  }
  static getGeom(t) {
    return t == null ? null : t.getAttr(_e.GeomObjectIndex);
  }
  get parent() {
    const t = this.entity.parent;
    return t ? $.getGeom(t) : null;
  }
  rebind(t) {
    this.entity = t, this.bind(_e.GeomObjectIndex);
  }
  *getAncestors() {
    let t = this.parent;
    for (; t != null; )
      yield t, t = t.parent;
  }
}
class Ji {
  static solve(t, e, i, s, n, r) {
    const o = t * n - s * e;
    if (!(Math.abs(o) < Ji.eps))
      return {
        x: (i * n - r * e) / o,
        y: (t * r - s * i) / o
      };
  }
}
Ji.eps = 1e-8;
class m {
}
m.distanceEpsilonPrecision = 6;
m.mult = Math.pow(10, 6);
m.defaultLeafBoxesOffset = 0.5;
m.lineSegmentThreshold = 0.05;
m.intersectionEpsilon = 1e-4;
m.distanceEpsilon = Math.pow(10, -m.distanceEpsilonPrecision);
m.squareOfDistanceEpsilon = Math.pow(10, -m.distanceEpsilonPrecision * 2);
m.tolerance = 1e-8;
function cd(a, t) {
  return (a ? 1 : 0) - (t ? 1 : 0);
}
function yt(a, t) {
  const e = a - t;
  return e < 0 ? -1 : e === 0 ? 0 : 1;
}
function lr(a, t) {
  const e = yt(a.y, t.y);
  return e || yt(a.x, t.x);
}
function D(a, t) {
  const e = a - t;
  return -m.distanceEpsilon <= e && e <= m.distanceEpsilon;
}
function uo(a, t) {
  return Er(a, t) > 0;
}
function Er(a, t) {
  const e = a - t;
  return e <= -m.distanceEpsilon ? -1 : e >= m.distanceEpsilon ? 1 : 0;
}
var L;
(function(a) {
  a[a.Clockwise = 0] = "Clockwise", a[a.Counterclockwise = 1] = "Counterclockwise", a[a.Collinear = 2] = "Collinear";
})(L || (L = {}));
function Z(a, t) {
  return a.sub(t).length;
}
class u {
  static RoundPoint(t) {
    return new u(u.RoundDouble(t.x), u.RoundDouble(t.y));
  }
  static RoundDouble(t) {
    return Math.round(t * m.mult) / m.mult;
  }
  toJSON() {
    return { x: this.x, y: this.y };
  }
  static fromJSON(t) {
    return new u(t.x, t.y);
  }
  /** c is projected to line through a, b */
  static ProjectionToLine(t, e, i) {
    let s = e.sub(t);
    const n = s.length;
    if (n < m.distanceEpsilon)
      return t;
    s = s.div(n);
    const r = i.sub(t).dot(s);
    return t.add(s.mul(r));
  }
  static RayIntersectsRayInteriors(t, e, i, s) {
    const n = u.lineLineIntersection(t, t.add(e), i, i.add(s));
    if (n && n.sub(t).dot(e.div(e.l1)) > m.distanceEpsilon && n.sub(i).dot(s.div(s.l1)) > m.distanceEpsilon)
      return n;
  }
  static IntervalIntersectsRay(t, e, i, s) {
    const n = u.lineLineIntersection(t, e, i, i.add(s));
    if (!n)
      return;
    const r = t.sub(n), o = n.sub(e);
    if (!(r.dot(o) <= 0) && !(n.sub(i).dot(s) < 0) && r.dot(r) > m.squareOfDistanceEpsilon && o.dot(o) >= m.squareOfDistanceEpsilon)
      return n;
  }
  static PointToTheLeftOfLineOrOnLine(t, e, i) {
    return u.signedDoubledTriangleArea(t, e, i) >= 0;
  }
  // returns true if "point" lies to the left of the line linePoint0, linePoint1
  static PointToTheLeftOfLine(t, e, i) {
    return u.signedDoubledTriangleArea(t, e, i) > 0;
  }
  static PointIsInsideCone(t, e, i, s) {
    return u.PointToTheRightOfLineOrOnLine(t, e, i) && u.PointToTheLeftOfLineOrOnLine(t, e, s);
  }
  static PointToTheRightOfLineOrOnLine(t, e, i) {
    return u.signedDoubledTriangleArea(e, i, t) <= 0;
  }
  static PointToTheRightOfLine(t, e, i) {
    return u.signedDoubledTriangleArea(e, i, t) < 0;
  }
  static closeIntersections(t, e) {
    return u.close(t, e, m.intersectionEpsilon);
  }
  get l1() {
    return Math.abs(this.x_) + Math.abs(this.y_);
  }
  dot(t) {
    return this.x * t.x + this.y * t.y;
  }
  get x() {
    return this.x_;
  }
  get y() {
    return this.y_;
  }
  compareTo(t) {
    const e = yt(this.x, t.x);
    return e !== 0 ? e : yt(this.y, t.y);
  }
  toString() {
    return "(" + this.x + "," + this.y + ")";
  }
  static close(t, e, i) {
    return t.sub(e).length <= i;
  }
  static closeSquare(t, e, i) {
    const s = e.sub(t);
    return s.dot(s) <= i;
  }
  static closeDistEps(t, e, i = m.distanceEpsilon) {
    return t.sub(e).length <= i;
  }
  normalize() {
    const t = this.length;
    return new u(this.x / t, this.y / t);
  }
  get length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  get lengthSquared() {
    return this.x * this.x + this.y * this.y;
  }
  constructor(t, e) {
    this.x_ = t, this.y_ = e;
  }
  static middle(t, e) {
    return t.add(e).div(2);
  }
  scale(t, e) {
    return new u(this.x * t, this.y * e);
  }
  add(t) {
    return new u(this.x + t.x, this.y + t.y);
  }
  sub(t) {
    return new u(this.x - t.x, this.y - t.y);
  }
  mul(t) {
    return new u(this.x * t, this.y * t);
  }
  div(t) {
    return new u(this.x / t, this.y / t);
  }
  equal(t) {
    return t.x === this.x && t.y === this.y;
  }
  neg() {
    return new u(-this.x, -this.y);
  }
  static lineLineIntersection(t, e, i, s) {
    const n = e.sub(t), r = i.sub(s), o = i.sub(t), l = Ji.solve(n.x, r.x, o.x, n.y, r.y, o.y);
    if (l !== void 0)
      return t.add(n.mul(l.x));
  }
  static segSegIntersection(t, e, i, s) {
    const n = e.sub(t), r = i.sub(s), o = i.sub(t), l = m.tolerance, h = Ji.solve(n.x, r.x, o.x, n.y, r.y, o.y);
    if (h !== void 0 && h.x > -l && h.x < 1 + l && h.y > -l && h.y < 1 + l)
      return t.add(n.mul(h.x));
  }
  static parallelWithinEpsilon(t, e, i) {
    const s = t.length, n = e.length;
    return s < i || n < i ? !0 : (t = t.div(s), e = e.div(n), Math.abs(-t.x * e.y + t.y * e.x) < i);
  }
  static crossProduct(t, e) {
    return t.x * e.y - t.y * e.x;
  }
  static dot(t, e) {
    return t.x * e.x + t.y * e.y;
  }
  static add(t, e) {
    return t.add(e);
  }
  rotate90Ccw() {
    return new u(-this.y, this.x);
  }
  rotate90Cw() {
    return new u(this.y, -this.x);
  }
  clone() {
    return new u(this.x, this.y);
  }
  // returns this rotated by the angle counterclockwise; does not change "this" value
  rotate(t) {
    const e = Math.cos(t), i = Math.sin(t);
    return new u(e * this.x - i * this.y, i * this.x + e * this.y);
  }
  static mkPoint(t, e, i, s) {
    return e.mul(t).add(s.mul(i));
  }
  static convSum(t, e, i) {
    return e.add(i.sub(e).mul(t));
  }
  static anglePCP(t, e, i) {
    return u.angle(t.sub(e), i.sub(e));
  }
  // The angle you need to turn "side0" counterclockwise to make it collinear with "side1"
  static angle(t, e) {
    const i = t.x, s = t.y, n = e.x, r = e.y, o = i * r - s * n, l = i * n + s * r;
    if (Math.abs(l) < m.tolerance)
      return Math.abs(o) < m.tolerance ? 0 : o < -m.tolerance ? 3 * Math.PI / 2 : Math.PI / 2;
    if (Math.abs(o) < m.tolerance)
      return l < -m.tolerance ? Math.PI : 0;
    const h = Math.atan2(o, l);
    return o >= -m.tolerance ? h : Math.PI * 2 + h;
  }
  static signedDoubledTriangleArea(t, e, i) {
    return (e.x - t.x) * (i.y - t.y) - (i.x - t.x) * (e.y - t.y);
  }
  static getTriangleOrientation(t, e, i) {
    const s = u.signedDoubledTriangleArea(t, e, i);
    return s > m.distanceEpsilon ? L.Counterclockwise : s < -m.distanceEpsilon ? L.Clockwise : L.Collinear;
  }
  static getTriangleOrientationWithIntersectionEpsilon(t, e, i) {
    const s = u.signedDoubledTriangleArea(t, e, i);
    return s > m.intersectionEpsilon ? L.Counterclockwise : s < -m.intersectionEpsilon ? L.Clockwise : L.Collinear;
  }
  static ClosestPointAtLineSegment(t, e, i) {
    const s = i.sub(e), n = t.sub(e), r = s.dot(n), o = s.dot(s);
    return r <= 0 + m.tolerance ? e : o <= r + m.tolerance ? i : e.add(s.mul(r / o));
  }
  static pointToTheLeftOfLineOrOnLine(t, e, i) {
    return u.signedDoubledTriangleArea(t, e, i) >= 0;
  }
  // returns true if "point" lies to the left of the line linePoint0, linePoint1
  static pointToTheLeftOfLine(t, e, i) {
    return u.signedDoubledTriangleArea(t, e, i) > 0;
  }
  // returns true if "point" lies to the right of the line linePoint0, linePoint1
  static pointToTheRightOfLineOrOnLine(t, e, i) {
    return u.signedDoubledTriangleArea(e, i, t) <= 0;
  }
  static pointToTheRightOfLine(t, e, i) {
    return u.signedDoubledTriangleArea(e, i, t) < 0;
  }
  static canProject(t, e, i) {
    const s = i.sub(e);
    return !(t.sub(e).dot(s) < 0 || t.sub(i).dot(s) > 0);
  }
  static distToLineSegment(t, e, i) {
    const s = i.sub(e), n = t.sub(e);
    let r, o;
    if ((r = s.dot(n)) <= m.tolerance)
      return { par: 0, dist: n.length };
    if ((o = s.dot(s)) <= r + m.tolerance)
      return { par: 1, dist: t.sub(i).length };
    const l = r / o;
    return { par: l, dist: e.add(s.mul(l)).length };
  }
}
class ei {
  constructor() {
    this._next = null, this.prev = null;
  }
  get point() {
    return this._point;
  }
  set point(t) {
    this._point = t;
  }
  get next() {
    return this._next;
  }
  set next(t) {
    this._next = t;
  }
  get nextOnPolyline() {
    return this.polyline.next(this);
  }
  get prevOnPolyline() {
    return this.polyline.prev(this);
  }
  //
  getNext() {
    return this.next;
  }
  setNext(t) {
    this.next = t, this.polyline != null && this.polyline.setInitIsRequired();
  }
  //
  getPrev() {
    return this.prev;
  }
  setPrev(t) {
    this.prev = t, this.polyline != null && this.polyline.setInitIsRequired();
  }
  static mkFromPoint(t) {
    const e = new ei();
    return e.point = t, e;
  }
}
var vi;
(function(a) {
  a[a.Corner = 0] = "Corner", a[a.VertexA = 1] = "VertexA", a[a.otherCorner = 2] = "otherCorner", a[a.VertexB = 3] = "VertexB";
})(vi || (vi = {}));
class Q {
  // Return true if the parallelogram contains the point
  contains(t) {
    const e = t.sub(this.corner), i = m.distanceEpsilon, s = e.dot(this.bRot);
    if (s > this.abRot + i || s < -i)
      return !1;
    const n = e.dot(this.aRot);
    return n <= this.baRot + i && n >= -i;
  }
  get area() {
    return Math.abs(this.a.x * this.b.y - this.a.y * this.b.x);
  }
  vertex(t) {
    switch (t) {
      case vi.Corner:
        return this.corner;
      case vi.VertexA:
        return this.aPlusCorner;
      case vi.otherCorner:
        return this.otherCorner;
      case vi.VertexB:
        return this.bPlusCorner;
      default:
        return;
    }
  }
  static parallelogramOfTwo(t, e) {
    const i = new Q(), s = t.corner, n = {
      minx: s.x,
      maxx: s.x,
      miny: s.y,
      maxy: s.y
    };
    return Q.pumpMinMax(n, t.aPlusCorner), Q.pumpMinMax(n, t.otherCorner), Q.pumpMinMax(n, t.bPlusCorner), Q.pumpMinMax(n, e.corner), Q.pumpMinMax(n, e.aPlusCorner), Q.pumpMinMax(n, e.otherCorner), Q.pumpMinMax(n, e.bPlusCorner), i.corner = new u(n.minx, n.miny), i.a = new u(0, n.maxy - n.miny), i.b = new u(n.maxx - n.minx, 0), i.aPlusCorner = i.a.add(i.corner), i.otherCorner = i.b.add(i.aPlusCorner), i.bPlusCorner = i.b.add(i.corner), i.aRot = new u(-i.a.y, i.a.x), i.aRot.length > 0.5 && (i.aRot = i.aRot.normalize()), i.bRot = new u(-i.b.y, i.b.x), i.bRot.length > 0.5 && (i.bRot = i.bRot.normalize()), i.abRot = i.a.dot(i.bRot), i.baRot = i.b.dot(i.aRot), i.abRot < 0 && (i.abRot = -i.abRot, i.bRot = i.bRot.neg()), i.baRot < 0 && (i.baRot = -i.baRot, i.aRot = i.aRot.neg()), i.isSeg = i.a.sub(i.b).length < m.distanceEpsilon, i;
  }
  static pumpMinMax(t, e) {
    e.x < t.minx ? t.minx = e.x : e.x > t.maxx && (t.maxx = e.x), e.y < t.miny ? t.miny = e.y : e.y > t.maxy && (t.maxy = e.y);
  }
  // returns true if parallelograms intersect
  static intersect(t, e) {
    return !(Q.separByA(t, e) || Q.separByA(e, t) || Q.separByB(t, e) || Q.separByB(e, t)) === !1 ? !1 : !(t.isSeg && e.isSeg) || !u.parallelWithinEpsilon(t.otherCorner.sub(t.corner), e.otherCorner.sub(e.corner), 1e-5) ? !0 : Q.ParallelSegsIntersect(e, t);
  }
  static ParallelSegsIntersect(t, e) {
    const i = t.corner, s = t.otherCorner, n = e.corner, r = e.otherCorner, o = s.sub(i), l = 0, h = o.dot(o);
    let c = n.sub(i).dot(o), d = r.sub(i).dot(o);
    if (c > d) {
      const f = c;
      c = d, d = f;
    }
    return !(d < l - m.distanceEpsilon || c > h + m.distanceEpsilon);
  }
  static separByB(t, e) {
    const i = m.distanceEpsilon, s = e.vertex(0).sub(t.corner).dot(t.bRot), n = [vi.VertexA, vi.otherCorner, vi.VertexB];
    if (s > t.abRot + i) {
      for (const r of n)
        if (e.vertex(r).sub(t.corner).dot(t.bRot) <= t.abRot + i)
          return !1;
      return !0;
    } else if (s < -i) {
      for (const r of n)
        if (e.vertex(r).sub(t.corner).dot(t.bRot) >= -i)
          return !1;
      return !0;
    }
    return !1;
  }
  static separByA(t, e) {
    const i = m.distanceEpsilon;
    let s = e.corner.sub(t.corner);
    const n = u.dot(s, t.aRot);
    return n > t.baRot + i ? (s = e.aPlusCorner.sub(t.corner), !(u.dot(s, t.aRot) <= t.baRot + i || (s = e.bPlusCorner.sub(t.corner), u.dot(s, t.aRot) <= t.baRot + i) || (s = e.otherCorner.sub(t.corner), u.dot(s, t.aRot) <= t.baRot + i))) : n < -i ? (s = e.aPlusCorner.sub(t.corner), !(u.dot(s, t.aRot) >= -i || (s = e.bPlusCorner.sub(t.corner), u.dot(s, t.aRot) >= -i) || (s = e.otherCorner.sub(t.corner), u.dot(s, t.aRot) >= -i))) : !1;
  }
  static parallelogramByCornerSideSide(t, e, i) {
    const s = new Q();
    return s.corner = t, s.a = e, s.b = i, s.aRot = new u(-e.y, e.x), s.aRot.length > 0.5 && (s.aRot = s.aRot.normalize()), s.bRot = new u(-i.y, i.x), s.bRot.length > 0.5 && (s.bRot = s.bRot.normalize()), s.abRot = s.bRot.dot(e), s.baRot = i.dot(s.aRot), s.abRot < 0 && (s.abRot = -s.abRot, s.bRot = s.bRot.neg()), s.baRot < 0 && (s.baRot = -s.baRot, s.aRot = s.aRot.neg()), s.isSeg = e.sub(i).length < m.distanceEpsilon, s.aPlusCorner = e.add(t), s.otherCorner = i.add(s.aPlusCorner), s.bPlusCorner = i.add(t), s;
  }
  static getParallelogramOfAGroup(t) {
    let e = 0, i = 0, s = 0, n = 0, r = !0;
    for (const o of t) {
      const l = ud(o);
      for (const h of l) {
        const c = h.x, d = h.y;
        r ? (r = !1, e = i = c, s = n = d) : (c < e ? e = c : c > i && (i = c), d < s ? s = d : d > n && (n = d));
      }
    }
    return Q.parallelogramByCornerSideSide(new u(e, s), new u(0, n - s), new u(i - e, 0));
  }
}
function* ud(a) {
  yield a.corner, yield a.aPlusCorner, yield a.otherCorner, yield a.bPlusCorner;
}
class v {
  static fromJSON(t) {
    return v.mkPP(u.fromJSON(t.start), u.fromJSON(t.end));
  }
  toJSON() {
    return { start: this.start.toJSON(), end: this.end.toJSON() };
  }
  // Offsets the curve in the direction of dir
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  offsetCurve(t, e) {
    return null;
  }
  constructor(t, e, i, s) {
    this.parStart = 0, this.parEnd = 1, this.start = new u(t, e), this.end = new u(i, s);
  }
  // Returns the trim curve
  trim(t, e) {
    if (t = Math.max(this.parStart, t), e = Math.min(this.parEnd, e), t > e)
      throw "wrong params in trimming";
    const i = this.value(t), s = this.value(e);
    return u.close(i, s, m.distanceEpsilon) ? null : v.mkPP(i, s);
  }
  value(t) {
    return this.start.add(this.end.sub(this.start).mul(t));
  }
  // Not Implemented: Returns the trimmed curve, wrapping around the end if start is greater than end.
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  trimWithWrap(t, e) {
    return null;
  }
  // not implemented
  // A tree of ParallelogramNodes covering the curve.
  // This tree is used in curve intersections routines.
  // <value></value>
  pNodeOverICurve() {
    const t = this.end.sub(this.start).mul(0.5);
    return {
      parallelogram: Q.parallelogramByCornerSideSide(this.start, t, t),
      seg: this,
      leafBoxesOffset: 0,
      node: {
        low: 0,
        high: 1,
        chord: this
      }
    };
  }
  normal() {
    let t = this.start.sub(this.end);
    return t = t.div(t.length), new u(-t.y, t.x);
  }
  // construct a line segment
  static mkPP(t, e) {
    return new v(t.x, t.y, e.x, e.y);
  }
  // constructs a line segment
  static mkLinePXY(t, e, i) {
    return new v(t.x, t.y, e, i);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  derivative(t) {
    return this.end.sub(this.start);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  secondDerivative(t) {
    return new u(0, 0);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  thirdDerivative(t) {
    return new u(0, 0);
  }
  reverse() {
    return v.mkPP(this.end, this.start);
  }
  /*
  static internal IntersectionInfo Cross(LineSeg coeff, LineSeg side1){
  IntersectionInfo xx=CrossTwoLines(coeff.start, coeff.End-coeff.start,side1.start, side1.End-side1.start);
  if (xx == null )
  {
  //parallel segs
  Point adir=coeff.d1(0);
  Point bdir=side1.d1(0);
  
  if (adir.length > bdir.length)
  {
  if (adir.length > Curve.DistEps)
  {
  adir = adir.normalize();
  if(Math.Abs((coeff-side1)*adir<Curve.DistEps)){
  
  }
  }
  }
  return null;
  }
  
  if(xx.Par0>1){
  if (Point.closeDistEps(coeff.End, xx.x))
  {
  xx.x = coeff.End;
  xx.Par0 = 1;
  }
  else
  return null;
  }
  else if(xx.Par0<0){
  if(Point.closeDistEps(coeff.start,xx.x)){
  xx.x=coeff.start;
  xx.Par0=1;
  }
  else
  return null;
  }
  
  if (xx.Par1 > 1)
  {
  if (Point.closeDistEps(side1.End, xx.x))
  {
  xx.x = coeff.End;
  xx.Par1 = 1;
  }
  else
  return null;
  }
  else if (xx.Par1 < 0)
  {
  if (Point.closeDistEps(side1.start, xx.x))
  {
  xx.x = coeff.start;
  xx.Par1 = 1;
  }
  else
  return null;
  }
  
  return xx;
  }
  * */
  // mutable! changes this
  // Returns the curved moved by delta
  translate(t) {
    this.start = this.start.add(t), this.end = this.end.add(t);
  }
  // Scale (multiply) from origin by x and y
  scaleFromOrigin(t, e) {
    return v.mkPP(this.start.scale(t, e), this.end.scale(t, e));
  }
  // gets the parameter at a specific length from the start along the curve
  getParameterAtLength(t) {
    const e = this.end.sub(this.start).length;
    if (e < m.tolerance)
      return 0;
    const i = t / e;
    return i > 1 ? 1 : i < 0 ? 0 : i;
  }
  // Return the transformed curve
  transform(t) {
    return v.mkPP(t.multiplyPoint(this.start), t.multiplyPoint(this.end));
  }
  // returns a parameter t such that the distance between curve[t] and targetPoint is minimal
  // and t belongs to the closed segment [low,high]
  closestParameterWithinBounds(t, e, i) {
    let s = this.closestParameter(t);
    return s < e && (s = e), s > i && (s = i), s;
  }
  // return length of the curve segment [start,end]
  lengthPartial(t, e) {
    return this.value(e).sub(this.value(t)).length;
  }
  // Get the length of the curve
  get length() {
    return this.start.sub(this.end).length;
  }
  // The bounding box of the line
  get boundingBox() {
    return T.mkPP(this.start, this.end);
  }
  // clones the curve.
  clone() {
    return v.mkPP(this.start.clone(), this.end.clone());
  }
  static closestParameterOnLineSegment(t, e, i) {
    const s = i.sub(e), n = t.sub(e), r = s.dot(n);
    if (r <= 0 + m.tolerance)
      return 0;
    const o = s.dot(s);
    return o <= r + m.tolerance ? 1 : r / o;
  }
  // returns a parameter t such that the distance between curve[t] and a is minimal
  closestParameter(t) {
    return v.closestParameterOnLineSegment(t, this.start, this.end);
  }
  // left derivative at t
  leftDerivative(t) {
    return this.derivative(t);
  }
  // right derivative at t
  rightDerivative(t) {
    return this.derivative(t);
  }
  // returns true if segments are not parallel and are intesecting
  static IntersectPPPP(t, e, i, s) {
    const n = u.lineLineIntersection(t, e, i, s);
    if (n != null && Rs(n, t, e) && Rs(n, i, s))
      return n;
  }
  //
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  curvature(t) {
    return 0;
  }
  //
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  curvatureDerivative(t) {
    return 0;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  curvatureSecondDerivative(t) {
    return 0;
  }
  // [a,b] and [c,d] are the segments. u and v are the corresponding closest point params
  // see http://www.geometrictools.com/Documentation/DistanceLine3Line3.pdf
  static minDistBetweenLineSegments(t, e, i, s) {
    const n = e.sub(t), r = s.sub(i), o = t.sub(i), l = u.crossProduct(n, r), h = n.dot(n), c = n.dot(r), d = r.dot(r), f = n.dot(o), p = r.dot(o);
    let P, y;
    const C = Math.abs(l);
    let w = C, N = C;
    C < m.tolerance ? (P = 0, w = 1, y = p, N = d) : (P = u.crossProduct(r, o), y = u.crossProduct(n, o), l < 0 && (P = -P, y = -y), P < 0 ? (P = 0, y = p, N = d) : P > w && (P = w = 1, y = p + c, N = d)), y < 0 ? (y = 0, -f < 0 ? P = 0 : -f > h ? P = w : (P = -f, w = h)) : y > N && (y = N = 1, -f + c < 0 ? P = 0 : -f + c > h ? P = w : (P = -f + c, w = h));
    const I = Math.abs(P) < m.tolerance ? 0 : P / w, x = Math.abs(y) < m.tolerance ? 0 : y / N;
    return {
      parab: I,
      parcd: x,
      // get the difference of the two closest points
      //           const dP = w + (parab * u) - (parcd * v),
      dist: o.add(n.mul(I).sub(r.mul(x))).length
      // return the closest distance
    };
  }
}
function Rs(a, t, e) {
  return a.x >= Math.min(t.x, e.x) - m.distanceEpsilon && a.y >= Math.min(t.y, e.y) - m.distanceEpsilon && a.x <= Math.max(t.x, e.x) + m.distanceEpsilon && a.y <= Math.max(t.y, e.y) + m.distanceEpsilon;
}
function Rh(a, t, e, i) {
  const s = u.getTriangleOrientation(a, t, e), n = u.getTriangleOrientation(a, t, i), r = u.getTriangleOrientation(e, i, a), o = u.getTriangleOrientation(e, i, t);
  return !!(s != n && r != o || s == L.Collinear && Rs(e, a, t) || n == L.Collinear && Rs(i, a, t) || r == L.Collinear && Rs(a, e, i) || o == L.Collinear && Rs(t, e, i));
}
function dd(a, t, e, i, s) {
  return {
    parallelogram: e,
    seg: i,
    leafBoxesOffset: s,
    node: {
      low: a,
      high: t,
      chord: null
      // create a cord only the segment and the chord are within intersectionEpsilon
    }
  };
}
class Ct {
  static distToSegm(t, e, i) {
    const s = i.sub(e);
    if (s.length < m.intersectionEpsilon)
      return t.sub(e.add(i).div(2)).length;
    let n = new u(-s.y, s.x);
    return n = n.mul(1 / n.length), Math.abs(t.sub(e).dot(n));
  }
  static createParallelogramOnSubSeg(t, e, i) {
    let s = i.derivative(t);
    const n = i.derivative(e), r = new u(-n.y, n.x), o = i.value(t), l = i.value(e), c = l.sub(o).dot(r), d = s.dot(r), f = Math.abs(c) < m.distanceEpsilon;
    if (!f && Math.abs(d) < m.distanceEpsilon)
      return;
    const p = f ? 0 : c / d;
    return s = s.mul(p), Q.parallelogramByCornerSideSide(o, s, l.sub(o).sub(s));
  }
  static createParallelogramNodeForCurveSeg(t, e, i, s) {
    if (t === i.parStart && e === i.parEnd && u.close(i.start, i.end, m.distanceEpsilon))
      return Ct.createNodeWithSegmentSplit(t, e, i, s);
    const r = i.value(t), o = i.value(e), l = o.sub(r), h = i.value((t + e) / 2);
    if (Ct.distToSegm(h, r, o) <= m.intersectionEpsilon && l.dot(l) < m.lineSegmentThreshold * m.lineSegmentThreshold && e - t < m.lineSegmentThreshold) {
      const c = v.mkPP(r, o), d = c.pNodeOverICurve();
      d.seg = i;
      const f = d.node;
      return f.low = t, f.high = e, f.chord = c, d;
    }
    if (Ct.WithinEpsilon(i, t, e, s)) {
      const c = Ct.createParallelogramOnSubSeg(t, e, i);
      if (c !== void 0)
        return dd(t, e, c, i, s);
    }
    return Ct.createNodeWithSegmentSplit(t, e, i, s);
  }
  static WithinEpsilon(t, e, i, s) {
    const r = (i - e) / 3, o = t.value(e), l = t.value(i);
    return Ct.distToSegm(t.value(e + r), o, l) > s ? !1 : Ct.distToSegm(t.value(e + r * 2), o, l) <= s;
  }
  static createParallelogramNodeForCurveSegDefaultOffset(t) {
    return Ct.createParallelogramNodeForCurveSeg(t.parStart, t.parEnd, t, m.defaultLeafBoxesOffset);
  }
  static createNodeWithSegmentSplit(t, e, i, s) {
    const n = {
      parallelogram: null,
      seg: i,
      leafBoxesOffset: 1,
      node: { children: [] }
    }, r = n.node;
    return r.children.push(Ct.createParallelogramNodeForCurveSeg(t, 0.5 * (t + e), i, s)), r.children.push(Ct.createParallelogramNodeForCurveSeg(0.5 * (t + e), e, i, s)), n.parallelogram = Q.parallelogramOfTwo(r.children[0].parallelogram, r.children[1].parallelogram), n;
  }
}
class Mi {
  // the constructor
  constructor(t, e, i, s, n) {
    this.par0 = t, this.par1 = e, this.x = i, this.seg0 = s, this.seg1 = n;
  }
}
class wr {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static closestPoint(t, e, i, s, n) {
    let l = i, h = 0, c = 0, d, f = !1;
    do {
      const p = t.value(l), P = t.derivative(l), y = t.secondDerivative(l), C = P.dot(P) + p.sub(e).dot(y);
      if (Math.abs(C) < m.tolerance)
        return l;
      d = p.sub(e).dot(P.div(C)), l -= d, l > n + m.tolerance ? (l = n, c++) : l < s - m.tolerance && (l = s, c++), h++;
    } while (Math.abs(d) > m.tolerance && !(f = h >= 5 || c >= 5));
    return f && t.value(i).sub(e).length < m.distanceEpsilon && (l = i), l;
  }
}
class j {
  isFullEllipse() {
    return this.parEnd === Math.PI * 2 && this.parStart === 0;
  }
  static fromJSON(t) {
    return new j(t.parStart, t.parEnd, u.fromJSON(t.axis0), u.fromJSON(t.axis1), u.fromJSON(t.center));
  }
  toJSON() {
    return {
      parStart: this.parStart,
      parEnd: this.parEnd,
      axis0: this.aAxis.toJSON(),
      axis1: this.bAxis.toJSON(),
      center: this.center.toJSON()
    };
  }
  /** offsets the curve in the given direction */
  offsetCurve(t, e) {
    const i = e.sub(this.center), s = u.angle(this.aAxis, i);
    if (this.aAxis.mul(Math.cos(s)).add(this.bAxis.mul(Math.sin(s))).length < i.length) {
      const r = this.aAxis.length, o = this.bAxis.length;
      return j.mkEllipsePPP(this.aAxis.normalize().mul(r + t), this.bAxis.normalize().mul(o + t), this.center);
    }
    {
      const r = this.aAxis.length, o = this.bAxis.length;
      return j.mkEllipsePPP(this.aAxis.normalize().mul(r - t), this.bAxis.normalize().mul(o - t), this.center);
    }
  }
  /** Reverse the ellipe: not implemented. */
  reverse() {
    return null;
  }
  static mkEllipsePPP(t, e, i) {
    return new j(0, Math.PI * 2, t, e, i);
  }
  constructor(t, e, i, s, n) {
    for (this.parStart = t, this.parEnd = e, this.aAxis = i, this.bAxis = s, this.center = n, this.pNode = null, this.setBoundingBox(); this.parStart < 0; )
      this.parStart += Math.PI * 2, this.parEnd += Math.PI * 2;
  }
  get start() {
    return this.value(this.parStart);
  }
  get end() {
    return this.value(this.parEnd);
  }
  /** Trims the curve */
  trim(t, e) {
    return new j(Math.max(t, this.parStart), Math.min(e, this.parEnd), this.aAxis, this.bAxis, this.center);
  }
  // Not Implemented: Returns the trimmed curve, wrapping around the end if start is greater than end.
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  trimWithWrap(t, e) {
    return null;
  }
  /** The bounding box of the ellipse */
  get boundingBox() {
    return this.box;
  }
  /** Returns the point on the curve corresponding to parameter t */
  value(t) {
    return this.center.add(u.mkPoint(Math.cos(t), this.aAxis, Math.sin(t), this.bAxis));
  }
  /** first derivative */
  derivative(t) {
    return u.mkPoint(-Math.sin(t), this.aAxis, Math.cos(t), this.bAxis);
  }
  /** second derivative */
  secondDerivative(t) {
    return u.mkPoint(-Math.cos(t), this.aAxis, -Math.sin(t), this.bAxis);
  }
  /** third derivative */
  thirdDerivative(t) {
    return u.mkPoint(Math.sin(t), this.aAxis, -Math.cos(t), this.bAxis);
  }
  /** a tree of ParallelogramNodes covering the edge */
  pNodeOverICurve() {
    return this.pNode != null ? this.pNode : this.pNode = Ct.createParallelogramNodeForCurveSegDefaultOffset(this);
  }
  setBoundingBox() {
    if (D(this.parStart, 0) && D(this.parEnd, Math.PI * 2))
      this.box = this.fullBox();
    else {
      this.box = T.mkPP(this.start, this.end);
      let t;
      for (let e = Math.ceil(this.parStart / (Math.PI / 2)); (t = e * Math.PI / 2) < this.parEnd; e++)
        t > this.parStart && this.box.add(this.value(t));
    }
  }
  static mkEllipse(t, e, i, s, n, r) {
    return new j(t, e, i, s, new u(n, r));
  }
  /** Construct a full ellipse by two axes */
  static mkFullEllipsePPP(t, e, i) {
    return new j(0, Math.PI * 2, t, e, i);
  }
  /** Constructs a full ellipse with axes aligned to X and Y directions */
  static mkFullEllipseNNP(t, e, i) {
    return new j(0, Math.PI * 2, new u(t, 0), new u(0, e), i);
  }
  /** creates a circle by a given radius and the center */
  static mkCircle(t, e) {
    return j.mkFullEllipseNNP(t, t, e);
  }
  /** Moves the ellipse to the delta vector */
  translate(t) {
    this.center = this.center.add(t), this.box.center = this.box.center.add(t), this.pNode = null;
  }
  /** Scales the ellipse by x and by y */
  scaleFromOrigin(t, e) {
    return new j(this.parStart, this.parEnd, this.aAxis.mul(t), this.bAxis.mul(e), this.center.scale(t, e));
  }
  //
  getParameterAtLength(t) {
    let i = this.parStart, s = this.parEnd;
    const n = t + 1e-3, r = t - 1e-3;
    for (; s - i > m.distanceEpsilon; ) {
      const o = 0.5 * (s + i), l = this.lengthPartial(this.parStart, o);
      if (l > n)
        s = o;
      else if (l < r)
        i = o;
      else
        return o;
    }
    return (s + i) / 2;
  }
  /** Transforms the ellipse */
  transform(t) {
    if (t != null) {
      const e = t.multiplyPoint(this.aAxis).sub(t.offset()), i = t.multiplyPoint(this.bAxis).sub(t.offset());
      return new j(this.parStart, this.parEnd, e, i, t.multiplyPoint(this.center));
    }
    return this.clone();
  }
  /** returns a parameter t such that the distance between curve[t] and targetPoint is minimal
   * and t belongs to the closed segment [low,high] */
  closestParameterWithinBounds(t, e, i) {
    const n = (i - e) / 9;
    let r = e, o = Number.MAX_VALUE;
    for (let h = 0; h <= 8; h++) {
      const c = e + h * n, d = t.sub(this.value(c)), f = d.dot(d);
      f < o && (o = f, r = c);
    }
    r === 0 && i === Math.PI * 2 && (e = -Math.PI);
    let l = wr.closestPoint(this, t, r, e, i);
    return l < 0 && (l += 2 * Math.PI), l;
  }
  // return length of the curve segment [start,end] : not implemented
  lengthPartial(t, e) {
    return g.lengthWithInterpolationAndThreshold(this.trim(t, e), m.lineSegmentThreshold / 100);
  }
  get length() {
    return (this.aAxis.length + this.bAxis.length) * Math.abs(this.parEnd - this.parStart) / 2;
  }
  /** clones the ellipse . */
  clone() {
    return new j(this.parStart, this.parEnd, this.aAxis.clone(), this.bAxis.clone(), this.center.clone());
  }
  /** returns a parameter t such that the distance between curve[t] and a is minimal */
  closestParameter(t) {
    let e = 0;
    const i = 8, s = (this.parEnd - this.parStart) / (i + 1);
    let n = this.parStart, r = Number.MAX_VALUE;
    for (let h = 0; h <= i; h++) {
      const c = this.parStart + h * s, d = t.sub(this.value(c)), f = d.dot(d);
      f < r && (r = f, n = c);
    }
    let o = !1;
    n === 0 && this.parEnd === Math.PI * 2 && (o = !0, e = this.parStart, this.parStart = -Math.PI);
    let l = wr.closestPoint(this, t, n, this.parStart, this.parEnd);
    return l < 0 && (l += 2 * Math.PI), o && (this.parStart = e), l;
  }
  // left derivative at t
  leftDerivative(t) {
    return this.derivative(t);
  }
  // right derivative at t
  rightDerivative(t) {
    return this.derivative(t);
  }
  //
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  curvature(t) {
    throw "NotImplementedException()";
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  curvatureDerivative(t) {
    throw "NotImplementedException();";
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  curvatureSecondDerivative(t) {
    throw "NotImplementedException()";
  }
  // returns true if the ellipse goes counterclockwise
  orientedCounterclockwise() {
    return u.crossProduct(this.aAxis, this.bAxis) > 0;
  }
  //returns the box of the ellipse that this ellipse is a part of
  fullBox() {
    const t = this.aAxis.add(this.bAxis);
    return T.mkPP(this.center.add(t), this.center.sub(t));
  }
  /**is it a proper arc? meaning that it just a part of a circle */
  isArc() {
    return Math.abs(this.aAxis.dot(this.bAxis)) < m.tolerance && Math.abs(this.aAxis.length - this.bAxis.length) < m.tolerance && u.closeDistEps(this.aAxis.rotate90Ccw(), this.bAxis);
  }
}
class fd {
  initValues() {
    this.a = this.curveA.value(this.si), this.b = this.curveB.value(this.ti), this.a_b = this.a.sub(this.b), this.ad = this.curveA.derivative(this.si), this.add = this.curveA.secondDerivative(this.si), this.bd = this.curveB.derivative(this.ti), this.bdd = this.curveB.secondDerivative(this.ti);
  }
  // curveAPar">first curve</param>
  // curveBPar">second curve</param>
  // lowBound0">the first curve minimal parameter</param>
  // upperBound0">the first curve maximal parameter</param>
  // lowBound1">the second curve minimal parameter</param>
  // upperBound1">the first curve maximal parameter</param>
  // guess0"></param>
  // guess1"></param>
  constructor(t, e, i, s, n, r, o, l) {
    this.curveA = t, this.curveB = e, this.aMin = i, this.bMin = n, this.aMax = s, this.bMax = r, this.aGuess = o, this.bGuess = l, this.si = o, this.ti = l;
  }
  //we ignore the mulitplier 2 here fore efficiency reasons
  Fs() {
    return (
      /*2**/
      this.a_b.dot(this.ad)
    );
  }
  Fss() {
    return (
      /*2**/
      this.a_b.dot(this.add) + this.ad.dot(this.ad)
    );
  }
  Fst() {
    return -/*2**/
    this.bd.dot(this.ad);
  }
  Ftt() {
    return (
      /*2**/
      -this.a_b.dot(this.bdd) + this.bd.dot(this.bd)
    );
  }
  Ft() {
    return -/*2**/
    this.a_b.dot(this.bd);
  }
  // xy - the first row
  // uw - the second row
  delta(t, e, i, s) {
    return t * s - i * e;
  }
  //Fs + Fss*ds + Fst*dt = 0
  //Ft + Fst*ds + Ftt*dt = 0
  solve() {
    let t = 0;
    const e = 10;
    let i = 0;
    const s = 100;
    let n = !1;
    if (this.initValues(), this.curveA instanceof v && this.curveB instanceof v) {
      let o = this.curveB.derivative(0);
      o = o.div(o.length);
      const l = this.curveA.normal(), h = Math.abs(l.dot(o));
      if (Math.abs(h) < m.distanceEpsilon || this.delta(this.Fss(), this.Fst(), this.Fst(), this.Ftt()) < m.tolerance) {
        this.success = !0, this.parallelLineSegLineSegMinDist();
        return;
      }
    }
    let r;
    do {
      const o = this.delta(this.Fss(), this.Fst(), this.Fst(), this.Ftt());
      if (Math.abs(o) < m.tolerance) {
        this.success = !1, n = !0;
        break;
      }
      r = {
        s: this.delta(-this.Fs(), this.Fst(), -this.Ft(), this.Ftt()) / o,
        t: this.delta(this.Fss(), -this.Fs(), this.Fst(), -this.Ft()) / o
      };
      const l = this.si + r.s, h = this.ti + r.t;
      let c;
      l > this.aMax + m.distanceEpsilon || l < this.aMin - m.distanceEpsilon || h > this.bMax + m.distanceEpsilon || h < this.bMin - m.distanceEpsilon ? (t++, this.chopDsDt(r), this.si += r.s, this.ti += r.t, c = !0) : (c = !1, this.si = l, this.ti = h, this.si > this.aMax ? this.si = this.aMax : this.si < this.aMin && (this.si = this.aMin), this.ti > this.bMax ? this.ti = this.bMax : this.ti < this.bMin && (this.ti = this.bMin)), this.initValues(), i++, n = t >= e || i >= s || r.s === 0 && r.t === 0 && c;
    } while ((Math.abs(r.s) >= m.tolerance || Math.abs(r.t) >= m.tolerance) && !n);
    if (n) {
      const o = this.curveA.value(this.aGuess).sub(this.curveB.value(this.bGuess));
      if (o.dot(o) < m.distanceEpsilon * m.distanceEpsilon) {
        this.aSolution = this.aGuess, this.bSolution = this.bGuess, this.aPoint = this.curveA.value(this.aGuess), this.bPoint = this.curveB.value(this.bGuess), this.success = !0;
        return;
      }
    }
    this.aSolution = this.si, this.bSolution = this.ti, this.aPoint = this.a, this.bPoint = this.b, this.success = !n;
  }
  // d is is {s:number; d:number}
  chopDsDt(t) {
    if (t.s !== 0 && t.t !== 0) {
      let e = 1;
      this.si + t.s > this.aMax ? e = (this.aMax - this.si) / t.s : this.si + t.s < this.aMin && (e = (this.aMin - this.si) / t.s);
      let i = 1;
      this.ti + t.t > this.bMax ? i = (this.bMax - this.ti) / t.t : this.ti + t.t < this.bMin && (i = (this.bMin - this.ti) / t.t);
      const s = Math.min(e, i);
      t.s *= s, t.t *= s;
    } else t.s === 0 ? this.ti + t.t > this.bMax ? t.t = this.bMax - this.ti : this.ti + t.t < this.bMin && (t.t = this.bMin - this.ti) : this.si + t.s > this.aMax ? t.s = this.aMax - this.si : this.si + t.s < this.aMin && (t.s = this.aMin - this.si);
  }
  parallelLineSegLineSegMinDist() {
    const t = this.curveA, e = this.curveB, i = t.start, s = t.end, n = e.start, r = e.end;
    let o = s.sub(i);
    const l = o.length;
    let h = 0, c, d, f;
    if (l > m.distanceEpsilon) {
      o = o.div(l), c = o.dot(s.sub(i)), d = o.dot(n.sub(i)), f = o.dot(r.sub(i));
      let p = !1;
      if (d > f) {
        p = !0;
        const P = d;
        d = f, f = P;
      }
      if (f < h)
        this.aSolution = 0, this.bSolution = p ? 0 : 1;
      else if (d > c)
        this.aSolution = 1, this.bSolution = p ? 1 : 0;
      else {
        const P = Math.min(c, f);
        this.aSolution = P / (c - h), this.bSolution = (P - d) / (f - d), p && (this.bSolution = 1 - this.bSolution);
      }
    } else {
      let p = r.sub(n);
      const P = p.length;
      if (P > m.distanceEpsilon)
        if (p = p.div(P), h = 0, c = p.dot(r.sub(n)), d = p.dot(i.sub(n)), d < h)
          this.bSolution = 0, this.aSolution = 1;
        else if (d > c)
          this.bSolution = 1, this.aSolution = 0;
        else {
          const y = Math.min(c, d);
          this.bSolution = y / (c - h), this.aSolution = 0;
        }
      else
        this.aSolution = 0, this.bSolution = 0;
    }
    this.aPoint = this.curveA.value(this.aSolution), this.bPoint = this.curveB.value(this.bSolution);
  }
}
class st {
  toJSON() {
    return { b: this.b.map((t) => t.toJSON()) };
  }
  static fromJSON(t) {
    return st.mkBezier(t.b.map(u.fromJSON));
  }
  leftDerivative(t) {
    return this.derivative(t);
  }
  rightDerivative(t) {
    return this.derivative(t);
  }
  /** get a control point */
  B(t) {
    return this.b[t];
  }
  /** A tree of ParallelogramNodes covering the curve.
   This tree is used in curve intersections routines. */
  pNodeOverICurve() {
    return this.pBoxNode != null ? this.pBoxNode : this.pBoxNode = Ct.createParallelogramNodeForCurveSegDefaultOffset(this);
  }
  /** Returns the point on the curve corresponding to parameter t */
  value(t) {
    const e = t * t, i = e * t;
    return this.l.mul(i).add(this.e.mul(e).add(this.c.mul(t)).add(this.b[0]));
  }
  static adjustParamTo01(t) {
    return t > 1 ? 1 : t < 0 ? 0 : t;
  }
  /**throw away the segments [0,u] and [v,1] of the segment,
  Returns the trimmed curve */
  trim(t, e) {
    if (t = st.adjustParamTo01(t), e = st.adjustParamTo01(e), t > e)
      return this.trim(e, t);
    if (t > 1 - m.tolerance)
      return new st(this.b[3], this.b[3], this.b[3], this.b[3]);
    const i = new Array(3), s = new Array(2), n = this.casteljau(t, i, s), r = new st(n, s[1], i[2], this.b[3]), o = r.casteljau((e - t) / (1 - t), i, s);
    return new st(r.b[0], i[0], s[0], o);
  }
  // Not Implemented: Returns the trimmed curve, wrapping around the end if start is greater than end.
  trimWithWrap(t, e) {
    throw "NotImplementedException()";
  }
  //array for casteljau method
  casteljau(t, e, i) {
    const s = 1 - t;
    for (let n = 0; n < 3; n++)
      e[n] = u.mkPoint(s, this.b[n], t, this.b[n + 1]);
    for (let n = 0; n < 2; n++)
      i[n] = u.mkPoint(s, e[n], t, e[n + 1]);
    return u.mkPoint(s, i[0], t, i[1]);
  }
  // first derivative
  derivative(t) {
    return this.l.mul(3 * t * t).add(this.e.mul(2 * t)).add(this.c);
  }
  // second derivative
  secondDerivative(t) {
    return u.mkPoint(6 * t, this.l, 2, this.e);
  }
  // third derivative
  thirdDerivative(t) {
    return this.l.mul(6);
  }
  // the constructor
  constructor(t, e, i, s) {
    this.b = new Array(4), this.parStart = 0, this.parEnd = 1, this.b[0] = t, this.b[1] = e, this.b[2] = i, this.b[3] = s, this.c = this.b[1].sub(this.b[0]).mul(3), this.e = this.b[2].sub(this.b[1]).mul(3).sub(this.c), this.l = this.b[3].sub(this.b[0]).sub(this.c).sub(this.e);
  }
  get start() {
    return this.b[0];
  }
  get end() {
    return this.b[3];
  }
  // this[Reverse[t]]=this[ParEnd+ParStart-t]
  reverse() {
    return new st(this.b[3], this.b[2], this.b[1], this.b[0]);
  }
  // mutable! changes "this"
  // Returns the curved moved by delta
  translate(t) {
    this.b[0] = this.b[0].add(t), this.b[1] = this.b[1].add(t), this.b[2] = this.b[2].add(t), this.b[3] = this.b[3].add(t), this.c = this.b[1].sub(this.b[0]).mul(3), this.e = this.b[2].sub(this.b[1]).mul(3).sub(this.c), this.l = this.b[3].sub(this.b[0]).sub(this.c).sub(this.e), this.bbox && (this.bbox = T.translate(this.bbox, t)), this.pBoxNode = null;
  }
  // Returns the curved scaled by x and y
  scaleFromOrigin(t, e) {
    return new st(this.b[0].scale(t, e), this.b[1].scale(t, e), this.b[2].scale(t, e), this.b[3].scale(t, e));
  }
  // Offsets the curve in the direction of dir
  offsetCurve(t, e) {
    return null;
  }
  // return length of the curve segment [start,end]
  lengthPartial(t, e) {
    return this.trim(t, e).length;
  }
  // Get the length of the curve
  get length() {
    return st.lengthOnControlPolygon(this.b[0], this.b[1], this.b[2], this.b[3]);
  }
  //
  static lengthOnControlPolygon(t, e, i, s) {
    const n = s.sub(t).length, r = e.sub(t).length + i.sub(e).length + s.sub(i).length;
    if (r - n > m.lineSegmentThreshold) {
      const o = u.middle(t, e), l = u.middle(e, i), h = u.middle(i, s), c = u.middle(o, l), d = u.middle(h, l), f = u.middle(c, d);
      return st.lengthOnControlPolygon(t, o, c, f) + st.lengthOnControlPolygon(f, d, h, s);
    }
    return (r + n) / 2;
  }
  // the segment bounding box
  get boundingBox() {
    return this.bbox ? this.bbox : this.bbox = T.mkOnPoints(this.b);
  }
  // Return the transformed curve
  transform(t) {
    return new st(t.multiplyPoint(this.b[0]), t.multiplyPoint(this.b[1]), t.multiplyPoint(this.b[2]), t.multiplyPoint(this.b[3]));
  }
  // returns a parameter t such that the distance between curve[t] and targetPoint is minimal
  // and t belongs to the closed segment [low,high]
  closestParameterWithinBounds(t, e, i) {
    const s = (i - e) / 8;
    let n = 0, r = Number.MAX_VALUE;
    for (let o = 0; o < 9; o++) {
      const l = t.sub(this.value(o * s + e)), h = l.dot(l);
      h < r && (r = h, n = o * s + e);
    }
    return wr.closestPoint(this, t, n, e, i);
  }
  // clones the curve.
  clone() {
    return new st(this.b[0], this.b[1], this.b[2], this.b[3]);
  }
  static mkBezier(t) {
    return new st(t[0], t[1], t[2], t[3]);
  }
  // the signed curvature of the segment at t
  curvature(t) {
    const e = this.G(t);
    return this.F(t) / e;
  }
  F(t) {
    return this.Xp(t) * this.Ypp(t) - this.Yp(t) * this.Xpp(t);
  }
  // G(t) is the denomenator of the curvature
  G(t) {
    const e = this.Xp(t), i = this.Yp(t), s = e * e + i * i;
    return Math.sqrt(s * s * s);
  }
  // the first derivative of x-coord
  Xp(t) {
    return 3 * this.l.x * t * t + 2 * this.e.x * t + this.c.x;
  }
  // the second derivativ of y-coordinate
  Ypp(t) {
    return 6 * this.l.y * t + 2 * this.e.y;
  }
  // the first derivative of y-coord
  Yp(t) {
    return 3 * this.l.y * t * t + 2 * this.e.y * t + this.c.y;
  }
  // the seconde derivative of x coord
  Xpp(t) {
    return 6 * this.l.x * t + 2 * this.e.x;
  }
  // the third derivative of x coordinate
  Xppp(t) {
    return 6 * this.l.x;
  }
  // the third derivative of y coordinate
  Yppp(t) {
    return 6 * this.l.y;
  }
  // the derivative of the curvature at t
  curvatureDerivative(t) {
    const e = this.G(t);
    return (this.Fp(t) * e - this.Gp(t) * this.F(t)) / (e * e);
  }
  Fp(t) {
    return this.Xp(t) * this.Yppp(t) - this.Yp(t) * this.Xppp(t);
  }
  Fpp(t) {
    return this.Xpp(t) * this.Yppp(t) - // + Xp(t) * Ypppp(t)=0
    this.Ypp(t) * this.Xppp(t);
  }
  // returns a parameter t such that the distance between curve[t] and a is minimal
  closestParameter(t) {
    let i = 0, s = Number.MAX_VALUE;
    for (let n = 0; n < 9; n++) {
      const r = t.sub(this.value(n * 0.125)), o = r.dot(r);
      o < s && (s = o, i = n * 0.125);
    }
    return wr.closestPoint(this, t, i, 0, 1);
  }
  //
  curvatureSecondDerivative(t) {
    const e = this.G(t);
    return (this.Qp(t) * e - 2 * this.Q(t) * this.Gp(t)) / (e * e * e);
  }
  Q(t) {
    return this.Fp(t) * this.G(t) - this.Gp(t) * this.F(t);
  }
  Qp(t) {
    return this.Fpp(t) * this.G(t) - this.Gpp(t) * this.F(t);
  }
  Gpp(t) {
    const e = this.Xp(t), i = this.Yp(t), s = this.Xpp(t), n = this.Ypp(t), r = this.Xppp(t), o = this.Yppp(t), l = Math.sqrt(e * e + i * i), h = e * s + i * n;
    return 3 * (h * h / l + l * (s * s + e * r + n * n + i * o));
  }
  Gp(t) {
    const e = this.Xp(t), i = this.Yp(t), s = this.Xpp(t), n = this.Ypp(t);
    return 3 * Math.sqrt(e * e + i * i) * (e * s + i * n);
  }
  getParameterAtLength(t) {
    let e = 0, i = 1;
    for (; i - e > m.tolerance; ) {
      const s = (i + e) / 2, n = this.evaluateError(t, s);
      if (n > 0)
        i = s;
      else if (n < 0)
        e = s;
      else
        return s;
    }
    return (e + i) / 2;
  }
  evaluateError(t, e) {
    const i = 1 - e, s = u.mkPoint(i, this.b[0], e, this.b[1]), n = u.mkPoint(i, this.b[1], e, this.b[2]), r = u.mkPoint(i, this.b[2], e, this.b[3]), o = u.mkPoint(i, s, e, n), l = u.mkPoint(i, n, e, r), h = u.mkPoint(i, o, e, l), c = st.lengthOnControlPolygon(this.b[0], s, o, h);
    return c > t + m.distanceEpsilon ? 1 : c < t - m.distanceEpsilon ? -1 : 0;
  }
}
function gd(a) {
  return a.seg.value(a.par);
}
function pd(a) {
  return a.seg.derivative(a.par);
}
function md(a) {
  return a.seg.secondDerivative(a.par);
}
function Pd(a) {
  return a.seg.thirdDerivative(a.par);
}
var F;
(function(a) {
  a[a.Outside = 0] = "Outside", a[a.Boundary = 1] = "Boundary", a[a.Inside = 2] = "Inside";
})(F || (F = {}));
function Sd(a) {
  if (a instanceof j)
    return { tag: "ellipse", segData: a.toJSON() };
  if (a instanceof v)
    return { tag: "lineSegment", segData: a.toJSON() };
  if (a instanceof st)
    return { tag: "bezier", segData: a.toJSON() };
  throw new Error("not implemented");
}
class g {
  static fromJSON(t) {
    const e = new g();
    for (const i of t.segs)
      switch (i.tag) {
        case "bezier":
          e.addSegment(st.fromJSON(i.segData));
          break;
        case "ellipse":
          e.addSegment(j.fromJSON(i.segData));
          break;
        case "lineSegment":
          e.addSegment(v.fromJSON(i.segData));
          break;
        default:
          throw new Error("not implemented");
      }
    return e;
  }
  toJSON() {
    return { segs: this.segs.map((t) => Sd(t)) };
  }
  static CurvesIntersect(t, e) {
    return t === e || g.intersectionOne(t, e, !1) != null;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static lengthWithInterpolationAndThreshold(t, e) {
    throw new Error("not implemented");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static lengthWithInterpolation(t) {
    throw "not implemented";
  }
  get parStart() {
    return 0;
  }
  get parEnd() {
    return this.parEnd_;
  }
  lengthPartial(t, e) {
    const i = {
      start: t,
      end: e
    };
    this.adjustStartEndEndParametersToDomain(i);
    const s = this.getSegIndexParam(t), n = this.getSegIndexParam(e);
    if (s.segIndex < n.segIndex) {
      let r = this.segs[s.segIndex], o = r.lengthPartial(s.par, r.parEnd);
      for (let l = s.segIndex + 1; l < n.segIndex; l++)
        o += this.segs[l].length;
      return r = this.segs[n.segIndex], o + r.lengthPartial(r.parStart, n.par);
    } else
      throw new Error("not implemented.");
  }
  // this[Reverse[t]]=this[ParEnd+ParStart-t]
  reverse() {
    const t = new g();
    for (let e = this.segs.length - 1; e >= 0; e--)
      t.addSegment(this.segs[e].reverse());
    return t;
  }
  // Constructs the curve for a given number of segments
  constructor() {
    this.segs = [], this.parEnd_ = 0;
  }
  mkCurveWithSegs(t) {
    this.segs = t;
    for (const e of t)
      this.parEnd_ += g.paramSpan(e);
  }
  get start() {
    return this.segs[0].start;
  }
  get end() {
    return this.segs[this.segs.length - 1].end;
  }
  scaleFromOrigin(t, e) {
    const i = new g();
    for (const s of this.segs)
      i.addSegment(s.scaleFromOrigin(t, e));
    return i;
  }
  // Returns the trimmed curve
  trim(t, e) {
    const i = {
      start: t,
      end: e
    };
    this.adjustStartEndEndParametersToDomain(i);
    const s = this.getSegIndexParam(i.start), n = this.getSegIndexParam(i.end);
    if (s.segIndex === n.segIndex)
      return this.segs[s.segIndex].trim(s.par, n.par);
    let r = new g();
    s.par < this.segs[s.segIndex].parEnd && (r = r.addSegment(this.segs[s.segIndex].trim(s.par, this.segs[s.segIndex].parEnd)));
    for (let o = s.segIndex + 1; o < n.segIndex; o++)
      r = r.addSegment(this.segs[o]);
    return this.segs[n.segIndex].parStart < n.par && (r = r.addSegment(this.segs[n.segIndex].trim(this.segs[n.segIndex].parStart, n.par))), r;
  }
  translate(t) {
    for (const e of this.segs)
      e.translate(t);
    this.boundingBox_ && (this.boundingBox_ = T.translate(this.boundingBox_, t)), this.pBNode = null;
  }
  adjustStartEndEndParametersToDomain(t) {
    if (t.start > t.end) {
      const e = t.start;
      t.start = t.end, t.end = e;
    }
    t.start < this.parStart && (t.start = this.parStart), t.end > this.parEnd && (t.end = this.parEnd);
  }
  // Returns the trimmed curve, wrapping around the end if start is greater than end.
  trimWithWrap(t, e) {
    if (t < e)
      return this.trim(t, e);
    const i = new g();
    return i.addSegment(this.trim(t, this.parEnd)), i.addSegment(this.trim(this.parStart, e)), i;
  }
  addSegs(t) {
    for (const e of t)
      this.addSegment(e);
    return this;
  }
  // Adds a segment to the curve
  addSegment(t) {
    if (t == null)
      return this;
    if (this.boundingBox_ = null, !(t instanceof g))
      this.segs.push(t), this.parEnd_ += g.paramSpan(t);
    else
      for (const e of t.segs)
        this.segs.push(e), this.parEnd_ += g.paramSpan(e);
    return this;
  }
  // A tree of ParallelogramNodes covering the curve.
  // This tree is used in curve intersections routines.
  pNodeOverICurve() {
    if (this.pBNode != null)
      return this.pBNode;
    const t = [], e = [];
    for (const i of this.segs) {
      const s = i.pNodeOverICurve();
      t.push(s.parallelogram), e.push(s);
    }
    return this.pBNode = {
      parallelogram: Q.getParallelogramOfAGroup(t),
      seg: this,
      leafBoxesOffset: m.defaultLeafBoxesOffset,
      node: { children: e }
    }, this.pBNode;
  }
  // finds an intersection between to curves,
  static intersectionOne(t, e, i) {
    let s = g.curveCurveXWithParallelogramNodesOne(t.pNodeOverICurve(), e.pNodeOverICurve());
    return i && s != null && (s = g.liftIntersectionToCurves(t, e, s)), s;
  }
  /**
   *   Calculates all intersections between curve0 and curve1.
   *  If liftIntersections is true then the intersections parameters
   *  recalculated, lifted, to the curve parameter domain. Otherwise they * stay in the segment domains
   */
  static getAllIntersections(t, e, i) {
    return t instanceof v ? g.getAllIntersectionsOfLineAndICurve(t, e, i) : g.getAllIntersectionsInternal(t, e, i);
  }
  static getAllIntersectionsInternal(t, e, i) {
    const s = [];
    if (g.curveCurveXWithParallelogramNodes(t.pNodeOverICurve(), e.pNodeOverICurve(), s), i)
      for (let n = 0; n < s.length; n++)
        s[n] = g.liftIntersectionToCurves(t, e, s[n]);
    return s;
  }
  static getAllIntersectionsOfLineAndICurve(t, e, i) {
    return e instanceof B ? g.getAllIntersectionsOfLineAndPolyline(t, e) : e instanceof g ? g.getAllIntersectionsOfLineAndCurve(t, e, i) : e instanceof j && e.isArc() ? g.getAllIntersectionsOfLineAndArc(t, e) : g.getAllIntersectionsInternal(t, e, i);
  }
  static getAllIntersectionsOfLineAndCurve(t, e, i) {
    const s = [], n = t.pNodeOverICurve(), r = e.pNodeOverICurve();
    if (Q.intersect(n.parallelogram, r.parallelogram) === !1)
      return s;
    let o = 0;
    for (const l of e.segs) {
      const h = g.getAllIntersections(t, l, !1);
      if (i) {
        for (const c of h)
          c.par1 += o - l.parStart, c.seg1 = e;
        o += l.parEnd - l.parStart;
      }
      for (const c of h)
        g.alreadyInside(s, c) || s.push(c);
    }
    return s;
  }
  static closeIntersections(t, e) {
    return u.close(t.x, e.x, m.intersectionEpsilon);
  }
  static closeIntersectionPoints(t, e) {
    return u.close(t, e, m.intersectionEpsilon);
  }
  static alreadyInside(t, e) {
    for (let i = 0; i < t.length; i++) {
      const s = t[i];
      if (g.closeIntersections(s, e))
        return !0;
    }
    return !1;
  }
  static getAllIntersectionsOfLineAndArc(t, e) {
    let i = t.end.sub(t.start);
    const s = [], n = i.length;
    if (n < m.distanceEpsilon) {
      const d = t.start.sub(e.center);
      if (D(d.length, e.aAxis.length)) {
        let f = u.angle(e.aAxis, d);
        e.parStart - m.tolerance <= f && (f = Math.max(f, e.parStart), f <= e.parEnd + m.tolerance && (f = Math.min(e.parEnd, f), s.push(new Mi(0, f, t.start, t, e))));
      }
      return s;
    }
    const r = i.rotate90Ccw().div(n), o = t.start.sub(e.center).dot(r), l = e.center.add(r.mul(o)), h = e.aAxis.length, c = Math.abs(o);
    if (h < c - m.distanceEpsilon)
      return s;
    if (i = r.rotate90Cw(), D(h, c))
      g.tryToAddPointToLineCircleCrossing(t, e, s, l, n, i);
    else {
      const d = Math.sqrt(h * h - o * o), f = i.mul(d);
      g.tryToAddPointToLineCircleCrossing(t, e, s, l.add(f), n, i), g.tryToAddPointToLineCircleCrossing(t, e, s, l.sub(f), n, i);
    }
    return s;
  }
  static tryToAddPointToLineCircleCrossing(t, e, i, s, n, r) {
    let l = s.sub(t.start).dot(r);
    if (l < -m.distanceEpsilon || (l = Math.max(l, 0), l > n + m.distanceEpsilon))
      return;
    l = Math.min(l, n), l /= n;
    let h = u.angle(e.aAxis, s.sub(e.center));
    e.parStart - m.tolerance <= h && (h = Math.max(h, e.parStart), h <= e.parEnd + m.tolerance && (h = Math.min(e.parEnd, h), i.push(new Mi(l, h, s, t, e))));
  }
  static getAllIntersectionsOfLineAndPolyline(t, e) {
    const i = [];
    let s = 0, n = e.startPoint;
    for (; n != null && n.getNext() != null; n = n.getNext()) {
      const r = g.crossTwoLineSegs(t.start, t.end, n.point, n.getNext().point, 0, 1, 0, 1);
      r && (g.adjustSolution(t.start, t.end, n.point, n.getNext().point, r), g.oldIntersection(i, r.x) || i.push(new Mi(r.aSol, s + r.bSol, r.x, t, e))), s++;
    }
    if (e.closed) {
      const r = g.crossTwoLineSegs(t.start, t.end, n.point, e.start, 0, 1, 0, 1);
      r && (g.adjustSolution(t.start, t.end, n.point, e.start, r), g.oldIntersection(i, r.x) || i.push(new Mi(r.aSol, s + r.bSol, r.x, t, e)));
    }
    return i;
  }
  static adjustSolution(t, e, i, s, n) {
    g.closeIntersectionPoints(n.x, t) ? (n.x = t, n.aSol = 0) : g.closeIntersectionPoints(n.x, e) && (n.x = e, n.aSol = 1), g.closeIntersectionPoints(n.x, i) ? (n.x = i, n.bSol = Math.floor(n.bSol)) : g.closeIntersectionPoints(n.x, s) && (n.x = s, n.bSol = Math.ceil(n.bSol));
  }
  static curveCurveXWithParallelogramNodesOne(t, e) {
    if (!Q.intersect(t.parallelogram, e.parallelogram))
      return null;
    const i = t.node, s = e.node, n = i.hasOwnProperty("children"), r = s.hasOwnProperty("children");
    if (n && r)
      for (const o of i.children)
        for (const l of s.children) {
          const h = g.curveCurveXWithParallelogramNodesOne(o, l);
          if (h != null)
            return h;
        }
    else if (r)
      for (const o of s.children) {
        const l = g.curveCurveXWithParallelogramNodesOne(t, o);
        if (l != null)
          return l;
      }
    else if (n)
      for (const o of i.children) {
        const l = g.curveCurveXWithParallelogramNodesOne(o, e);
        if (l != null)
          return l;
      }
    else
      return g.crossOverIntervalsOne(t, e);
    return null;
  }
  static curveCurveXWithParallelogramNodes(t, e, i) {
    if (!Q.intersect(t.parallelogram, e.parallelogram))
      return;
    const s = t.node.hasOwnProperty("children"), n = e.node.hasOwnProperty("children");
    if (s && n)
      for (const r of t.node.children)
        for (const o of e.node.children)
          g.curveCurveXWithParallelogramNodes(r, o, i);
    else if (n)
      for (const r of e.node.children)
        g.curveCurveXWithParallelogramNodes(t, r, i);
    else if (s)
      for (const r of t.node.children)
        g.curveCurveXWithParallelogramNodes(r, e, i);
    else
      i = g.crossOverLeaves(t, e, i);
  }
  static crossOverIntervalsOne(t, e) {
    const i = t.node, s = e.node, n = (i.high - i.low) / 2, r = (s.high - s.low) / 2;
    for (let o = 1; o < 2; o++) {
      const l = o * n + i.low;
      for (let h = 1; h < 2; h++) {
        const c = h * r + s.low;
        let d;
        if (i.chord == null && s.chord == null ? d = g.crossWithinIntervalsWithGuess(t.seg, e.seg, i.low, i.high, s.low, s.high, l, c) : i.chord != null && s.chord == null ? d = g.crossWithinIntervalsWithGuess(i.chord, e.seg, 0, 1, s.low, s.high, 0.5 * o, c) : i.chord == null ? (d = g.crossWithinIntervalsWithGuess(t.seg, s.chord, i.low, i.high, 0, 1, l, 0.5 * h), d && (d.bSol = s.low + d.bSol * (s.high - s.low))) : (d = g.crossWithinIntervalsWithGuess(i.chord, s.chord, 0, 1, 0, 1, 0.5 * o, 0.5 * h), d && (d.aSol = i.low + d.aSol * (i.high - i.low), d.bSol = s.low + d.bSol * (s.high - s.low))), d)
          return g.createIntersectionOne(t, e, d.aSol, d.bSol, d.x);
      }
    }
    return g.goDeeperOne(t, e);
  }
  static crossOverLeaves(t, e, i) {
    const s = t.node, n = e.node;
    let r = !1;
    const o = (s.high - s.low) / 2 + s.low, l = (n.high - n.low) / 2 + n.low;
    let h;
    return s.chord == null && n.chord == null ? h = g.crossWithinIntervalsWithGuess(t.seg, e.seg, s.low, s.high, n.low, n.high, o, l) : s.chord != null && n.chord == null ? (h = g.crossWithinIntervalsWithGuess(s.chord, e.seg, 0, 1, n.low, n.high, 0.5, l), h && (h.aSol = s.low + h.aSol * (s.high - s.low))) : s.chord == null ? (h = g.crossWithinIntervalsWithGuess(t.seg, n.chord, s.low, s.high, 0, 1, o, 0.5), h && (h.bSol = n.low + h.bSol * (n.high - n.low))) : (h = g.crossWithinIntervalsWithGuess(s.chord, n.chord, 0, 1, 0, 1, 0.5, 0.5), h && (h.bSol = n.low + h.bSol * (n.high - n.low), h.aSol = s.low + h.aSol * (s.high - s.low))), h && (g.addIntersection(t, e, i, h), r = !0), r || g.goDeeper(i, t, e), i;
  }
  static addIntersection(t, e, i, s) {
    const n = t.node;
    g.closeIntersectionPoints(s.x, t.seg.value(n.low)) ? (s.x = t.seg.value(n.low), s.aSol = n.low) : g.closeIntersectionPoints(s.x, t.seg.value(n.high)) && (s.x = t.seg.value(n.high), s.aSol = n.high);
    const r = e.node;
    if (g.closeIntersectionPoints(s.x, e.seg.value(r.low)) ? (s.x = e.seg.value(r.low), s.bSol = r.low) : g.closeIntersectionPoints(s.x, e.seg.value(r.high)) && (s.x = e.seg.value(r.high), s.bSol = r.high), !g.oldIntersection(i, s.x)) {
      const l = new Mi(s.aSol, s.bSol, s.x, t.seg, e.seg);
      i.push(l);
    }
  }
  // returns true if the intersection exists already
  static oldIntersection(t, e) {
    for (const i of t)
      if (e.sub(i.x).length < m.distanceEpsilon * 100)
        return !0;
    return !1;
  }
  static createIntersectionOne(t, e, i, s, n) {
    const r = t.node, o = e.node;
    return g.closeIntersectionPoints(n, t.seg.value(r.low)) ? (n = t.seg.value(r.low), i = r.low) : g.closeIntersectionPoints(n, t.seg.value(r.high)) && (n = t.seg.value(r.high), i = r.high), g.closeIntersectionPoints(n, e.seg.value(o.low)) ? (n = e.seg.value(o.low), s = o.low) : g.closeIntersectionPoints(n, e.seg.value(o.high)) && (n = e.seg.value(o.high), s = o.high), new Mi(i, s, n, t.seg, e.seg);
  }
  static liftIntersectionToCurves_(t, e, i, s, n, r, o) {
    const l = t instanceof g ? g.liftParameterToCurve(t, i - r.parStart, r) : i, h = e instanceof g ? g.liftParameterToCurve(e, s - o.parStart, o) : s;
    return new Mi(l, h, n, t, e);
  }
  static DropIntersectionToSegs(t) {
    let e, i;
    if (t.seg0 instanceof g) {
      const r = t.seg0.getSegParam(t.par0);
      e = r.seg, i = r.par;
    } else
      i = t.par0, e = t.seg0;
    let s, n;
    if (t.seg1 instanceof g) {
      const r = t.seg1.getSegParam(t.par1);
      n = r.par, s = r.seg;
    } else
      n = t.par1, s = t.seg1;
    return new Mi(i, n, t.x, e, s);
  }
  static liftIntersectionToCurves(t, e, i) {
    return g.liftIntersectionToCurves_(t, e, i.par0, i.par1, i.x, i.seg0, i.seg1);
  }
  static liftParameterToCurve(t, e, i) {
    if (t === i)
      return e;
    if (!t.hasOwnProperty("segs"))
      return;
    const s = t;
    let n = 0;
    for (const r of s.segs) {
      if (r === i)
        return e + n;
      n += g.paramSpan(r);
    }
    throw "bug in liftParameterToCurve";
  }
  static paramSpan(t) {
    return t.parEnd - t.parStart;
  }
  static goDeeperOne(t, e) {
    const i = t.node, s = e.node;
    if (t.leafBoxesOffset > m.distanceEpsilon && e.leafBoxesOffset > m.distanceEpsilon) {
      const o = Ct.createParallelogramNodeForCurveSeg(i.low, i.high, t.seg, t.leafBoxesOffset / 2), l = Ct.createParallelogramNodeForCurveSeg(s.low, s.high, e.seg, e.leafBoxesOffset / 2);
      return g.curveCurveXWithParallelogramNodesOne(o, l);
    }
    if (t.leafBoxesOffset > m.distanceEpsilon) {
      const o = Ct.createParallelogramNodeForCurveSeg(i.low, i.high, t.seg, t.leafBoxesOffset / 2);
      return g.curveCurveXWithParallelogramNodesOne(o, e);
    }
    if (e.leafBoxesOffset > m.distanceEpsilon) {
      const o = Ct.createParallelogramNodeForCurveSeg(s.low, s.high, e.seg, e.leafBoxesOffset / 2);
      return g.curveCurveXWithParallelogramNodesOne(t, o);
    }
    const n = t.seg.value(i.low), r = t.seg.value(i.high);
    if (!u.closeDistEps(n, r)) {
      const o = e.seg.value(s.low), l = e.seg.value(s.high);
      if (!u.closeDistEps(o, l)) {
        const h = t.seg instanceof v ? t.seg : v.mkPP(n, r), c = e.seg instanceof v ? e.seg : v.mkPP(o, l), d = g.crossWithinIntervalsWithGuess(h, c, 0, 1, 0, 1, 0.5, 0.5);
        if (d)
          return g.adjustParameters(t, h, e, c, d), g.createIntersectionOne(t, e, d.aSol, d.bSol, d.x);
      }
    }
    return null;
  }
  static goDeeper(t, e, i) {
    const s = e.node, n = i.node, r = e.leafBoxesOffset > m.distanceEpsilon, o = i.leafBoxesOffset > m.distanceEpsilon;
    if (r && o) {
      const l = Ct.createParallelogramNodeForCurveSeg(s.low, s.high, e.seg, e.leafBoxesOffset / 2), h = Ct.createParallelogramNodeForCurveSeg(n.low, n.high, i.seg, i.leafBoxesOffset / 2);
      g.curveCurveXWithParallelogramNodes(l, h, t);
    } else if (r) {
      const l = Ct.createParallelogramNodeForCurveSeg(s.low, s.high, e.seg, e.leafBoxesOffset / 2);
      g.curveCurveXWithParallelogramNodes(l, i, t);
    } else if (o) {
      const l = Ct.createParallelogramNodeForCurveSeg(n.low, n.high, i.seg, i.leafBoxesOffset / 2);
      g.curveCurveXWithParallelogramNodes(e, l, t);
    } else {
      const l = e.seg.value(s.low), h = e.seg.value(s.high);
      if (!u.closeDistEps(l, h)) {
        const c = i.seg.value(n.low), d = i.seg.value(n.high);
        if (!u.closeDistEps(c, d)) {
          const f = e.seg instanceof v ? e.seg : v.mkPP(l, h), p = i.seg instanceof v ? i.seg : v.mkPP(c, d), P = g.crossWithinIntervalsWithGuess(f, p, 0, 1, 0, 1, 0.5, 0.5);
          P && (g.adjustParameters(e, f, i, p, P), g.addIntersection(e, i, t, P));
        }
      }
    }
  }
  static adjustParameters(t, e, i, s, n) {
    if (e !== t.seg && !(t.seg instanceof B))
      n.aSol = t.seg.closestParameter(n.x);
    else {
      const r = t.node;
      n.aSol = r.low + n.aSol * (r.high - r.low);
    }
    if (s !== i.seg && !(i.seg instanceof B))
      n.bSol = i.seg.closestParameter(n.x);
    else {
      const r = i.node;
      n.bSol = r.low + n.bSol * (r.high - r.low);
    }
  }
  // returns the segment correspoinding to t and the segment parameter
  getSegParam(t) {
    let e = this.parStart;
    for (const s of this.segs) {
      const n = e + s.parEnd - s.parStart;
      if (t >= e && t <= n)
        return {
          par: t - e + s.parStart,
          seg: s
        };
      e = n;
    }
    const i = this.segs[this.segs.length - 1];
    return {
      seg: i,
      par: i.parEnd
    };
  }
  /** return the segment index and the parameter inside of the segment */
  getSegIndexParam(t) {
    let e = 0;
    const i = this.segs.length;
    for (let n = 0; n < i; n++) {
      const r = this.segs[n], o = e + r.parEnd - r.parStart;
      if (t >= e && t <= o)
        return {
          segIndex: n,
          par: t - e + r.parStart
        };
      e = o;
    }
    const s = this.segs[i - 1];
    return {
      segIndex: i - 1,
      par: s.parEnd
    };
  }
  // Returns the point on the curve corresponding to parameter t
  value(t) {
    return gd(this.getSegParam(t));
  }
  // first derivative at t
  derivative(t) {
    return pd(this.getSegParam(t));
  }
  // second derivative
  secondDerivative(t) {
    return md(this.getSegParam(t));
  }
  // third derivative
  thirdDerivative(t) {
    return Pd(this.getSegParam(t));
  }
  // For curves A(s) and B(t), when we have some evidence that
  // there is at most one intersection point, and we have a guess for the parameters (s0, t0)...
  // You are trying to bring to (0,0) the vector F(s,t) = A(s) - B(t).  To minimize the length of F(s,t)
  // we solve the system of equations:
  //F*Fs + (F*Fss + Fs*Fs)ds + (F*Fst + Fs*Ft)dt = 0
  //F*Ft + (F*Fst + Fs*Ft)ds + (F*Ftt + Ft*Ft)dt = 0
  //
  //Where F = F(si,ti), Fs and Ft are the first partials at si, ti, Fxx are the second partials,
  //   and s(i+1) = si+ds, t(i+1) = ti+dt.
  //We adjust ds and dt to stay in the domain.
  static crossWithinIntervalsWithGuess(t, e, i, s, n, r, o, l) {
    if (t instanceof v && e instanceof v) {
      const d = g.crossTwoLineSegs(t.start, t.end, e.start, e.end, i, s, n, r);
      if (d !== void 0)
        return d;
    }
    const h = g.minDistWithinIntervals(t, e, i, s, n, r, o, l);
    if (h == null)
      return;
    const c = h.aX.sub(h.bX);
    return c.dot(c) >= m.distanceEpsilon ? void 0 : {
      aSol: h.aSol,
      bSol: h.bSol,
      x: u.middle(h.aX, h.bX)
    };
  }
  static crossTwoLineSegs(t, e, i, s, n, r, o, l) {
    const h = e.sub(t), c = i.sub(s), d = i.sub(t), f = Ji.solve(h.x, c.x, d.x, h.y, c.y, d.y);
    if (f == null)
      return;
    let p = f.x, P = f.y;
    const y = t.add(h.mul(p));
    if (!(p < n - m.tolerance) && (p = Math.max(p, n), !(p > r + m.tolerance) && (p = Math.min(p, r), !(P < o - m.tolerance) && (P = Math.max(P, o), !(P > l + m.tolerance)))))
      return P = Math.min(P, l), {
        aSol: p,
        bSol: P,
        x: y
      };
  }
  // Decides if the point lies inside, outside or on the curve
  static PointRelativeToCurveLocation(t, e) {
    if (!e.boundingBox.contains(t))
      return F.Outside;
    const i = 2 * e.boundingBox.diagonal, s = Math.PI / 180;
    let n = 0;
    for (let r = 13; r < 360; r += 13) {
      const o = new u(Math.cos(r * s), Math.sin(r * s)), l = v.mkPP(t, t.add(o.mul(i))), h = this.getAllIntersectionsOfLineAndICurve(l, e, !0);
      if (g.AllIntersectionsAreGood(h, e)) {
        for (const d of h)
          if (u.closeDistEps(d.x, t))
            return F.Boundary;
        if (h.length % 2 === 1 ? n++ : n--, n >= 2)
          return F.Inside;
        if (n <= -2)
          return F.Outside;
      }
    }
    return F.Boundary;
  }
  static AllIntersectionsAreGood(t, e) {
    const i = e.hasOwnProperty("segs");
    let s = null;
    if (i || e instanceof B && (s = e.toCurve()), s) {
      for (const n of t)
        if (!g.RealCut(g.DropIntersectionToSegs(n), s, !1))
          return !1;
    }
    return !0;
  }
  static RealCut(t, e, i) {
    const s = t.seg0, n = t.seg1, r = t.par0, o = t.par1, l = t.x, h = s.derivative(r).normalize(), c = n.derivative(o).normalize().rotate(Math.PI / 2);
    if (u.closeDistEps(l, n.end)) {
      let f = null;
      for (let y = 0; y < e.segs.length - 1; y++)
        if (e.segs[y] === n) {
          f = e.segs[y + 1];
          break;
        }
      if (f == null)
        return !1;
      const p = h.rotate(Math.PI / 2);
      return !(p.dot(n.derivative(n.parEnd)) * p.dot(f.derivative(f.parStart)) < m.tolerance);
    }
    if (u.closeDistEps(l, n.start)) {
      let f = null;
      for (let y = e.segs.length - 1; y > 0; y--)
        if (e.segs[y] === n) {
          f = e.segs[y - 1];
          break;
        }
      if (f == null)
        return !1;
      const p = h.rotate(Math.PI / 2);
      return !(p.dot(n.derivative(n.parStart)) * p.dot(f.derivative(f.parEnd)) < m.tolerance);
    }
    const d = h.dot(c);
    return i ? d > m.distanceEpsilon : Math.abs(d) > m.distanceEpsilon;
  }
  //   static boolean debug;
  // Returns true if curves do not touch in the intersection point
  // only when the second curve cuts the first one from the inside</param>
  static realCutWithClosedCurve(t, e, i) {
    const s = t.seg0, n = t.seg1, r = t.par0, o = t.par1, l = t.x, h = s.derivative(r).normalize(), c = n.derivative(o).normalize().rotate(Math.PI / 2);
    if (u.closeDistEps(l, n.end)) {
      let f = null;
      for (let y = 0; y < e.segs.length; y++)
        if (e.segs[y] === n) {
          f = e.segs[(y + 1) % e.segs.length];
          break;
        }
      if (f == null)
        throw new Error();
      const p = h.rotate(Math.PI / 2);
      return !(p.dot(n.derivative(n.parEnd)) * p.dot(f.derivative(f.parStart)) < m.tolerance);
    }
    if (u.closeDistEps(l, n.start)) {
      let f = null;
      for (let y = 0; y < e.segs.length; y++)
        if (e.segs[y] === n) {
          f = e.segs[y > 0 ? y - 1 : e.segs.length - 1];
          break;
        }
      const p = h.rotate(Math.PI / 2);
      return !(p.dot(n.derivative(n.parStart)) * p.dot(f.derivative(f.parEnd)) < m.tolerance);
    }
    const d = h.dot(c);
    return i ? d > m.distanceEpsilon : Math.abs(d) > m.distanceEpsilon;
  }
  /*
  
  if (Point.closeDistEps(x, pseg.start)) {
  //so pseg exits the spline
  ICurve enterSeg = null;
  for (int i = polyline.segs.length - 1; i > 0; i--)
  if (polyline.segs[i] === pseg) {
  enterSeg = polyline.segs[i - 1];
  break;
  }
  if (enterSeg == null )
  return false;
  Point tsn = ts.rotate((Math.PI/2));
  boolean touch = (tsn*pseg.derivative(pseg.Parstart))*
  (tsn*enterSeg.derivative(enterSeg.parEnd)) < GeomConstants.tolerance;
  
  return !touch;
  }
  
  number d = ts*pn;
  if (onlyFromInsideCuts)
  return d > GeomConstants.distanceEpsilon;
  return Math.Abs(d) > GeomConstants.distanceEpsilon;
  }
  */
  static minDistWithinIntervals(t, e, i, s, n, r, o, l) {
    const h = new fd(t, e, i, s, n, r, o, l);
    return h.solve(), h.success ? {
      aSol: h.aSolution,
      bSol: h.bSolution,
      aX: h.aPoint,
      bX: h.bPoint
    } : void 0;
  }
  /*
      #if DEBUGCURVES
      public override string ToString()
      {
      boolean poly = true;
      for (ICurve s of segs)
      if (s is LineSeg === false)
      {
      poly = false;
      break;
      }
      
      string ret;
      if (!poly)
      {
      ret = "{";
      
      for (ICurve seg of Segs)
      {
      ret += seg + ",";
      }
      
      
      return ret + "}";
      }
      ret = "{";
      if (segs.length > 0)
      ret += segs[0].start.x.ToString() + "," + segs[0].start.y.ToString()+" ";
      for(LineSeg s of segs)
      ret += s.end.x.ToString() + "," + s.end.y.ToString() + " ";
      return ret + "}";
      }
      #endif
   */
  // Offsets the curve in the direction of dir
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  offsetCurve(t, e) {
    throw new Error("Method not implemented.");
  }
  /**
   * The bounding rectangle of the curve
   */
  get boundingBox() {
    if (this.boundingBox_)
      return this.boundingBox_;
    if (this.segs.length === 0)
      this.boundingBox_ = T.mkEmpty();
    else {
      const t = this.segs[0].boundingBox.clone();
      for (let e = 1; e < this.segs.length; e++)
        t.addRecSelf(this.segs[e].boundingBox);
      return this.boundingBox_ = t;
    }
  }
  /**  clones the curve */
  clone() {
    const t = new g();
    for (const e of this.segs)
      t.addSegment(e.clone());
    return this.boundingBox_ != null && (t.boundingBox_ = this.boundingBox_.clone()), t;
  }
  getParameterAtLength(t) {
    let e = 0;
    for (const i of this.segs) {
      const s = i.length;
      if (s >= t)
        return e + i.getParameterAtLength(t);
      t -= s, e += i.parEnd - i.parStart;
    }
    return this.parEnd;
  }
  get length() {
    let t = 0;
    for (const e of this.segs)
      t += e.length;
    return t;
  }
  /** returns a new curve */
  transform(t) {
    const e = new g();
    for (const i of this.segs)
      e.addSegment(i.transform(t));
    return this.boundingBox_ && (e.boundingBox_ = this.boundingBox_.transform(t)), e;
  }
  // returns a parameter t such that the distance between curve[t] and targetPoint is minimal
  // and t belongs to the closed segment [low,high]
  closestParameterWithinBounds(t, e, i) {
    let s = 0, n = Number.MAX_VALUE, r = 0;
    for (const o of this.segs) {
      if (r > i)
        break;
      const l = g.paramSpan(o);
      if (r + l >= e) {
        const c = Math.max(o.parStart, o.parStart + (e - r)), d = Math.min(o.parEnd, o.parStart + (i - r)), f = o.closestParameterWithinBounds(t, c, d), p = t.sub(o.value(f)), P = p.dot(p);
        P < n && (s = r + f - o.parStart, n = P);
      }
      r += l;
    }
    return s;
  }
  // returns a parameter t such that the distance between curve[t] and a is minimal
  closestParameter(t) {
    let e = 0, i = Number.MAX_VALUE, s = 0;
    for (const n of this.segs) {
      const r = n.closestParameter(t), o = t.sub(n.value(r)), l = o.dot(o);
      if (l < i) {
        if (e = s + r - n.parStart, l === 0)
          break;
        i = l;
      }
      s += g.paramSpan(n);
    }
    return e;
  }
  static addLineSegment(t, e, i) {
    return t.addSegment(v.mkPP(e, i));
  }
  static addLineSegmentCNNP(t, e, i, s) {
    return g.addLineSegment(t, new u(e, i), s);
  }
  // adds a line segment to the curve
  static addLineSegmentCNNNN(t, e, i, s, n) {
    g.addLineSegment(t, new u(e, i), new u(s, n));
  }
  // adds a line segment to the curve
  static continueWithLineSegmentNN(t, e, i) {
    g.addLineSegment(t, t.end, new u(e, i));
  }
  // adds a line segment to the curve
  static continueWithLineSegmentP(t, e) {
    g.addLineSegment(t, t.end, e);
  }
  static closeCurve(t) {
    return g.continueWithLineSegmentP(t, t.start), t;
  }
  // left derivative at t
  leftDerivative(t) {
    const e = this.tryToGetLeftSegment(t);
    return e != null ? e.derivative(e.parEnd) : this.derivative(t);
  }
  // right derivative at t
  rightDerivative(t) {
    const e = this.tryToGetRightSegment(t);
    return e != null ? e.derivative(e.parStart) : this.derivative(t);
  }
  tryToGetLeftSegment(t) {
    if (Math.abs(t - this.parStart) < m.tolerance)
      return this.start.equal(this.end) ? this.segs[this.segs.length - 1] : null;
    for (const e of this.segs)
      if (t -= g.paramSpan(e), Math.abs(t) < m.tolerance)
        return e;
    return null;
  }
  tryToGetRightSegment(t) {
    if (Math.abs(t - this.parEnd) < m.tolerance)
      return this.start === this.end ? this.segs[0] : null;
    for (const e of this.segs) {
      if (Math.abs(t) < m.tolerance)
        return e;
      t -= g.paramSpan(e);
    }
    return null;
  }
  /*
         // gets the closest point together with its parameter
         public static number closestParameterWithPoint(ICurve curve, Point location, out Point pointOnCurve) {
  
         number t = curve.closestParameter(location);
         pointOnCurve = curve[t];
         return t;
         }
         */
  // gets the point on the curve that is closest to the given point
  static ClosestPoint(t, e) {
    return t.value(t.closestParameter(e));
  }
  // Tests whether the first curve is inside the second.
  // We suppose that the curves are convex and they are
  // not degenerated into a point
  static CurveIsInsideOther(t, e) {
    if (!e.boundingBox.containsRect(t.boundingBox))
      return !1;
    const i = g.getAllIntersections(t, e, !0);
    if (i.length === 0)
      return g.NonIntersectingCurveIsInsideOther(t, e);
    if (i.length === 1)
      return t.start.equal(i[0].x) ? g.PointRelativeToCurveLocation(t.value((t.parStart + t.parEnd) / 2), e) == F.Inside : g.PointRelativeToCurveLocation(t.start, e) === F.Inside;
    for (const s of g.PointsBetweenIntersections(t, i))
      if (g.PointRelativeToCurveLocation(s, e) === F.Outside)
        return !1;
    return !0;
  }
  // Return points between but not including the intersections.
  static *PointsBetweenIntersections(t, e) {
    e.sort((o, l) => o.par0 - l.par0);
    for (let o = 0; o < e.length - 1; o++)
      yield t.value((e[o].par0 + e[o + 1].par0) / 2);
    const i = e[e.length - 1].par0, s = e[0].par0, n = t.parEnd - i + (s - t.parStart);
    let r = i + n / 2;
    r > t.parEnd && (r = t.parStart + (r - t.parEnd)), yield t.value(r);
  }
  static NonIntersectingCurveIsInsideOther(t, e) {
    for (let i = t.parStart; i < t.parEnd; i += 0.5) {
      const s = g.PointRelativeToCurveLocation(t.value(i), e);
      if (F.Boundary !== s)
        return F.Inside === s;
    }
    return F.Outside !== g.PointRelativeToCurveLocation(t.end, e);
  }
  // Tests whether the interiors of two closed convex curves intersect
  static ClosedCurveInteriorsIntersect(t, e) {
    if (!e.boundingBox.intersects(t.boundingBox))
      return !1;
    const i = g.getAllIntersections(t, e, !0);
    if (i.length === 0)
      return g.NonIntersectingCurveIsInsideOther(t, e) || g.NonIntersectingCurveIsInsideOther(e, t);
    if (i.length === 1)
      return t.start.equal(i[0].x) ? g.PointRelativeToCurveLocation(t.value((t.parStart + t.parEnd) / 2), e) === F.Inside || !e.start.equal(i[0].x) ? g.PointRelativeToCurveLocation(e.start, t) === F.Inside : g.PointRelativeToCurveLocation(e.value((e.parStart + e.parEnd) / 2), t) === F.Inside : g.PointRelativeToCurveLocation(t.start, e) === F.Inside;
    for (const s of g.PointsBetweenIntersections(t, i))
      if (g.PointRelativeToCurveLocation(s, e) === F.Inside)
        return !0;
    return !0;
  }
  // ICurve Members
  curvature(t) {
    const e = this.getSegParam(t);
    return e.seg.curvature(e.par);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  curvatureDerivative(t) {
    throw new Error("Not implemente");
  }
  //
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  curvatureSecondDerivative(t) {
    throw new Error("Not implemented");
  }
  /*  #endregion
       
       public static boolean CurvesIntersect(ICurve curve1, ICurve curve2) {
       return curve1 === curve2 || (CurveCurveIntersectionOne(curve1, curve2, false) != null);
       }
       */
  static createBezierSeg(t, e, i, s, n) {
    const r = u.mkPoint(t, i.point, 1 - t, s.point), o = u.mkPoint(e, n.point, 1 - e, s.point), l = s.point.mul(2 / 3);
    return new st(r, r.div(3).add(l), l.add(o.div(3)), o);
  }
  static createBezierSegN(t, e, i, s) {
    const n = i.mul(s);
    return new st(t, t.add(n), e.add(n), e);
  }
  static findCorner(t) {
    const e = t.next;
    if (e.next == null)
      return;
    const i = e.next;
    if (i != null)
      return { b: e, c: i };
  }
  static trimEdgeSplineWithNodeBoundaries(t, e, i, s) {
    let n = i.parStart, r = i.parEnd;
    t != null && (n = g.findNewStart(i, n, t, s)), e != null && (r = g.findNewEnd(i, e, s, r));
    const o = Math.min(n, r), l = Math.max(n, r);
    return o < l ? i.trim(o, l) : i;
  }
  static findNewEnd(t, e, i, s) {
    const n = g.getAllIntersections(t, e, !0);
    if (n.length === 0)
      return s = t.parEnd, s;
    if (i) {
      s = t.parEnd;
      for (const r of n)
        r.par0 < s && (s = r.par0);
    } else {
      s = t.parStart;
      for (const r of n)
        r.par0 > s && (s = r.par0);
    }
    return s;
  }
  static findNewStart(t, e, i, s) {
    const n = g.getAllIntersections(t, i, !0);
    if (n.length === 0) {
      e = t.parStart;
      return;
    }
    if (s) {
      e = t.parStart;
      for (const r of n)
        r.par0 > e && (e = r.par0);
    } else {
      e = t.parEnd;
      for (const r of n)
        r.par0 < e && (e = r.par0);
    }
    return e;
  }
  static polylineAroundClosedCurve(t) {
    if (t instanceof j)
      return g.refineEllipse(t);
    if (t instanceof B)
      return t;
    if (t instanceof g && g.allSegsAreLines(t)) {
      const e = new B();
      for (const i of t.segs)
        e.addPoint(i.start);
      if (e.closed = !0, !e.isClockwise())
        return e.reverse();
    }
    return t.boundingBox.perimeter();
  }
  static allSegsAreLines(t) {
    for (const e of t.segs)
      if (!(e instanceof v))
        return !1;
    return !0;
  }
  // this code only works for the standard ellipse
  static refineEllipse(t) {
    const e = t.boundingBox.perimeter(), i = Math.PI / 4, s = t.boundingBox.width, n = t.boundingBox.height, r = Math.sqrt(s * s + n * n), o = [];
    for (let h = 0; h < 4; h++) {
      const c = i + h * Math.PI / 2, d = t.value(c), f = t.derivative(c).normalize().mul(r), p = v.mkPP(d.sub(f), d.add(f));
      for (const P of g.getAllIntersections(e, p, !0))
        o.push(P);
    }
    o.sort((h, c) => h.par0 < c.par0 ? -1 : h.par0 > c.par0 ? 1 : 0);
    const l = new B();
    return o.forEach((h) => l.addPoint(h.x)), l.closed = !0, l;
  }
  // Create a closed Polyline from a rectangle
  static polyFromBox(t) {
    const e = new B();
    return e.addPoint(t.leftTop), e.addPoint(t.rightTop), e.addPoint(t.rightBottom), e.addPoint(t.leftBottom), e.closed = !0, e;
  }
}
class B {
  constructor() {
    this.initIsRequired = !0, this.isClosed_ = !1;
  }
  toJSON() {
    return { points: Array.from(this).map((t) => t.toJSON()) };
  }
  static fromJSON(t) {
    return B.mkFromPoints(t.points.map((e) => u.fromJSON(e)));
  }
  RemoveStartPoint() {
    const t = this.startPoint.next;
    t.prev = null, this.startPoint = t, this.setInitIsRequired();
  }
  RemoveEndPoint() {
    const t = this.endPoint.prev;
    t.next = null, this.endPoint = t, this.setInitIsRequired();
  }
  setInitIsRequired() {
    this.initIsRequired = !0;
  }
  addPointXY(t, e) {
    this.addPoint(new u(t, e));
  }
  /** should true, by internal assumptions,  in general for convex polylines */
  isClockwise() {
    return u.getTriangleOrientation(this.startPoint.point, this.startPoint.next.point, this.startPoint.next.next.point) == L.Clockwise;
  }
  /**  adds a point to the polyline */
  addPoint(t) {
    const e = new ei();
    e.polyline = this, e.point = t.clone(), this.endPoint != null ? (this.endPoint.next = e, e.prev = this.endPoint, this.endPoint = e) : this.startPoint = this.endPoint = e, this.setInitIsRequired();
  }
  PrependPoint(t) {
    const e = ei.mkFromPoint(t);
    e.polyline = this, this.startPoint != null ? u.closeDistEps(t, this.startPoint.point) || (this.startPoint.prev = e, e.next = this.startPoint, this.startPoint = e) : (this.endPoint = e, this.startPoint = e), this.setInitIsRequired();
  }
  *[Symbol.iterator]() {
    for (let t = this.startPoint; t != null; t = t.next)
      yield t.point;
  }
  *polylinePoints() {
    for (let t = this.startPoint; t != null; t = t.next)
      yield t;
  }
  *skip(t) {
    for (let e = this.startPoint; e != null; e = e.next)
      t > 0 ? t-- : yield e;
  }
  static parallelogramOfLineSeg(t, e) {
    const i = e.sub(t).div(2);
    return Q.parallelogramByCornerSideSide(t, i, i);
  }
  static mkFromPoints(t) {
    const e = new B();
    for (const i of t)
      e.addPoint(i);
    return e;
  }
  static mkClosedFromPoints(t) {
    const e = B.mkFromPoints(t);
    return e.closed = !0, e;
  }
  calculatePbNode() {
    const t = [], e = [];
    let i = this.startPoint, s = 0;
    for (; i.next != null; ) {
      const n = B.parallelogramOfLineSeg(i.point, i.next.point);
      t.push(n), e.push({
        parallelogram: n,
        seg: this,
        leafBoxesOffset: 0,
        node: {
          low: s,
          high: s + 1,
          chord: v.mkPP(i.point, i.next.point)
        }
      }), i = i.next, s++;
    }
    if (this.isClosed_) {
      const n = B.parallelogramOfLineSeg(this.endPoint.point, this.startPoint.point);
      t.push(n), e.push({
        parallelogram: n,
        seg: this,
        leafBoxesOffset: 0,
        node: {
          low: s,
          high: s + 1,
          chord: v.mkPP(this.endPoint.point, this.startPoint.point)
        }
      });
    }
    this.pBNode = {
      parallelogram: Q.getParallelogramOfAGroup(t),
      seg: this,
      leafBoxesOffset: 0,
      node: {
        children: e
      }
    };
  }
  init() {
    this.bBox = T.rectangleOnPoint(this.startPoint.point);
    for (const t of this.skip(1))
      this.bBox.add(t.point);
    this.updateCount(), this.calculatePbNode(), this.initIsRequired = !1;
  }
  updateCount() {
    this.count_ = 0;
    for (let t = this.startPoint; t != null; t = t.next)
      this.count_++;
  }
  get count() {
    return this.initIsRequired && this.init(), this.count_;
  }
  get closed() {
    return this.isClosed_;
  }
  set closed(t) {
    this.isClosed_ = t;
  }
  value(t) {
    this.initIsRequired && this.init();
    const e = this.getAdjustedParamAndStartEndPoints(t);
    return u.convSum(e.t, e.a, e.b);
  }
  getAdjustedParamAndStartEndPoints(t) {
    let e = this.startPoint;
    for (; e.next != null; ) {
      if (t <= 1)
        return {
          a: e.point,
          b: e.next.point,
          t
        };
      e = e.next, t -= 1;
    }
    if (this.closed && t <= 1)
      return {
        a: this.endPoint.point,
        b: this.startPoint.point,
        t
      };
    throw new Error("out of the parameter domain");
  }
  derivative(t) {
    const e = this.getAdjustedParamAndStartEndPoints(t);
    return e.b.sub(e.a);
  }
  secondDerivative(t) {
    return new u(0, 0);
  }
  thirdDerivative(t) {
    return new u(0, 0);
  }
  pNodeOverICurve() {
    return this.initIsRequired && this.init(), this.pBNode;
  }
  get boundingBox() {
    return this.initIsRequired && this.init(), this.bBox;
  }
  get parStart() {
    return 0;
  }
  get parEnd() {
    return this.initIsRequired && this.init(), this.closed ? this.count_ : this.count_ - 1;
  }
  static polylineFromCurve(t) {
    const e = new B();
    e.addPoint(t.start);
    for (const i of t.segs)
      e.addPoint(i.end);
    return e.closed = t.start === t.end, e;
  }
  trim(t, e) {
    let i = this.toCurve();
    return i = i.trim(t, e), i instanceof g ? B.polylineFromCurve(i) : B.mkFromPoints([i.start, i.end]);
  }
  trimWithWrap(t, e) {
    throw new Error("Method not implemented.");
  }
  translate(t) {
    let e = this.startPoint;
    do {
      if (e.point = e.point.add(t), e === this.endPoint)
        break;
      e = e.getNext();
    } while (!0);
    this.setInitIsRequired();
  }
  scaleFromOrigin(t, e) {
    throw new Error("Method not implemented.");
  }
  get start() {
    return this.startPoint.point;
  }
  get end() {
    return this.endPoint.point;
  }
  reverse() {
    const t = new B();
    t.closed = this.closed;
    let e = this.endPoint;
    do {
      if (t.addPoint(e.point), e === this.startPoint)
        break;
      e = e.getPrev();
    } while (!0);
    return t;
  }
  offsetCurve(t, e) {
    throw new Error("Method not implemented.");
  }
  lengthPartial(t, e) {
    throw new Error("Method not implemented.");
  }
  get length() {
    throw new Error("Method not implemented.");
  }
  getParameterAtLength(t) {
    throw new Error("Method not implemented.");
  }
  transform(t) {
    const e = new B();
    for (const i of this.polylinePoints())
      e.addPoint(t.multiplyPoint(i.point));
    return e.closed = this.closed, e;
  }
  closestParameterWithinBounds(t, e, i) {
    throw new Error("Method not implemented.");
  }
  closestParameter(t) {
    let e = 0, i = Number.MAX_VALUE, s = 0, n = this.startPoint;
    for (; n.next != null; ) {
      const r = v.mkPP(n.point, n.next.point), o = r.closestParameter(t), l = r.value(o).sub(t), h = l.dot(l);
      h < i && (i = h, e = o + s), n = n.next, s++;
    }
    if (this.closed) {
      const r = v.mkPP(this.endPoint.point, this.startPoint.point), o = r.closestParameter(t), l = r.value(o).sub(t);
      l.dot(l) < i && (e = o + s);
    }
    return e;
  }
  clone() {
    const t = new B();
    t.closed = this.closed;
    let e = this.startPoint;
    do {
      if (t.addPoint(e.point), e === this.endPoint)
        break;
      e = e.getNext();
    } while (!0);
    return t;
  }
  leftDerivative(t) {
    throw new Error("Method not implemented.");
  }
  rightDerivative(t) {
    throw new Error("Method not implemented.");
  }
  curvature(t) {
    throw new Error("Method not implemented.");
  }
  curvatureDerivative(t) {
    throw new Error("Method not implemented.");
  }
  curvatureSecondDerivative(t) {
    throw new Error("Method not implemented.");
  }
  next(t) {
    var e;
    return (e = t.next) !== null && e !== void 0 ? e : this.closed ? this.startPoint : null;
  }
  prev(t) {
    var e;
    return (e = t.prev) !== null && e !== void 0 ? e : this.closed ? this.endPoint : null;
  }
  toCurve() {
    const t = new g();
    g.addLineSegment(t, this.startPoint.point, this.startPoint.next.point);
    let e = this.startPoint.next;
    for (; (e = e.next) != null; )
      g.continueWithLineSegmentP(t, e.point);
    return this.closed && g.continueWithLineSegmentP(t, this.startPoint.point), t;
  }
  RemoveCollinearVertices() {
    for (let t = this.startPoint.next; t.next != null; t = t.next)
      u.getTriangleOrientation(t.prev.point, t.point, t.next.point) === L.Collinear && (t.prev.next = t.next, t.next.prev = t.prev);
    return this.setInitIsRequired(), this;
  }
}
class Ti {
  pad(t) {
    this.width += t * 2;
  }
  /** creates a square if called with width only */
  constructor(t, e = t) {
    this.width = t, this.height = e;
  }
}
class T {
  /** this function will not work correctly for transformations that are not translations, or rotations by n*90, or a combination of those */
  transform(t) {
    return T.mkPP(t.multiplyPoint(this.leftTop), t.multiplyPoint(this.rightBottom));
  }
  translate(t) {
    return T.mkSizeCenter(this.size, this.center.add(t));
  }
  /** Returns true iff the rectangles are geometrically identical */
  equal(t) {
    return this.left_ === t.left && this.right_ === t.right && this.top_ === t.top && this.bottom_ === t.bottom;
  }
  /** Returns true iff the rectangles are distEpsilon close */
  equalEps(t) {
    return D(this.left_, t.left) && D(this.right_, t.right) && D(this.top_, t.top) && D(this.bottom_, t.bottom);
  }
  /** make a rectangle with the given size and center */
  static mkSizeCenter(t, e) {
    const i = t.width / 2, s = t.height / 2;
    return new T({
      left: e.x - i,
      right: e.x + i,
      bottom: e.y - s,
      top: e.y + s
    });
  }
  constructor(t) {
    this.left_ = t.left, this.right_ = t.right, this.top_ = t.top, this.bottom = t.bottom;
  }
  add_rect(t) {
    return this.addRec(t);
  }
  contains_point(t) {
    return this.contains(t);
  }
  contains_rect(t) {
    return this.containsRect(t);
  }
  intersection_rect(t) {
    return this.intersection(t);
  }
  intersects_rect(t) {
    return this.intersects(t);
  }
  unite(t) {
    return T.rectangleOfTwo(this, t);
  }
  contains_point_radius(t, e) {
    return this.containsWithPadding(t, e);
  }
  // returns true if r intersect this rectangle
  intersects(t) {
    return this.intersectsOnX(t) && this.intersectsOnY(t);
  }
  // intersection (possibly empty) of rectangles
  intersection(t) {
    if (!this.intersects(t)) {
      const r = T.mkEmpty();
      return r.setToEmpty(), r;
    }
    const e = Math.max(this.left, t.left), i = Math.min(this.right, t.right), s = Math.max(this.bottom, t.bottom), n = Math.min(this.top, t.top);
    return new T({ left: e, bottom: s, right: i, top: n });
  }
  // the center of the bounding box
  get center() {
    return this.leftTop.add(this.rightBottom).mul(0.5);
  }
  set center(t) {
    const e = this.leftTop.add(this.rightBottom).mul(0.5), i = t.sub(e);
    this.leftTop = this.leftTop.add(i), this.rightBottom = this.rightBottom.add(i);
  }
  intersectsOnY(t) {
    return !(t.bottom_ > this.top_ + m.distanceEpsilon || t.top_ < this.bottom_ - m.distanceEpsilon);
  }
  intersectsOnX(t) {
    return !(t.left > this.right_ + m.distanceEpsilon || t.right < this.left_ - m.distanceEpsilon);
  }
  // creates an empty rectangle
  static mkEmpty() {
    return new T({ left: 0, right: -1, bottom: 0, top: -1 });
  }
  get left() {
    return this.left_;
  }
  set left(t) {
    this.left_ = t, this.onUpdated();
  }
  get right() {
    return this.right_;
  }
  set right(t) {
    this.right_ = t, this.onUpdated();
  }
  get top() {
    return this.top_;
  }
  set top(t) {
    this.top_ = t, this.onUpdated();
  }
  get bottom() {
    return this.bottom_;
  }
  set bottom(t) {
    this.bottom_ = t, this.onUpdated();
  }
  get leftBottom() {
    return new u(this.left_, this.bottom_);
  }
  set leftBottom(t) {
    this.left_ = t.x, this.bottom = t.y;
  }
  get rightTop() {
    return new u(this.right_, this.top_);
  }
  set rightTop(t) {
    this.right_ = t.x, this.top_ = t.y;
  }
  get leftTop() {
    return new u(this.left_, this.top_);
  }
  set leftTop(t) {
    this.left_ = t.x, this.top_ = t.y;
  }
  get rightBottom() {
    return new u(this.right_, this.bottom_);
  }
  set rightBottom(t) {
    this.right_ = t.x, this.bottom = t.y;
  }
  /* eslint-disable  @typescript-eslint/no-empty-function */
  onUpdated() {
  }
  // create a box of two points
  static mkPP(t, e) {
    const i = new T({
      left: t.x,
      right: t.x,
      top: t.y,
      bottom: t.y
    });
    return i.add(e), i;
  }
  // create rectangle from a point
  static rectangleOnPoint(t) {
    return new T({ left: t.x, right: t.x, top: t.y, bottom: t.y });
  }
  static mkLeftBottomSize(t, e, i) {
    const s = t + i.width, n = e + i.height;
    return new T({ left: t, right: s, top: n, bottom: e });
  }
  // create a box on points (x0,y0), (x1,y1)
  static getRectangleOnCoords(t, e, i, s) {
    const n = new T({ left: t, bottom: e, right: t, top: e });
    return n.add(new u(i, s)), n;
  }
  // Create rectangle that is the bounding box of the given points
  static mkOnPoints(t) {
    const e = T.mkEmpty();
    for (const i of t)
      e.add(i);
    return e;
  }
  // Create rectangle that is the bounding box of the given Rectangles
  static mkOnRectangles(t) {
    const e = T.mkEmpty();
    for (const i of t)
      e.addRecSelf(i);
    return e;
  }
  // the width of the rectangle
  get width() {
    return this.right_ - this.left_;
  }
  set width(t) {
    const e = t / 2, i = (this.left_ + this.right_) / 2;
    this.left_ = i - e, this.right_ = i + e;
  }
  // returns true if the rectangle has negative width
  isEmpty() {
    return this.right < this.left;
  }
  // makes the rectangle empty
  setToEmpty() {
    this.left = 0, this.right = -1;
  }
  // height of the rectangle
  get height() {
    return this.top_ - this.bottom_;
  }
  set height(t) {
    const e = t / 2, i = (this.top_ + this.bottom_) / 2;
    this.top_ = i + e, this.bottom = i - e;
  }
  // rectangle containing both a and b
  static rectangleOfTwo(t, e) {
    const i = new T({
      left: t.left_,
      right: t.right_,
      top: t.top_,
      bottom: t.bottom_
    });
    return i.addRecSelf(e), i;
  }
  // contains with padding
  containsWithPadding(t, e) {
    return this.left_ - e - m.distanceEpsilon <= t.x && t.x <= this.right_ + e + m.distanceEpsilon && this.bottom_ - e - m.distanceEpsilon <= t.y && t.y <= this.top_ + e + m.distanceEpsilon;
  }
  // Rectangle area
  get area() {
    return (this.right_ - this.left_) * (this.top_ - this.bottom_);
  }
  // adding a point to the rectangle
  add(t) {
    this.isEmpty() ? (this.left_ = this.right_ = t.x, this.top_ = this.bottom = t.y) : (this.left_ > t.x && (this.left_ = t.x), this.top_ < t.y && (this.top_ = t.y), this.right_ < t.x && (this.right_ = t.x), this.bottom_ > t.y && (this.bottom = t.y));
  }
  // adding rectangle
  addRecSelf(t) {
    this.add(t.leftTop), this.add(t.rightBottom);
  }
  // adding rectangle
  addRec(t) {
    const e = this.clone();
    return e.add(t.leftTop), e.add(t.rightBottom), e;
  }
  /**  Returns the translated clone of the specified rectangle */
  static translate(t, e) {
    const i = t.clone();
    return i.center = t.center.add(e), i;
  }
  /**  Returns a new Rectangle which is the transform the input rectangle */
  static transform(t, e) {
    return T.mkPP(e.multiplyPoint(t.leftTop), e.multiplyPoint(t.rightBottom));
  }
  // returns true if the rectangle contains the point
  contains(t) {
    return this.containsWithPadding(t, 0);
  }
  // returns true if this rectangle compconstely contains the specified rectangle
  containsRect(t) {
    return this.contains(t.leftTop) && this.contains(t.rightBottom);
  }
  // returns true if this rectangle compconstely contains the specified rectangle
  containsRectWithPadding(t, e) {
    return this.containsWithPadding(t.leftTop, e) && this.containsWithPadding(t.rightBottom, e);
  }
  // return the length of the diagonal
  get diagonal() {
    return Math.sqrt(this.width * this.width + this.height * this.height);
  }
  // pad the rectangle horizontally by the given padding
  padWidth(t) {
    this.left -= t, this.right += t;
  }
  // pad the rectangle vertically by the given padding
  padHeight(t) {
    this.top += t, this.bottom -= t;
  }
  // pad the rectangle by the given padding
  pad(t) {
    t < -this.width / 2 && (t = -this.width / 2), t < -this.height / 2 && (t = -this.height / 2), this.padWidth(t), this.padHeight(t);
  }
  // Pad the rectangle by the given amount on each side
  padEverywhere(t) {
    this.left -= t.left, this.right += t.right, this.bottom -= t.bottom, this.top += t.top;
  }
  // Returns the intersection of two rectangles.
  static intersect(t, e) {
    return t.intersects(e) ? T.mkPP(new u(Math.max(t.left, e.left), Math.max(t.bottom, e.bottom)), new u(Math.min(t.right, e.right), Math.min(t.top, e.top))) : T.mkEmpty();
  }
  perimeter() {
    const t = new B();
    return t.addPoint(this.leftTop), t.addPoint(this.rightTop), t.addPoint(this.rightBottom), t.addPoint(this.leftBottom), t.closed = !0, t;
  }
  scaleAroundCenter(t) {
    this.width = this.width * t, this.height = this.height * t;
  }
  clone() {
    return new T({ left: this.left, right: this.right, top: this.top, bottom: this.bottom });
  }
  // gets or sets the Size
  get size() {
    return new Ti(this.width, this.height);
  }
  set size(t) {
    this.width = t.width, this.height = t.height;
  }
  // constructor with Size and center
  static creatRectangleWithSize(t, e) {
    const i = t.width / 2, s = e.x - i, n = e.x + i, r = t.height / 2, o = e.y - r, l = e.y + r;
    return new T({ left: s, right: n, top: l, bottom: o });
  }
  // adding a point with a Size
  addPointWithSize(t, e) {
    const i = t.width / 2, s = t.height / 2;
    this.add(new u(e.x - i, e.y - s)), this.add(new u(e.x + i, e.y - s)), this.add(new u(e.x - i, e.y + s)), this.add(new u(e.x + i, e.y + s));
  }
}
class St {
  constructor() {
    this.previouisBezierCoefficient = 0.5, this.nextBezierCoefficient = 0.5, this.previousTangentCoefficient = 1 / 3, this.nextTangentCoefficient = 1 / 3;
  }
  static mkSiteP(t) {
    const e = new St();
    return e.point = t, e;
  }
  static mkSiteSP(t, e) {
    const i = new St();
    return i.point = e, i.prev = t, t.next = i, i;
  }
  static mkSiteSPS(t, e, i) {
    const s = new St();
    return s.prev = t, s.point = e, s.next = i, t.next = s, i.prev = s, s;
  }
  get turn() {
    return this.next == null || this.prev == null ? 0 : u.getTriangleOrientation(this.prev.point, this.point, this.next.point);
  }
  clone() {
    const t = new St();
    return t.previouisBezierCoefficient = this.previouisBezierCoefficient, t.point = this.point, t;
  }
}
class Tt {
  // creates the polyline from corner points
  static mkFromPoints(t) {
    let e = null, i = null;
    for (const s of t)
      if (i == null)
        i = St.mkSiteP(s), e = new Tt(i);
      else {
        const n = St.mkSiteP(s);
        n.prev = i, i.next = n, i = n;
      }
    return e;
  }
  clone() {
    let t = this.headSite, e = null, i, s = null;
    for (; t != null; )
      i = t.clone(), i.prev = e, e != null ? e.next = i : s = i, t = t.next, e = i;
    return new Tt(s);
  }
  constructor(t) {
    this.headSite = t;
  }
  // the last site of the polyline
  // <
  get lastSite() {
    let t = this.headSite;
    for (; t.next != null; )
      t = t.next;
    return t;
  }
  *[Symbol.iterator]() {
    let t = this.headSite;
    for (; t != null; )
      yield t.point, t = t.next;
  }
  /** Creates a curve by using the underlying polyline*/
  createCurve() {
    const t = new g();
    let e = this.headSite, i;
    do {
      const s = g.findCorner(e);
      if (s == null)
        break;
      const n = Tt.createBezierSegOnSite(s.b);
      t.segs.length === 0 ? u.closeDistEps(e.point, n.start) || g.addLineSegment(t, e.point, n.start) : u.closeDistEps(t.end, n.start) || g.continueWithLineSegmentP(t, n.start), t.addSegment(n), e = s.b;
    } while (!0);
    return t.segs.length === 0 ? u.closeDistEps(e.point, e.next.point) ? t.segs.push(new st(e.point, e.point.add(new u(5, 5)), e.point.add(new u(-5, 5)), i.point)) : g.addLineSegment(t, e.point, e.next.point) : u.closeDistEps(t.end, e.next.point) || g.continueWithLineSegmentP(t, e.next.point), t;
  }
  static createBezierSegOnSite(t) {
    const e = t.previouisBezierCoefficient, i = t.nextBezierCoefficient, s = t.prev, n = t.next, r = s.point.mul(e).add(t.point.mul(1 - e)), o = n.point.mul(i).add(t.point.mul(1 - i)), l = r.mul(t.previousTangentCoefficient).add(t.point.mul(1 - t.previousTangentCoefficient)), h = o.mul(t.nextTangentCoefficient).add(t.point.mul(1 - t.nextTangentCoefficient));
    return st.mkBezier([r, l, h, o]);
  }
}
class _t {
  // the matrix elements
  get Elements() {
    return this.elements;
  }
  // i,j th element
  getElem(t, e) {
    return this.elements[t][e];
  }
  setElem(t, e, i) {
    this.elements[t][e] = i;
  }
  // Divid matrix by a matrix
  static Divide(t, e) {
    return t.multiply(e.inverse());
  }
  isIdentity() {
    return D(this.elements[0][0], 1) && D(this.elements[0][1], 0) && D(this.elements[0][2], 0) && D(this.elements[1][0], 0) && D(this.elements[1][1], 1) && D(this.elements[1][2], 0);
  }
  // returns the point of the matrix offset
  offset() {
    return new u(this.getElem(0, 2), this.getElem(1, 2));
  }
  static getIdentity() {
    return new _t(1, 0, 0, 0, 1, 0);
  }
  constructor(t, e, i, s, n, r) {
    this.elements = [
      [t, e, i],
      [s, n, r]
    ];
  }
  // Rotation matrix - rotates counterclockwise by 'angle'
  static rotation(t) {
    const e = Math.cos(t), i = Math.sin(t);
    return new _t(e, -i, 0, i, e, 0);
  }
  static scaleAroundCenterTransformation(t, e, i) {
    const s = 1 - t, n = 1 - e;
    return new _t(t, 0, s * i.x, 0, e, n * i.y);
  }
  // Point by matrix multiplication
  multiplyPoint(t) {
    return new u(this.getElem(0, 0) * t.x + this.getElem(0, 1) * t.y + this.getElem(0, 2), this.getElem(1, 0) * t.x + this.getElem(1, 1) * t.y + this.getElem(1, 2));
  }
  // matrix matrix multiplication
  multiply(t) {
    return t != null ? new _t(this.getElem(0, 0) * t.getElem(0, 0) + this.getElem(0, 1) * t.getElem(1, 0), this.getElem(0, 0) * t.getElem(0, 1) + this.getElem(0, 1) * t.getElem(1, 1), this.getElem(0, 0) * t.getElem(0, 2) + this.getElem(0, 1) * t.getElem(1, 2) + this.getElem(0, 2), this.getElem(1, 0) * t.getElem(0, 0) + this.getElem(1, 1) * t.getElem(1, 0), this.getElem(1, 0) * t.getElem(0, 1) + this.getElem(1, 1) * t.getElem(1, 1), this.getElem(1, 0) * t.getElem(0, 2) + this.getElem(1, 1) * t.getElem(1, 2) + this.getElem(1, 2)) : null;
  }
  // returns the inversed matrix
  inverse() {
    const t = this.getElem(0, 0) * this.getElem(1, 1) - this.getElem(1, 0) * this.getElem(0, 1), e = this.getElem(1, 1) / t, i = -this.getElem(0, 1) / t, s = -this.getElem(1, 0) / t, n = this.getElem(0, 0) / t, r = -e * this.getElem(0, 2) - i * this.getElem(1, 2), o = -s * this.getElem(0, 2) - n * this.getElem(1, 2);
    return new _t(e, i, r, s, n, o);
  }
}
class pt {
  static mkEllipse(t, e, i) {
    return j.mkFullEllipseNNP(t, e, i);
  }
  static createParallelogram(t, e, i) {
    const s = e / 2, n = t / 2, r = i.x, o = i.y, l = 80 * Math.PI / 180, h = s / Math.tan(l);
    return B.mkClosedFromPoints([
      new u(-n - h + r, -s + o),
      new u(n + r, -s + o),
      new u(n + r + h, s + o),
      new u(-n + r, s + o)
    ]);
  }
  static createHexagon(t, e, i) {
    const s = e / 2, n = t / 2, r = i.x, o = i.y;
    return B.mkClosedFromPoints([
      new u(-n + r, -s + o),
      new u(n + r, -s + o),
      new u(n + (s + r), 0 + o),
      new u(n + r, s + o),
      new u(-n + r, s + o),
      new u(-(n - s) + r, 0 + o)
    ]);
  }
  static createOctagon(t, e, i) {
    const s = t / 2, n = e / 2, r = new Array(8);
    r[0] = new u(s + pt.octagonPad * s, n - n * pt.octagonPad), r[3] = new u(r[0].x * -1, r[0].y), r[4] = new u(r[3].x, r[3].y * -1), r[7] = new u(r[0].x, r[0].y * -1), r[1] = new u(s - s * pt.octagonPad, n + n * pt.octagonPad), r[2] = new u(r[1].x * -1, r[1].y), r[6] = new u(r[1].x, r[1].y * -1), r[5] = new u(r[2].x, r[2].y * -1);
    for (let o = 0; o < 8; o++)
      r[o] = r[o].add(i);
    return B.mkClosedFromPoints(r);
  }
  static createInvertedHouse(t, e, i) {
    const s = pt.createHouse(t, e, i);
    return pt.rotateCurveAroundCenterByDegree(s, i, 180);
  }
  static createHouse(t, e, i) {
    const s = t / 2, n = e / 2, r = i.x, o = i.y, l = new g();
    return g.addLineSegmentCNNNN(l, r - s, o - n, r + s, o - n), g.continueWithLineSegmentNN(l, r + s, o + n), g.continueWithLineSegmentNN(l, r, o + 2 * n), g.continueWithLineSegmentNN(l, r - s, o + n), g.closeCurve(l);
  }
  static mkDiamond(t, e, i) {
    const s = t, n = e, r = i.x, o = i.y, l = new g(), h = [new u(r, o - n), new u(r + s, o), new u(r, o + n), new u(r - s, o)];
    return l.addSegs([v.mkPP(h[0], h[1]), v.mkPP(h[1], h[2]), v.mkPP(h[2], h[3]), v.mkPP(h[3], h[0])]), l;
  }
  static rotateCurveAroundCenterByDegree(t, e, i) {
    return pt.rotateCurveAroundCenterByRadian(t, e, i * Math.PI / 180);
  }
  static rotateCurveAroundCenterByRadian(t, e, i) {
    const s = Math.cos(i), n = Math.sin(i), r = new _t(1, 0, e.x, 0, 1, e.y).multiply(new _t(s, -n, 0, n, s, 0)).multiply(new _t(1, 0, -e.x, 0, 1, -e.y));
    return t.transform(r);
  }
  static mkCircle(t, e) {
    return j.mkCircle(t, e);
  }
  static createRectangle(t, e, i) {
    const s = t / 2, n = e / 2, r = i.x, o = i.y, l = new g(), h = [new u(r - s, o - n), new u(r + s, o - n), new u(r + s, o + n), new u(r - s, o + n)];
    return l.addSegs([v.mkPP(h[0], h[1]), v.mkPP(h[1], h[2]), v.mkPP(h[2], h[3]), v.mkPP(h[3], h[0])]), l;
  }
  static isRoundedRect(t) {
    if (!(t instanceof g))
      return;
    const e = t.segs;
    if (e.length !== 8 && e.length !== 4)
      return;
    const i = e.length === 8;
    let s, n;
    for (let r = 0; r < 4; r++) {
      const o = i ? 2 * r + 1 : r;
      if (r === 0) {
        if (!(e[o] instanceof j))
          return;
        const l = e[o];
        s = l.aAxis.length, n = l.bAxis.length;
      } else {
        if (!(e[o] instanceof j))
          return;
        const l = e[o];
        if (s !== l.aAxis.length || n !== l.bAxis.length)
          return;
      }
    }
    return {
      radX: s,
      radY: n
    };
  }
  static mkRectangleWithRoundedCorners(t, e, i, s, n = new u(0, 0)) {
    if (i === 0 || s === 0)
      return pt.createRectangle(t, e, n);
    const r = new g(), o = t / 2;
    i > o / 2 && (i = o / 2);
    const l = e / 2;
    s > l / 2 && (s = l / 2);
    const h = n.x, c = n.y, d = o - i, f = l - s, p = c + l, P = c - l, y = h - o, C = h + o, w = new u(i, 0), N = new u(0, s);
    return d > 0 && r.addSegment(v.mkPP(new u(h - d, P), new u(h + d, P))), r.addSegment(j.mkEllipse(1.5 * Math.PI, 2 * Math.PI, w, N, h + d, c - f)), f > 0 && r.addSegment(v.mkPP(new u(C, c - f), new u(C, c + f))), r.addSegment(j.mkEllipse(0, 0.5 * Math.PI, w, N, h + d, c + f)), d > 0 && r.addSegment(v.mkPP(new u(h + d, p), new u(h - d, p))), r.addSegment(j.mkEllipse(0.5 * Math.PI, Math.PI, w, N, h - d, c + f)), f > 0 && r.addSegment(v.mkPP(new u(y, c + f), new u(y, c - f))), r.addSegment(j.mkEllipse(Math.PI, 1.5 * Math.PI, w, N, h - d, c - f)), r;
  }
}
pt.octagonPad = 1 / 4;
function Vi(a) {
  return a.parEnd - a.parStart;
}
var S;
(function(a) {
  a[a.None = 0] = "None", a[a.North = 1] = "North", a[a.East = 2] = "East", a[a.South = 4] = "South", a[a.West = 8] = "West";
})(S || (S = {}));
class b {
  // ReSharper restore InconsistentNaming
  static get DifferenceEpsilon() {
    return b.differenceEpsilon;
  }
  // Determines whether the specified Points, which are assumed to have been Round()ed,
  // are close enough to be considered equal.
  // <returns>True if the inputs are close enough to be considered equal, else false</returns>
  static EqualPP(t, e) {
    return b.Equal(t.x, e.x) && b.Equal(t.y, e.y);
  }
  // Determines whether the specified double values, which are assumed to have been Round()ed,
  // are close enough to be considered equal.
  // <returns>True if the inputs are close enough to be considered equal, else false</returns>
  static Equal(t, e) {
    return b.Compare(t, e) === 0;
  }
  // The usual Compare operation, with inputs that are assumed to have been Round()ed.
  //
  //
  // <returns>0 if the inputs are close enough to be considered equal, else -1 if lhs is
  // less than rhs, else 1.</returns>
  static Compare(t, e) {
    let i = 0;
    return t + b.DifferenceEpsilon < e ? i = -1 : e + b.DifferenceEpsilon < t && (i = 1), i;
  }
  // The usual Compare operation, with inputs that are assumed to have been Round()ed.
  // <returns>0 if the inputs are close enough to be considered equal, else -1 if lhs is
  // less than rhs, else 1.</returns>
  static ComparePP(t, e) {
    let i = b.Compare(t.x, e.x);
    return i === 0 && (i = b.Compare(t.y, e.y)), i;
  }
  // return true if less or equal holds for two values that are assumed to have been Round()ed
  static LessOrEqual(t, e) {
    const i = b.Compare(t, e);
    return i < 0 || i === 0;
  }
  static Less(t, e) {
    return b.Compare(t, e) < 0;
  }
  // static Assert_Rounded(d: number) {
  //  //  Be sure there is enough precision to round that far; anything larger than this is
  //  //  unlikely to be a graph coordinate (it's probably a line intersection way out of range).
  //  if (Math.log10(Math.abs(d)) < 14 - GeomConstants.distanceEpsilonPrecision) {
  //    /*Assert.assert(
  //      Math.abs(Point.RoundDouble(d) - d) <
  //        PointComparer.DifferenceEpsilon,
  //      'unRounded value passed',
  //    )*/
  //  }
  // }
  // static Assert_RoundedP(p: Point) {
  //  // PointComparer.Assert_Rounded(p.x)
  //  // PointComparer.Assert_Rounded(p.y)
  // }
  static GetDirections(t, e) {
    return E.DirectionFromPointToPoint(t, e);
  }
  static IsPureDirection(t, e) {
    return E.IsPureDirection(b.GetDirections(t, e));
  }
  static IsPureDirectionD(t) {
    return E.IsPureDirection(t);
  }
  static IsPureLower(t, e) {
    const i = b.GetDirections(t, e);
    return S.East === i || S.North === i;
  }
  static GetPureDirectionVV(t, e) {
    return b.GetDirections(t.point, e.point);
  }
}
b.differenceEpsilon = m.distanceEpsilon / 2;
class E {
  constructor(t) {
    this.Dir = t;
  }
  get Right() {
    return new E(E.RotateRight(this.Dir));
  }
  static RotateRight(t) {
    switch (t) {
      case S.North:
        return S.East;
      case S.East:
        return S.South;
      case S.South:
        return S.West;
      case S.West:
        return S.North;
      default:
        throw new Error();
    }
  }
  static RotateLeft(t) {
    switch (t) {
      case S.North:
        return S.West;
      case S.West:
        return S.South;
      case S.South:
        return S.East;
      case S.East:
        return S.North;
      default:
        throw new Error();
    }
  }
  static ToIndex(t) {
    switch (t) {
      case S.North:
        return 0;
      case S.East:
        return 1;
      case S.South:
        return 2;
      case S.West:
        return 3;
      default:
        throw new Error();
    }
  }
  static VectorDirection(t) {
    let e = S.None;
    return t.x > b.DifferenceEpsilon ? e = S.East : t.x < -b.DifferenceEpsilon && (e = S.West), t.y > b.DifferenceEpsilon ? e = e | S.North : t.y < -b.DifferenceEpsilon && (e = e | S.South), e;
  }
  static VectorDirectionPP(t, e) {
    let i = S.None;
    const s = e.x - t.x, n = e.y - t.y;
    return s > b.DifferenceEpsilon ? i = S.East : -s > b.DifferenceEpsilon && (i = S.West), n > b.DifferenceEpsilon ? i |= S.North : -n > b.DifferenceEpsilon && (i |= S.South), i;
  }
  static DirectionFromPointToPoint(t, e) {
    return E.VectorDirectionPP(t, e);
  }
  static OppositeDir(t) {
    switch (t) {
      case S.North:
        return S.South;
      case S.West:
        return S.East;
      case S.South:
        return S.North;
      case S.East:
        return S.West;
      default:
        return S.None;
    }
  }
  static IsPureDirection(t) {
    switch (t) {
      case S.North:
        return !0;
      case S.East:
        return !0;
      case S.South:
        return !0;
      case S.West:
        return !0;
      default:
        return !1;
    }
  }
  static IsPureDirectionPP(t, e) {
    return E.IsPureDirection(E.DirectionFromPointToPoint(t, e));
  }
  static DirectionsAreParallel(t, e) {
    return t === e || t === E.OppositeDir(e);
  }
  // Translates the CompassVector's direction into a new Point.
  ToPoint() {
    let t = 0, e = 0;
    return (this.Dir & S.East) === S.East && t++, (this.Dir & S.North) === S.North && e++, (this.Dir & S.West) === S.West && t--, (this.Dir & S.South) === S.South && e--, new u(t, e);
  }
  // Translates a direction into a Point.
  static toPoint(t) {
    return new E(t).ToPoint();
  }
  //  the negation operator
  static negate(t) {
    return new E(E.OppositeDir(t.Dir));
  }
}
class Zr extends $ {
  /** clones but does not bind to the entity and does not set the parent edge*/
  clone() {
    const t = new Zr(null, null);
    return t.isPositioned = this.isPositioned, t._boundingBox = this._boundingBox.clone(), t.attachmentSegmentEnd = this.attachmentSegmentEnd, t.attachmentSegmentStart = this.attachmentSegmentStart, t;
  }
  get isPositioned() {
    return this._isPositioned;
  }
  set isPositioned(t) {
    this._isPositioned = t;
  }
  constructor(t, e) {
    super(t), this._isPositioned = !1, e && (this.boundingBox = T.mkPP(new u(0, 0), new u(e.width, e.height)));
  }
  get boundingBox() {
    return this._boundingBox;
  }
  set boundingBox(t) {
    this._boundingBox = t;
  }
  setBoundingBox(t) {
    this.isPositioned = !0, this._boundingBox = t;
  }
  get width() {
    return this.boundingBox.width;
  }
  set width(t) {
    this.boundingBox.width = t;
  }
  get height() {
    return this.boundingBox.height;
  }
  set height(t) {
    this.boundingBox.height = t;
  }
  get center() {
    return this.boundingBox.center;
  }
  set center(t) {
    this.boundingBox.center = t;
  }
  translate(t) {
    this.isPositioned && (this.center = this.center.add(t));
  }
  transform(t) {
    this.isPositioned && (this.center = t.multiplyPoint(this.center));
  }
  positionCenter(t) {
    this.boundingBox.center = t, this.isPositioned = !0;
  }
}
class Kt extends $ {
  *getSmoothPolyPoints() {
    yield this.source.center, this.curve instanceof g ? yield* this.getCurvePoints(this.curve) : this.curve instanceof v ? (yield this.curve.start, yield this.curve.end) : this.curve instanceof j ? (yield this.curve.start, yield this.curve.value((this.curve.parStart + this.curve.parEnd) / 0.5), yield this.curve.end) : this.curve instanceof st && (yield this.curve.start, yield this.curve.value(0.25), yield this.curve.value(0.75), yield this.curve.end), yield this.target.center;
  }
  *getCurvePoints(t) {
    for (const e of t.segs)
      if (yield e.start, e instanceof st) {
        const i = yd(e);
        i && (yield i);
      }
    yield t.end;
  }
  static getGeom(t) {
    return $.getGeom(t);
  }
  /** clones but does not bind to the entity */
  clone() {
    const t = new Kt(null);
    return this.smoothedPolyline && (t.smoothedPolyline = this.smoothedPolyline.clone()), t.curve = this.curve.clone(), this.sourceArrowhead != null && (t.sourceArrowhead = this.sourceArrowhead.clone()), this.targetArrowhead != null && (t.targetArrowhead = this.targetArrowhead.clone()), t;
  }
  get label() {
    return this.edge != null && this.edge.label != null ? $.getGeom(this.edge.label) : null;
  }
  set label(t) {
    this.edge.label.setAttr(_e.GeomObjectIndex, t);
  }
  RaiseLayoutChangeEvent(t) {
    this.edge.raiseEvents(t);
  }
  requireRouting() {
    this.curve = null, this.smoothedPolyline = null;
  }
  translate(t) {
    if (!(t.x === 0 && t.y === 0)) {
      if (this.curve != null && this.curve.translate(t), this.smoothedPolyline != null)
        for (let e = this.smoothedPolyline.headSite, i = this.smoothedPolyline.headSite; e != null; e = e.next, i = i.next)
          e.point = i.point.add(t);
      if (this.sourceArrowhead != null && this.sourceArrowhead.tipPosition && (this.sourceArrowhead.tipPosition = this.sourceArrowhead.tipPosition.add(t)), this.targetArrowhead != null && this.targetArrowhead.tipPosition && (this.targetArrowhead.tipPosition = this.targetArrowhead.tipPosition.add(t)), this.edge.label) {
        const e = Zr.getGeom(this.edge.label);
        e && e.translate(t);
      }
    }
  }
  GetMaxArrowheadLength() {
    let t = 0;
    return this.sourceArrowhead != null && (t = this.sourceArrowhead.length), this.targetArrowhead != null && this.targetArrowhead.length > t ? this.targetArrowhead.length : t;
  }
  transform(t) {
    if (this.curve != null) {
      if (this.curve = this.curve.transform(t), this.smoothedPolyline != null)
        for (let e = this.smoothedPolyline.headSite, i = this.smoothedPolyline.headSite; e != null; e = e.next, i = i.next)
          e.point = t.multiplyPoint(e.point);
      this.sourceArrowhead != null && (this.sourceArrowhead.tipPosition = t.multiplyPoint(this.sourceArrowhead.tipPosition)), this.targetArrowhead != null && (this.targetArrowhead.tipPosition = t.multiplyPoint(this.targetArrowhead.tipPosition));
    }
  }
  get edge() {
    return this.entity;
  }
  get source() {
    return $.getGeom(this.edge.source);
  }
  /** iterates over the source arrowhead corner points */
  *sourceArrowheadPoints(t) {
    if (this.sourceArrowhead == null)
      return;
    yield this.sourceArrowhead.tipPosition;
    let e = this.sourceArrowhead.tipPosition.sub(this.curve.start);
    e = e.rotate90Cw().mul(Math.tan(t * 0.5 * (Math.PI / 180))), yield e.add(this.curve.start), yield this.curve.start.sub(e);
  }
  /** iterates over the target arrowhead corner points */
  *targetArrowheadPoints(t) {
    if (this.targetArrowhead == null)
      return;
    yield this.targetArrowhead.tipPosition;
    let e = this.targetArrowhead.tipPosition.sub(this.curve.end);
    e = e.rotate90Cw().mul(Math.tan(t * 0.5 * (Math.PI / 180))), yield e.add(this.curve.end), yield this.curve.end.sub(e);
  }
  get boundingBox() {
    const t = T.mkEmpty();
    if (this.smoothedPolyline != null)
      for (const i of this.smoothedPolyline)
        t.add(i);
    this.curve != null && t.addRecSelf(this.curve.boundingBox);
    for (const i of this.sourceArrowheadPoints(25))
      t.add(i);
    for (const i of this.targetArrowheadPoints(25))
      t.add(i);
    this.label && t.addRecSelf(this.label.boundingBox);
    const e = this.lineWidth;
    return t.left -= e, t.top += e, t.right += e, t.bottom -= e, t;
  }
  isInterGraphEdge() {
    return this.edge.isInterGraphEdge();
  }
  get target() {
    return $.getGeom(this.edge.target);
  }
  constructor(t) {
    super(t), this.lineWidth = 1;
  }
  toString() {
    return this.source.toString() + "->" + this.target;
  }
  static RouteSelfEdge(t, e, i) {
    const s = t.boundingBox.width, n = t.boundingBox.height, r = t.boundingBox.center, o = new u(r.x - s / 4, r.y), l = new u(r.x - s / 4, r.y - n / 2 - e), h = new u(r.x + s / 4, r.y - n / 2 - e), c = new u(r.x + s / 4, r.y);
    return i.smoothedPolyline = Tt.mkFromPoints([o, l, h, c]), i.smoothedPolyline.createCurve();
  }
  underCollapsedGraph() {
    return this.source.underCollapsedGraph() || this.target.underCollapsedGraph();
  }
  EdgeToAncestor() {
    return this.edge.EdgeToAncestor();
  }
}
function yd(a) {
  return u.lineLineIntersection(a.b[0], a.b[1], a.b[2], a.b[3]);
}
var $n = {}, Ua;
function bd() {
  if (Ua) return $n;
  Ua = 1, Object.defineProperty($n, "__esModule", { value: !0 });
  const a = kl();
  class t extends a.LinkedList {
    constructor(...i) {
      super(...i);
    }
    get top() {
      return this.head;
    }
    get size() {
      return this.length;
    }
    push(i) {
      this.prepend(i);
    }
    pop() {
      return this.removeHead();
    }
  }
  return $n.Stack = t, $n;
}
var mt = bd(), at;
(function(a) {
  a[a.Continue = 0] = "Continue", a[a.Stop = 1] = "Stop";
})(at || (at = {}));
function vd(a, t, e, i, s, n) {
  for (let o = 0; o < a.length; o++) {
    if (o === t || o === e)
      continue;
    const l = n.box0.add_rect(a[o].irect), h = l.area - n.box0.area, c = n.box1.add_rect(a[o].irect), d = c.area - n.box1.area;
    i.length * 2 < s.length ? (i.push(a[o]), n.box0 = l) : s.length * 2 < i.length ? (s.push(a[o]), n.box1 = c) : h < d ? (i.push(a[o]), n.box0 = l) : d < h ? (s.push(a[o]), n.box1 = c) : n.box0.area < n.box1.area ? (i.push(a[o]), n.box0 = l) : (s.push(a[o]), n.box1 = c);
  }
}
function Et(a) {
  if (a.length === 0)
    return null;
  if (a.length === 1)
    return a[0];
  const t = { b0: a[0].irect, seed0: 1 }, e = Cd(a, t), i = [], s = [];
  i.push(a[t.seed0]), s.push(a[e]);
  const n = { box0: a[t.seed0].irect, box1: a[e].irect };
  vd(a, t.seed0, e, i, s, n);
  const r = Nh(a.length);
  return r.irect = n.box0.add_rect(n.box1), r.Left = Et(i), r.Right = Et(s), r;
}
function Xa(a, t) {
  return a.add_rect(t).area;
}
function Cd(a, t) {
  let e = Xa(t.b0, a[t.seed0].irect);
  for (let s = 2; s < a.length; s++) {
    const n = Xa(t.b0, a[s].irect);
    n > e && (t.seed0 = s, e = n);
  }
  let i;
  for (let s = 0; s < a.length; s++)
    if (s !== t.seed0) {
      i = s;
      break;
    }
  e = a[t.seed0].irect.add_rect(a[i].irect).area;
  for (let s = 0; s < a.length; s++) {
    if (s === t.seed0)
      continue;
    const n = a[t.seed0].irect.add_rect(a[s].irect).area;
    n > e && (i = s, e = n);
  }
  return i;
}
function Ar(a, t) {
  if (a == null || t == null)
    return null;
  const e = Array.from(a).map((i) => Bt(i, t(i)));
  return Et(e);
}
function Nh(a) {
  const t = new na();
  return t.Count = a, t;
}
function Bt(a, t) {
  const e = new na();
  return e.UserData = a, e.irect = t, e.Count = 1, e;
}
function Fo(a, t, e) {
  return a.irect.intersects_rect(e) ? t(a.UserData) === at.Continue ? a.Left != null ? Fo(a.Left, t, e) === at.Continue && Fo(a.Right, t, e) === at.Continue ? at.Continue : at.Stop : at.Continue : at.Stop : at.Continue;
}
class na {
  toString() {
    return this.IsLeaf ? this.Count.toString() + " " + this.UserData : this.Count.toString();
  }
  // false if it is an internal node and true if it is a leaf
  get IsLeaf() {
    return this.left == null;
  }
  //if left is a null then right is also a null
  //
  get Left() {
    return this.left;
  }
  set Left(t) {
    this.left != null && this.left.Parent === this && (this.left.Parent = null), this.left = t, this.left != null && (this.left.Parent = this);
  }
  get Right() {
    return this.right;
  }
  set Right(t) {
    this.right != null && this.right.Parent === this && (this.right.Parent = null), this.right = t, this.right != null && (this.right.Parent = this);
  }
  get IsLeftChild() {
    return this === this.Parent.Left;
  }
  // brings the first leaf which rectangle was intersected
  FirstIntersectedNode(t) {
    var e;
    return t.intersects_rect(this.irect) ? this.IsLeaf ? this : (e = this.Left.FirstIntersectedNode(t)) !== null && e !== void 0 ? e : this.Right.FirstIntersectedNode(t) : null;
  }
  FirstHitNodeWithPredicate(t, e) {
    var i;
    return this.irect.contains_point(t) ? this.IsLeaf ? e(t, this.UserData) === at.Stop ? this : null : (i = this.Left.FirstHitNodeWithPredicate(t, e)) !== null && i !== void 0 ? i : this.Right.FirstHitNodeWithPredicate(t, e) : null;
  }
  FirstHitByRectWithPredicate(t, e) {
    var i;
    return this.irect.intersects_rect(t) ? this.IsLeaf ? e(this.UserData) === at.Stop ? this : null : (i = this.Left.FirstHitByRectWithPredicate(t, e)) !== null && i !== void 0 ? i : this.Right.FirstHitByRectWithPredicate(t, e) : null;
  }
  // brings the first leaf which rectangle was hit and the delegate is happy with the object
  FirstHitNode(t) {
    var e;
    return this.irect.contains_point(t) ? this.IsLeaf ? this : (e = this.Left.FirstHitNode(t)) !== null && e !== void 0 ? e : this.Right.FirstHitNode(t) : null;
  }
  // returns all leaf nodes for which the rectangle was hit and the delegate is happy with the object
  *AllHitItems(t, e = null) {
    const i = new mt.Stack();
    for (i.push(this); i.size > 0; ) {
      const s = i.pop();
      s.irect.intersects_rect(t) && (s.IsLeaf ? (e == null || e(s.UserData)) && (yield s.UserData) : (i.push(s.left), i.push(s.right)));
    }
  }
  // returns all items for which the rectangle contains the point
  *AllHitItems_(t) {
    const e = new mt.Stack();
    for (e.push(this); e.size > 0; ) {
      const i = e.pop();
      i.irect.contains_point(t) && (i.IsLeaf ? yield i.UserData : (e.push(i.left), e.push(i.right)));
    }
  }
  // Returns all leaves whose rectangles intersect hitRectangle (or all leaves before hitTest returns false).
  VisitTree(t, e) {
    Fo(this, t, e);
  }
  //
  Clone() {
    const t = Nh(this.Count);
    return t.UserData = this.UserData, t.irect = this.irect, this.Left != null && (t.Left = this.Left.Clone()), this.Right != null && (t.Right = this.Right.Clone()), t;
  }
  // yields all leaves which rectangles intersect the given one. We suppose that leaves are all nodes having UserData not a null.
  *GetNodeItemsIntersectingRectangle(t) {
    for (const e of this.GetLeafRectangleNodesIntersectingRectangle(t))
      yield e.UserData;
  }
  // yields all leaves whose rectangles intersect the given one. We suppose that leaves are all nodes having UserData not a null.
  *GetLeafRectangleNodesIntersectingRectangle(t) {
    const e = new mt.Stack();
    for (e.push(this); e.size > 0; ) {
      const i = e.pop();
      i.irect.intersects_rect(t) && (i.IsLeaf ? yield i : (e.push(i.left), e.push(i.right)));
    }
  }
  // Walk the tree and return the data from all leaves
  *GetAllLeaves() {
    for (const t of this.GetAllLeafNodes())
      yield t.UserData;
  }
  *GetAllLeafNodes() {
    for (const t of this.EnumRectangleNodes(!0))
      yield t;
  }
  *EnumRectangleNodes(t) {
    const e = new mt.Stack();
    for (e.push(this); e.size > 0; ) {
      const i = e.pop();
      (i.IsLeaf || !t) && (yield i), i.IsLeaf || (e.push(i.left), e.push(i.right));
    }
  }
  //
  // Walk the tree from node down and apply visitor to all nodes
  TraverseHierarchy(t, e) {
    e(t), t.Left != null && this.TraverseHierarchy(t.Left, e), t.Right != null && this.TraverseHierarchy(t.Right, e);
  }
}
class ie {
  constructor(t, e) {
    lr(t, e) < 0 ? (this._first = t, this._second = e) : (this._first = e, this._second = t);
  }
  get first() {
    return this._first;
  }
  get second() {
    return this._second;
  }
  get Length() {
    return Z(this._first, this._second);
  }
  CompareTo(t) {
    const e = lr(this._first, t._first);
    return e !== 0 ? e : lr(this._second, t._second);
  }
  static equal(t, e) {
    return t._first.equal(e._first) && t._second.equal(e._second);
  }
  toString() {
    return this._first + (" " + this._second);
  }
}
let xt = class Bh {
  delete(t) {
    return this.deletexy(t.x, t.y);
  }
  clear() {
    this.mapOfSets.clear(), this.size_ = 0;
  }
  get size() {
    return this.size_;
  }
  static mk(t) {
    const e = new Bh();
    for (const i of t)
      e.add(i);
    return e;
  }
  addxy(t, e) {
    let i = this.mapOfSets.get(t);
    i == null && this.mapOfSets.set(t, i = /* @__PURE__ */ new Set()), i.has(e) || this.size_++, i.add(e);
  }
  add(t) {
    return this.addxy(t.x, t.y), this;
  }
  deletexy(t, e) {
    const i = this.mapOfSets.get(t);
    return i != null && i.delete(e) ? (this.size_--, !0) : !1;
  }
  hasxy(t, e) {
    return this.mapOfSets.has(t) && this.mapOfSets.get(t).has(e);
  }
  has(t) {
    return this.hasxy(t.x, t.y);
  }
  constructor() {
    this.size_ = 0, this.mapOfSets = /* @__PURE__ */ new Map();
  }
  forEach(t, e) {
    for (const i of this)
      t(i, i, e);
  }
  *entries() {
    for (const t of this)
      yield [t, t];
  }
  keys() {
    return this.values();
  }
  *values() {
    for (const t of this.mapOfSets)
      for (const e of t[1])
        yield new u(t[0], e);
  }
  [Symbol.iterator]() {
    return this.values();
  }
};
function zs(a, t) {
  const e = /* @__PURE__ */ new Set();
  for (const i of a)
    t.has(i) || e.add(i);
  return e;
}
function Id(a, t) {
  const e = new xt();
  for (const i of a)
    t.has(i) || e.add(i);
  return e;
}
function js(a, t) {
  const e = new Set(a);
  for (const i of t)
    e.add(i);
  return e;
}
function Di(a, t) {
  for (const e of t)
    a.push(e);
}
function Hi(a, t) {
  const e = /* @__PURE__ */ new Set();
  if (a.size < t.size)
    for (const i of a)
      t.has(i) && e.add(i);
  else
    for (const i of t)
      a.has(i) && e.add(i);
  return e;
}
function Ed(a) {
  if (a.length === 0)
    return /* @__PURE__ */ new Set();
  let t = a[0];
  for (let e = 1; e < a.length; e++)
    t = Hi(t, a[e]);
  return t;
}
function an(a, t) {
  for (const e of t)
    a.add(e);
}
function Tr(a, t) {
  if (a.size !== t.size)
    return !1;
  for (const e of a)
    if (!t.has(e))
      return !1;
  return !0;
}
function Qn(a, t) {
  const e = [];
  for (const i of a)
    for (const s of t(i))
      e.push(s);
  return e;
}
function Or(a, t, e) {
  let i = a.get(t);
  i || (i = /* @__PURE__ */ new Set(), a.set(t, i)), i.add(e);
}
function Ts(a, t, e) {
  let i = a.get(t);
  i || (i = new Array(), a.set(t, i)), i.push(e);
}
function Gh(a, t, e) {
  let i = a.get(t);
  i || (i = /* @__PURE__ */ new Set(), a.set(t, i)), i.add(e);
}
function wd(a, t, e) {
  Gh(a, new ie(t[0], t[1]), e);
}
function Ad(a, t, e) {
  const i = a.get(t);
  i && i.delete(e);
}
function Qa(a, t, e) {
  Ad(a, new ie(t[0], t[1]), e);
}
class lt {
  static assert(t, e = null) {
    if (!t)
      throw e != null ? (console.log(e), new Error(e)) : new Error("condition does not hold");
  }
}
var fs;
(function(a) {
  a[a.None = 0] = "None", a[a.FromAncestor = 1] = "FromAncestor", a[a.ToAncestor = 2] = "ToAncestor";
})(fs || (fs = {}));
class Mh extends Uo {
  constructor(t, e) {
    super(), this.source = t, this.target = e, t !== e ? (t.outEdges.add(this), e.inEdges.add(this)) : t.selfEdges.add(this);
  }
  add() {
    this.source !== this.target ? (this.source.outEdges.add(this), this.target.inEdges.add(this)) : this.source.selfEdges.add(this);
  }
  remove() {
    this.source !== this.target ? (this.source.outEdges.delete(this), this.target.inEdges.delete(this)) : this.source.selfEdges.delete(this);
  }
  toString() {
    return "(" + this.source.toString() + "->" + this.target.toString() + ")";
  }
  isInterGraphEdge() {
    return this.source.parent !== this.target.parent;
  }
  EdgeToAncestor() {
    return this.source instanceof di && this.target.isDescendantOf(this.source) ? fs.FromAncestor : this.target instanceof di && this.source.isDescendantOf(this.target) ? fs.ToAncestor : fs.None;
  }
}
class Td extends Uo {
  removeOutEdge(t) {
    this.outEdges.delete(t);
  }
  removeInEdge(t) {
    this.inEdges.delete(t);
  }
  /** the unique, in the parent graph, id of the node */
  get id() {
    return this._id;
  }
  set id(t) {
    this._id = t;
  }
  toString() {
    return this.id;
  }
  constructor(t) {
    super(), this.inEdges = /* @__PURE__ */ new Set(), this.outEdges = /* @__PURE__ */ new Set(), this.selfEdges = /* @__PURE__ */ new Set(), this.id = t;
  }
  *_edges() {
    for (const t of this.inEdges)
      yield t;
    for (const t of this.outEdges)
      yield t;
    for (const t of this.selfEdges)
      yield t;
  }
  get edges() {
    return this._edges();
  }
  get outDegree() {
    return this.outEdges.size;
  }
  get inDegree() {
    return this.inEdges.size;
  }
  get selfDegree() {
    return this.selfEdges.size;
  }
  get degree() {
    return this.outDegree + this.inDegree + this.selfDegree;
  }
}
class Od {
  constructor() {
    this.nodeMap = /* @__PURE__ */ new Map();
  }
  remove(t) {
    this.nodeMap.delete(t.id);
  }
  get size() {
    return this.nodeMap.size;
  }
  *nodes_() {
    for (const t of this.nodeMap.values())
      yield t;
  }
  *graphs_() {
    for (const t of this.nodes_())
      t instanceof di && (yield t);
  }
  findShallow(t) {
    return this.nodeMap.get(t);
  }
  get nodesShallow() {
    return this.nodes_();
  }
  get graphs() {
    return this.graphs_();
  }
  *_edges() {
    for (const t of this.nodeMap.values()) {
      for (const e of t.outEdges)
        yield e;
      for (const e of t.selfEdges)
        yield e;
    }
  }
  interGraphEdges() {
    throw new Error("not implemented");
  }
  get nodeShallowCount() {
    return this.nodeMap.size;
  }
  // caution: it is a linear by the number of nodes method
  get edgeCount() {
    let t = 0;
    for (const e of this.nodeMap.values())
      t += e.outDegree + e.selfDegree;
    return t;
  }
  /**  returns the edges of shallow nodes */
  get edges() {
    return this._edges();
  }
  addNode(t) {
    this.nodeMap.set(t.id, t);
  }
  nodeIsConsistent(t) {
    for (const e of t.outEdges)
      if (e.source !== t || e.source === e.target)
        return !1;
    for (const e of t.inEdges)
      if (e.target !== t || e.source === e.target)
        return !1;
    for (const e of t.selfEdges)
      if (e.target !== e.source || e.source !== t)
        return !1;
    return !0;
  }
  isConsistent() {
    for (const t of this.nodeMap.values())
      if (!this.nodeIsConsistent(t))
        return !1;
    return !0;
  }
}
let di = class yi extends Td {
  remove(t) {
    this.nodeCollection.remove(t);
  }
  /** Removes itself from under the parent.
   *  Also removes all the edges leading out of the graph.
   */
  removeSubgraph() {
    const t = this.parent;
    t && t.removeNode(this);
    for (const e of this.outGoingEdges())
      e.attachedAtSource ? e.node.removeOutEdge(e.edge) : e.node.removeInEdge(e.edge);
  }
  /** returns the objects that show how the edge is adjacent to a node  that is outside of the graph */
  *outGoingEdges() {
    for (const t of this.outEdges) {
      const e = t.target;
      this.isAncestor(e) || (yield { edge: t, node: e, attachedAtSource: !1 });
    }
    for (const t of this.inEdges) {
      const e = t.source;
      this.isAncestor(e) || (yield { edge: t, node: e, attachedAtSource: !0 });
    }
    for (const t of this.nodesBreadthFirst) {
      for (const e of t.outEdges) {
        const i = e.target;
        i !== this && (this.isAncestor(i) || (yield { edge: e, node: i, attachedAtSource: !1 }));
      }
      for (const e of t.inEdges) {
        const i = e.source;
        i !== this && (this.isAncestor(i) || (yield { edge: e, node: i, attachedAtSource: !0 }));
      }
    }
  }
  isAncestor(t) {
    for (const e of t.getAncestors())
      if (e === this)
        return !0;
    return !1;
  }
  /**  Iterates over all connected components of the graph and for each component
   * returns all its nodes with "this" as the parent
   */
  *getClusteredConnectedComponents() {
    const t = /* @__PURE__ */ new Set(), e = new We.Queue();
    for (const i of this.nodesBreadthFirst) {
      if (t.has(i))
        continue;
      t.add(i), e.enqueue(i);
      const s = /* @__PURE__ */ new Set();
      do {
        const n = e.dequeue();
        n.parent === this && s.add(n);
        for (const r of this.reachableFrom(n))
          t.has(r) || (t.add(r), e.enqueue(r));
      } while (e.length > 0);
      yield Array.from(s);
    }
  }
  *reachableFrom(t) {
    for (const e of t.outEdges)
      yield e.target;
    for (const e of t.inEdges)
      yield e.source;
    t instanceof yi && (yield* t.shallowNodes), t.parent != this && (yield t.parent);
  }
  hasSomeAttrOnIndex(t) {
    for (const e of this.nodesBreadthFirst)
      if (e.getAttr(t))
        return !0;
    for (const e of this.deepEdges)
      if (e.getAttr(t))
        return !0;
    return !1;
  }
  *graphs() {
    for (const t of this.nodeCollection.graphs)
      yield t;
  }
  noEmptySubgraphs() {
    for (const t of this.subgraphsBreadthFirst())
      if (t.shallowNodeCount === 0)
        return !1;
    return !0;
  }
  hasSubgraphs() {
    for (const t of this.shallowNodes)
      if (t instanceof yi)
        return !0;
    return !1;
  }
  /** iterates breadth first  */
  *subgraphsBreadthFirst() {
    for (const t of this.nodesBreadthFirst)
      t instanceof yi && (yield t);
  }
  isEmpty() {
    return this.shallowNodeCount === 0;
  }
  setEdge(t, e) {
    const i = this.nodeCollection.findShallow(t);
    if (i == null)
      return;
    const s = this.nodeCollection.findShallow(e);
    if (s != null)
      return new Mh(i, s);
  }
  /** Iterates over the nodes of the current graph but not entering the subgraphs.
   *  Yields the top subgraphs among the nodes as well
   */
  get shallowNodes() {
    return this.nodeCollection.nodesShallow;
  }
  /** Iterates over all the nodes of including the subgraphs.
   * The iteration happens in the breadth first pattern.
   */
  get nodesBreadthFirst() {
    return this.nodesBreadthFirst_();
  }
  /** iterates breadth first  */
  *nodesBreadthFirst_() {
    for (const t of this.nodeCollection.nodesShallow)
      yield t, t instanceof yi && (yield* t.nodesBreadthFirst);
  }
  constructor(t = "__graph__") {
    super(t), this.nodeCollection = new Od();
  }
  /**
   * Finds the node with the givin id belonging to a graph or one of its subgraphs.
   */
  findNodeRecursive(t) {
    const e = this.nodeCollection.findShallow(t);
    if (e)
      return e;
    for (const i of this.shallowNodes)
      if (i instanceof yi) {
        const s = i.findNodeRecursive(t);
        if (s)
          return s;
      }
    return null;
  }
  /** Returns a node belonging to this graph having the same id.
   * If a node with the given id belongs to a subgraph than it would no be returned.
   * To find such a deeper nested node use findNodeRecursive
   */
  findNode(t) {
    return this.nodeCollection.findShallow(t);
  }
  /** iterates over the edges of the graph which adjacent to the nodes of the graph:
   * not iterating over the subgraphs
   */
  get shallowEdges() {
    return this.nodeCollection.edges;
  }
  /** iterates over the edges of the graph including subgraphs */
  get deepEdges() {
    return this.deepEdgesIt();
  }
  *deepEdgesIt() {
    for (const t of this.nodesBreadthFirst) {
      for (const e of t.outEdges)
        yield e;
      for (const e of t.selfEdges)
        yield e;
      for (const e of t.inEdges)
        this.isAncestor(e.source) || (yield e);
    }
  }
  isConsistent() {
    return this.parent ? this.parent.isConsistent() : this.eachNodeIdIsUnique() && this.nodeCollection.isConsistent();
  }
  nodeIsConsistent(t) {
    return this.nodeCollection.nodeIsConsistent(t);
  }
  /** Detouches all the node's edges and removes the node from the graph.
   * This method does not change the parent of the node.
   */
  removeNode(t) {
    for (const e of t.outEdges)
      e.target.inEdges.delete(e);
    for (const e of t.inEdges)
      e.source.outEdges.delete(e);
    this.nodeCollection.remove(t);
    for (const e of this.subgraphsBreadthFirst())
      e.removeNode(t);
  }
  /** adds a node to the graph */
  addNode(t) {
    return lt.assert(this.findNodeRecursive(t.id) == null), t.parent = this, this.nodeCollection.addNode(t), t;
  }
  get shallowNodeCount() {
    return this.nodeCollection.nodeShallowCount;
  }
  get nodeCountDeep() {
    let t = this.nodeCollection.size;
    for (const e of this.shallowNodes)
      e instanceof yi && (t += e.nodeCountDeep);
    return t;
  }
  get edgeCount() {
    return this.nodeCollection.edgeCount;
  }
  // If n has an ancestor which is the graph child then return it.
  // Otherwise return null
  liftNode(t) {
    for (; t != null && t.parent !== this; )
      t = t.parent;
    return t;
  }
  /** return the number of all edges in the graph, including the subgraphs */
  get deepEdgesCount() {
    let t = 0;
    for (const e of this.nodesBreadthFirst)
      t += e.outDegree + e.selfDegree;
    return t;
  }
  eachNodeIdIsUnique() {
    const t = /* @__PURE__ */ new Set();
    for (const e of this.nodesBreadthFirst) {
      if (t.has(e.id))
        return !1;
      t.add(e.id);
    }
    return !0;
  }
  /** returns all the nodes under graph and the edges with at least one end adjacent to the graph */
  *allElements() {
    for (const t of this.allSuccessorsWidthFirst()) {
      yield t;
      for (const e of t.selfEdges)
        yield e;
      for (const e of t.outEdges)
        yield e;
      for (const e of t.inEdges)
        this.isAncestor(e.source) || (yield e);
    }
    yield* this.edges;
  }
  *allSuccessorsWidthFirst() {
    for (const t of this.shallowNodes)
      yield t;
    for (const t of this.shallowNodes)
      t instanceof yi && (yield* t.allSuccessorsWidthFirst());
  }
  *allSuccessorsDepthFirst() {
    for (const t of this.shallowNodes)
      t instanceof yi && (yield* t.allSuccessorsDepthFirst()), yield t;
  }
};
function* xd(a) {
  const t = /* @__PURE__ */ new Set(), e = new We.Queue();
  for (const n of a.shallowNodes) {
    if (t.has(n))
      continue;
    const r = new Array();
    for (s(n, e, t); e.length > 0; ) {
      const o = e.dequeue();
      r.push(o);
      for (const l of i(o))
        s(l, e, t);
    }
    yield r;
  }
  function* i(n) {
    for (const r of n.outEdges)
      yield r.target;
    for (const r of n.inEdges)
      yield r.source;
  }
  function s(n, r, o) {
    o.has(n) || (r.enqueue(n), o.add(n));
  }
}
function Ld(a, t) {
  let e = /* @__PURE__ */ new Map();
  const i = a.nodeCountDeep;
  let s = 1 / i;
  for (const n of a.nodesBreadthFirst)
    e.set(n, s);
  for (let n = 0; n < 50; n++) {
    s = (1 - t) / i;
    const r = /* @__PURE__ */ new Map();
    for (const o of a.nodesBreadthFirst)
      r.set(o, s);
    for (const o of a.nodesBreadthFirst) {
      let l = r.get(o);
      for (const h of o.inEdges) {
        const c = h.source;
        l += t * (e.get(c) / c.outDegree);
      }
      r.set(o, l);
    }
    e = r;
  }
  return e;
}
function hr(a, t) {
  return t.has(a.source) && t.has(a.target);
}
class Yt extends $ {
  /** clones but does not bind to the entity */
  clone() {
    const t = new Yt(null);
    return this.boundaryCurve && (t.boundaryCurve = this.boundaryCurve.clone()), t;
  }
  translate(t) {
    t.x === 0 && t.y === 0 || this.boundaryCurve.translate(t);
  }
  toJSON() {
    return { boundaryCurve: this.boundaryCurve };
  }
  get node() {
    return this.entity;
  }
  get boundaryCurve() {
    return this._boundaryCurve;
  }
  set boundaryCurve(t) {
    t != null && t.boundingBox && (t.boundingBox.height < Yt.minHeight || t.boundingBox.width < Yt.minWidth) && (t = pt.mkCircle(Yt.minWidth, t.boundingBox.center)), this._boundaryCurve = t;
  }
  get id() {
    return this.node.id;
  }
  toString() {
    return this.id;
  }
  // Creates a Node instance
  static mkNode(t, e) {
    const i = new Yt(e);
    return i.boundaryCurve = t, i;
  }
  // Fields which are set by Msagl
  // return the center of the curve bounding box
  get center() {
    return this.boundaryCurve.boundingBox.center;
  }
  set center(t) {
    const e = t.sub(this.center);
    this.boundaryCurve.translate(e);
  }
  // sets the bounding curve scaled to fit the targetBounds
  fitBoundaryCurveToTarget(t) {
    if (this.boundaryCurve != null) {
      const e = pt.isRoundedRect(this.boundaryCurve);
      if (e == null) {
        const i = t.width / this.boundaryCurve.boundingBox.width, s = t.height / this.boundaryCurve.boundingBox.height;
        this.boundaryCurve = this.boundaryCurve.scaleFromOrigin(i, s), this.boundaryCurve.translate(t.center.sub(this.boundaryCurve.boundingBox.center));
      } else
        this.boundaryCurve = pt.mkRectangleWithRoundedCorners(t.width, t.height, e.radX, e.radY, t.center);
    }
  }
  static getGeom(t) {
    return t.getAttr(_e.GeomObjectIndex);
  }
  *inEdges() {
    for (const t of this.node.inEdges)
      yield $.getGeom(t);
  }
  *outEdges() {
    for (const t of this.node.outEdges)
      yield $.getGeom(t);
  }
  *selfEdges() {
    for (const t of this.node.selfEdges)
      yield $.getGeom(t);
  }
  // the bounding box of the node
  get boundingBox() {
    return this.boundaryCurve ? this.boundaryCurve.boundingBox : null;
  }
  set boundingBox(t) {
    this.boundaryCurve && (Math.abs(t.width - this.width) < 1e-4 && Math.abs(t.height - this.height) < 1e-4 ? this.center = t.center : this.fitBoundaryCurveToTarget(t));
  }
  // width of the node does not include the padding
  get width() {
    return this.boundaryCurve.boundingBox.width;
  }
  // height of the node does not including the padding
  get height() {
    return this.boundaryCurve.boundingBox.height;
  }
  transform(t) {
    this.boundaryCurve != null && (this.boundaryCurve = this.boundaryCurve.transform(t));
  }
  underCollapsedGraph() {
    const t = this.node.parent;
    if (t == null)
      return !1;
    const e = $.getGeom(t);
    return e == null ? !1 : e.isCollapsed ? !0 : e.underCollapsedGraph();
  }
  *getAncestors() {
    for (const t of this.node.getAncestors())
      yield $.getGeom(t);
  }
}
Yt.minHeight = 2;
Yt.minWidth = 3;
class ht {
  ProgressStep() {
  }
  constructor(t) {
    this.cancelToken = t;
  }
}
class xn {
}
xn.GoldenRatio = (1 + Math.sqrt(5)) / 2;
xn.GoldenRatioRemainder = 2 - xn.GoldenRatio;
class Ii extends ht {
  constructor(t, e) {
    super(null), this.desiredAspectRatio = 1.2, this.bestPacking = null, this.cachedCosts = /* @__PURE__ */ new Map(), this.rectangles = t, this.desiredAspectRatio = e;
  }
  // The width of the widest row in the packed solution
  get PackedWidth() {
    return this.bestPacking != null ? this.bestPacking.PackedWidth : 0;
  }
  // The height of the bounding box of the packed solution
  get PackedHeight() {
    return this.bestPacking != null ? this.bestPacking.PackedHeight : 0;
  }
  Pack(t, e, i) {
    const s = Ii.GetGoldenSectionStep(t, e), n = Math.max(i / 10, (e - t) / Ii.MaxSteps);
    e += n, this.bestPackingCost = Number.MAX_VALUE, this.rectangles.length === 1 ? this.PackLimit(t) : this.rectangles.length === 2 ? (this.PackLimit(t), this.PackLimit(e)) : this.rectangles.length > 2 && Ii.GoldenSectionSearch((o) => this.PackLimit(o), t, s, e, n);
    const r = this.bestPacking.getRects();
    for (let o = 0; o < this.rectangles.length; o++)
      this.rectangles[o] = r[o];
  }
  PackLimit(t) {
    let e = this.cachedCosts.get(t);
    if (e == null) {
      const i = this.createPacking(this.rectangles, t);
      i.run(), this.cachedCosts.set(t, e = Math.abs(i.PackedAspectRatio - this.desiredAspectRatio)), e < this.bestPackingCost && (this.bestPackingCost = e, this.bestPacking = i);
    }
    return e;
  }
  // recursively searches a weakly unimodal function f(x) between x1 and x3 for the minimum.  It is assumed x2 \le x1 and x2 \le x3
  // and x2-x1=a \lt b=x3-x2.  The recursion generates a fourth point x4-x1=b \gt a=x3-x4 where x4-x2=c and b=a+c and:
  // if f(x4) \lt f(x2) we search in the range [x2, x3]
  // else if f(x2) \lt f(x4) we search in the range [x1, x4]
  // else
  // f(x2)==f(x4) and we know that f is only weakly unimodal (not strongly unimodal) and we must search both branches.
  static GoldenSectionSearch(t, e, i, s, n) {
    if (Math.abs(e - s) < n)
      return t(e) < t(s) ? e : s;
    const r = Ii.GetGoldenSectionStep(i, s), o = t(i), l = t(r), h = () => Ii.GoldenSectionSearch(t, r, i, e, n), c = () => Ii.GoldenSectionSearch(t, i, r, s, n);
    if (l < o)
      return c();
    if (l > o)
      return h();
    const d = c(), f = h();
    return t(f) < t(d) ? f : d;
  }
  static GetGoldenSectionStep(t, e) {
    return t < e ? t + xn.GoldenRatioRemainder * (e - t) : t - xn.GoldenRatioRemainder * (t - e);
  }
}
Ii.MaxSteps = 1e3;
class Rd extends ht {
  get PackedWidth() {
    return this.packedWidth;
  }
  set PackedWidth(t) {
    this.packedWidth = t;
  }
  get PackedHeight() {
    return this.packedHeight;
  }
  set PackedHeight(t) {
    this.packedHeight = t;
  }
  // Aspect ratio of the bounding box of the packed solution
  get PackedAspectRatio() {
    return this.PackedWidth / this.PackedHeight;
  }
  getRects() {
    const t = [];
    for (const [e, i] of this.rectsToCenters)
      e.center = i, t.push(e);
    return t;
  }
}
class xr extends Rd {
  // Constructor for packing, call Run to do the actual pack.
  // Each RectangleToPack.Rectangle is updated in place.
  // Pack rectangles tallest to shortest, left to right until wrapWidth is reached,
  // then wrap to right-most rectangle still with vertical space to fit the next rectangle
  constructor(t, e, i = !1) {
    super(null), this.rectsToCenters = /* @__PURE__ */ new Map(), this.rectanglesByDescendingHeight = i ? t : xr.SortRectangles(t), this.wrapWidth = e;
  }
  // Sort rectangles by height
  static SortRectangles(t) {
    return t.sort((e, i) => i.height - e.height), t;
  }
  // Pack rectangles tallest to shortest, left to right until wrapWidth is reached,
  // then wrap to right-most rectangle still with vertical space to fit the next rectangle
  run() {
    this.Pack();
  }
  // Traverses the rectangleEnumerator and places rectangles at the next available slot beneath the current parent,
  // until the parent is filled or until maxRowWidth is reached.  Each successfully placed rectangle is pushed onto
  // a stack, when there is no room for the rectangle we pop the stack for a new parent and try again.
  Pack() {
    this.PackedWidth = 0, this.PackedHeight = 0;
    const t = new mt.Stack();
    let e = !1, i = 0, s = 0, n = 0;
    const r = this.rectanglesByDescendingHeight;
    for (let o = 0; e || o < r.length; ) {
      const l = r[o], h = t.length > 0 ? t.top : null;
      if (h == null || h.right + l.width <= this.wrapWidth && i + l.height <= h.top) {
        const d = new u(h ? h.right : 0, i).add(new u(l.width / 2, l.height / 2));
        l.center = d, this.rectsToCenters.set(l, d), s = Math.max(s, l.right), n = Math.max(n, l.top), t.push(l), e = !1;
      } else
        i = h.top, t.pop(), e = !0;
      e || o++;
    }
    this.PackedWidth = s, this.PackedHeight = n;
  }
}
class Fh extends Ii {
  // Constructor for packing, call Run to do the actual pack.
  // Each RectangleToPack.Rectangle is updated in place.
  // Performs a Golden Section Search on packing width for the
  // closest aspect ratio to the specified desired aspect ratio
  constructor(t, e) {
    super(xr.SortRectangles(t), e), this.createPacking = (i, s) => new xr(i, s, !0);
  }
  // Performs a Golden Section Search on packing width for the
  // closest aspect ratio to the specified desired aspect ratio
  run() {
    let t = Number.MAX_VALUE, e = 0, i = 0;
    for (const s of this.rectangles) {
      const n = s.width;
      i += n, t = Math.min(t, n), e = Math.max(e, n);
    }
    this.Pack(e, i, t);
  }
}
function mn(a) {
  return new Lr(Et(a.map(([t, e]) => Bt(e, t))));
}
function Nd(a, t) {
  a.UserData = t.UserData, a.Left = t.Left, a.Right = t.Right, a.Count--, a.irect = t.irect;
}
function Ya(a) {
  for (let t = a.Parent; t != null; t = t.Parent)
    t.Count--, t.irect = t.Left.irect.add_rect(t.Right.irect);
}
function Bd(a, t) {
  const e = new Array();
  for (const s of a.GetAllLeafNodes())
    s !== t && e.push(s);
  const i = Et(e);
  a.Count = i.Count, a.Left = i.Left, a.Right = i.Right, a.irect = i.Left.irect.add_rect(i.Right.irect);
}
function Gd(a) {
  for (let t = a.Parent; t != null; t = t.Parent)
    if (!Vh(t))
      return t;
  return null;
}
function Vh(a) {
  return 2 * a.Left.Count >= a.Right.Count && 2 * a.Right.Count >= a.Left.Count;
}
function Vo(a, t, e, i) {
  return a.irect.intersects_rect(t) ? a.IsLeaf ? i(a.UserData) ? --e.bound !== 0 : !0 : Vo(a.Left, t, e, i) && Vo(a.Right, t, e, i) : !0;
}
class Lr {
  // Removes everything from the tree
  // <
  clear() {
    this.RootNode = null;
  }
  NumberOfIntersectedIsLessThanBound(t, e, i) {
    return Vo(this._rootNode, t, { bound: e }, i);
  }
  get RootNode() {
    return this._rootNode;
  }
  set RootNode(t) {
    this._rootNode = t;
  }
  // Create a query tree for a given root node
  constructor(t) {
    this._rootNode = t;
  }
  *GetAllLeaves() {
    if (this._rootNode != null && this.Count > 0)
      for (const t of this._rootNode.GetAllLeaves())
        yield t;
  }
  // The number of data elements of the tree (number of leaf nodes)
  get Count() {
    return this._rootNode == null ? 0 : this._rootNode.Count;
  }
  Add(t, e) {
    this.AddNode(Bt(e, t));
  }
  AddNode(t) {
    this._rootNode == null ? this._rootNode = t : this.Count <= 2 ? this._rootNode = Et(Array.from(this._rootNode.GetAllLeafNodes()).concat([t])) : this.AddNodeToTreeRecursive(t, this._rootNode);
  }
  Rebuild() {
    this._rootNode = Et(Array.from(this._rootNode.GetAllLeafNodes()));
  }
  AddNodeToTreeRecursive(t, e) {
    if (e.IsLeaf)
      e.Left = Bt(e.UserData, e.irect), e.Right = t, e.Count = 2;
    else {
      e.Count++;
      let i, s;
      if (2 * e.Left.Count < e.Right.Count)
        this.AddNodeToTreeRecursive(t, e.Left), e.Left.irect = e.Left.irect.add_rect(t.irect);
      else if (2 * e.Right.Count < e.Left.Count)
        this.AddNodeToTreeRecursive(t, e.Right), e.Right.irect = e.Right.irect.add_rect(t.irect);
      else {
        i = e.Left.irect.add_rect(t.irect);
        const n = i.area - e.Left.irect.area;
        s = e.Right.irect.add_rect(t.irect);
        const r = s.area - e.Right.irect.area;
        n < r ? (this.AddNodeToTreeRecursive(t, e.Left), e.Left.irect = i) : n > r ? (this.AddNodeToTreeRecursive(t, e.Right), e.Right.irect = s) : i.area < s.area ? (this.AddNodeToTreeRecursive(t, e.Left), e.Left.irect = i) : (this.AddNodeToTreeRecursive(t, e.Right), e.Right.irect = s);
      }
    }
    e.irect = e.Left.irect.add_rect(e.Right.irect);
  }
  GetAllIntersecting(t) {
    return this._rootNode == null || this.Count === 0 ? [] : Array.from(this._rootNode.GetNodeItemsIntersectingRectangle(t));
  }
  OneIntersecting(t) {
    if (this._rootNode == null || this.Count === 0)
      return;
    const e = this._rootNode.FirstIntersectedNode(t);
    if (e != null)
      return { intersectedLeaf: e.UserData };
  }
  // Get all leaf nodes with rectangles intersecting the specified rectangular region
  GetAllLeavesIntersectingRectangle(t) {
    return this._rootNode == null || this.Count === 0 ? [] : this._rootNode.GetLeafRectangleNodesIntersectingRectangle(t);
  }
  // Does minimal work to determine if any objects of the tree intersect with the query region
  IsIntersecting(t) {
    if (this._rootNode == null || this.Count === 0)
      return !1;
    for (const e of this._rootNode.GetNodeItemsIntersectingRectangle(t))
      return !0;
    return !1;
  }
  // return true iff there is a node with the rectangle and UserData that equals to the parameter "userData"
  Contains(t, e) {
    if (this._rootNode == null)
      return !1;
    for (const i of this._rootNode.GetLeafRectangleNodesIntersectingRectangle(t))
      if (i.UserData === e)
        return !0;
    return !1;
  }
  Remove(t, e) {
    if (this._rootNode == null)
      return;
    let i;
    for (const s of this._rootNode.GetLeafRectangleNodesIntersectingRectangle(t))
      s.UserData === e && (i = s);
    if (i != null)
      return this.RootNode.Count === 1 ? this.RootNode = null : this.RemoveLeaf(i), i.UserData;
  }
  RemoveLeaf(t) {
    const e = Gd(t);
    if (e != null)
      Bd(e, t), Ya(e);
    else {
      const i = t.Parent;
      i == null ? this._rootNode = new na() : (Nd(i, t.IsLeftChild ? i.Right : i.Left), Ya(i));
    }
  }
  UnbalancedNode(t) {
    for (let e = t.Parent; e != null; e = e.Parent)
      if (!Vh(e))
        return e;
    return null;
  }
}
class Md extends T {
  constructor(t) {
    super(t), this.radX = t.radX, this.radY = t.radY, this.roundedRect_ = pt.mkRectangleWithRoundedCorners(this.width, this.height, t.radX, t.radY, this.center);
  }
  onUpdated() {
    this.isEmpty || (this.roundedRect_ = pt.mkRectangleWithRoundedCorners(this.width, this.height, this.radX, this.radY, this.center));
  }
  isOk() {
    return this.isEmpty() ? !0 : this.roundedRect_.boundingBox.equalEps(this);
  }
  setRect(t) {
    this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.isEmpty() || (this.roundedRect_ = pt.mkRectangleWithRoundedCorners(t.width, t.height, this.radX, this.radY, this.center));
  }
}
function Fd(a, t) {
  const e = t.map((n) => [n, n.boundingBox]), i = e.map((n) => n[1]), s = new Fh(i, 1.5);
  s.run();
  for (const [n, r] of e) {
    const o = r.leftBottom.sub(n.boundingBox.leftBottom);
    n.translate(o);
  }
  a.boundingBox = new T({
    left: 0,
    bottom: 0,
    right: s.PackedWidth,
    top: s.PackedHeight
  });
}
class Nt extends Yt {
  isAncestor(t) {
    return this.graph.isAncestor(t.node);
  }
  deepTranslate(t) {
    for (const e of this.nodesBreadthFirst) {
      e instanceof Nt ? e.boundingBox = e.boundingBox.translate(t) : e.translate(t);
      for (const i of e.selfEdges())
        i.translate(t);
      for (const i of e.outEdges())
        this.graph.isAncestor(i.target.node) && i.translate(t);
    }
    this.boundingBox = this.boundingBox.translate(t);
  }
  /** it is a rather shallow clone */
  clone() {
    const t = new Nt(null);
    return t.boundingBox = this.boundingBox.clone(), t.layoutSettings = this.layoutSettings, t.margins = this.margins, t.radX = this.radX, t.radY = this.radY, t;
  }
  /** Calculate bounding box from children, not updating the bounding boxes recursively. */
  calculateBoundsFromChildren() {
    const t = T.mkEmpty();
    for (const e of this.shallowNodes)
      t.addRecSelf(e.boundingBox);
    return t.padEverywhere(this.margins), t;
  }
  *allSuccessorsWidthFirst() {
    for (const t of this.graph.allSuccessorsWidthFirst())
      yield Yt.getGeom(t);
  }
  static getGeom(t) {
    return $.getGeom(t);
  }
  edgeCurveOrArrowheadsIntersectRect(t, e) {
    for (const n of t.sourceArrowheadPoints(25))
      if (e.contains(n))
        return !0;
    for (const n of t.targetArrowheadPoints(25))
      if (e.contains(n))
        return !0;
    const i = t.curve, s = e.perimeter();
    return g.intersectionOne(i, s, !1) != null || g.PointRelativeToCurveLocation(i.start, s) === F.Inside;
  }
  isEmpty() {
    return this.graph.isEmpty();
  }
  setSettingsRecursively(t) {
    this.layoutSettings = t;
    for (const e of this.nodesBreadthFirst) {
      const i = e;
      i.layoutSettings = t;
    }
  }
  get layoutSettings() {
    return this._layoutSettings;
  }
  // recursively sets the same settings for subgraphs
  set layoutSettings(t) {
    this._layoutSettings = t;
  }
  get labelSize() {
    return this._labelSize;
  }
  set labelSize(t) {
    this._labelSize = t;
  }
  get boundingBox() {
    return this.rrect ? this.rrect.clone() : null;
  }
  set boundingBox(t) {
    t ? this.rrect.setRect(t) : this.rrect.roundedRect_ = null;
  }
  transform(t) {
    if (!t.isIdentity()) {
      for (const e of this.shallowNodes)
        e.transform(t);
      for (const e of this.shallowEdges)
        e.transform(t), e.label && e.label.transform(t);
      this.boundingBox = this.rrect == null || this.rrect.isEmpty() ? this.pumpTheBoxToTheGraphWithMargins() : this.boundingBox.transform(t);
    }
  }
  /** Contrary to the deepTranslate() it also translates edges leading out of the graph */
  translate(t) {
    t.x === 0 && t.y === 0 || this.deepTranslate(t);
  }
  get nodesBreadthFirst() {
    return this.nodesBreadthFirstIter();
  }
  *nodesBreadthFirstIter() {
    for (const t of this.graph.nodesBreadthFirst)
      yield $.getGeom(t);
  }
  setEdge(t, e) {
    const i = this.graph.setEdge(t, e);
    return new Kt(i);
  }
  /** this does not change the graph bounding box */
  getPumpedGraphWithMarginsBox() {
    const t = { b: T.mkEmpty() };
    return ra(this, t), t.b.padEverywhere(this.margins), t.b;
  }
  /** sets the bounding box and the boundary curve as well */
  pumpTheBoxToTheGraphWithMargins() {
    return this.boundingBox = this.getPumpedGraphWithMarginsBox();
  }
  // Fields which are set by Msagl
  // return the center of the curve bounding box
  get center() {
    return this.boundingBox || this.boundingBox.isEmpty ? this.boundingBox.center : new u(0, 0);
  }
  set center(t) {
    const e = t.sub(this.center), i = new _t(1, 0, e.x, 0, 1, e.y);
    this.transform(i);
  }
  get left() {
    return this.boundingBox.left;
  }
  get right() {
    return this.boundingBox.right;
  }
  get top() {
    return this.boundingBox.top;
  }
  get bottom() {
    return this.boundingBox.bottom;
  }
  CheckClusterConsistency() {
    throw new Error("Method not implemented.");
  }
  get edgeCount() {
    return this.graph.edgeCount;
  }
  get boundaryCurve() {
    return this.rrect.roundedRect_;
  }
  set boundaryCurve(t) {
    throw new Error();
  }
  get shallowNodes() {
    return this.shallowNodes_();
  }
  *shallowNodes_() {
    for (const t of this.graph.shallowNodes)
      yield $.getGeom(t);
  }
  /** iterates over the edges of the graph which adjacent to the nodes of the graph:
   * not iterating over the subgraphs
   */
  /** iterates over the edges of the graph including subgraphs */
  get deepEdges() {
    return this.deepEdgesIt();
  }
  *deepEdgesIt() {
    for (const t of this.graph.deepEdges)
      yield $.getGeom(t);
  }
  get shallowEdges() {
    return this.shallowEdgesIt();
  }
  *shallowEdgesIt() {
    for (const t of this.graph.shallowEdges)
      yield $.getGeom(t);
  }
  static mk(t, e = new Ti(0, 0)) {
    const i = new Nt(new di(t));
    return i.labelSize = e, i;
  }
  get Clusters() {
    return this.subgraphs();
  }
  /** iterates over all subgraphs  */
  *subgraphs() {
    for (const t of this.graph.subgraphsBreadthFirst())
      yield $.getGeom(t);
  }
  static mkWithGraphAndLabel(t, e) {
    const i = new Nt(t);
    return i.labelSize = e, i;
  }
  constructor(t) {
    super(t), this.margins = { left: 10, top: 10, bottom: 10, right: 10 }, this.radX = 10, this.radY = 10, this.rrect = new Md({ left: 0, right: -1, top: 20, bottom: 0, radX: this.radX, radY: this.radY });
  }
  get deepNodeCount() {
    let t = 0;
    for (const e of this.graph.nodesBreadthFirst)
      t++;
    return t;
  }
  get subgraphsDepthFirst() {
    return this.getSubgraphsDepthFirst();
  }
  *getSubgraphsDepthFirst() {
    for (const t of this.graph.allSuccessorsDepthFirst())
      t instanceof di && (yield Nt.getGeom(t));
  }
  get uniformMargins() {
    return Math.max(this.margins.left, this.margins.right, this.margins.right, this.margins.bottom);
  }
  set uniformMargins(t) {
    this.margins.left = this.margins.right = this.margins.right = this.margins.bottom = t;
  }
  get height() {
    return this.boundingBox.height;
  }
  get width() {
    return this.boundingBox.width;
  }
  get shallowNodeCount() {
    return this.graph.shallowNodeCount;
  }
  get graph() {
    return this.entity;
  }
  liftNode(t) {
    const e = this.graph.liftNode(t.node);
    return e ? $.getGeom(e) : null;
  }
  findNode(t) {
    const e = this.graph.findNode(t);
    return e ? $.getGeom(e) : null;
  }
  addNode(t) {
    return this.graph.addNode(t.node), t;
  }
  addLabelToGraphBB(t) {
    this.labelSize && (t.top += this.labelSize.height + 2, t.width < this.labelSize.width && (t.width = this.labelSize.width));
  }
}
function ra(a, t) {
  for (const i of a.shallowEdges) {
    if (!e(i))
      continue;
    const s = i.curve.boundingBox;
    if (t.b.addRecSelf(s), i.edge.label != null) {
      const n = $.getGeom(i.edge.label);
      n && t.b.addRecSelf(n.boundingBox);
    }
  }
  for (const i of a.shallowNodes)
    "shallowEdges" in i && ra(i, t), !(i.underCollapsedGraph() || !i.boundingBox) && t.b.addRecSelf(i.boundingBox);
  a instanceof Nt && a.addLabelToGraphBB(t.b);
  function e(i) {
    if (i == null || i.curve == null || i.underCollapsedGraph())
      return !1;
    if (a instanceof Nt) {
      const s = a.entity;
      return s.isAncestor(i.source.entity) && s.isAncestor(i.target.entity);
    } else
      return !0;
  }
}
class U {
  constructor(t, e) {
    this.x = t, this.y = e;
  }
  get source() {
    return this.x;
  }
  get target() {
    return this.y;
  }
  isDiagonal() {
    return this.x === this.y;
  }
}
class Ki {
  isEmpty() {
    if (this.arrayOfMaps.length === 0)
      return !0;
    for (const t of this.arrayOfMaps)
      if (t.size > 0)
        return !1;
    return !0;
  }
  set(t, e, i) {
    let s = this.arrayOfMaps[t];
    s === void 0 && (this.arrayOfMaps[t] = s = /* @__PURE__ */ new Map()), s.set(e, i);
  }
  setPair(t, e) {
    this.set(t.x, t.y, e);
  }
  delete(t, e) {
    if (t < 0 || t >= this.arrayOfMaps.length)
      return;
    const i = this.arrayOfMaps[t];
    i !== void 0 && (i.delete(e), i.size === 0 && (this.arrayOfMaps[t] = void 0));
  }
  has(t, e) {
    if (t < 0 || t >= this.arrayOfMaps.length)
      return !1;
    const i = this.arrayOfMaps[t];
    return i === void 0 ? !1 : i.has(e);
  }
  get(t, e) {
    if (t < 0 || t >= this.arrayOfMaps.length)
      return null;
    const i = this.arrayOfMaps[t];
    return i === void 0 ? null : i.get(e);
  }
  getI(t) {
    return this.get(t.x, t.y);
  }
  /** n is the maximum of (x + 1) where (x, *) runs over the keys  */
  constructor() {
    this.arrayOfMaps = new Array();
  }
  *keys() {
    for (let t = 0; t < this.arrayOfMaps.length; t++) {
      const e = this.arrayOfMaps[t];
      if (e !== void 0)
        for (const i of e)
          yield new U(t, i[0]);
    }
  }
  *keyValues() {
    for (let t = 0; t < this.arrayOfMaps.length; t++) {
      const e = this.arrayOfMaps[t];
      if (e !== void 0)
        for (const i of e)
          yield [new U(t, i[0]), i[1]];
    }
  }
  *values() {
    for (let t = 0; t < this.arrayOfMaps.length; t++) {
      const e = this.arrayOfMaps[t];
      if (e !== void 0)
        for (const i of e)
          yield i[1];
    }
  }
  get size() {
    let t = 0;
    for (let e = 0; e < this.arrayOfMaps.length; e++) {
      const i = this.arrayOfMaps[e];
      i !== void 0 && (t += i.size);
    }
    return t;
  }
}
class tr {
  get curveClips() {
    return this._curveClips;
  }
  set curveClips(t) {
    this._curveClips = t;
  }
  constructor(t) {
    this._curveClips = [], this.arrowheads = [], this.nodes = [], this.labels = [], this.rect = t, this._curveClips = [];
  }
  addCurveClip(t) {
    lt.assert(!(t.curve instanceof g), "CurveClip.curve should not be a Curve!"), this._curveClips.push(t);
  }
  isEmpty() {
    return this._curveClips.length == 0 && this.arrowheads.length == 0 && this.nodes.length == 0 && this.labels.length == 0;
  }
  initCurveClips() {
    this._curveClips = [];
  }
  /** clears all arrays but does not touch this.rect */
  clear() {
    this.arrowheads = [], this.nodes = [], this.labels = [], this._curveClips = [];
  }
  /** returns the number of entities that will be rendered for a tile: each bundle is counted as one entity */
  get entityCount() {
    return this._curveClips.length + this.arrowheads.length + this.labels.length + this.nodes.length;
  }
  addElement(t) {
    if (t instanceof Yt)
      this.nodes.push(t);
    else if (t instanceof Zr)
      this.labels.push(t);
    else if ("curve" in t)
      if (t.curve instanceof g)
        for (const e of t.curve.segs)
          this.addCurveClip({ edge: t.edge, curve: e, startPar: e.parStart, endPar: e.parEnd });
      else
        this.addCurveClip(t);
    else
      this.arrowheads.push(t);
  }
}
class qs {
  get Parents() {
    return Array.from(this.parents.values());
  }
  get Children() {
    return Array.from(this.children.values());
  }
  get BoundaryCurve() {
    return this.boundaryCurve;
  }
  set BoundaryCurve(t) {
    this.boundaryCurve = t;
  }
  // The bounding box of the shape.
  get BoundingBox() {
    return this.BoundaryCurve.boundingBox;
  }
  // The set of Ports for this obstacle, usually RelativePorts.  In the event of overlapping
  // obstacles, this identifies the obstacle to which the port applies.
  get Ports() {
    return this.ports;
  }
  // Default constructor.
  static mkShape() {
    return new qs(null);
  }
  /**  Constructor taking the curve of the shape.*/
  constructor(t = null) {
    this.parents = /* @__PURE__ */ new Set(), this.children = /* @__PURE__ */ new Set(), this.ports = /* @__PURE__ */ new Set(), this.BoundaryCurve = t;
  }
  /**  A group is a shape that has children.*/
  get IsGroup() {
    return this.children.size > 0;
  }
  *Descendants() {
    const t = new We.Queue();
    for (const e of this.Children)
      t.enqueue(e);
    for (; t.length > 0; ) {
      const e = t.dequeue();
      yield e;
      for (const i of e.Children)
        t.enqueue(i);
    }
  }
  *Ancestors() {
    const t = new We.Queue();
    for (const e of this.Parents)
      t.enqueue(e);
    for (; t.length > 0; ) {
      const e = t.dequeue();
      yield e;
      for (const i of e.Parents)
        t.enqueue(i);
    }
  }
  // Adds a parent. A shape can have several parents
  AddParent(t) {
    this.parents.add(t), t.children.add(this);
  }
  AddChild(t) {
    t.parents.add(this), this.children.add(t);
  }
  //
  RemoveChild(t) {
    this.children.delete(t), t.parents.delete(this);
  }
  //
  RemoveParent(t) {
    this.parents.delete(t), t.children.delete(this);
  }
  ToString() {
    return this.UserData ? this.UserData.toString() : "null";
  }
}
class oa {
}
class Te extends oa {
  // a curve associated with the port
  // constructor
  constructor(t, e) {
    super(), this.curve = this.curve, this.location = e.clone();
  }
  // the location of the port
  get Location() {
    return this.location;
  }
  set Location(t) {
    this.location = t;
  }
  // translate the port location by delta
  Translate(t) {
    this.location = this.location.add(t);
  }
  // the port's curve
  get Curve() {
    return this.curve;
  }
  set Curve(t) {
    this.curve = t;
  }
}
class Zi extends Te {
  static mk(t, e) {
    return new Zi(t, e, new u(0, 0));
  }
  // the delegate returning center
  get CenterDelegate() {
    return this.centerDelegate;
  }
  set CenterDelegate(t) {
    this.centerDelegate = t;
  }
  // the delegate returning center
  get CurveDelegate() {
    return this.curveDelegate;
  }
  set CurveDelegate(t) {
    this.curveDelegate = t;
  }
  //
  //        // The node where we calculate our location and Curve from
  //
  //        public Node RelativeTo { get; private set; }
  // An offset relative to the Center of the Node that we use to calculate Location
  get LocationOffset() {
    return this.locationOffset;
  }
  set LocationOffset(t) {
    this.locationOffset = t;
  }
  // Create a port relative to a specific node with an offset for the port Location from the nodes center
  constructor(t, e, i) {
    super(null, e().add(i)), this.LocationOffset = i, this.CurveDelegate = t, this.CenterDelegate = e;
  }
  //
  // // Create a port relative to the center of a specific node
  //
  // public constructor (curveDelegate: Func<ICurve>, centerDelegate: Func<Point>) :
  //        this(curveDelegate, centerDelegate, new Point()) {
  // }
  // Get the location = CenterDelegate() + LocationOffset
  get Location() {
    return this.CenterDelegate().add(this.LocationOffset);
  }
  // Get the curve from the node's BoundaryCurve
  get Curve() {
    return this.CurveDelegate();
  }
}
class fo {
  constructor(t, e, i, s, n) {
    this.color = t, e !== void 0 && (this.item = e), i !== void 0 && (this.parent = i), s !== void 0 && (this.left = s), n !== void 0 && (this.right = n);
  }
  toString() {
    return this.item.toString();
  }
}
var _;
(function(a) {
  a[a.Red = 0] = "Red", a[a.Black = 1] = "Black";
})(_ || (_ = {}));
class we {
  [Symbol.iterator]() {
    return this.allNodes();
  }
  constructor(t) {
    this.comparer = t, this.count = 0, this.root = this.nil = new fo(_.Black);
  }
  clear() {
    this.root = this.nil = new fo(_.Black);
  }
  toNull(t) {
    return t !== this.nil ? t : null;
  }
  isEmpty() {
    return this.root === this.nil;
  }
  getComparer() {
    return this.comparer;
  }
  getRoot() {
    return this.root;
  }
  find(t, e = this.root) {
    let i;
    for (; e !== this.nil && (i = this.comparer(t, e.item)) !== 0; )
      e = i < 0 ? e.left : e.right;
    return this.toNull(e);
  }
  findFirst(t, e = this.root) {
    if (e === this.nil)
      return null;
    let i = null;
    for (; e !== this.nil; )
      e = t(e.item) ? (i = e).left : e.right;
    return i;
  }
  findLast(t, e = this.root) {
    if (e === this.nil)
      return null;
    let i = null;
    for (; e !== this.nil; )
      e = t(e.item) ? (i = e).right : e.left;
    return i;
  }
  treeMinimum(t = this.root) {
    for (; t.left !== this.nil; )
      t = t.left;
    return this.toNull(t);
  }
  treeMaximum(t = this.root) {
    for (; t.right !== this.nil; )
      t = t.right;
    return this.toNull(t);
  }
  next(t) {
    if (t.right !== this.nil)
      return this.treeMinimum(t.right);
    let e = t.parent;
    for (; e !== this.nil && t === e.right; )
      t = e, e = e.parent;
    return this.toNull(e);
  }
  previous(t) {
    if (t.left !== this.nil)
      return this.treeMaximum(t.left);
    let e = t.parent;
    for (; e !== this.nil && t === e.left; )
      t = e, e = e.parent;
    return this.toNull(e);
  }
  leftRotate(t) {
    const e = t.right;
    t.right = e.left, e.left !== this.nil && (e.left.parent = t), e.parent = t.parent, t.parent === this.nil ? this.root = e : t === t.parent.left ? t.parent.left = e : t.parent.right = e, e.left = t, t.parent = e;
  }
  rightRotate(t) {
    const e = t.left;
    t.left = e.right, e.right !== this.nil && (e.right.parent = t), e.parent = t.parent, t.parent === this.nil ? this.root = e : t === t.parent.right ? t.parent.right = e : t.parent.left = e, e.right = t, t.parent = e;
  }
  deleteFixup(t) {
    for (; t !== this.root && t.color === _.Black; )
      if (t === t.parent.left) {
        let e = t.parent.right;
        e.color === _.Red && (e.color = _.Black, t.parent.color = _.Red, this.leftRotate(t.parent), e = t.parent.right), e.left.color === _.Black && e.right.color === _.Black ? (e.color = _.Red, t = t.parent) : (e.right.color === _.Black && (e.left.color = _.Black, e.color = _.Red, this.rightRotate(e), e = t.parent.right), e.color = t.parent.color, t.parent.color = _.Black, e.right.color = _.Black, this.leftRotate(t.parent), t = this.root);
      } else {
        let e = t.parent.left;
        e.color === _.Red && (e.color = _.Black, t.parent.color = _.Red, this.rightRotate(t.parent), e = t.parent.left), e.right.color === _.Black && e.left.color === _.Black ? (e.color = _.Red, t = t.parent) : (e.left.color === _.Black && (e.right.color = _.Black, e.color = _.Red, this.leftRotate(e), e = t.parent.left), e.color = t.parent.color, t.parent.color = _.Black, e.left.color = _.Black, this.rightRotate(t.parent), t = this.root);
      }
    t.color = _.Black;
  }
  deleteSubTree(t) {
    let e;
    if (t.left === this.nil || t.right === this.nil)
      e = t;
    else
      for (e = t.right; e.left !== this.nil; )
        e = e.left;
    const i = e.left !== this.nil ? e.left : e.right;
    return i.parent = e.parent, e.parent === this.nil ? this.root = i : e === e.parent.left ? e.parent.left = i : e.parent.right = i, e !== t && (t.item = e.item), e.color === _.Black && this.deleteFixup(i), this.toNull(t);
  }
  deleteNodeInternal(t) {
    this.count--, this.deleteSubTree(t);
  }
  remove(t) {
    const e = this.find(t);
    return e != null ? (this.count--, this.deleteSubTree(e)) : null;
  }
  insert(t) {
    const e = this.treeInsert(t);
    return this.insertPrivate(e), this.toNull(e);
  }
  treeInsert(t) {
    let e = this.nil, i = this.root, s = 0;
    for (; i !== this.nil; )
      e = i, s = this.comparer(t, i.item), i = s < 0 ? i.left : i.right;
    const n = new fo(_.Black, t, e, this.nil, this.nil);
    return e === this.nil ? this.root = n : s < 0 ? e.left = n : e.right = n, this.toNull(n);
  }
  insertPrivate(t) {
    for (this.count++, t.color = _.Red; t !== this.root && t.parent.color === _.Red; )
      if (t.parent === t.parent.parent.left) {
        const e = t.parent.parent.right;
        e.color === _.Red ? (t.parent.color = _.Black, e.color = _.Black, t.parent.parent.color = _.Red, t = t.parent.parent) : (t === t.parent.right && (t = t.parent, this.leftRotate(t)), t.parent.color = _.Black, t.parent.parent.color = _.Red, this.rightRotate(t.parent.parent));
      } else {
        const e = t.parent.parent.left;
        e.color === _.Red ? (t.parent.color = _.Black, e.color = _.Black, t.parent.parent.color = _.Red, t = t.parent.parent) : (t === t.parent.left && (t = t.parent, this.rightRotate(t)), t.parent.color = _.Black, t.parent.parent.color = _.Red, this.leftRotate(t.parent.parent));
      }
    this.root.color = _.Black;
  }
  *allNodes() {
    if (this.isEmpty())
      return;
    let t = this.treeMinimum();
    for (; t != null; )
      yield t.item, t = this.next(t);
  }
  toString() {
    let t = "{", e = 0;
    for (const i of this.allNodes())
      t += i.toString(), e !== this.count - 1 && (t += `
`), e++;
    return t + "}";
  }
}
class aa {
  *[Symbol.iterator]() {
    for (let t = 1; t <= this.heapSize; t++)
      yield this.A[t];
  }
  Enqueue(t) {
    let e = this.heapSize + 1;
    this.A[e] = t, this.heapSize++;
    let i = e >> 1, s, n;
    for (; e > 1 && this.Less(s = this.A[e], n = this.A[i]); )
      this.A[i] = s, this.A[e] = n, e = i, i = e >> 1;
  }
  Dequeue() {
    if (this.heapSize < 1)
      throw new Error();
    const t = this.A[1], e = this.A[this.heapSize];
    return this.heapSize--, this.ChangeMinimum(e), t;
  }
  ChangeMinimum(t) {
    this.A[1] = t;
    let e = 1, i = 2, s = !1;
    for (; i < this.heapSize && !s; ) {
      s = !0;
      const n = this.A[i], r = this.A[i + 1];
      this.compare(n, r) < 0 ? this.compare(n, t) < 0 && (this.A[e] = n, this.A[i] = t, s = !1, e = i, i = e << 1) : this.compare(r, t) < 0 && (this.A[e] = r, this.A[i + 1] = t, s = !1, e = i + 1, i = e << 1);
    }
    if (i === this.heapSize) {
      const n = this.A[i];
      this.compare(n, t) < 0 && (this.A[e] = n, this.A[i] = t);
    }
  }
  get Count() {
    return this.heapSize;
  }
  Less(t, e) {
    return this.compare(t, e) < 0;
  }
  constructor(t) {
    this.heapSize = 0, this.A = [], this.compare = t;
  }
  GetMinimum() {
    return this.A[1];
  }
}
class Gi {
}
class en extends Gi {
  get Site() {
    return this.Vertex.point;
  }
  constructor(t) {
    super(), this.Vertex = t;
  }
  get Polyline() {
    return this.Vertex.polyline;
  }
}
class Vd extends en {
  constructor(t) {
    super(t);
  }
}
class Dd {
  constructor(t) {
    this.lineSweeper = t;
  }
  Compare(t, e) {
    switch (u.getTriangleOrientation(e.Start, e.End, this.x)) {
      case L.Collinear:
        return 0;
      case L.Clockwise:
        return 1;
      default:
        return -1;
    }
  }
  SetOperand(t) {
    this.x = this.IntersectionOfSideAndSweepLine(t);
  }
  IntersectionOfSideAndSweepLine(t) {
    const e = t.Direction.dot(this.lineSweeper.SweepDirection), i = (this.lineSweeper.Z - t.Start.dot(this.lineSweeper.SweepDirection)) / e;
    return t.Start.add(t.Direction.mul(i));
  }
}
class kd extends Gi {
  constructor(t) {
    super(), this.site = t;
  }
  get Site() {
    return this.site;
  }
}
class Dh {
  constructor(t, e) {
    this.PreviousZ = Number.NEGATIVE_INFINITY, this.z = Number.NEGATIVE_INFINITY, this.Obstacles = t ?? [], this.SweepDirection = e, this.DirectionPerp = e.rotate(-Math.PI / 2), this.EventQueue = new aa((i, s) => this.Compare(i, s)), this.ObstacleSideComparer = new Dd(this), this.LeftObstacleSideTree = new we((i, s) => this.ObstacleSideComparer.Compare(i, s)), this.RightObstacleSideTree = new we((i, s) => this.ObstacleSideComparer.Compare(i, s));
  }
  get EventQueue() {
    return this.eventQueue;
  }
  set EventQueue(t) {
    this.eventQueue = t;
  }
  // sweep direction rotated by 90 degrees clockwise
  get DirectionPerp() {
    return this.directionPerp;
  }
  set DirectionPerp(t) {
    this.directionPerp = t;
  }
  get Z() {
    return this.z;
  }
  set Z(t) {
    t > this.z + m.tolerance && (this.PreviousZ = this.z), this.z = t;
  }
  GetZS(t) {
    return this.SweepDirection.dot(t.Site);
  }
  GetZP(t) {
    return this.SweepDirection.dot(t);
  }
  SegmentIsNotHorizontal(t, e) {
    return Math.abs(t.sub(e).dot(this.SweepDirection)) > m.distanceEpsilon;
  }
  RemoveLeftSide(t) {
    this.ObstacleSideComparer.SetOperand(t), this.LeftObstacleSideTree.remove(t);
  }
  RemoveRightSide(t) {
    this.ObstacleSideComparer.SetOperand(t), this.RightObstacleSideTree.remove(t);
  }
  InsertLeftSide(t) {
    this.ObstacleSideComparer.SetOperand(t), this.LeftObstacleSideTree.insert(t);
  }
  InsertRightSide(t) {
    this.ObstacleSideComparer.SetOperand(t), this.RightObstacleSideTree.insert(t);
  }
  FindFirstObstacleSideToTheLeftOfPoint(t) {
    const e = this.RightObstacleSideTree.findLast((i) => u.pointToTheRightOfLineOrOnLine(t, i.Start, i.End));
    return e == null ? null : e.item;
  }
  FindFirstObstacleSideToToTheRightOfPoint(t) {
    const e = this.LeftObstacleSideTree.findFirst((i) => !u.pointToTheRightOfLineOrOnLine(t, i.Start, i.End));
    return e == null ? null : e.item;
  }
  EnqueueEvent(t) {
    this.eventQueue.Enqueue(t);
  }
  InitQueueOfEvents() {
    for (const t of this.Obstacles)
      this.EnqueueLowestPointsOnObstacles(t);
    if (this.Ports != null)
      for (const t of this.Ports.values())
        this.EnqueueEvent(new kd(t));
  }
  EnqueueLowestPointsOnObstacles(t) {
    const e = this.GetLowestPoint(t);
    this.EnqueueEvent(new Vd(e));
  }
  GetLowestPoint(t) {
    let e = t.startPoint, i = t.startPoint.next;
    for (; i != null; i = i.next)
      this.Less(i.point, e.point) && (e = i);
    return e;
  }
  // imagine that direction points up,
  // lower events have higher priorities,
  // for events at the same level events to the left have higher priority
  Compare(t, e) {
    const i = t.Site, s = e.Site;
    return this.ComparePoints(
      /* ref */
      i,
      /* ref */
      s
    );
  }
  Less(t, e) {
    return this.ComparePoints(
      /* ref */
      t,
      /* ref */
      e
    ) < 0;
  }
  ComparePoints(t, e) {
    let i = this.SweepDirection.dot(t), s = this.SweepDirection.dot(e);
    return i < s ? -1 : i > s ? 1 : (i = this.directionPerp.dot(t), s = this.directionPerp.dot(e), i < s ? -1 : i > s ? 1 : 0);
  }
}
var go = {}, Ja;
function _d() {
  return Ja || (Ja = 1, (function(a) {
    Object.defineProperty(a, "__esModule", { value: !0 }), a.StringBuilder = a.String = a.emptyString = void 0, a.isNullOrWhiteSpace = e, a.joinString = i, a.formatString = s;
    let t = `\r
`;
    function e(o) {
      return n.isNullOrWhiteSpace(o);
    }
    function i(o, ...l) {
      return n.join(o, ...l);
    }
    function s(o, ...l) {
      return n.format(o, ...l);
    }
    a.emptyString = "";
    class n {
      static regexNumber = /{(\d+(:\w*)?)}/g;
      static regexObject = /{(\w+(:\w*)?)}/g;
      static empty = "";
      static Empty = "";
      static IsNullOrWhiteSpace(l) {
        return n.isNullOrWhiteSpace(l);
      }
      static Join(l, ...h) {
        return n.join(l, ...h);
      }
      static Format(l, ...h) {
        return n.format(l, ...h);
      }
      static isNullOrWhiteSpace(l) {
        try {
          return l == null || l == "undefined" ? !0 : l.toString().replace(/\s/g, "").length < 1;
        } catch (h) {
          return console.log(h), !1;
        }
      }
      static join(l, ...h) {
        try {
          var c = h[0];
          if (Array.isArray(c) || c instanceof Array) {
            let p = n.empty;
            for (let P = 0; P < c.length; P++) {
              var d = c[P];
              P < c.length - 1 ? p += d + l : p += d;
            }
            return p;
          }
          if (typeof c == "object") {
            let p = n.empty, P = c;
            return Object.keys(c).forEach((y) => {
              p += P[y] + l;
            }), p = p.slice(0, p.length - l.length);
          }
          var f = h;
          return n.joinString(l, ...f);
        } catch (p) {
          return console.log(p), n.empty;
        }
      }
      static format(l, ...h) {
        try {
          return l.match(n.regexNumber) ? n.formatString(n.regexNumber, l, h) : l.match(n.regexObject) ? n.formatString(n.regexObject, l, h, !0) : l;
        } catch (c) {
          return console.log(c), n.empty;
        }
      }
      static formatString(l, h, c, d = !1) {
        return h.replace(l, function(f, p) {
          var P = f.split(":");
          1 < P.length && (p = P[0].replace("{", ""), f = P[1].replace("}", ""));
          let y;
          return (y = (d ? c[0] : c)[p]) == null || y == null || f.match(/{\d+}/) || (y = n.parsePattern(f, y)) !== void 0 && y != null ? y : n.empty;
        });
      }
      static parsePattern(l, h) {
        switch (l) {
          case "L":
            return h = h.toLocaleLowerCase();
          case "U":
            return h = h.toLocaleUpperCase();
          case "d":
            if (typeof h == "string") return n.getDisplayDateFromString(h);
            if (h instanceof Date) return n.format("{0:00}.{1:00}.{2:0000}", h.getDate(), h.getMonth(), h.getFullYear());
            break;
          case "s":
            if (typeof h == "string") return n.getSortableDateFromString(h);
            if (h instanceof Date) return n.format("{0:0000}-{1:00}-{2:00}", h.getFullYear(), h.getMonth(), h.getDate());
            break;
          case "n": {
            var f = (h = typeof h != "string" ? h.toString() : h).replace(/,/g, ".");
            if (isNaN(parseFloat(f)) || f.length <= 3) break;
            f = f.split(/\D+/g);
            let p = f;
            var f = (p = 1 < f.length ? [n.joinString("", ...f.splice(0, f.length - 1)), f[f.length - 1]] : p)[0], c = f.length % 3, d = 0 < c ? f.substring(0, c) : n.empty, f = f.substring(c).match(/.{3}/g);
            return h = d + "." + n.join(".", f) + (1 < p.length ? "," + p[1] : "");
          }
          case "x":
            return this.decimalToHexString(h);
          case "X":
            return this.decimalToHexString(h, !0);
        }
        return typeof h != "number" && isNaN(h) || isNaN(+l) || n.isNullOrWhiteSpace(h) ? h : n.formatNumber(h, l);
      }
      static decimalToHexString(l, h = !1) {
        return l = parseFloat(l).toString(16), h ? l.toLocaleUpperCase() : l;
      }
      static getDisplayDateFromString(l) {
        var h = l.split("-");
        if (h.length <= 1) return l;
        let c = h[h.length - 1];
        return l = h[h.length - 2], h = h[h.length - 3], (c = (c = c.split("T")[0]).split(" ")[0]) + `.${l}.` + h;
      }
      static getSortableDateFromString(l) {
        var h = l.replace(",", "").split(".");
        if (h.length <= 1) return l;
        l = h[h.length - 1].split(" ");
        let c = n.empty, d = (1 < l.length && (c = l[l.length - 1]), h[h.length - 1].split(" ")[0] + `-${h[h.length - 2]}-` + h[h.length - 3]);
        return !n.isNullOrWhiteSpace(c) && 1 < c.length ? d += "T" + c : d += "T00:00:00", d;
      }
      static formatNumber(d, c) {
        var c = c.length, d = d.toString();
        return c <= d.length ? d : (c = c - d.length, ++c, new Array(c).join("0") + d);
      }
      static joinString(l, ...h) {
        let c = n.empty;
        for (let f = 0; f < h.length; f++) if (!(typeof h[f] == "string" && n.isNullOrWhiteSpace(h[f]) || typeof h[f] != "number" && typeof h[f] != "string")) {
          var d = "" + h[f];
          c += d;
          for (let p = f + 1; p < h.length; p++) if (!n.isNullOrWhiteSpace(h[p])) {
            c += l, f = p - 1;
            break;
          }
        }
        return c;
      }
    }
    a.String = n;
    class r {
      Values;
      constructor(l = "") {
        this.Values = [], n.isNullOrWhiteSpace(l) || (this.Values = new Array(l));
      }
      toString() {
        return this.Values.join(n.empty);
      }
      ToString() {
        return this.toString();
      }
      append(l) {
        this.Values.push(l);
      }
      Append(l) {
        this.append(l);
      }
      appendLine(l) {
        this.Values.push(t + l);
      }
      AppendLine(l) {
        this.appendLine(l);
      }
      appendFormat(l, ...h) {
        this.Values.push(n.format(l, ...h));
      }
      AppendFormat(l, ...h) {
        this.appendFormat(l, ...h);
      }
      appendLineFormat(l, ...h) {
        this.Values.push(t + n.format(l, ...h));
      }
      AppendLineFormat(l, ...h) {
        return this.appendLineFormat(l, ...h);
      }
      clear() {
        this.Values = [];
      }
      Clear() {
        this.clear();
      }
    }
    a.StringBuilder = r;
  })(go)), go;
}
var Gt = _d();
class ce {
  static closeuv(t, e) {
    return u.closeDistEps(t.point, ce.u, 0.1) && u.closeDistEps(e.point, ce.v, 0.1);
  }
  constructor(t, e, i = 1) {
    this.LengthMultiplier = 1, this.Source = t, this.Target = e, this.Weight = i;
  }
  // edge source point
  get SourcePoint() {
    return this.Source.point;
  }
  // edge target point
  get TargetPoint() {
    return this.Target.point;
  }
  get Length() {
    return this.SourcePoint.sub(this.TargetPoint).length * this.LengthMultiplier;
  }
  toString() {
    return Gt.String.format("{0}->{1} ({2})", this.Source, this.Target, this.Weight);
  }
  ReversedClone() {
    return new ce(this.Target, this.Source);
  }
  Clone() {
    return new ce(this.Source, this.Target);
  }
}
ce.u = new u(545.833, 840.458);
ce.v = new u(606.1667261889578, 786.2917261889578);
ce.DefaultWeight = 1;
class pi extends ce {
  static constructorVV(t, e) {
    return new pi(t, e, 0);
  }
  constructor(t, e, i = 0) {
    super(t, e, i);
  }
}
class ii {
  deleteP(t) {
    return this.delete(t.x, t.y);
  }
  clear() {
    this.m.clear();
  }
  get size() {
    return this.m.size;
  }
  setxy(t, e, i) {
    this.m.set(er(t, e), i);
  }
  set(t, e) {
    this.setxy(t.x, t.y, e);
  }
  delete(t, e) {
    return this.m.delete(er(t, e));
  }
  hasxy(t, e) {
    return this.m.has(er(t, e));
  }
  has(t) {
    return this.hasxy(t.x, t.y);
  }
  getxy(t, e) {
    return this.m.get(er(t, e));
  }
  get(t) {
    return this.getxy(t.x, t.y);
  }
  constructor() {
    this.m = /* @__PURE__ */ new Map();
  }
  *keys() {
    for (const t of this.m.keys()) {
      const e = t.split(",");
      yield new u(Number(e[0]), Number(e[1]));
    }
  }
  *[Symbol.iterator]() {
    for (const [t, e] of this.m) {
      const i = t.split(",");
      yield [new u(Number(i[0]), Number(i[1])), e];
    }
  }
  *values() {
    yield* this.m.values();
  }
}
function er(a, t) {
  return a.toString() + "," + t.toString();
}
class ks {
  get InEdges() {
    return this._inEdges;
  }
  // this collection is sorted by the target point, in the lexicographical order
  get OutEdges() {
    return this._outEdges;
  }
  get Degree() {
    return this._inEdges.length + this.OutEdges.count;
  }
  InEdgesLength() {
    return this._inEdges.length;
  }
  addInEdge(t) {
    this._inEdges.push(t);
  }
  get IsTerminal() {
    return this._isTerminal;
  }
  set IsTerminal(t) {
    this._isTerminal = t;
  }
  get IsShortestPathTerminal() {
    return this._isShortestPathTerminal;
  }
  set IsShortestPathTerminal(t) {
    this._isShortestPathTerminal = t;
  }
  constructor(t) {
    this._inEdges = new Array(), this._outEdges = new we((e, i) => this.Compare(e, i)), this.point = t;
  }
  toString() {
    return this.point.toString();
  }
  // These iterate from the end of the list because Array.Remove is linear in
  // the number of items, so callers have been optimized where possible to
  // remove only the last or next-to-last edges (but in some cases such as
  // rectilinear, this optimization isn't always possible).
  RemoveOutEdge(t) {
    this.OutEdges.remove(t);
  }
  RemoveInEdge(t) {
    const e = this._inEdges.indexOf(t);
    if (e === -1)
      return;
    const i = this._inEdges.length - 1;
    e !== i && (this._inEdges[e] = this._inEdges[i]), this._inEdges.pop();
  }
  // avoiding using delegates in calling RBTree.FindFirst because of the memory allocations
  static FindFirst(t, e) {
    return ks.FindFirst_t(t.root, t, e);
  }
  static FindFirst_t(t, e, i) {
    if (t === e.nil)
      return null;
    let s = null;
    for (; t !== e.nil; )
      t = t.item.TargetPoint.compareTo(i) >= 0 ? (s = t).left : t.right;
    return s;
  }
  get(t) {
    let e = ks.FindFirst(this.OutEdges, t.point);
    return e != null && e.item.Target === t || (e = ks.FindFirst(t.OutEdges, this.point), e != null && e.item.Target === this) ? e.item : null;
  }
  Compare(t, e) {
    return t.TargetPoint.compareTo(e.TargetPoint);
  }
  ClearEdges() {
    this._outEdges.clear(), this._inEdges = [];
  }
}
class wt {
  constructor() {
    this.activeVertices = /* @__PURE__ */ new Set(), this.VertexFactory = (t) => new ks(t), this.pointToVertexMap = new ii();
  }
  *edges_() {
    for (const t of this.pointToVertexMap.values())
      for (const e of t.OutEdges)
        yield e;
  }
  get Edges() {
    return this.edges_();
  }
  ClearPrevEdgesTable() {
    for (const t of this.activeVertices)
      t.prevEdge = null;
    this.activeVertices.clear();
  }
  ShrinkLengthOfPrevEdge(t, e) {
    t.prevEdge.LengthMultiplier = e;
  }
  // needed for shortest path calculations
  PreviosVertex(t) {
    const e = t.prevEdge;
    return e ? e.Source === t ? e.Target : e.Source : null;
  }
  SetPreviousEdge(t, e) {
    this.activeVertices.add(t), t.prevEdge = e;
  }
  //  static GetVisibilityGraphForShortestPath(pathStart: Point, pathEnd: Point, obstacles: Array<Polyline>, /* out */sourceVertex: VisibilityVertex, /* out */targetVertex: VisibilityVertex): VisibilityGraph {
  //      let holes = new Array<Polyline>(VisibilityGraph.OrientHolesClockwise(obstacles));
  //      let visibilityGraph = VisibilityGraph.CalculateGraphOfBoundaries(holes);
  //      let polygons = holes.Select(() => {  }, new Polygon(holes)).ToList();
  //      TangentVisibilityGraphCalculator.AddTangentVisibilityEdgesToGraph(polygons, visibilityGraph);
  //      PointVisibilityCalculator.CalculatePointVisibilityGraph(holes, visibilityGraph, pathStart, VisibilityKind.Tangent, /* out */sourceVertex);
  //      PointVisibilityCalculator.CalculatePointVisibilityGraph(holes, visibilityGraph, pathEnd, VisibilityKind.Tangent, /* out */targetVertex);
  //      return visibilityGraph;
  //  }
  //  //  Calculates the tangent visibility graph
  //  public static FillVisibilityGraphForShortestPath(obstacles: Array<Polyline>): VisibilityGraph {
  //      let holes = new Array<Polyline>(VisibilityGraph.OrientHolesClockwise(obstacles));
  //      let visibilityGraph = VisibilityGraph.CalculateGraphOfBoundaries(holes);
  //      let polygons = holes.Select(() => {  }, new Polygon(hole)).ToList();
  //      TangentVisibilityGraphCalculator.AddTangentVisibilityEdgesToGraph(polygons, visibilityGraph);
  //      return visibilityGraph;
  //  }
  //  static CalculateGraphOfBoundaries(holes: Array<Polyline>): VisibilityGraph {
  //      let graphOfHoleBoundaries = new VisibilityGraph();
  //      for (let polyline: Polyline of holes) {
  //          graphOfHoleBoundaries.AddHole(polyline);
  //      }
  //      return graphOfHoleBoundaries;
  //  }
  AddHole(t) {
    let e = t.startPoint;
    for (; e !== t.endPoint; )
      this.AddEdgePlPl(e, e.next), e = e.next;
    this.AddEdgePlPl(t.endPoint, t.startPoint);
  }
  static *OrientHolesClockwise(t) {
    for (const e of t)
      for (let i = e.startPoint; ; i = i.next) {
        const s = u.getTriangleOrientation(i.point, i.next.point, i.next.next.point);
        if (s !== L.Collinear) {
          yield s === L.Clockwise ? e : e.reverse();
          break;
        }
      }
  }
  //  static CheckThatPolylinesAreConvex(holes: Array<Polyline>) {
  //      for (let polyline of holes) {
  //          VisibilityGraph.CheckThatPolylineIsConvex(polyline);
  //      }
  //  }
  //  static CheckThatPolylineIsConvex(polyline: Polyline) {
  //      Assert.assert(polyline.closed, "Polyline is not closed");
  //      let a: PolylinePoint = polyline.startPoint;
  //      let b: PolylinePoint = a.next;
  //      let c: PolylinePoint = b.next;
  //      let orient: TriangleOrientation = Point.getTriangleOrientation(a.point, b.point, c.point);
  //      while ((c !== polyline.endPoint)) {
  //          a = a.next;
  //          b = b.next;
  //          c = c.next;
  //          let currentOrient = Point.getTriangleOrientation(a.point, b.point, c.point);
  //          if ((currentOrient === TriangleOrientation.Collinear)) {
  //              continue
  //          }
  //          if ((orient === TriangleOrientation.Collinear)) {
  //              orient = currentOrient;
  //          }
  //          else if ((orient !== currentOrient)) {
  //              throw new InvalidOperationException();
  //          }
  //      }
  //      let o = Point.getTriangleOrientation(polyline.endPoint.Point, polyline.startPoint.Point, polyline.startPoint.Next.Point);
  //      if (((o !== TriangleOrientation.Collinear)
  //                  && (o !== orient))) {
  //          throw new InvalidOperationException();
  //      }
  //  }
  //  //  TEST || VERIFY
  //  //  Enumerate all VisibilityEdges in the VisibilityGraph.
  //  public get Edges(): Array<VisibilityEdge> {
  //      return PointToVertexMap.Values.SelectMany(() => {  }, vertex.OutEdges);
  //  }
  //  get PointToVertexMap(): Map<Point, VisibilityVertex> {
  //      return this.pointToVertexMap;
  //  }
  //  get VertexCount(): number {
  //      return this.PointToVertexMap.Count;
  //  }
  //  AddVertex(polylinePoint: PolylinePoint): VisibilityVertex {
  //      return this.AddVertex(polylinePoint.point);
  //  }
  AddVertexP(t) {
    const e = this.pointToVertexMap.get(t);
    if (e)
      return e;
    const i = this.VertexFactory(t);
    return this.pointToVertexMap.set(t, i), i;
  }
  AddVertexV(t) {
    this.pointToVertexMap.set(t.point, t);
  }
  ContainsVertex(t) {
    return this.pointToVertexMap.has(t);
  }
  static AddEdgeVV(t, e) {
    let i;
    if (i = t.get(e))
      return i;
    if (t === e)
      throw new Error("Self-edges are not allowed");
    const s = new ce(t, e);
    return t.OutEdges.insert(s), e.InEdges.push(s), s;
  }
  AddEdgePlPl(t, e) {
    this.AddEdgePP(t.point, e.point);
  }
  static AddEdge(t) {
    t.Source.OutEdges.insert(t), t.Target.addInEdge(t);
  }
  AddEdgeF(t, e, i) {
    let s = this.FindVertex(t), n = null;
    if (s != null && (n = this.FindVertex(e), n != null)) {
      const o = s.get(n);
      if (o)
        return o;
    }
    s == null ? (s = this.AddVertexP(t), n = this.AddVertexP(e)) : n == null && (n = this.AddVertexP(e));
    const r = i(s, n);
    return s.OutEdges.insert(r), n.addInEdge(r), r;
  }
  AddEdgePP(t, e) {
    return this.AddEdgeF(t, e, (i, s) => new ce(i, s));
  }
  FindVertex(t) {
    return this.pointToVertexMap.get(t);
  }
  Vertices() {
    return this.pointToVertexMap.values();
  }
  RemoveVertex(t) {
    for (const e of t.OutEdges)
      e.Target.RemoveInEdge(e);
    for (const e of t.InEdges)
      e.Source.RemoveOutEdge(e);
    this.pointToVertexMap.deleteP(t.point);
  }
  //  RemoveEdge(v1: VisibilityVertex, v2: VisibilityVertex) {
  //      let edge: VisibilityEdge;
  //      if (!v1.TryGetEdge(v2, /* out */edge)) {
  //          return;
  //      }
  //      edge.Source.RemoveOutEdge(edge);
  //      edge.Target.RemoveInEdge(edge);
  //  }
  //  RemoveEdge(p1: Point, p2: Point) {
  //      //  the order of p1 and p2 is not important.
  //      let edge: VisibilityEdge = this.FindEdge(p1, p2);
  //      if ((edge == null )) {
  //          return;
  //      }
  //      edge.Source.RemoveOutEdge(edge);
  //      edge.Target.RemoveInEdge(edge);
  //  }
  //  static FindEdge(edge: VisibilityEdge): VisibilityEdge {
  //      if (edge.Source.TryGetEdge(edge.Target, /* out */edge)) {
  //          return edge;
  //      }
  //      return null;
  //  }
  FindEdgePP(t, e) {
    const i = this.FindVertex(t);
    if (i == null)
      return null;
    const s = this.FindVertex(e);
    return s == null ? null : i.get(s);
  }
  static RemoveEdge(t) {
    t.Source.RemoveOutEdge(t), t.Target.RemoveInEdge(t);
  }
  ClearEdges() {
    for (const t of this.Vertices())
      t.ClearEdges();
  }
}
class la {
  constructor() {
    this.Removed = !1;
  }
}
class Ns extends la {
  get Start() {
    return this.start;
  }
  get End() {
    return this.EndVertex.point;
  }
  constructor(t, e, i) {
    super(), this.start = t, this.EndVertex = e, this.ConeSide = i;
  }
  get Direction() {
    return this.End.sub(this.Start);
  }
  toString() {
    return "BrokenConeSide: " + (this.Start + ("," + this.End));
  }
}
class po {
  get Removed() {
    return this.removed;
  }
  set Removed(t) {
    this.removed = t;
  }
  constructor(t, e) {
    this.apex = t, this.coneSweeper = e;
  }
  get Apex() {
    return this.apex;
  }
  set Apex(t) {
    this.apex = t;
  }
  get RightSideDirection() {
    return this.coneSweeper.ConeRightSideDirection;
  }
  get LeftSideDirection() {
    return this.coneSweeper.ConeLeftSideDirection;
  }
  get RightSide() {
    return this.rightSide;
  }
  set RightSide(t) {
    this.rightSide = t, this.rightSide.Cone = this;
  }
  get LeftSide() {
    return this.leftSide;
  }
  set LeftSide(t) {
    this.leftSide = t, this.leftSide.Cone = this;
  }
}
class Ka extends Gi {
  get ConeToClose() {
    return this.coneToClose;
  }
  get Site() {
    return this.site;
  }
  constructor(t, e) {
    super(), this.site = t, this.coneToClose = e;
  }
  toString() {
    return "ConeClosureEvent " + this.site;
  }
}
class ri extends la {
  constructor(t) {
    super(), this.Cone = t;
  }
  get Start() {
    return this.Cone.Apex;
  }
  get Direction() {
    return this.Cone.LeftSideDirection;
  }
  toString() {
    return "ConeLeftSide " + this.Start + (" " + this.Direction);
  }
}
class Fi extends la {
  constructor(t) {
    super(), this.Cone = t;
  }
  get Start() {
    return this.Cone.Apex;
  }
  get Direction() {
    return this.Cone.RightSideDirection;
  }
  toString() {
    return "ConeRightSide " + this.Start + " " + this.Direction;
  }
}
class Rr {
  SetOperand(t) {
    this.x = this.IntersectionOfSegmentAndSweepLine(t);
  }
  constructor(t) {
    this.coneSweeper = t;
  }
  Compare(t, e) {
    const i = t instanceof Ns, s = e instanceof Ns;
    return i ? s ? this.CompareBrokenSides(t, e) : this.CompareObstacleSideAndConeSide(e) : s ? this.CompareConeSideAndObstacleSide(t, e) : Rr.CompareNotIntersectingSegs(t, e);
  }
  static CompareNotIntersectingSegs(t, e) {
    switch (u.getTriangleOrientation(t.Start, e.Start, e.Start.add(e.Direction))) {
      case L.Counterclockwise:
        return -1;
      case L.Clockwise:
        return 1;
      default:
        return 0;
    }
  }
  CompareObstacleSideAndConeSide(t) {
    const e = u.getTriangleOrientation(this.x, t.Start, t.Start.add(t.Direction));
    return e === L.Counterclockwise ? -1 : e === L.Clockwise ? 1 : t instanceof ri ? -1 : 1;
  }
  CompareConeSideAndObstacleSide(t, e) {
    const i = u.getTriangleOrientation(this.x, e.start, e.End);
    return i === L.Counterclockwise ? -1 : i === L.Clockwise || t instanceof ri ? 1 : -1;
  }
  IntersectionOfSegmentAndSweepLine(t) {
    const e = t.Direction.dot(this.coneSweeper.SweepDirection), i = (this.coneSweeper.Z - t.Start.dot(this.coneSweeper.SweepDirection)) / e;
    return t.Start.add(t.Direction.mul(i));
  }
  CompareBrokenSides(t, e) {
    return t.EndVertex === e.EndVertex ? Rr.CompareNotIntersectingSegs(t.ConeSide, e.ConeSide) : u.getTriangleOrientation(this.x, e.start, e.EndVertex.point) === L.Counterclockwise ? -1 : 1;
  }
}
class ln extends Gi {
  get EndVertex() {
    return this.endVertex;
  }
  constructor(t, e, i) {
    super(), this.coneLeftSide = t, this.intersectionPoint = e, this.endVertex = i;
  }
  get Site() {
    return this.intersectionPoint;
  }
  toString() {
    return "LeftIntersectionEvent " + this.intersectionPoint;
  }
}
class ha {
  get Direction() {
    return this.End.sub(this.Start);
  }
  toString() {
    return this.Start + " " + this.End;
  }
}
class ca extends ha {
  Init(t) {
    this.StartVertex = t;
  }
  constructor(t) {
    super(), this.Init(t);
  }
  get Polyline() {
    return this.StartVertex.polyline;
  }
  get Start() {
    return this.StartVertex.point;
  }
  get End() {
    return this.EndVertex.point;
  }
}
class Bs extends ca {
  constructor(t) {
    super(t), this.end = t.nextOnPolyline.point;
  }
  get End() {
    return this.end;
  }
  get EndVertex() {
    return this.StartVertex.nextOnPolyline;
  }
}
class ls extends en {
  constructor(t) {
    super(t);
  }
}
class Za extends Gi {
  get EndVertex() {
    return this.endVertex;
  }
  set EndVertex(t) {
    this.endVertex = t;
  }
  constructor(t, e, i) {
    super(), this.coneRightSide = t, this.intersectionPoint = e, this.endVertex = i;
  }
  get Site() {
    return this.intersectionPoint;
  }
  toString() {
    return "RightIntersectionEvent " + this.intersectionPoint;
  }
}
class Gs extends ca {
  constructor(t) {
    super(t), this.end = t.prevOnPolyline.point;
  }
  get End() {
    return this.end;
  }
  get EndVertex() {
    return this.StartVertex.prevOnPolyline;
  }
}
class hs extends en {
  constructor(t) {
    super(t);
  }
}
class qt extends Dh {
  constructor(t, e, i, s, n, r, o) {
    super(t, e), this.visibilityGraph = n, this.ConeRightSideDirection = i, this.ConeLeftSideDirection = s, this.coneSideComparer = new Rr(this), this.leftConeSides = new we((l, h) => this.coneSideComparer.Compare(l, h)), this.rightConeSides = new we((l, h) => this.coneSideComparer.Compare(l, h)), this.Ports = r, this.BorderPolyline = o, this.PortEdgesCreator = (l, h) => new pi(l, h, 0);
  }
  static Sweep(t, e, i, s, n, r) {
    new qt(t, e, e.rotate(-i / 2), e.rotate(i / 2), s, n, r).Calculate();
  }
  Calculate() {
    for (this.InitQueueOfEvents(); this.EventQueue.Count > 0; )
      this.ProcessEvent(this.EventQueue.Dequeue());
    this.BorderPolyline != null && this.CloseRemainingCones(), this.CreatePortEdges();
  }
  CreatePortEdges() {
    if (this.portEdgesGraph != null)
      for (const t of this.portEdgesGraph.Edges)
        this.visibilityGraph.AddEdgeF(t.SourcePoint, t.TargetPoint, this.PortEdgesCreator);
  }
  CloseRemainingCones() {
    if (this.leftConeSides.count === 0)
      return;
    let t = this.BorderPolyline.startPoint, e = this.leftConeSides.count;
    do {
      const i = this.leftConeSides.treeMinimum().item.Cone;
      t = this.FindPolylineSideIntersectingConeRightSide(t, i), t = this.GetPolylinePointInsideOfConeAndRemoveCones(t, i), e--;
    } while (this.leftConeSides.count > 0 && e > 0);
  }
  GetPolylinePointInsideOfConeAndRemoveCones(t, e) {
    const i = t.nextOnPolyline, s = qt.FindInsidePoint(t.point, i.point, e);
    return u.closeDistEps(s, t.point) ? (this.AddEdgeAndRemoveCone(e, t.point), this.AddEdgesAndRemoveRemainingConesByPoint(t.point)) : u.closeDistEps(s, i.point) ? (this.AddEdgeAndRemoveCone(e, i.point), this.AddEdgesAndRemoveRemainingConesByPoint(i.point), t = i) : (t = qt.InsertPointIntoPolylineAfter(this.BorderPolyline, t, s), this.AddEdgeAndRemoveCone(e, t.point), this.AddEdgesAndRemoveRemainingConesByPoint(t.point)), t;
  }
  static FindInsidePoint(t, e, i) {
    return qt.FindInsidePointBool(t, e, i.Apex, i.Apex.add(i.LeftSideDirection), i.Apex.add(i.RightSideDirection));
  }
  static FindInsidePointBool(t, e, i, s, n) {
    if (u.closeDistEps(t, e) || u.PointIsInsideCone(t, i, s, n))
      return t;
    if (u.PointIsInsideCone(e, i, s, n))
      return e;
    const r = u.middle(t, e);
    return u.pointToTheLeftOfLine(r, i, s) ? qt.FindInsidePointBool(r, e, i, s, n) : qt.FindInsidePointBool(t, r, i, s, n);
  }
  AddEdgesAndRemoveRemainingConesByPoint(t) {
    const e = new Array();
    for (const i of this.leftConeSides)
      if (u.PointToTheRightOfLineOrOnLine(t, i.Start, i.Start.add(i.Direction)))
        e.push(i.Cone);
      else
        break;
    for (const i of e)
      this.AddEdgeAndRemoveCone(i, t);
  }
  FindPolylineSideIntersectingConeRightSide(t, e) {
    const i = t, s = e.Apex, n = e.Apex.add(this.ConeRightSideDirection);
    let r = qt.GetSign(t, s, n);
    for (; ; ) {
      const o = t.nextOnPolyline, l = qt.GetSign(o, s, n);
      if (l - r > 0)
        return t;
      if (t = o, r = l, t === i)
        throw new Error("cannod decide if the polyline intersects the cone!");
    }
  }
  // #if TEST_MSAGL
  //         // ReSharper disable UnusedMember.Local
  //         static ICurve Box(Point p) {
  //             // ReSharper restore UnusedMember.Local
  //             return CurveFactory.CreateRectangle(2, 2, p);
  //         }
  //             "CA1303:Do not pass literals as localized parameters", MessageId = "System.Diagnostics.Debug.WriteLine(System.String)"
  //         )]
  //         void PrintOutRightSegTree() {
  //             System.Diagnostics.Debug.WriteLine("right segment tree");
  //             foreach(var t of rightConeSides)
  //             System.Diagnostics.Debug.WriteLine(t);
  //             System.Diagnostics.Debug.WriteLine("end of right segments");
  //         }
  // #endif
  static GetSign(t, e, i) {
    const s = u.signedDoubledTriangleArea(e, i, t.point);
    return s < 0 ? 1 : s > 0 ? -1 : 0;
  }
  // #if TEST_MSAGL && TEST_MSAGL
  //         void Showside(PolylinePoint p, Point a, Point b, PolylinePoint pn) {
  //             ShowBothTrees(new DebugCurve(100, 1, "brown", BorderPolyline), new DebugCurve(100, 2, "blue",
  //                 new LineSegment(a, b)),
  //                 new DebugCurve(100, 2, "green",
  //                     new LineSegment(
  //                         pn.point, p.point)
  //                 ));
  //         }
  // #endif
  //        void CheckThatPolylineIsLegal()
  //        {
  //            var p = BorderPolyline.startPoint;
  //            do
  //            {
  //                var pn = p.NextOnPolyline;
  //                Assert.assert(!Point.closeDistEps(p.point, pn.point));
  //                Assert.assert((pn.point - p.point)*(pn.NextOnPolyline.point - pn.point) > -GeomConstants.tolerance);
  //                p = pn;
  //            } while (p !== BorderPolyline.startPoint);
  //        }
  // #if TEST_MSAGL
  //         void ShowBoundaryPolyline() {
  //             LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(CreateBoundaryPolyDebugCurves());
  //         }
  //         Array < DebugCurve > CreateBoundaryPolyDebugCurves() {
  //             int i = 0;
  //             for (var p = BorderPolyline.startPoint; p != null; p = p.next) {
  //                 yield return new DebugCurve(new Ellipse(1, 1, p.point), i++);
  //             }
  //         }
  // #endif
  AddEdgeAndRemoveCone(t, e) {
    this.Ports != null && this.Ports.has(t.Apex) ? this.CreatePortEdge(t, e) : this.visibilityGraph.AddEdgePP(t.Apex, e), this.RemoveCone(t);
  }
  CreatePortEdge(t, e) {
    this.portEdgesGraph == null && (this.portEdgesGraph = new wt());
    const i = this.portEdgesGraph.FindVertex(t.Apex), s = i != null ? Array.from(i.InEdges).concat(Array.from(i.OutEdges.allNodes())) : null;
    if (s)
      for (const n of s) {
        const r = (n.Target === i ? n.Source : n.Target).point;
        wt.RemoveEdge(n), this.portEdgesGraph.AddEdgePP(r, e);
      }
    this.portEdgesGraph.AddEdgePP(t.Apex, e);
  }
  static InsertPointIntoPolylineAfter(t, e, i) {
    let s;
    return e.next != null ? (s = ei.mkFromPoint(i), s.prev = e, s.next = e.next, e.next.prev = s, e.next = s) : (s = ei.mkFromPoint(i), s.prev = e, e.next = s, t.endPoint = s), s.polyline = t, t.setInitIsRequired(), s;
  }
  ProcessEvent(t) {
    t instanceof en ? this.ProcessVertexEvent(t) : t instanceof Za ? this.ProcessRightIntersectionEvent(t) : t instanceof ln ? this.ProcessLeftIntersectionEvent(t) : (t instanceof Ka ? t.ConeToClose.Removed || this.RemoveCone(t.ConeToClose) : this.ProcessPortObstacleEvent(t), this.Z = this.GetZS(t));
  }
  // #if TEST_MSAGL
  //        protected override bool TreesAreCorrect() {
  //            return TreeIsCorrect(leftConeSides) && TreeIsCorrect(rightConeSides);
  //        }
  //
  //        bool TreeIsCorrect(RBTree<ConeSide> tree) {
  //            var y = Number.NEGATIVE_INFINITY;
  //            foreach (var t of tree) {
  //                var x = coneSideComparer.IntersectionOfSegmentAndSweepLine(t);
  //                var yp = x*DirectionPerp;
  //                if (yp < y - GeomConstants.distanceEpsilon)
  //                    return false;
  //                y = yp;
  //            }
  //            return true;
  //        }
  // #endif
  ProcessPortObstacleEvent(t) {
    this.Z = this.GetZS(t), this.GoOverConesSeeingVertexEvent(t), this.CreateConeOnVertex(t);
  }
  ProcessLeftIntersectionEvent(t) {
    if (t.coneLeftSide.Removed === !1)
      if (Math.abs(t.EndVertex.point.sub(t.Site).dot(this.SweepDirection)) < m.distanceEpsilon)
        this.RemoveCone(t.coneLeftSide.Cone);
      else {
        this.RemoveSegFromLeftTree(t.coneLeftSide), this.Z = this.GetZP(t.Site);
        const e = new Ns(t.Site, t.EndVertex, t.coneLeftSide);
        this.InsertToTree(this.leftConeSides, e), t.coneLeftSide.Cone.LeftSide = e, this.LookForIntersectionOfObstacleSideAndLeftConeSide(t.Site, t.EndVertex), this.TryCreateConeClosureForLeftSide(e);
      }
    else
      this.Z = this.GetZP(t.Site);
  }
  TryCreateConeClosureForLeftSide(t) {
    if (t.Cone.RightSide instanceof Fi) {
      const e = t.Cone.RightSide;
      u.getTriangleOrientation(e.Start, e.Start.add(e.Direction), t.EndVertex.point) == L.Clockwise && this.CreateConeClosureEvent(t, e);
    }
  }
  CreateConeClosureEvent(t, e) {
    const i = u.RayIntersectsRayInteriors(t.start, t.Direction, e.Start, e.Direction);
    if (i) {
      const s = new Ka(i, t.Cone);
      this.EnqueueEvent(s);
    }
  }
  ProcessRightIntersectionEvent(t) {
    if (t.coneRightSide.Removed)
      this.Z = this.GetZP(t.Site);
    else {
      this.RemoveSegFromRightTree(t.coneRightSide), this.Z = this.GetZP(t.Site);
      const e = new Ns(t.Site, t.EndVertex, t.coneRightSide);
      this.InsertToTree(this.rightConeSides, e), t.coneRightSide.Cone.RightSide = e, this.LookForIntersectionOfObstacleSideAndRightConeSide(t.Site, t.EndVertex), this.TryCreateConeClosureForRightSide(e);
    }
  }
  TryCreateConeClosureForRightSide(t) {
    if (t.Cone.LeftSide instanceof ri) {
      const e = t.Cone.LeftSide;
      u.getTriangleOrientation(e.Start, e.Start.add(e.Direction), t.EndVertex.point) == L.Counterclockwise && this.CreateConeClosureEvent(t, e);
    }
  }
  RemoveConesClosedBySegment(t, e) {
    this.CloseConesCoveredBySegment(t, e, this.GetZP(t) > this.GetZP(e) ? this.leftConeSides : this.rightConeSides);
  }
  CloseConesCoveredBySegment(t, e, i) {
    let s = i.findFirst((o) => u.getTriangleOrientation(o.Start, o.Start.add(o.Direction), t) === L.Counterclockwise);
    if (s == null || !u.IntervalIntersectsRay(t, e, s.item.Start, s.item.Direction))
      return;
    const r = new Array();
    do
      r.push(s.item.Cone), s = i.next(s);
    while (s != null && u.IntervalIntersectsRay(t, e, s.item.Start, s.item.Direction) !== void 0);
    for (const o of r)
      this.RemoveCone(o);
  }
  ProcessVertexEvent(t) {
    this.Z = this.GetZS(t), this.GoOverConesSeeingVertexEvent(t), this.AddConeAndEnqueueEvents(t);
  }
  // #if TEST_MSAGL
  //         // ReSharper disable UnusedMember.Local
  //         static Ellipse EllipseOnVert(SweepEvent vertexEvent) {
  //             // ReSharper restore UnusedMember.Local
  //             return new Ellipse(5, 5, vertexEvent.Site);
  //         }
  //         // ReSharper disable UnusedMember.Local
  //         static Ellipse EllipseOnPolylinePoint(PolylinePoint pp) {
  //             // ReSharper restore UnusedMember.Local
  //             return EllipseOnPolylinePoint(pp, 5);
  //         }
  //         // ReSharper disable UnusedMember.Local
  //         static Ellipse EllipseOnPolylinePoint(PolylinePoint pp, double i)
  //         // ReSharper restore UnusedMember.Local
  //         {
  //             return new Ellipse(i, i, pp.point);
  //         }
  static Diamond(t) {
    return pt.mkDiamond(2, 2, t);
  }
  //         // ReSharper disable UnusedMember.Local
  //             "CA1303:Do not pass literals as localized parameters", MessageId = "System.Diagnostics.Debug.WriteLine(System.String)"
  //         ),
  //         void CheckConsistency() {
  //             // ReSharper restore UnusedMember.Local
  //             foreach(var s of rightConeSides) {
  //                 coneSideComparer.SetOperand(s);
  //             }
  //             foreach(var s of leftConeSides) {
  //                 coneSideComparer.SetOperand(s);
  //                 if (!rightConeSides.Contains(s.Cone.RightSide)) {
  //                     PrintOutRightSegTree();
  //                     PrintOutLeftSegTree();
  //                     ShowLeftTree();
  //                     ShowRightTree();
  //                 }
  //             }
  //         }
  //         void ShowRightTree(params ICurve[] curves) {
  //             var l = Obstacles.Select(p => new DebugCurve(100, 5, "green", p)).ToList();
  //             l.AddRange(rightConeSides.Select(s => new DebugCurve(100, 5, "blue", ExtendSegmentToZ(s))));
  //             //            foreach (VisibilityEdge edge of visibilityGraph.Edges)
  //             //                l.Add(BezierOnEdge(edge));
  //             l.AddRange(curves.Select(c => new DebugCurve(100, 5, "brown", c)));
  //             LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);
  //         }
  //         void ShowBothTrees(params DebugCurve[] curves) {
  //             var l = Obstacles.Select(p => new DebugCurve(100, 5, "green", p)).ToList();
  //             l.AddRange(leftConeSides.Select(s => new DebugCurve(ExtendSegmentToZ(s))));
  //             l.AddRange(rightConeSides.Select(s => new DebugCurve(ExtendSegmentToZ(s))));
  //             //            foreach (VisibilityEdge edge of visibilityGraph.Edges)
  //             //                l.Add(BezierOnEdge(edge));
  //             LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);
  //         }
  //         void ShowLeftTree(params ICurve[] curves) {
  //             var l = Obstacles.Select(p => new DebugCurve(100, 0.01, "green", p)).ToList();
  //             var range = new RealNumberSpan();
  //             var ellipseSize = 0.01;
  //             foreach(var s of leftConeSides) {
  //                 var curve = ExtendSegmentToZ(s);
  //                 range.AddValue(curve.start * DirectionPerp);
  //                 range.AddValue(curve.End * DirectionPerp);
  //                 l.Add(new DebugCurve(100, 0.1, "red", curve));
  //                 l.Add(new DebugCurve(200, 0.1, "black", new Ellipse(ellipseSize, ellipseSize, curve.End)));
  //                 ellipseSize += 2;
  //             }
  //             l.Add(DebugSweepLine(range));
  //             //            foreach (VisibilityEdge edge of visibilityGraph.Edges)
  //             //                l.Add(BezierOnEdge(edge));
  //             l.AddRange(curves.Select(c => new DebugCurve(100, 0.5, "brown", c)));
  //             LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);
  //         }
  //         DebugCurve DebugSweepLine(RealNumberSpan range) {
  //             var ls = new LineSegment(Z * SweepDirection + DirectionPerp * range.Min, Z * SweepDirection + DirectionPerp * range.Max);
  //             return new DebugCurve(100, 0.1, "magenta", ls);
  //         }
  // #endif
  AddConeAndEnqueueEvents(t) {
    if (t instanceof ls) {
      const e = t.Vertex.nextOnPolyline;
      this.CloseConesAddConeAtLeftVertex(t, e);
    } else if (t instanceof hs) {
      const e = t.Vertex.prevOnPolyline;
      this.CloseConesAddConeAtRightVertex(t, e);
    } else
      this.CloseConesAddConeAtLeftVertex(t, t.Vertex.nextOnPolyline), this.CloseConesAddConeAtRightVertex(t, t.Vertex.prevOnPolyline);
  }
  CloseConesAddConeAtRightVertex(t, e) {
    const i = t.Vertex.nextOnPolyline.point;
    this.directionPerp.dot(t.Site.sub(i)) > m.distanceEpsilon && this.RemoveConesClosedBySegment(i, t.Vertex.point), this.directionPerp.dot(e.point.sub(t.Site)) > m.distanceEpsilon && this.RemoveConesClosedBySegment(t.Site, e.point);
    const s = t.Site, n = s.add(this.ConeLeftSideDirection), r = s.add(this.ConeRightSideDirection), o = e.point;
    this.GetZP(s.sub(i)) > m.distanceEpsilon && this.RemoveRightSide(new Gs(t.Vertex.nextOnPolyline)), this.GetZP(s.sub(e.point)) > m.distanceEpsilon && this.RemoveLeftSide(new Bs(e)), this.GetZP(o) + m.distanceEpsilon < this.GetZS(t) && this.CreateConeOnVertex(t), u.PointToTheRightOfLineOrOnLine(o, s, n) ? u.PointToTheLeftOfLineOrOnLine(o, s, r) ? this.CaseToTheLeftOfLineOrOnLineConeRp(t, e) : (this.GetZP(o.sub(s)) > m.distanceEpsilon && (this.LookForIntersectionOfObstacleSideAndLeftConeSide(t.Site, e), this.InsertRightSide(new Gs(t.Vertex))), this.EnqueueRightVertexEvent(new hs(e))) : (this.CreateConeOnVertex(t), u.PointToTheLeftOfLineOrOnLine(o.add(this.DirectionPerp), o, s) && this.EnqueueRightVertexEvent(new hs(e)));
  }
  CaseToTheLeftOfLineOrOnLineConeRp(t, e) {
    this.EnqueueRightVertexEvent(new hs(e));
    const i = new po(t.Vertex.point, this), s = new Ns(i.Apex, e, new ri(i));
    i.LeftSide = s, i.RightSide = new Fi(i);
    const n = this.InsertToTree(this.rightConeSides, i.RightSide);
    this.LookForIntersectionWithConeRightSide(n);
    const r = this.InsertToTree(this.leftConeSides, i.LeftSide);
    this.FixConeLeftSideIntersections(s, r), this.GetZP(e.point.sub(t.Site)) > m.distanceEpsilon && this.InsertRightSide(new Gs(t.Vertex));
  }
  LookForIntersectionOfObstacleSideAndRightConeSide(t, e) {
    const i = this.GetLastNodeToTheLeftOfPointInRightSegmentTree(t);
    if (i != null && i.item instanceof Fi) {
      const s = u.IntervalIntersectsRay(t, e.point, i.item.Start, this.ConeRightSideDirection);
      s && this.SegmentIsNotHorizontal(s, e.point) && this.EnqueueEvent(this.CreateRightIntersectionEvent(i.item, s, e));
    }
  }
  CreateRightIntersectionEvent(t, e, i) {
    return new Za(t, e, i);
  }
  GetLastNodeToTheLeftOfPointInRightSegmentTree(t) {
    return this.rightConeSides.findLast((e) => qt.PointIsToTheRightOfSegment(t, e));
  }
  LookForIntersectionOfObstacleSideAndLeftConeSide(t, e) {
    const i = this.GetFirstNodeToTheRightOfPoint(t);
    if (i == null || !(i.item instanceof ri))
      return;
    const s = i.item, n = u.IntervalIntersectsRay(t, e.point, s.Start, this.ConeLeftSideDirection);
    n && this.EnqueueEvent(new ln(s, n, e));
  }
  GetFirstNodeToTheRightOfPoint(t) {
    return this.leftConeSides.findFirst((e) => qt.PointIsToTheLeftOfSegment(t, e));
  }
  static PointIsToTheLeftOfSegment(t, e) {
    return u.getTriangleOrientation(e.Start, e.Start.add(e.Direction), t) === L.Counterclockwise;
  }
  static PointIsToTheRightOfSegment(t, e) {
    return u.getTriangleOrientation(e.Start, e.Start.add(e.Direction), t) === L.Clockwise;
  }
  FixConeLeftSideIntersections(t, e) {
    do
      e = this.leftConeSides.next(e);
    while (e != null && u.PointToTheRightOfLineOrOnLine(t.Start, e.item.Start, e.item.Start.add(e.item.Direction)));
    if (e != null && e.item instanceof ri) {
      const i = e.item, s = u.IntervalIntersectsRay(t.start, t.End, i.Start, i.Direction);
      s && this.EnqueueEvent(new ln(i, s, t.EndVertex));
    }
  }
  InsertToTree(t, e) {
    return this.coneSideComparer.SetOperand(e), t.insert(e);
  }
  CloseConesAddConeAtLeftVertex(t, e) {
    const i = t.Vertex.prevOnPolyline.point;
    t.Site.sub(i).dot(this.directionPerp) < -m.distanceEpsilon && this.RemoveConesClosedBySegment(t.Site, i), e.point.sub(t.Site).dot(this.directionPerp) < -m.distanceEpsilon && this.RemoveConesClosedBySegment(e.point, t.Site);
    const s = t.Site, n = s.add(this.ConeLeftSideDirection), r = s.add(this.ConeRightSideDirection), o = e.point;
    this.GetZP(s.sub(i)) > m.distanceEpsilon && this.RemoveLeftSide(new Bs(t.Vertex.prevOnPolyline));
    const l = this.GetZP(o) - this.Z;
    l < -m.distanceEpsilon && this.RemoveRightSide(new Gs(e));
    const h = o.sub(t.Site);
    if (l < -m.distanceEpsilon || D(l, 0) && this.GetZP(h) > 0 && h.dot(this.directionPerp) > -m.distanceEpsilon)
      this.CreateConeOnVertex(t);
    else if (!u.PointToTheLeftOfLineOrOnLine(o, s, r))
      this.CreateConeOnVertex(t), this.EnqueueEvent(new ls(e));
    else if (u.PointToTheLeftOfLineOrOnLine(o, s, n))
      this.EnqueueEvent(new ls(e)), this.GetZP(h) > m.distanceEpsilon && (this.LookForIntersectionOfObstacleSideAndRightConeSide(t.Site, e), this.InsertLeftSide(new Bs(t.Vertex)));
    else {
      this.EnqueueEvent(new ls(e));
      const c = new po(t.Vertex.point, this), d = new Ns(t.Vertex.point, e, new Fi(c));
      c.RightSide = d, c.LeftSide = new ri(c), this.LookForIntersectionWithConeLeftSide(this.InsertToTree(this.leftConeSides, c.LeftSide));
      const f = this.InsertToTree(this.rightConeSides, d);
      this.FixConeRightSideIntersections(d, f), this.GetZP(h) > m.distanceEpsilon && this.InsertLeftSide(new Bs(t.Vertex));
    }
  }
  RemoveCone(t) {
    t.Removed = !0, this.RemoveSegFromLeftTree(t.LeftSide), this.RemoveSegFromRightTree(t.RightSide);
  }
  RemoveSegFromRightTree(t) {
    this.coneSideComparer.SetOperand(t);
    let e = this.rightConeSides.remove(t);
    if (t.Removed = !0, e == null) {
      const i = this.Z;
      this.Z = Math.max(this.GetZP(t.Start), this.Z - 0.01), this.coneSideComparer.SetOperand(t), e = this.rightConeSides.remove(t), this.Z = i;
    }
  }
  RemoveSegFromLeftTree(t) {
    if (t.Removed = !0, this.coneSideComparer.SetOperand(t), this.leftConeSides.remove(t) == null) {
      const i = this.Z;
      this.Z = Math.max(this.GetZP(t.Start), this.Z - 0.01), this.coneSideComparer.SetOperand(t), this.leftConeSides.remove(t), this.Z = i;
    }
  }
  FixConeRightSideIntersections(t, e) {
    do
      e = this.rightConeSides.previous(e);
    while (e != null && u.PointToTheLeftOfLineOrOnLine(t.start, e.item.Start, e.item.Start.add(e.item.Direction)));
    if (e != null) {
      let i;
      if (e.item instanceof Fi) {
        const s = e.item;
        (i = u.IntervalIntersectsRay(t.start, t.End, s.Start, s.Direction)) && this.EnqueueEvent(this.CreateRightIntersectionEvent(s, i, t.EndVertex));
      }
    }
  }
  CreateConeOnVertex(t) {
    const e = new po(t.Site, this);
    e.LeftSide = new ri(e), e.RightSide = new Fi(e);
    const i = this.InsertToTree(this.leftConeSides, e.LeftSide), s = this.InsertToTree(this.rightConeSides, e.RightSide);
    this.LookForIntersectionWithConeRightSide(s), this.LookForIntersectionWithConeLeftSide(i);
  }
  LookForIntersectionWithConeLeftSide(t) {
    if (t.item instanceof ri) {
      const e = t.item, i = this.FindFirstObstacleSideToTheLeftOfPoint(e.Start);
      i != null && this.TryIntersectionOfConeLeftSideAndObstacleSide(e, i);
    } else {
      const e = t.item;
      t = this.leftConeSides.next(t), t != null && t.item instanceof ri && this.TryIntersectionOfConeLeftSideAndObstacleConeSide(t.item, e);
    }
  }
  LookForIntersectionWithConeRightSide(t) {
    if (t.item instanceof Fi) {
      const e = t.item, i = this.FindFirstObstacleSideToToTheRightOfPoint(e.Start);
      i != null && this.TryIntersectionOfConeRightSideAndObstacleSide(e, i);
    } else {
      const e = t.item;
      t = this.rightConeSides.previous(t), t != null && t.item instanceof Fi && this.TryIntersectionOfConeRightSideAndObstacleConeSide(t.item, e);
    }
  }
  TryIntersectionOfConeRightSideAndObstacleConeSide(t, e) {
    const i = u.IntervalIntersectsRay(e.start, e.End, t.Start, t.Direction);
    i && this.EnqueueEvent(this.CreateRightIntersectionEvent(t, i, e.EndVertex));
  }
  TryIntersectionOfConeRightSideAndObstacleSide(t, e) {
    const i = u.IntervalIntersectsRay(e.Start, e.End, t.Start, t.Direction);
    i && this.EnqueueEvent(this.CreateRightIntersectionEvent(t, i, e.EndVertex));
  }
  TryIntersectionOfConeLeftSideAndObstacleConeSide(t, e) {
    const i = u.IntervalIntersectsRay(e.start, e.End, t.Start, t.Direction);
    i && this.EnqueueEvent(new ln(t, i, e.EndVertex));
  }
  TryIntersectionOfConeLeftSideAndObstacleSide(t, e) {
    const i = u.IntervalIntersectsRay(e.Start, e.End, t.Start, t.Direction);
    i && this.EnqueueEvent(new ln(t, i, e.EndVertex));
  }
  // Show(curves: ICurve[], fn: string) {
  //   let l = Array.from(this.Obstacles).map((o) => DebugCurve.mkDebugCurveTWCI(200, 0.5, 'Blue', o))
  //   for (const s of this.rightConeSides) {
  //     l.push(DebugCurve.mkDebugCurveWCI(0.5, 'Brown', this.ExtendSegmentToZ(s)))
  //     if (s instanceof BrokenConeSide) l.push(DebugCurve.mkDebugCurveCI('Brown', LineSweeper.Diamond(s.start)))
  //     l.push(DebugCurve.mkDebugCurveWCI(0.5, 'Green', this.ExtendSegmentToZ(s.Cone.LeftSide)))
  //     if (s.Cone.LeftSide instanceof BrokenConeSide) l.push(DebugCurve.mkDebugCurveCI('Green', LineSweeper.Diamond(s.Cone.LeftSide.start)))
  //   }
  //   l.push(
  //     ...Array.from(this.visibilityGraph.Edges).map((edge) =>
  //       DebugCurve.mkDebugCurveTWCI(100, 0.1, 'Cyan', LineSegment.mkPP(edge.SourcePoint, edge.TargetPoint)),
  //     ),
  //   )
  //   l.push(...curves.map((c) => DebugCurve.mkDebugCurveCI('Red', c)))
  //   l.push(
  //     ...Array.from(this.eventQueue)
  //       .filter((e) => e instanceof RightIntersectionEvent)
  //       .map((e) => DebugCurve.mkDebugCurveCI('Black', LineSweeper.mkRightIntersDiamond(e.Site))),
  //   )
  //   SvgDebugWriter.dumpDebugCurves(fn, l)
  // }
  //         static BezierSeg BezierOnEdge(VisibilityEdge edge) {
  //             return new BezierSeg(edge.SourcePoint, 2.0 / 3.0 * edge.SourcePoint + 1.0 / 3.0 * edge.TargetPoint,
  //                 1.0 / 3.0 * edge.SourcePoint + 2.0 / 3.0 * edge.TargetPoint, edge.TargetPoint);
  //         }
  ExtendSegmentToZ(t) {
    const e = t.Direction.dot(this.SweepDirection), i = (this.Z + 40 - t.Start.dot(this.SweepDirection)) / e;
    return v.mkPP(t.Start, t.Start.add(t.Direction.mul(i)));
  }
  //         internal ICurve ExtendSegmentToZPlus1(ConeSide segment) {
  //             double den = segment.Direction * SweepDirection;
  //             Assert.assert(Math.Abs(den) > GeomConstants.distanceEpsilon);
  //             double t = (Z + 1 - segment.start * SweepDirection) / den;
  //             return new LineSegment(segment.start, segment.start + segment.Direction * t);
  //         }
  // #endif
  GoOverConesSeeingVertexEvent(t) {
    let e = this.FindFirstSegmentInTheRightTreeNotToTheLeftOfVertex(t);
    if (e == null)
      return;
    const s = e.item.Cone, n = s.LeftSide;
    if (qt.VertexIsToTheLeftOfSegment(t, n))
      return;
    const r = [s];
    if (this.coneSideComparer.SetOperand(n), e = this.leftConeSides.find(n), e == null) {
      const o = this.Z;
      this.Z = Math.max(this.GetZP(n.Start), this.PreviousZ), this.coneSideComparer.SetOperand(n), e = this.leftConeSides.find(n), this.Z = o;
    }
    if (!(e == null && (e = this.GetRbNodeEmergency(n), e == null))) {
      for (e = this.leftConeSides.next(e); e != null && !qt.VertexIsToTheLeftOfSegment(t, e.item); )
        r.push(e.item.Cone), e = this.leftConeSides.next(e);
      for (const o of r)
        this.AddEdgeAndRemoveCone(o, t.Site);
    }
  }
  GetRbNodeEmergency(t) {
    if (this.leftConeSides.count === 0)
      return null;
    for (let e = this.leftConeSides.treeMinimum(); e != null; e = this.leftConeSides.next(e))
      if (e.item === t)
        return e;
    return null;
  }
  // #if TEST_MSAGL
  //             MessageId = "System.Int32.ToString")]
  //         internal static GeometryGraph CreateGraphFromObstacles(Array < Polyline > obstacles) {
  //             var gg = new GeometryGraph();
  //             foreach(var ob of obstacles) {
  //                 gg.Nodes.Add(new Node(ob.ToCurve()));
  //             }
  //             return gg;
  //         }
  //             "CA1303:Do not pass literals as localized parameters", MessageId = "System.Diagnostics.Debug.WriteLine(System.String)"
  //         )]
  //         void PrintOutLeftSegTree() {
  //             System.Diagnostics.Debug.WriteLine("Left cone segments########");
  //             foreach(var t of leftConeSides) {
  //                 var x = coneSideComparer.IntersectionOfSegmentAndSweepLine(t);
  //                 System.Diagnostics.Debug.WriteLine("{0} x={1}", t, x * DirectionPerp);
  //             }
  //             System.Diagnostics.Debug.WriteLine("##########end of left cone segments");
  //         }
  // #endif
  static VertexIsToTheLeftOfSegment(t, e) {
    return u.getTriangleOrientation(e.Start, e.Start.add(e.Direction), t.Site) === L.Counterclockwise;
  }
  static VertexIsToTheRightOfSegment(t, e) {
    return u.getTriangleOrientation(e.Start, e.Start.add(e.Direction), t.Site) === L.Clockwise;
  }
  FindFirstSegmentInTheRightTreeNotToTheLeftOfVertex(t) {
    return this.rightConeSides.findFirst((e) => !qt.VertexIsToTheRightOfSegment(t, e));
  }
  EnqueueRightVertexEvent(t) {
    this.GetZP(t.Site.sub(t.Vertex.prevOnPolyline.point)) > m.tolerance || this.EnqueueEvent(t);
  }
  invariant() {
    for (const t of this.leftConeSides)
      if (t.Removed)
        return !1;
    for (const t of this.rightConeSides)
      if (t.Removed)
        return !1;
    return !0;
  }
}
class Us extends ht {
  constructor(t, e) {
    super(null), this.coneAngle = Math.PI / 6, this.ports = new xt(), this._obstacles = Array.from(wt.OrientHolesClockwise(t)), this._visibilityGraph = e;
  }
  static mk(t, e, i, s, n) {
    const r = new Us(t, e);
    return r.Ports = s, r.BorderPolyline = n, r.ConeAngle = i, r;
  }
  get ConeAngle() {
    return this.coneAngle;
  }
  set ConeAngle(t) {
    this.coneAngle = t;
  }
  get Ports() {
    return this.ports;
  }
  set Ports(t) {
    this.ports = t;
  }
  get BorderPolyline() {
    return this.borderPolyline;
  }
  set BorderPolyline(t) {
    this.borderPolyline = t;
  }
  // If set to true then a smaller visibility graph is created.
  // An edge is added to the visibility graph only if it is found at least twice:
  // once sweeping with a direction d and the second time with -d
  get Bidirectional() {
    return this._bidirectional;
  }
  set Bidirectional(t) {
    this._bidirectional = t;
  }
  static GetTotalSteps(t) {
    return Math.floor((2 * Math.PI - t / 2) / t) + 1;
  }
  run() {
    const t = 2 * Math.PI - this.coneAngle / 2;
    if (this.Bidirectional)
      this.HandleBideractionalCase();
    else {
      let e;
      for (let i = 0; (e = this.coneAngle * i) <= t; i++)
        super.ProgressStep(), this.AddDirection(new u(Math.cos(e), Math.sin(e)), this.BorderPolyline, this._visibilityGraph);
    }
  }
  HandleBideractionalCase() {
    const t = Math.PI / this.coneAngle;
    for (let e = 0; e < t; e++) {
      const i = e * this.coneAngle, s = new wt();
      this.AddDirection(new u(Math.cos(i), Math.sin(i)), this.BorderPolyline, s);
      const n = new wt();
      this.AddDirection(new u(Math.cos(i) * -1, Math.sin(i) * -1), this.BorderPolyline, n), this.AddIntersectionOfBothDirectionSweepsToTheResult(s, n);
    }
  }
  AddIntersectionOfBothDirectionSweepsToTheResult(t, e) {
    for (const i of t.Edges)
      e.FindEdgePP(i.SourcePoint, i.TargetPoint) != null && this._visibilityGraph.AddEdgePP(i.SourcePoint, i.TargetPoint);
  }
  AddDirection(t, e, i) {
    qt.Sweep(this._obstacles, t, this.coneAngle, i, this.Ports, e);
  }
}
class $t extends oa {
  mk(t, e) {
    const i = new $t(t);
    return i.HookSize = e, i;
  }
  constructor(t) {
    super(), this.adjustmentAngle = Math.PI / 10, this.hookSize = 9, this.curve = t, this.location = this.curve().start;
  }
  // returns a point on the boundary curve
  get Location() {
    return this.location;
  }
  // Gets the boundary curve of the port.
  get Curve() {
    return this.curve();
  }
  SetLocation(t) {
    this.location = t;
  }
  // We are trying to correct the last segment of the polyline by make it perpendicular to the Port.Curve.
  // For this purpose we trim the curve by the cone of the angle 2*adjustment angle and project the point before the last of the polyline to this curve.
  get AdjustmentAngle() {
    return this.adjustmentAngle;
  }
  set AdjustmentAngle(t) {
    this.adjustmentAngle = t;
  }
  // the size of the self-loop
  get HookSize() {
    return this.hookSize;
  }
  set HookSize(t) {
    this.hookSize = t;
  }
}
class Ve extends Zi {
  get LoosePolyline() {
    return this.loosePolyline;
  }
  set LoosePolyline(t) {
    this.loosePolyline = t;
  }
  // constructor
  constructor(t, e, i = new u(0, 0)) {
    super(t, e, i);
  }
  // constructor
  static mk(t, e) {
    return new Ve(t, e);
  }
}
class Oe extends oa {
  get Location() {
    return this.curve.value(this.parameter);
  }
  set Location(t) {
    throw new Error("Method should not be called.");
  }
  // constructor
  static mk(t, e) {
    const i = new Oe();
    return i.curve = t, i.parameter = e, i;
  }
  get Parameter() {
    return this.parameter;
  }
  set Parameter(t) {
    this.parameter = t;
  }
  get Curve() {
    return this.curve;
  }
  set Curve(t) {
    this.curve = t;
  }
}
class Dt {
  constructor() {
    this.capacityOverflowCoefficient = Dt.DefaultCapacityOverflowCoefficientMultiplier, this.RotateBundles = !1, this.MaxHubRadius = 50, this.MinHubRadius = 0.1, this.CreateUnderlyingPolyline = !1, this.pathLengthImportance = Dt.DefaultPathLengthImportance, this.inkImportance = Dt.DefaultInkImportance, this.edgeSeparation = Dt.DefaultEdgeSeparation, this._edgeWidthShrinkCoeff = 1, this.useCubicBezierSegmentsInsideOfHubs = !1, this.angleThreshold = Math.PI / 180 * 45, this.hubRepulsionImportance = 100, this.bundleRepulsionImportance = 100, this.minimalRatioOfGoodCdtEdges = 0.9, this.highestQuality = !0, this.KeepOverlaps = !1, this.StopAfterShortestPaths = !1;
  }
  toJSON() {
    const t = {};
    return this.capacityOverflowCoefficient != Dt.DefaultCapacityOverflowCoefficientMultiplier && (t.capacityOverflowCoefficient = this.capacityOverflowCoefficient), this.RotateBundles && (t.RotateBundles = this.RotateBundles), this.MaxHubRadius != 50 && (t.MaxHubRadius = this.MaxHubRadius), this.MinHubRadius != 0.1 && (t.MinHubRadius = this.MinHubRadius), this.CreateUnderlyingPolyline && (t.CreateUnderlyingPolyline = this.CreateUnderlyingPolyline), this.pathLengthImportance != Dt.DefaultPathLengthImportance && (t.pathLengthImportance = this.pathLengthImportance), this.inkImportance != Dt.DefaultInkImportance && (t.inkImportance = this.inkImportance), this.edgeSeparation != Dt.DefaultEdgeSeparation && (t.edgeSeparation = this.edgeSeparation), this._edgeWidthShrinkCoeff != 1 && (t._edgeWidthShrinkCoeff = this._edgeWidthShrinkCoeff), this.useCubicBezierSegmentsInsideOfHubs && (t.useCubicBezierSegmentsInsideOfHubs = this.useCubicBezierSegmentsInsideOfHubs), this.angleThreshold != Math.PI / 180 * 45 && (t.angleThreshold = this.angleThreshold), this.hubRepulsionImportance != 100 && (t.hubRepulsionImportance = this.hubRepulsionImportance), this.bundleRepulsionImportance != 100 && (t.bundleRepulsionImportance = this.bundleRepulsionImportance), this.minimalRatioOfGoodCdtEdges != 0.9 && (t.minimalRatioOfGoodCdtEdges = this.minimalRatioOfGoodCdtEdges), this.highestQuality || (t.highestQuality = this.highestQuality), this.KeepOverlaps && (t.KeepOverlaps = this.KeepOverlaps), this.StopAfterShortestPaths && (t.StopAfterShortestPaths = this.StopAfterShortestPaths), t;
  }
  static createFromJSON(t) {
    const e = new Dt();
    return t.capacityOverflowCoefficient && (e.capacityOverflowCoefficient = t.capacityOverflowCoefficient), t.RotateBundles && (e.RotateBundles = t.RotateBundles), t.MaxHubRadius && (e.MaxHubRadius = t.MaxHubRadius), t.MinHubRadius && (e.MinHubRadius = t.MinHubRadius), t.CreateUnderlyingPolyline && (e.CreateUnderlyingPolyline = t.CreateUnderlyingPolyline), t.pathLengthImportance && (e.pathLengthImportance = t.pathLengthImportance), t.inkImportance && (e.inkImportance = t.inkImportance), t.edgeSeparation && (e.edgeSeparation = t.edgeSeparation), t._edgeWidthShrinkCoeff && (e._edgeWidthShrinkCoeff = t._edgeWidthShrinkCoeff), t.useCubicBezierSegmentsInsideOfHubs && (e.useCubicBezierSegmentsInsideOfHubs = t.useCubicBezierSegmentsInsideOfHubs), t.angleThreshold && (e.angleThreshold = t.angleThreshold), t.hubRepulsionImportance && (e.hubRepulsionImportance = t.hubRepulsionImportance), t.bundleRepulsionImportance && (e.bundleRepulsionImportance = t.bundleRepulsionImportance), t.minimalRatioOfGoodCdtEdges && (e.minimalRatioOfGoodCdtEdges = t.minimalRatioOfGoodCdtEdges), t.highestQuality && (e.HighestQuality = t.highestQuality), t.KeepOverlaps && (e.KeepOverlaps = t.KeepOverlaps), t.StopAfterShortestPaths && (e.StopAfterShortestPaths = t.StopAfterShortestPaths), e;
  }
  // this number is muliplied by the overflow penalty cost and by the sum of the LengthImportanceCoefficient
  // and InkImportanceCoefficient, and added to the routing price
  get CapacityOverflowCoefficient() {
    return this.capacityOverflowCoefficient;
  }
  set CapacityOverflowCoefficient(t) {
    this.capacityOverflowCoefficient = t;
  }
  // the importance of path lengths coefficient
  get PathLengthImportance() {
    return this.pathLengthImportance;
  }
  set PathLengthImportance(t) {
    this.pathLengthImportance = t;
  }
  get InkImportance() {
    return this.inkImportance;
  }
  set InkImportance(t) {
    this.inkImportance = t;
  }
  /** Separation between the neighbor edges within a bundle */
  get EdgeSeparation() {
    return this.edgeSeparation;
  }
  set EdgeSeparation(t) {
    this.edgeSeparation = t;
  }
  get edgeWidthShrinkCoeff() {
    return this._edgeWidthShrinkCoeff;
  }
  set edgeWidthShrinkCoeff(t) {
    this._edgeWidthShrinkCoeff = t;
  }
  ActualEdgeWidth(t, e = this.edgeWidthShrinkCoeff) {
    return e * (this.edgeSeparation + t.lineWidth);
  }
  // if is set to true will be using Cubic Bezie Segments inside of hubs, otherwise will be using Biarcs
  get UseCubicBezierSegmentsInsideOfHubs() {
    return this.useCubicBezierSegmentsInsideOfHubs;
  }
  set UseCubicBezierSegmentsInsideOfHubs(t) {
    this.useCubicBezierSegmentsInsideOfHubs = t;
  }
  // 45 degrees;
  // min angle for gluing edges
  get AngleThreshold() {
    return this.angleThreshold;
  }
  set AngleThreshold(t) {
    this.angleThreshold = t;
  }
  // the importance of hub repulsion coefficient
  get HubRepulsionImportance() {
    return this.hubRepulsionImportance;
  }
  set HubRepulsionImportance(t) {
    this.hubRepulsionImportance = t;
  }
  // the importance of bundle repulsion coefficient
  get BundleRepulsionImportance() {
    return this.bundleRepulsionImportance;
  }
  set BundleRepulsionImportance(t) {
    this.bundleRepulsionImportance = t;
  }
  // minimal ration of cdt edges with satisfied capacity needed to perform bundling
  // (otherwise bundling will not be executed)
  get MinimalRatioOfGoodCdtEdges() {
    return this.minimalRatioOfGoodCdtEdges;
  }
  set MinimalRatioOfGoodCdtEdges(t) {
    this.minimalRatioOfGoodCdtEdges = t;
  }
  // speed vs quality of the drawing
  get HighestQuality() {
    return this.highestQuality;
  }
  set HighestQuality(t) {
    this.highestQuality = t;
  }
}
Dt.DefaultCapacityOverflowCoefficientMultiplier = 1e3;
Dt.DefaultPathLengthImportance = 500;
Dt.DefaultInkImportance = 0.01;
Dt.DefaultEdgeSeparation = 0.5;
class Do extends qs {
  get BoundaryCurve() {
    return this.node.boundaryCurve;
  }
  set BoundaryCurve(t) {
    if (t)
      throw new Error("Cannot set BoundaryCurve directly for RelativeShape");
  }
  // Constructor taking the ID and the curve delegate for the shape.
  constructor(t) {
    super(null), this.node = t;
  }
}
class ze {
  static GetShapes(t, e) {
    const i = /* @__PURE__ */ new Map();
    for (const s of t)
      ze.ProcessAncestorDescendantCouple(s.target, s.source, i), ze.InsertEdgePortsToShapes(i, s);
    for (const s of e)
      ze.ProcessAncestorDescendantCouple(s.source, s.target, i), ze.InsertEdgePortsToShapes(i, s);
    return ze.BindShapes(i), Array.from(i.values());
  }
  static InsertEdgePortsToShapes(t, e) {
    t.get(e.target).Ports.add(e.targetPort), t.get(e.source).Ports.add(e.sourcePort);
  }
  static BindShapes(t) {
    for (const [e, i] of t) {
      if (!(e instanceof Nt))
        continue;
      const s = e;
      for (const n of mo(s)) {
        const r = t.get(n);
        r && i.AddChild(r);
      }
    }
  }
  static ProcessAncestorDescendantCouple(t, e, i) {
    let s = ir(e);
    do {
      for (const n of mo(s))
        ze.CreateShapeIfNeeeded(n, i);
      if (s === t)
        break;
      s = ir(s);
    } while (!0);
    ze.CreateShapeIfNeeeded(s, i);
  }
  static CreateShapeIfNeeeded(t, e) {
    e.has(t) || e.set(t, new Do(t));
  }
  static NumberOfActiveNodesIsUnderThreshold(t, e, i) {
    const s = /* @__PURE__ */ new Set();
    for (const n of t)
      if (ze.SetOfActiveNodesIsLargerThanThreshold(n.target, n.source, s, i))
        return !1;
    for (const n of e)
      if (ze.SetOfActiveNodesIsLargerThanThreshold(n.source, n.target, s, i))
        return !1;
    return !0;
  }
  static SetOfActiveNodesIsLargerThanThreshold(t, e, i, s) {
    let n = ir(e);
    for (; ; ) {
      for (const r of mo(n))
        if (i.add(r), i.size > s)
          return !0;
      if (n === t)
        break;
      n = ir(n);
    }
    return i.add(n), i.size > s;
  }
}
function ir(a) {
  const t = a.node.parent;
  return $.getGeom(t);
}
function* mo(a) {
  for (const t of a.graph.shallowNodes)
    yield $.getGeom(t);
}
class Xe {
  constructor(t) {
    this.stamp = 0, this.SetPivotAndAllocateHullPointsArray(t);
  }
  SetPivotAndAllocateHullPointsArray(t) {
    this.pivot = new u(0, Number.MAX_SAFE_INTEGER);
    let e = -1, i = 0;
    for (const s of t)
      s.y < this.pivot.y ? (this.pivot = s, e = i) : s.y === this.pivot.y && s.x > this.pivot.x && (this.pivot = s, e = i), i++;
    if (i >= 1) {
      this.hullPoints = new Array(i - 1), i = 0;
      for (const s of t)
        i !== e ? this.hullPoints[i++] = {
          point: s,
          deleted: !1,
          stamp: this.stamp++
        } : e = -1;
    }
  }
  get StackTopPoint() {
    return this.stack.point;
  }
  get StackSecondPoint() {
    return this.stack.next.point;
  }
  // calculates the convex hull of the given set of points
  static *CalculateConvexHull(t) {
    const e = new Xe(t);
    for (const i of e.Calculate())
      yield i;
  }
  *Calculate() {
    if (this.pivot.y !== Number.MAX_SAFE_INTEGER) {
      if (this.hullPoints.length === 0) {
        yield this.pivot;
        return;
      }
      this.SortAllPointsWithoutPivot(), this.Scan();
      for (const t of this.EnumerateStack())
        yield t;
    }
  }
  *EnumerateStack() {
    let t = this.stack;
    for (; t != null; )
      yield t.point, t = t.next;
  }
  Scan() {
    let t = 0;
    for (; this.hullPoints[t].deleted; )
      t++;
    for (this.stack = { point: this.pivot, next: null }, this.Push(t++), t < this.hullPoints.length && (this.hullPoints[t].deleted ? t++ : this.Push(t++)); t < this.hullPoints.length; )
      this.hullPoints[t].deleted ? t++ : this.LeftTurn(t) ? this.Push(t++) : this.Pop();
    for (; this.StackHasMoreThanTwoPoints() && !this.LeftTurnToPivot(); )
      this.Pop();
  }
  LeftTurnToPivot() {
    return u.getTriangleOrientation(this.StackSecondPoint, this.StackTopPoint, this.pivot) === L.Counterclockwise;
  }
  StackHasMoreThanTwoPoints() {
    return this.stack.next != null && this.stack.next.next != null;
  }
  Pop() {
    this.stack = this.stack.next;
  }
  LeftTurn(t) {
    if (this.stack.next == null)
      return !0;
    const e = u.getTriangleOrientationWithIntersectionEpsilon(this.StackSecondPoint, this.StackTopPoint, this.hullPoints[t].point);
    return e === L.Counterclockwise ? !0 : e === L.Clockwise ? !1 : this.BackSwitchOverPivot(this.hullPoints[t].point);
  }
  BackSwitchOverPivot(t) {
    return this.stack.next.next != null ? !1 : this.StackTopPoint.x > this.pivot.x + m.distanceEpsilon && t.x < this.pivot.x - m.distanceEpsilon;
  }
  Push(t) {
    this.stack = { point: this.hullPoints[t].point, next: this.stack };
  }
  SortAllPointsWithoutPivot() {
    this.hullPoints.sort(Wd(this.pivot));
  }
  static createConvexHullAsClosedPolyline(t) {
    return B.mkClosedFromPoints(Array.from(Xe.CalculateConvexHull(t)));
  }
}
function Wd(a) {
  return (t, e) => {
    if (t === e)
      return 0;
    if (t == null)
      return -1;
    if (e == null)
      return 1;
    switch (u.getTriangleOrientationWithIntersectionEpsilon(a, t.point, e.point)) {
      case L.Counterclockwise:
        return -1;
      case L.Clockwise:
        return 1;
      case L.Collinear:
        const i = t.point.x - a.x, s = e.point.x - a.x;
        if (i > m.distanceEpsilon && s < -m.distanceEpsilon)
          return -1;
        if (i < -m.distanceEpsilon && s > m.distanceEpsilon)
          return 1;
        const n = t.point.sub(a), r = e.point.sub(a), o = n.l1 - r.l1;
        return o < 0 ? (t.deleted = !0, -1) : o > 0 ? (e.deleted = !0, 1) : (t.stamp > e.stamp ? t.deleted = !0 : e.deleted = !0, 0);
    }
    throw new Error();
  };
}
function ae(a, t, e) {
  a.irect.intersects_rect(t.irect) && (a.Left == null ? t.Left == null ? e(a.UserData, t.UserData) : (ae(a, t.Left, e), ae(a, t.Right, e)) : t.Left != null ? (ae(a.Left, t.Left, e), ae(a.Left, t.Right, e), ae(a.Right, t.Left, e), ae(a.Right, t.Right, e)) : (ae(a.Left, t, e), ae(a.Right, t, e)));
}
function Xt(a, t, e) {
  a.irect.intersects_rect(t.irect) && (a === t ? zd(a, e) : a.Left == null ? t.Left == null ? e(a.UserData, t.UserData) : (Xt(a, t.Left, e), Xt(a, t.Right, e)) : t.Left != null ? (Xt(a.Left, t.Left, e), Xt(a.Left, t.Right, e), Xt(a.Right, t.Left, e), Xt(a.Right, t.Right, e)) : (Xt(a.Left, t, e), Xt(a.Right, t, e)));
}
function xe(a, t, e) {
  if (!a.irect.intersects_rect(t.irect))
    return !1;
  if (a === t)
    return Hd(a, e);
  if (a.Left == null) {
    if (t.Left == null)
      return e(a.UserData, t.UserData);
    if (xe(a, t.Left, e) || xe(a, t.Right, e))
      return !0;
  } else if (t.Left != null) {
    if (xe(a.Left, t.Left, e) || xe(a.Left, t.Right, e) || xe(a.Right, t.Left, e) || xe(a.Right, t.Right, e))
      return !0;
  } else if (xe(a.Left, t, e) || xe(a.Right, t, e))
    return !0;
  return !1;
}
function Hd(a, t) {
  return a.Left == null ? !1 : xe(a.Left, a.Left, t) || xe(a.Left, a.Right, t) || xe(a.Right, a.Right, t);
}
function zd(a, t) {
  a.Left != null && (Xt(a.Left, a.Left, t), Xt(a.Left, a.Right, t), Xt(a.Right, a.Right, t));
}
const $a = BigInt("6364136223846793005"), Po = (BigInt(1) << BigInt(32)) - BigInt(1), Si = (BigInt(1) << BigInt(64)) - BigInt(1);
class $r {
  /**
   * A PRNG class. Provides two main methods:
   *
   * - `random` - Produces a "continuous" standard uniform distribution.
   * - `randint` - Produces a discrete uniform distribution.
   *
   * For more details, check the individual methods.
   *
   * @param initState The seed to initialise the state of the generator.
   * @param initSequence The seed to initialise the sequence number of the
   * generator.
   */
  // The state and sequence are stored as bigints, but anything that is
  // coercible to a bigint should be a valid seed.
  constructor(t, e) {
    this._state = BigInt(0), this._inc = (BigInt(e) << BigInt(1) | BigInt(1)) & Si, this._random_b(), this._state = this._state + BigInt(t) & Si, this._random_b();
  }
  /**
   * This is the source of randomness for all other random methods.
   *
   * Produces a uniformly distributed 32-bit unsigned integer as a bigint.
   *
   * Although the produced number is 32 bits; the implementation requires that
   * the state of the generator be a 64 bit unsigned integer. Since the js
   * Number datatype cannot reliably handle integers that large, we use the
   * BigInt class for the calculation.
   */
  _random_b() {
    const t = this._state;
    this._state = t * $a + this._inc & Si;
    const e = (t >> BigInt(18) ^ t) >> BigInt(27), i = t >> BigInt(59), s = i ^ BigInt(31);
    return (e >> i | e << s) & Po;
  }
  /**
   * Advances the internal state of the generator `delta` steps. Delta can be
   * negative to reverse.
   *
   * This is calculated in a very similar way to the square and multiply method
   * for taking the power of a number. As you may expect, it is calculated in
   * log(delta) time.
   */
  _advance(t) {
    t &= Si;
    let e = BigInt(1), i = $a, s = BigInt(0), n = this._inc;
    for (; t > 0; )
      t & BigInt(1) && (e = e * i & Si, s = s * i + n & Si), n = (i + BigInt(1)) * n & Si, i = i * i & Si, t >>= BigInt(1);
    this._state = e * this._state + s & Si;
  }
  /**
   * Produces a uniformly distributed integer, r, with 0  r < bound.
   *
   * To produce a uniformly distributed integer in the range [low, high):
   *
   * ```js
   * const i = low + rand.randint(high - low)
   * ```
   *
   * @param bound The lower bound for the number.
   */
  randint(t) {
    if (t > Po)
      throw new TypeError(`Bound too large: ${t}`);
    if (t <= 0)
      throw new TypeError(`Empty sample space for r: 0  r < ${t}`);
    const e = BigInt(t), i = (Po ^ e) % e;
    for (; ; ) {
      const s = this._random_b();
      if (s >= i)
        return Number(s % e);
    }
  }
  /**
   * Generates an approximately uniformly distributed number, r, with 0  r < 1.
   *
   * @returns The number r.
   */
  random() {
    return Number(this._random_b()) / Math.pow(2, 32);
  }
}
let gs;
function Xs(a) {
  return gs == null && (gs = new $r(0, 0)), gs.randint(a);
}
function to(a) {
  gs = new $r(a, 0);
}
function Cs() {
  return gs == null && (gs = new $r(0, 0)), gs.random();
}
function* Qs(a) {
  const t = new Array(a.nodeCount).fill(!1), e = new We.Queue();
  for (let i = 0; i < a.nodeCount; i++)
    if (!t[i]) {
      const s = new Array();
      for (tl(i, e, t); e.length > 0; ) {
        const n = e.dequeue();
        s.push(n);
        for (const r of jd(a, n))
          tl(r, e, t);
      }
      yield s;
    }
}
function* jd(a, t) {
  for (const e of a.outEdges[t])
    yield e.target;
  for (const e of a.inEdges[t])
    yield e.source;
}
function tl(a, t, e) {
  e[a] === !1 && (t.enqueue(a), e[a] = !0);
}
function Nr(a) {
  const t = new te();
  return t.SetEdges(a, te.vertexCount(a)), t;
}
function kh(a) {
  const t = new te();
  return t.SetEdges(a, te.vertexCount(a)), t;
}
function fi(a, t) {
  const e = new te();
  return e.SetEdges(a, t), e;
}
class te {
  constructor() {
    this.nodeCount = 0;
  }
  *incidentEdges(t) {
    for (const e of this.outEdges[t])
      yield e;
    for (const e of this.inEdges[t])
      yield e;
  }
  static deleteFromArray(t, e) {
    const i = t.indexOf(e, 0);
    i > -1 && t.splice(i, 1);
  }
  // the method is not efficient, takes linear time
  removeEdge(t) {
    te.deleteFromArray(this.edges, t), t.source !== t.target ? (te.deleteFromArray(this.outEdges[t.source], t), te.deleteFromArray(this.inEdges[t.target], t)) : te.deleteFromArray(this.selfEdges[t.source], t);
  }
  // This method should be static be
  // finds the maximum of sources and targets, and return it incremented by 1
  static vertexCount(t) {
    let e = 0;
    for (const i of t)
      i.source >= e && (e = i.source), i.target >= e && (e = i.target);
    return ++e;
  }
  // sets edges of the graph
  SetEdges(t, e) {
    this.edges = t, this.nodeCount = e;
    const i = new Array(this.nodeCount).fill(0), s = new Array(this.nodeCount).fill(0), n = new Array(this.nodeCount).fill(0);
    this.outEdges = new Array(this.nodeCount), this.inEdges = new Array(this.nodeCount), this.selfEdges = new Array(this.nodeCount);
    for (const r of this.edges)
      r.source !== r.target ? (i[r.source]++, s[r.target]++) : n[r.source]++;
    for (let r = 0; r < this.nodeCount; r++)
      this.outEdges[r] = new Array(i[r]), i[r] = 0, this.inEdges[r] = new Array(s[r]), s[r] = 0, this.selfEdges[r] = new Array(n[r]), n[r] = 0;
    for (const r of this.edges) {
      const o = r.source, l = r.target;
      o !== l ? (this.outEdges[o][i[o]++] = r, this.inEdges[l][s[l]++] = r) : this.selfEdges[o][n[o]++] = r;
    }
  }
  inEdgesCount(t) {
    return this.inEdges[t].length;
  }
  outEdgesCount(t) {
    return this.outEdges[t].length;
  }
  selfEdgesCount(t) {
    return this.selfEdges[t].length;
  }
  addEdge(t) {
    this.edges.push(t), t.source !== t.target ? (this.outEdges[t.source].push(t), this.inEdges[t.target].push(t)) : this.selfEdges[t.source].push(t);
  }
  // We assume that the graph is connected here
  *nodesOfConnectedGraph() {
    if (this.edges.length === 0)
      return;
    const t = /* @__PURE__ */ new Set(), e = new We.Queue();
    let i = this.edges[0].source;
    for (te.enqueue(t, e, i), yield i; e.length > 0; ) {
      i = e.dequeue();
      for (const s of this.outEdges[i]) {
        const n = s.target;
        t.has(n) || (te.enqueue(t, e, n), yield n);
      }
      for (const s of this.inEdges[i]) {
        const n = s.source;
        t.has(n) || (te.enqueue(t, e, n), yield n);
      }
    }
  }
  *pred(t) {
    for (const e of this.inEdges[t])
      yield e.source;
  }
  *succ(t) {
    for (const e of this.outEdges[t])
      yield e.target;
  }
  static enqueue(t, e, i) {
    e.enqueue(i), t.add(i);
  }
}
var Mt;
(function(a) {
  a[a.Increasing = 0] = "Increasing", a[a.Decreasing = 1] = "Decreasing", a[a.Extremum = 2] = "Extremum";
})(Mt || (Mt = {}));
class sr {
  // the sequence values
  get Sequence() {
    return this.f;
  }
  set Sequence(t) {
    this.f = t;
  }
  // the length of the sequence: the sequence starts from 0
  get Length() {
    return this.length;
  }
  set Length(t) {
    this.length = t;
  }
  constructor(t, e) {
    this.f = t, this.length = e;
  }
  FindMinimum() {
    let t = 0, e = this.length - 1, i = t + Math.floor((e - t) / 2);
    const s = this.f(i);
    if (s >= this.f(0) && s >= this.f(this.length - 1))
      return this.f(0) < this.f(this.length - 1) ? 0 : this.length - 1;
    for (; e - t > 1; )
      switch (i = t + Math.floor((e - t) / 2), this.BehaviourAtIndex(i)) {
        case Mt.Decreasing:
          t = i;
          break;
        case Mt.Increasing:
          e = i;
          break;
        case Mt.Extremum:
          return i;
      }
    return t === e || this.f(t) <= this.f(e) ? t : e;
  }
  BehaviourAtIndex(t) {
    const e = this.f(t);
    if (t === 0) {
      const n = this.f(1);
      return n === e ? Mt.Extremum : n > e ? Mt.Increasing : Mt.Decreasing;
    }
    if (t === this.length - 1) {
      const n = this.f(this.length - 2);
      return n === e ? Mt.Extremum : n > e ? Mt.Decreasing : Mt.Increasing;
    }
    const i = e - this.f(t - 1), s = this.f(t + 1) - e;
    return i * s <= 0 ? Mt.Extremum : i > 0 ? Mt.Increasing : Mt.Decreasing;
  }
  FindMaximum() {
    let t = 0, e = this.length - 1, i = t + Math.floor((e - t) / 2);
    const s = this.f(i);
    if (s <= this.f(0) && s <= this.f(this.length - 1))
      return this.f(0) > this.f(this.length - 1) ? 0 : this.length - 1;
    for (; e - t > 1; )
      switch (i = t + Math.floor((e - t) / 2), this.BehaviourAtIndex(i)) {
        case Mt.Decreasing:
          e = i;
          break;
        case Mt.Increasing:
          t = i;
          break;
        case Mt.Extremum:
          return i;
      }
    return t === e || this.f(t) >= this.f(e) ? t : e;
  }
}
class qd {
  toArray() {
    const t = [];
    for (let e = 0; e < this.length; e++)
      t.push(this.f(e));
    return t;
  }
  constructor(t, e) {
    this.f = t, this.length = e;
  }
  GetAdjustedSequenceForMinimum() {
    const t = this.f(0), i = (this.f(this.length - 1) - t) / (this.length - 1);
    return (s) => Math.min(this.f(s), t + i * s);
  }
  GetAdjustedSequenceForMaximum() {
    const t = this.f(0), i = (this.f(this.length - 1) - t) / (this.length - 1);
    return (s) => Math.max(this.f(s), t + i * s);
  }
  // following Chazelle, Dobkin
  FindMinimum() {
    return this.f(0) === this.f(this.length - 1) ? new sr(this.f, this.length).FindMinimum() : new sr(this.GetAdjustedSequenceForMinimum(), this.length).FindMinimum();
  }
  FindMaximum() {
    return this.f(0) === this.f(this.length - 1) ? new sr(this.f, this.length).FindMaximum() : new sr(this.GetAdjustedSequenceForMaximum(), this.length).FindMaximum();
  }
}
class eo {
  constructor(t, e) {
    this.P = t, this.Q = e;
  }
  LeftFromLineOnP(t, e, i) {
    const s = this.P.pnt(t);
    return this.upperBranchOnP ? u.pointToTheLeftOfLineOrOnLine(i, s, e) : u.pointToTheRightOfLineOrOnLine(i, s, e);
  }
  LeftFromLineOnQ(t, e, i) {
    const s = this.Q.pnt(t);
    return this.lowerBranchOnQ ? u.pointToTheLeftOfLineOrOnLine(i, s, e) : u.pointToTheRightOfLineOrOnLine(i, s, e);
  }
  PrevOnP(t) {
    return this.upperBranchOnP ? this.P.Prev(t) : this.P.Next(t);
  }
  PrevOnQ(t) {
    return this.lowerBranchOnQ ? this.Q.Prev(t) : this.Q.Next(t);
  }
  NextOnP(t) {
    return this.upperBranchOnP ? this.P.Next(t) : this.P.Prev(t);
  }
  NextOnQ(t) {
    return this.lowerBranchOnQ ? this.Q.Next(t) : this.Q.Prev(t);
  }
  MedianOnP(t, e) {
    return this.upperBranchOnP ? this.P.Median(t, e) : this.P.Median(e, t);
  }
  MedianOnQ(t, e) {
    return this.lowerBranchOnQ ? this.Q.Median(t, e) : this.Q.Median(e, t);
  }
  ModuleP(t, e) {
    return this.upperBranchOnP ? this.P.Module(e - t) : this.P.Module(t - e);
  }
  ModuleQ(t, e) {
    return this.lowerBranchOnQ ? this.Q.Module(e - t) : this.Q.Module(t - e);
  }
  // we pretend here that the branches go clockwise from p0 to p1, and from q0 to q1
  TangentBetweenBranches(t, e, i, s) {
    for (; e !== t || s !== i; ) {
      const n = e !== t ? this.MedianOnP(t, e) : t, r = s !== i ? this.MedianOnQ(i, s) : i, o = this.P.pnt(n), l = this.Q.pnt(r);
      let h = !0;
      this.ModuleP(t, e) > 1 ? this.LeftFromLineOnP(this.NextOnP(n), o, l) ? t = n : this.LeftFromLineOnP(this.PrevOnP(n), o, l) ? e = n : h = !1 : e !== t ? this.LeftFromLineOnP(e, this.P.pnt(t), l) ? t = e : this.LeftFromLineOnP(t, this.P.pnt(e), l) ? e = t : h = !1 : h = !1;
      let c = !0;
      this.ModuleQ(i, s) > 1 ? this.LeftFromLineOnQ(this.NextOnQ(r), l, o) ? i = r : this.LeftFromLineOnQ(this.PrevOnQ(r), l, o) ? s = r : c = !1 : s !== i ? this.LeftFromLineOnQ(s, this.Q.pnt(i), o) ? i = s : this.LeftFromLineOnQ(i, this.Q.pnt(s), o) ? s = i : c = !1 : c = !1, !h && !c && (t = n, e = n, i = r, s = r);
    }
    return [t, s];
  }
  // following the paper of Edelsbrunner
  FindDividingBisector(t) {
    const e = {
      pClosest: void 0,
      qClosest: void 0,
      p1: void 0,
      p2: void 0,
      q1: void 0,
      q2: void 0
    };
    this.FindClosestFeatures(e), t.bisectorPivot = u.middle(e.pClosest, e.qClosest), t.bisectorRay = e.pClosest.sub(e.qClosest).rotate(Math.PI / 2), t.p1 = e.p1, t.p2 = e.p2, t.q1 = e.q1, t.q2 = e.q2;
  }
  FindClosestPoints() {
    const t = {
      q2: void 0,
      p1: void 0,
      p2: void 0,
      q1: void 0,
      pClosest: void 0,
      qClosest: void 0
    };
    return this.FindClosestFeatures(t), { pClosest: t.pClosest, qClosest: t.qClosest };
  }
  FindClosestFeatures(t) {
    const e = {
      leftTangentPoint: void 0,
      rightTangentPoint: void 0
    };
    this.P.GetTangentPoints(e, this.Q.pp(0).point), t.p2 = e.leftTangentPoint, t.p1 = e.rightTangentPoint, t.p2 === t.p1 && (t.p2 += this.P.count), this.Q.GetTangentPoints(e, this.P.pp(0).point), t.q1 = e.leftTangentPoint, t.q2 = e.rightTangentPoint, t.q2 === t.q1 && (t.q2 += this.Q.count), this.FindClosestPoints_(t);
  }
  //chunks go clockwise from p1 to p2 and from q2 to q1
  FindClosestPoints_(t) {
    for (; this.ChunksAreLong(t.p2, t.p1, t.q2, t.q1); )
      this.ShrinkChunks(t);
    t.p1 === t.p2 ? (t.pClosest = this.P.pp(t.p2).point, t.q1 === t.q2 ? t.qClosest = this.Q.pp(t.q1).point : (t.qClosest = u.ClosestPointAtLineSegment(t.pClosest, this.Q.pp(t.q1).point, this.Q.pp(t.q2).point), u.closeDistEps(t.qClosest, this.Q.pnt(t.q1)) ? t.q2 = t.q1 : u.closeDistEps(t.qClosest, this.Q.pnt(t.q2)) && (t.q1 = t.q2))) : (t.qClosest = this.Q.pp(t.q1).point, t.pClosest = u.ClosestPointAtLineSegment(t.qClosest, this.P.pp(t.p1).point, this.P.pp(t.p2).point), u.closeDistEps(t.pClosest, this.P.pnt(t.p1)) ? t.p2 = t.p1 : u.closeDistEps(t.qClosest, this.P.pnt(t.p2)) && (t.p1 = t.p2));
  }
  ChunksAreLong(t, e, i, s) {
    const n = this.P.Module(t - e) + 1;
    if (n > 2)
      return !0;
    const r = this.Q.Module(s - i) + 1;
    return r > 2 || n === 2 && r === 2;
  }
  ShrinkChunks(t) {
    const e = t.p1 === t.p2 ? t.p1 : this.P.Median(t.p1, t.p2), i = t.q1 === t.q2 ? t.q1 : this.Q.Median(t.q2, t.q1), s = this.P.pp(e).point, n = this.Q.pp(i).point, r = {
      a1: void 0,
      a2: void 0,
      b1: void 0,
      b2: void 0
    };
    if (this.GetAnglesAtTheMedian(e, i, s, n, r), !this.InternalCut(t, e, i, r.a1, r.a2, r.b1, r.b2) && !eo.OneOfChunksContainsOnlyOneVertex(t, e, i, r.a1, r.b1) && !this.OnlyOneChunkContainsExactlyTwoVertices(t, { mp: e, mq: i }, r)) {
      if (t.p2 === this.P.Next(t.p1) && t.q1 === this.Q.Next(t.q2)) {
        const o = v.minDistBetweenLineSegments(this.P.pnt(t.p1), this.P.pnt(t.p2), this.Q.pnt(t.q1), this.Q.pnt(t.q2));
        o.parab === 0 ? t.p2 = t.p1 : o.parab === 1 ? t.p1 = t.p2 : o.parcd === 0 ? t.q2 = t.q1 : o.parcd === 1 && (t.q1 = t.q2);
        return;
      }
      r.a1 <= Math.PI && r.a2 <= Math.PI && r.b1 <= Math.PI && r.b2 <= Math.PI ? r.a1 + r.b1 > Math.PI ? r.a1 >= Math.PI / 2 ? t.p1 = e : t.q1 = i : r.a2 >= Math.PI / 2 ? t.p2 = e : t.q2 = i : r.a1 > Math.PI ? t.p1 = e : r.a2 > Math.PI ? t.p2 = e : r.b1 > Math.PI ? t.q1 = i : t.q2 = i;
    }
  }
  InternalCut(t, e, i, s, n, r, o) {
    let l = !1;
    if (s >= Math.PI && n >= Math.PI) {
      const h = this.P.pp(e).point, c = this.Q.pp(i).point, d = this.P.pp(this.P.Next(e)).point, f = u.getTriangleOrientation(h, c, this.Q.pp(0).point), p = u.getTriangleOrientation(h, c, d);
      f === p ? t.p1 = this.P.Next(e) : t.p2 = this.P.Prev(e), l = !0;
    }
    if (r >= Math.PI && o >= Math.PI) {
      const h = this.P.pp(e).point, c = this.Q.pp(i).point, d = this.Q.pp(this.Q.Next(i)).point, f = u.getTriangleOrientation(h, c, this.P.pp(0).point), p = u.getTriangleOrientation(h, c, d);
      f === p ? t.q2 = this.Q.Next(i) : t.q1 = this.Q.Prev(i), l = !0;
    }
    return l;
  }
  // void ProcessLeftSideOfTrapez(ref number p1, ref number p2, ref number q2, ref number q1) {
  //   //the closest vertex is on the left side
  //   Point pn1 = P.Pnt(p1); Point pn2 = P.Pnt(p2);
  //   Point qn1 = Q.Pnt(q1); Point qn2 = Q.Pnt(q2);
  //  //SugiyamaLayoutSettings.Show(new LineSegment(pn1, pn2), new LineSegment(pn2, qn2), new LineSegment(qn2, qn1), new LineSegment(qn1, pn1));
  //   number ap1 = Point.angle(pn2, pn1, qn1);
  //   number aq1 = Point.angle(pn1, qn1, qn2);
  //   Assert.assert(ap1 + aq1 >= Math.PI);
  //   //the point is on the left side
  //   if (ap1 >= Math.PI / 2 && aq1 >= Math.PI / 2) {
  //       q2 = q1; //the vertices of the left side gives the solution
  //       p2 = p1;
  //   } else if (ap1 < Math.PI / 2) {
  //       q2 = q1;
  //       if (!Point.CanProject(qn1, pn1, pn2))
  //           p1 = p2;
  //   } else { //aq1<Pi/2
  //       p2 = p1;
  //       if (!Point.CanProject(pn1, qn1, qn2))
  //           q1 = q2;
  //   }
  //}
  GetAnglesAtTheMedian(t, e, i, s, n) {
    n.a1 = u.anglePCP(s, i, this.P.pnt(this.P.Prev(t))), n.a2 = u.anglePCP(this.P.pnt(this.P.Next(t)), i, s), n.b1 = u.anglePCP(this.Q.pnt(this.Q.Next(e)), s, i), n.b2 = u.anglePCP(i, s, this.Q.pnt(this.Q.Prev(e)));
  }
  // we know here that p1!=p2 and q1!=q2
  OnlyOneChunkContainsExactlyTwoVertices(t, e, i) {
    const s = t.p2 === this.P.Next(t.p1), n = t.q1 === this.Q.Next(t.q2);
    return s && !n ? (this.ProcessShortSide(t, e.mp, e.mq, i.a1, i.b1, i.a2, i.b2), !0) : n && !s ? (this.SwapEverything(t, e, i), this.ProcessShortSide(t, e.mp, e.mq, i.a1, i.b1, i.a2, i.b2), this.SwapEverything(t, e, i), !0) : !1;
  }
  SwapEverything(t, e, i) {
    this.SwapPq();
    let s = t.p2;
    t.p2 = t.q1, t.q1 = s, s = t.q2, t.q2 = t.p1, t.p1 = s, s = e.mq, e.mq = e.mp, e.mp = s, s = i.a2, i.a2 = i.b1, i.b1 = s, s = i.b2, i.b2 = i.a1, i.a1 = s;
  }
  ProcessShortSide(t, e, i, s, n, r, o) {
    e === t.p2 ? this.ProcessSide(t, i, s, n, o) : r <= Math.PI ? r + o >= Math.PI ? r >= Math.PI / 2 ? t.p2 = t.p1 : t.q2 = i : n >= Math.PI / 2 ? t.q1 = i : r < o && (u.canProject(this.Q.pnt(i), this.P.pp(t.p1).point, this.P.pp(t.p2).point) ? t.q1 = i : t.p1 = t.p2) : s + n <= Math.PI ? t.p1 = t.p2 : t.p2 = t.p1;
  }
  SwapPq() {
    const t = this.P;
    this.P = this.Q, this.Q = t;
  }
  ProcessSide(t, e, i, s, n) {
    const r = this.Q.pnt(e);
    i <= Math.PI ? i + s >= Math.PI ? i >= Math.PI / 2 ? t.p1 = t.p2 : t.q1 = e : n >= Math.PI / 2 ? t.q2 = e : i < n && (u.canProject(r, this.P.pp(t.p1).point, this.P.pp(t.p2).point) ? t.q2 = e : t.p2 = t.p1) : (t.p2 = t.p1, s >= Math.PI ? t.q1 = e : n >= Math.PI && (t.q2 = e));
  }
  static OneOfChunksContainsOnlyOneVertex(t, e, i, s, n) {
    return t.p1 === t.p2 ? (n >= Math.PI / 2 ? t.q1 = i : t.q2 = i, !0) : t.q1 === t.q2 ? (s >= Math.PI / 2 ? t.p1 = e : t.p2 = e, !0) : !1;
  }
  CalculateLeftTangents() {
    const t = {
      bisectorPivot: null,
      bisectorRay: null,
      p1: 0,
      p2: 0,
      q1: 0,
      q2: 0
    };
    this.FindDividingBisector(t);
    const e = this.P.FindTheFurthestVertexFromBisector(t.p1, t.p2, t.bisectorPivot, t.bisectorRay), i = this.Q.FindTheFurthestVertexFromBisector(t.q2, t.q1, t.bisectorPivot, t.bisectorRay);
    this.upperBranchOnP = !1, this.lowerBranchOnQ = !0, this.leftPLeftQ = this.TangentBetweenBranches(e, t.p1, i, t.q1), this.lowerBranchOnQ = !1, this.leftPRightQ = this.TangentBetweenBranches(e, t.p1, i, t.q2);
  }
  // bool QContains(number x ,number y) {
  //   foreach (Point p of Q.Polyline) {
  //       if (p.x === x && p.y === y)
  //           return true;
  //   }
  //   return false;
  //}
  //bool PContains(number x, number y) {
  //   foreach (Point p of P.Polyline) {
  //       if (p.x === x && p.y === y)
  //           return true;
  //   }
  //   return false;
  //}
  CalculateRightTangents() {
    const t = { bisectorPivot: null, bisectorRay: null, p1: 0, p2: 0, q1: 0, q2: 0 };
    this.FindDividingBisector(t);
    const e = this.P.FindTheFurthestVertexFromBisector(t.p1, t.p2, t.bisectorPivot, t.bisectorRay), i = this.Q.FindTheFurthestVertexFromBisector(t.q2, t.q1, t.bisectorPivot, t.bisectorRay);
    this.upperBranchOnP = !0, this.lowerBranchOnQ = !0, this.rightPLeftQ = this.TangentBetweenBranches(e, t.p2, i, t.q1), this.lowerBranchOnQ = !1, this.rightPRightQ = this.TangentBetweenBranches(e, t.p2, i, t.q2);
  }
}
class ue {
  static mkFromPoints(t) {
    return new ue(B.mkClosedFromPoints(t));
  }
  get Polyline() {
    return this.polyline;
  }
  constructor(t) {
    this.polyline = t, this.points = new Array();
    for (let e = this.polyline.startPoint; e; e = e.next)
      this.points.push(e);
  }
  Next(t) {
    return this.Module(t + 1);
  }
  Prev(t) {
    return this.Module(t - 1);
  }
  get count() {
    return this.Polyline.count;
  }
  Module(t) {
    return t < 0 ? t + this.count : t < this.count ? t : t - this.count;
  }
  pp(t) {
    return this.points[this.Module(t)];
  }
  // LineSegment ls(Point pivot, int p) {
  //    return new LineSegment(pivot, Pnt(p));
  // }
  pnt(t) {
    return this.pp(t).point;
  }
  toString() {
    return this.polyline.toString();
  }
  // the median of a chunk going clockwise from p1 to p2
  Median(t, e) {
    return e > t ? Math.floor((e + t) / 2) : this.Module(e + Math.floor((this.count + t) / 2));
  }
  // p1 and p2 represent the closest feature. Two cases are possible p1=p2, or p1 and p2 share an edge going from p1 to p2
  // Remind that the polygons are oriented clockwise
  FindTheFurthestVertexFromBisector(t, e, i, s) {
    let n = s.rotate(Math.PI / 2);
    this.polyline.startPoint.point.sub(i).dot(n) < 0 && (n = n.mul(-1)), t === e && (e = this.Next(t));
    do {
      const r = this.Median(e, t), o = this.pnt(r);
      this.pnt(this.Next(r)).sub(o).dot(n) >= 0 ? e = this.Next(r) : this.pnt(this.Prev(r)).sub(o).dot(n) >= 0 ? t = this.Prev(r) : e = r, t = r;
    } while (t !== e);
    return t;
  }
  static TestPolygonDist(t, e) {
    let i = Number.MAX_SAFE_INTEGER;
    for (let s = 0; s < t.count; s++)
      for (let n = 0; n < e.count; n++) {
        const r = v.minDistBetweenLineSegments(t.pnt(s), t.pnt(s + 1), e.pnt(n), e.pnt(n + 1));
        i = Math.min(i, r.dist);
      }
    return i;
  }
  // Distance between two polygons
  // p and q are the closest points
  // The function doesn't work if the polygons intersect each other
  static Distance(t, e) {
    const s = new eo(t, e).FindClosestPoints();
    return {
      p: s.pClosest,
      q: s.qClosest,
      dist: s.pClosest.sub(s.qClosest).length
    };
  }
  // Distance between two polygons
  static DistanceOnly(t, e) {
    return ue.Distance(t, e).dist;
  }
  static PolygonIsLegalDebug(t) {
    const e = t.Polyline;
    for (let i = e.startPoint; i.next != null && i.next.next != null; i = i.next)
      if (u.getTriangleOrientation(i.point, i.next.point, i.next.next.point) === L.Collinear)
        return !1;
    return !0;
  }
  // Distance between polygon and point, assuming the point is outside of the polygon
  static DistancePoint(t, e) {
    let i = Number.MAX_VALUE;
    for (let s = 0; s < t.count; s++) {
      const n = u.distToLineSegment(e, t.points[s].point, t.points[(s + 1) % t.count].point).dist;
      i = Math.min(i, n);
    }
    return i;
  }
  GetTangentPoints(t, e) {
    const i = new qd(this.GetSequenceDelegate(e), this.count);
    t.leftTangentPoint = i.FindMaximum(), t.rightTangentPoint = i.FindMinimum();
  }
  GetSequenceDelegate(t) {
    const e = this.pnt(0);
    return (i) => {
      const s = u.anglePCP(e, t, this.pnt(i));
      return s < Math.PI ? s : s - 2 * Math.PI;
    };
  }
}
class G {
  ObstaclesIntersectLine(t, e) {
    return this.ObstaclesIntersectICurve(v.mkPP(t, e));
  }
  static PadCorner(t, e, i, s, n) {
    const r = G.GetPaddedCorner(e, i, s, n);
    return r.numberOfPoints === -1 ? !1 : (t.addPoint(r.a), r.numberOfPoints === 2 && t.addPoint(r.b), !0);
  }
  static CurveIsClockwise(t, e) {
    return u.getTriangleOrientation(e, t.start, t.start.add(t.derivative(t.parStart))) == L.Clockwise;
  }
  static PaddedPolylineBoundaryOfNode(t, e, i = !1) {
    return G.CreatePaddedPolyline(g.polylineAroundClosedCurve(t), e, i);
  }
  /** surrounds the given polyline with the given offset, optionally randomizes the output */
  static LoosePolylineWithFewCorners(t, e, i) {
    return e < m.distanceEpsilon ? t : G.CreateLoosePolylineOnBisectors(t, e, i);
  }
  static CreateLoosePolylineOnBisectors(t, e, i) {
    const s = Array.from(G.BisectorPoints(t, e));
    i && r();
    const n = Xe.CalculateConvexHull(s);
    return B.mkClosedFromPoints(n);
    function r() {
      for (let o = 0; o < s.length; o++) {
        const l = s[o];
        s[o] = new u(l.x + (2 * Cs() - 1) * i, l.y + (2 * Cs() - 1) * i);
      }
    }
  }
  static CreateRectNodeOfPolyline(t) {
    return Bt(t, t.boundingBox);
  }
  CreateLooseObstacles() {
    this.tightPolylinesToLooseDistances = /* @__PURE__ */ new Map(), this.LooseObstacles = new Array();
    for (const t of this.TightObstacles) {
      const e = G.FindMaxPaddingForTightPolyline(this.RootOfTightHierarchy, t, this.LoosePadding);
      this.tightPolylinesToLooseDistances.set(t, e), this.LooseObstacles.push(G.LoosePolylineWithFewCorners(t, e, this.randomizationShift));
    }
    this.RootOfLooseHierarchy = G.CalculateHierarchy(this.LooseObstacles);
  }
  CreateTightObstacles() {
    this.RootOfTightHierarchy = this.CreateTightObstacles_(), this.OverlapsDetected = this.TightObstacles.size < this.Obstacles.length;
  }
  Calculate() {
    this.IgnoreTightPadding ? this.CreateTightObstaclesIgnoringTightPadding() : this.CreateTightObstacles(), this.IsEmpty() || this.CreateLooseObstacles();
  }
  IsEmpty() {
    return this.TightObstacles == null || this.TightObstacles.size === 0;
  }
  constructor(t, e, i, s) {
    this.randomizationShift = 0.01, this.TightObstacles = /* @__PURE__ */ new Set(), this.Obstacles = t, this.TightPadding = e, this.LoosePadding = i, this.IgnoreTightPadding = s;
  }
  ObstaclesIntersectICurve(t) {
    const e = t.boundingBox;
    return G.CurveIntersectsRectangleNode(t, e, this.RootOfTightHierarchy);
  }
  static CurveIntersectsRectangleNode(t, e, i) {
    if (!i.irect.intersects(e))
      return !1;
    if (i.UserData != null) {
      const s = i.UserData;
      return g.intersectionOne(s, t, !1) != null || G.PointIsInside(s.start, t);
    }
    return G.CurveIntersectsRectangleNode(t, e, i.Left) || G.CurveIntersectsRectangleNode(t, e, i.Right);
  }
  static PointIsInside(t, e) {
    return g.PointRelativeToCurveLocation(t, e) === F.Inside;
  }
  CreateTightObstaclesIgnoringTightPadding() {
    const t = this.Obstacles.map((s) => g.polylineAroundClosedCurve(s)), e = G.CalculateHierarchy(t), i = G.GetOverlappedPairSet(e);
    if (this.TightObstacles = /* @__PURE__ */ new Set(), i.size === 0) {
      for (const s of t) {
        const n = G.FindMaxPaddingForTightPolyline(e, s, this.TightPadding);
        this.TightObstacles.add(G.LoosePolylineWithFewCorners(s, n, this.randomizationShift));
      }
      this.RootOfTightHierarchy = G.CalculateHierarchy(Array.from(this.TightObstacles));
    } else {
      for (const s of t)
        this.TightObstacles.add(G.CreatePaddedPolyline(s, this.TightPadding));
      if (!this.IsEmpty())
        for (this.RootOfTightHierarchy = G.CalculateHierarchy(Array.from(this.TightObstacles)), this.OverlapsDetected = !1; G.GetOverlappedPairSet(this.RootOfTightHierarchy).size > 0; )
          this.RootOfTightHierarchy = G.ReplaceTightObstaclesWithConvexHulls(this.TightObstacles, Array.from(i)), this.OverlapsDetected = !0;
    }
  }
  CreateTightObstacles_() {
    if (this.Obstacles.length === 0)
      return null;
    for (const t of this.Obstacles)
      G.CalculateTightPolyline(this.TightObstacles, this.TightPadding, t);
    return G.RemovePossibleOverlapsInTightPolylinesAndCalculateHierarchy(this.TightObstacles);
  }
  static CalculateTightPolyline(t, e, i) {
    const s = G.PaddedPolylineBoundaryOfNode(i, e);
    t.add(s);
  }
  static CalculateHierarchy(t) {
    const e = t.map((i) => G.CreateRectNodeOfPolyline(i));
    return Et(e);
  }
  static RemovePossibleOverlapsInTightPolylinesAndCalculateHierarchy(t, e = null) {
    let i = G.CalculateHierarchy(Array.from(t)), s;
    for (; (s = G.GetOverlappedPairSet(i)).size > 0; )
      i = G.ReplaceTightObstaclesWithConvexHulls(t, Array.from(s), e);
    return i;
  }
  static MapToInt(t) {
    const e = /* @__PURE__ */ new Map();
    for (let i = 0; i < t.length; i++)
      e.set(t[i], i);
    return e;
  }
  static ReplaceTightObstaclesWithConvexHulls(t, e, i = null) {
    const s = /* @__PURE__ */ new Set();
    for (const h of e)
      s.add(h[0]), s.add(h[1]);
    const n = Array.from(s), r = G.MapToInt(n), o = kh(Array.from(e).map((h) => new U(r.get(h[0]), r.get(h[1])))), l = Qs(o);
    for (const h of l) {
      const c = h.map((P) => n[P]), d = Qn(c, (P) => P), f = Xe.createConvexHullAsClosedPolyline(d), p = new Array();
      for (const P of c)
        t.delete(P), i != null && (p.push(...i.get(P)), i.delete(P));
      i?.set(f, p), t.add(f);
    }
    return G.CalculateHierarchy(Array.from(t));
  }
  static OneCurveLiesInsideOfOther(t, e) {
    return g.PointRelativeToCurveLocation(t.start, e) !== F.Outside || g.PointRelativeToCurveLocation(e.start, t) !== F.Outside;
  }
  static PolylinesIntersect(t, e) {
    return g.CurvesIntersect(t, e) || G.OneCurveLiesInsideOfOther(t, e);
  }
  static GetOverlappedPairSet(t) {
    const e = /* @__PURE__ */ new Set();
    return Xt(t, t, (i, s) => {
      G.PolylinesIntersect(i, s) && e.add([i, s]);
    }), e;
  }
  static *BisectorPoints(t, e) {
    for (let i = t.startPoint; i != null; i = i.next) {
      const s = { skip: !1 }, n = G.GetStickingVertexOnBisector(i, e, s);
      s.skip || (yield n);
    }
  }
  static GetStickingVertexOnBisector(t, e, i) {
    const s = t.polyline.prev(t).point, n = t.point, r = t.polyline.next(t).point;
    let o = n.sub(s).normalize().add(n.sub(r).normalize());
    const l = o.length;
    return l < m.tolerance ? i.skip = !0 : (i.skip = !1, o = o.div(l)), o.mul(e).add(n);
  }
  static FindMaxPaddingForTightPolyline(t, e, i) {
    let s = i;
    const n = new ue(e), r = e.boundingBox.clone();
    r.pad(2 * i);
    for (const o of Array.from(t.GetNodeItemsIntersectingRectangle(r)).filter((l) => l !== e)) {
      const l = ue.Distance(n, new ue(o)).dist;
      s = Math.min(s, l / G.LooseDistCoefficient);
    }
    return s;
  }
  static GetPaddedCorner(t, e, i, s) {
    const n = t.point, r = e.point, o = i.point;
    if (u.getTriangleOrientation(n, r, o) === L.Counterclockwise)
      return { a: void 0, b: void 0, numberOfPoints: -1 };
    let l = r.sub(n).rotate(Math.PI / 2).normalize();
    if (G.CornerIsNotTooSharp(n, r, o)) {
      l = l.mul(s);
      const P = o.sub(r).normalize().mul(s).rotate(Math.PI / 2), y = u.lineLineIntersection(n.add(l), r.add(l), r.add(P), o.add(P));
      return { a: y, b: y, numberOfPoints: 1 };
    }
    const h = r.sub(n).normalize().add(r.sub(o).normalize());
    if (h.length < m.intersectionEpsilon) {
      const P = r.add(l.mul(s));
      return { a: P, b: P, numberOfPoints: 1 };
    }
    const c = h.normalize().mul(s), d = c.rotate(Math.PI / 2), f = (s - c.dot(l)) / d.dot(l), p = d.mul(f);
    return { a: c.add(p).add(r), b: c.sub(p).add(r), numberOfPoints: 2 };
  }
  static CornerIsNotTooSharp(t, e, i) {
    const s = t.sub(e).rotate(Math.PI / 4).add(e);
    return u.getTriangleOrientation(e, s, i) === L.Counterclockwise;
  }
  static CreatePaddedPolyline(t, e, i = !1) {
    const s = new B(), n = i ? Ud(t) : t;
    if (!G.PadCorner(s, n.endPoint.prev, n.endPoint, n.startPoint, e) || !G.PadCorner(s, n.endPoint, n.startPoint, n.startPoint.next, e))
      return G.CreatePaddedPolyline(B.mkClosedFromPoints(Array.from(Xe.CalculateConvexHull(n))), e);
    for (let r = n.startPoint; r.next.next != null; r = r.next)
      if (!G.PadCorner(s, r, r.next, r.next.next, e))
        return G.CreatePaddedPolyline(B.mkClosedFromPoints(Array.from(Xe.CalculateConvexHull(n))), e);
    return s.closed = !0, s;
  }
}
G.LooseDistCoefficient = 2.1;
function Ud(a) {
  const t = new B(), e = 0.01;
  for (let i = a.startPoint; i; i = i.next) {
    const s = i.point.x + e * Cs(), n = i.point.y + e * Cs();
    t.addPointXY(s, n);
  }
  return t.closed = a.closed, t;
}
class ua {
  get TightPolyline() {
    return this.tightPoly;
  }
  set TightPolyline(t) {
    this.tightPoly = t;
  }
  static mk(t, e, i) {
    const s = new ua();
    return s.TightPolyline = t, s.LooseShape = e, s.Distance = i, s;
  }
  toString() {
    return (this.TightPolyline == null ? "null" : this.TightPolyline.toString().substring(0, 5)) + "," + (this.LooseShape == null ? "null" : this.LooseShape.toString().substring(0, 5));
  }
}
class da {
  constructor(t, e, i, s) {
    this.loosePolylinesToNodes = /* @__PURE__ */ new Map(), this.MainShape = t, this.TightPadding = e, this.LoosePadding = i, this.ShapesToTightLooseCouples = s;
  }
  Calculate(t) {
    to(3), this.MainShape.Children.length !== 0 && (this.CreateTightObstacles(), this.CreateTigthLooseCouples(t), this.OverlapsDetected && this.FillTheMapOfShapeToTightLooseCouples());
  }
  FillTheMapOfShapeToTightLooseCouples() {
    const t = Et(this.MainShape.Children.map((e) => Bt(e, e.BoundingBox)));
    ae(t, this.coupleHierarchy, this.TryMapShapeToTightLooseCouple.bind(this));
  }
  TryMapShapeToTightLooseCouple(t, e) {
    da.ShapeIsInsideOfPoly(t, e.TightPolyline) && this.ShapesToTightLooseCouples.set(t, e);
  }
  // this test is valid in our situation where the tight polylines are disjoint and the shape can cross only one of them
  static ShapeIsInsideOfPoly(t, e) {
    return g.PointRelativeToCurveLocation(t.BoundaryCurve.start, e) === F.Inside;
  }
  CreateTigthLooseCouples(t) {
    const e = new Array();
    for (const i of this.tightHierarchy.GetAllLeaves()) {
      const s = G.FindMaxPaddingForTightPolyline(this.tightHierarchy, i, this.LoosePadding), n = G.LoosePolylineWithFewCorners(i, s, t), r = new qs(n), o = ua.mk(i, r, s), l = this.tightToShapes.get(i);
      for (const h of l)
        this.ShapesToTightLooseCouples.set(h, o);
      e.push(o);
    }
    this.coupleHierarchy = Et(e.map((i) => Bt(i, i.TightPolyline.boundingBox)));
  }
  CreateTightObstacles() {
    this.tightToShapes = /* @__PURE__ */ new Map();
    const t = new Set(this.MainShape.Children.map(this.InitialTightPolyline.bind(this))), e = t.size;
    this.tightHierarchy = G.RemovePossibleOverlapsInTightPolylinesAndCalculateHierarchy(t, this.tightToShapes), this.OverlapsDetected = e > t.size;
  }
  InitialTightPolyline(t) {
    let e = G.PaddedPolylineBoundaryOfNode(t.BoundaryCurve, this.TightPadding);
    const i = Qn(this.LoosePolylinesUnderShape(t), (n) => n).filter((n) => g.PointRelativeToCurveLocation(n, e) === F.Outside);
    if (i.length == 0)
      return this.tightToShapes && this.tightToShapes.set(e, [t]), e;
    const s = Array.from(e).concat(i);
    return e = B.mkClosedFromPoints(Xe.CalculateConvexHull(s)), this.tightToShapes && this.tightToShapes.set(e, [t]), e;
  }
  LoosePolylinesUnderShape(t) {
    return t.Children.map((e) => this.ShapesToTightLooseCouples.get(e).LooseShape.BoundaryCurve);
  }
}
class Xd {
  // value
  constructor(t, e, i) {
    this.indexToA = t, this.priority = e, this.v = i;
  }
}
class is {
  get count() {
    return this.heapSize;
  }
  ContainsElement(t) {
    return this.cache.has(t);
  }
  constructor(t = yt) {
    this.heapSize = 0, this.compare = t, this.cache = /* @__PURE__ */ new Map(), this.A = [];
  }
  SwapWithParent(t) {
    const e = this.A[t >> 1];
    this.PutAtI(t >> 1, this.A[t]), this.PutAtI(t, e);
  }
  Enqueue(t, e) {
    let i = ++this.heapSize;
    const s = new Xd(i, e, t);
    for (this.cache.set(t, s), this.A[i] = s; i > 1 && this.compare(this.A[i >> 1].priority, e) > 0; )
      this.SwapWithParent(i), i >>= 1;
  }
  IsEmpty() {
    return this.heapSize === 0;
  }
  PutAtI(t, e) {
    this.A[t] = e, e.indexToA = t;
  }
  Dequeue() {
    if (this.heapSize === 0)
      throw new Error("dequeue on an empty queue");
    const t = this.A[1].v;
    return this.MoveQueueOneStepForward(t), t;
  }
  DequeueAndGetPriority(t) {
    if (this.heapSize === 0)
      throw new Error("dequeue on an empty queue");
    const e = this.A[1].v;
    return t.priority = this.A[1].priority, this.MoveQueueOneStepForward(e), e;
  }
  MoveQueueOneStepForward(t) {
    this.cache.delete(t), this.PutAtI(1, this.A[this.heapSize]);
    let e = 1;
    for (; ; ) {
      let i = e;
      const s = e << 1;
      s <= this.heapSize && this.compare(this.A[s].priority, this.A[e].priority) < 0 && (i = s);
      const n = s + 1;
      if (n <= this.heapSize && this.compare(this.A[n].priority, this.A[i].priority) < 0 && (i = n), i !== e)
        this.SwapWithParent(i);
      else
        break;
      e = i;
    }
    this.heapSize--;
  }
  DecreasePriority(t, e) {
    const i = this.cache.get(t);
    if (!i)
      return;
    i.priority = e;
    let s = i.indexToA;
    for (; s > 1 && this.compare(this.A[s].priority, this.A[s >> 1].priority) < 0; ) {
      this.SwapWithParent(s);
      s >>= 1;
    }
  }
  *GetEnumerator() {
    for (let t = 1; t <= this.heapSize; t++)
      yield this.A[t].v;
  }
  //
  Peek(t) {
    if (this.count === 0) {
      t.priority = 0;
      return;
    }
    return t.priority = this.A[1].priority, this.A[1].v;
  }
  toString() {
    const t = new Gt.StringBuilder();
    for (const e of this.A)
      t.Append(e + ",");
    return t.ToString();
  }
}
class Ln {
  constructor(t, e, i) {
    this.upperBound = Number.POSITIVE_INFINITY, this._visGraph = i, this._visGraph.ClearPrevEdgesTable();
    for (const s of i.Vertices())
      s.Distance = Number.POSITIVE_INFINITY;
    this.source = t, this.targets = new Set(e), this.source.Distance = 0;
  }
  // Returns  a  path
  GetPath() {
    const t = new is(yt);
    for (this.source.Distance = 0, t.Enqueue(this.source, 0); !t.IsEmpty() && (this.current = t.Dequeue(), !this.targets.has(this.current)); ) {
      for (const e of this.current.OutEdges)
        this.PassableOutEdge(e) && this.ProcessNeighbor(t, e, e.Target);
      for (const e of this.current.InEdges)
        this.PassableInEdge(e) && this.ProcessNeighbor(t, e, e.Source);
    }
    return this._visGraph.PreviosVertex(this.current) == null ? null : this.CalculatePath();
  }
  PassableOutEdge(t) {
    return t.Source === this.source || this.targets.has(t.Target) || !Ln.IsForbidden(t);
  }
  PassableInEdge(t) {
    return this.targets.has(t.Source) || t.Target === this.source || !Ln.IsForbidden(t);
  }
  static IsForbidden(t) {
    return t.IsPassable != null && !t.IsPassable() || t instanceof pi;
  }
  ProcessNeighbor(t, e, i) {
    const s = e.Length, n = this.current.Distance + s;
    n >= this.upperBound || (this.targets.has(i) && (this.upperBound = n, this.closestTarget = i), i !== this.source && this._visGraph.PreviosVertex(i) == null ? (i.Distance = n, this._visGraph.SetPreviousEdge(i, e), t.Enqueue(i, n)) : n < i.Distance && (i.Distance = n, this._visGraph.SetPreviousEdge(i, e), t.DecreasePriority(i, n)));
  }
  CalculatePath() {
    if (this.closestTarget == null)
      return null;
    const t = new Array();
    let e = this.closestTarget;
    do
      t.push(e), e = this._visGraph.PreviosVertex(e);
    while (e !== this.source);
    return t.push(this.source), t.reverse();
  }
}
class Br {
  get LengthMultiplier() {
    return this._lengthMultiplier;
  }
  set LengthMultiplier(t) {
    this._lengthMultiplier = t;
  }
  get LengthMultiplierForAStar() {
    return this._lengthMultiplierForAStar;
  }
  set LengthMultiplierForAStar(t) {
    this._lengthMultiplierForAStar = t;
  }
  constructor(t, e, i) {
    this._lengthMultiplier = 1, this._lengthMultiplierForAStar = 1, this._visGraph = t, this._source = e, this._target = i, this._source.Distance = 0;
  }
  // Returns  a  path
  GetPath(t) {
    const e = new is(yt);
    for (this._source.Distance = 0, this._target.Distance = Number.POSITIVE_INFINITY, e.Enqueue(this._source, this.H(this._source)); !e.IsEmpty(); ) {
      const i = { priority: 0 }, s = e.DequeueAndGetPriority(i);
      if (i.priority >= this._target.Distance)
        break;
      for (const n of s.OutEdges)
        if (this.PassableOutEdge(n)) {
          const r = n.Target;
          this.ProcessNeighbor(e, s, n, r);
        }
      for (const n of s.InEdges)
        if (this.PassableInEdge(n)) {
          const r = n.Source;
          this.ProcessNeighbor(e, s, n, r);
        }
    }
    return this._visGraph.PreviosVertex(this._target) == null ? null : this.CalculatePath(t);
  }
  // private AssertEdgesPassable(path: Array<VisibilityEdge>) {
  //  for (const edge of path) Assert.assert(this.PassableOutEdge(edge) || this.PassableInEdge(edge))
  // }
  PassableOutEdge(t) {
    return t.Source === this._source || t.Target === this._target || !Br.IsForbidden(t);
  }
  PassableInEdge(t) {
    return t.Source === this._target || t.Target === this._source || !Br.IsForbidden(t);
  }
  static IsForbidden(t) {
    return t.IsPassable != null && !t.IsPassable() || t instanceof pi;
  }
  ProcessNeighborN(t, e, i, s, n) {
    const r = i.Length + n, o = e.Distance + r;
    s !== this._source && this._visGraph.PreviosVertex(s) == null ? (s.Distance = o, this._visGraph.SetPreviousEdge(s, i), s !== this._target && t.Enqueue(s, this.H(s))) : s !== this._source && o < s.Distance && (s.Distance = o, this._visGraph.SetPreviousEdge(s, i), s !== this._target && t.DecreasePriority(s, this.H(s)));
  }
  ProcessNeighbor(t, e, i, s) {
    const n = i.Length, r = e.Distance + n;
    s !== this._source && this._visGraph.PreviosVertex(s) == null ? (s.Distance = r, this._visGraph.SetPreviousEdge(s, i), s !== this._target && t.Enqueue(s, this.H(s))) : s !== this._source && r < s.Distance && (s.Distance = r, this._visGraph.SetPreviousEdge(s, i), s !== this._target && t.DecreasePriority(s, this.H(s)));
  }
  H(t) {
    return t.Distance + t.point.sub(this._target.point).length * this.LengthMultiplierForAStar;
  }
  CalculatePath(t) {
    const e = new Array();
    let i = this._target;
    do
      e.push(i), t && this._visGraph.ShrinkLengthOfPrevEdge(i, this.LengthMultiplier), i = this._visGraph.PreviosVertex(i);
    while (i !== this._source);
    return e.push(this._source), e.reverse();
  }
}
var Oi;
(function(a) {
  a[a.Regular = 0] = "Regular", a[a.Tangent = 1] = "Tangent";
})(Oi || (Oi = {}));
class el {
  toString() {
    return Gt.String.format("{0},{1}", this.Start, this.End);
  }
  get Start() {
    return this.leftTangent.End.point;
  }
  get End() {
    return this.rightTangent.End.point;
  }
  constructor(t, e) {
    this.LeftTangent = t, this.RightTangent = e;
  }
  get LeftTangent() {
    return this.leftTangent;
  }
  set LeftTangent(t) {
    this.leftTangent = t;
  }
  get RightTangent() {
    return this.rightTangent;
  }
  set RightTangent(t) {
    this.rightTangent = t;
  }
  get RbNode() {
    return this.rbNode;
  }
  set RbNode(t) {
    this.rbNode = t;
  }
}
class il {
  // the complimentary tangent
  get Comp() {
    return this.comp;
  }
  set Comp(t) {
    this.comp = t;
  }
  get IsHigh() {
    return !this.IsLow;
  }
  // true means that it is a low tangent to Q, false meanst that it is a high tangent to Q
  get IsLow() {
    return this.lowTangent;
  }
  set IsLow(t) {
    this.lowTangent = t;
  }
  get SeparatingPolygons() {
    return this.separatingPolygons;
  }
  set SeparatingPolygons(t) {
    this.separatingPolygons = t;
  }
  // the diagonal will be not a null only when it is active
  get Diagonal() {
    return this.diagonal;
  }
  set Diagonal(t) {
    this.diagonal = t;
  }
  get Start() {
    return this.start;
  }
  set Start(t) {
    this.start = t;
  }
  get End() {
    return this.end;
  }
  set End(t) {
    this.end = t;
  }
  constructor(t, e) {
    this.start = t, this.End = e;
  }
  toString() {
    return Gt.String.format("{0},{1}", this.Start, this.End);
  }
}
class sl {
  get PointOnTangentAndInsertedDiagonal() {
    return this.pointOnTheRay;
  }
  set PointOnTangentAndInsertedDiagonal(t) {
    this.pointOnTheRay = t;
  }
  Compare(t, e) {
    return t.Start.equal(e.Start) ? 0 : u.getTriangleOrientation(this.PointOnTangentAndInsertedDiagonal, e.Start, e.End) === L.Counterclockwise ? -1 : 1;
  }
  static BelongsToTheDiagonal(t, e, i) {
    return u.closeDistEps(t, u.ClosestPointAtLineSegment(t, e, i));
  }
  static IntersectDiagonalWithRay(t, e, i) {
    const s = e.sub(t), n = i.Start, r = i.End, o = Ji.solve(r.x - n.x, s.x * -1, t.x - n.x, r.y - n.y, s.y * -1, t.y - n.y);
    return t.add(s.mul(o.y));
  }
}
class _s {
  constructor(t) {
    this.pivot = t;
  }
  IComparer(t, e) {
    if (t === e)
      return 0;
    if (t == null)
      return -1;
    if (e == null)
      return 1;
    const i = t.Start.point.sub(this.pivot), s = e.Start.point.sub(this.pivot);
    return _s.CompareVectorsByAngleToXAxis(i, s);
  }
  static CompareVectorsByAngleToXAxis(t, e) {
    return t.y >= 0 ? e.y < 0 ? -1 : _s.CompareVectorsPointingToTheSameYHalfPlane(t, e) : e.y >= 0 ? 1 : _s.CompareVectorsPointingToTheSameYHalfPlane(t, e);
  }
  static CompareVectorsPointingToTheSameYHalfPlane(t, e) {
    const i = t.x * e.y - t.y * e.x;
    if (i > m.tolerance)
      return -1;
    if (i < -m.tolerance)
      return 1;
    if (t.x >= 0) {
      if (e.x < 0)
        return -1;
    } else if (e.x >= 0)
      return 1;
    let s = Math.abs(t.x) - Math.abs(e.x);
    return s < 0 ? -1 : s > 0 ? 1 : (s = Math.abs(t.y) - Math.abs(e.y), s < 0 ? -1 : s > 0 ? 1 : 0);
  }
}
class zi extends ht {
  // we calculate tangents between activePolygons and between activePolygons and existingObsacles
  run() {
    this.useLeftPTangents = !0, this.CalculateAndAddEdges(), this.useLeftPTangents = !1, this.CalculateAndAddEdges();
  }
  CalculateAndAddEdges() {
    for (const t of this.addedPolygons)
      this.CalculateVisibleTangentsFromPolygon(t);
    this.ProgressStep();
  }
  CalculateVisibleTangentsFromPolygon(t) {
    this.currentPolygon = t, this.AllocateDataStructures(), this.OrganizeTangents(), this.InitActiveDiagonals(), this.Sweep();
  }
  AllocateDataStructures() {
    this.tangents = new Array(), this.diagonals = new Array(), this.activeDiagonalTree = new we(this.activeDiagonalComparer.Compare.bind(this.activeDiagonalComparer));
  }
  Sweep() {
    if (!(this.tangents.length < 2))
      for (let t = 1; t < this.tangents.length; t++) {
        const e = this.tangents[t];
        e.Diagonal != null ? (e.Diagonal.RbNode === this.activeDiagonalTree.treeMinimum() && this.AddVisibleEdge(e), e.IsHigh && this.RemoveDiagonalFromActiveNodes(e.Diagonal)) : e.IsLow && (this.activeDiagonalComparer.PointOnTangentAndInsertedDiagonal = e.End.point, this.InsertActiveDiagonal(new el(e, e.Comp)), e.Diagonal.RbNode === this.activeDiagonalTree.treeMinimum() && this.AddVisibleEdge(e));
      }
  }
  AddVisibleEdge(t) {
    wt.AddEdgeVV(nl(this.visibilityGraph, t.start), nl(this.visibilityGraph, t.End));
  }
  // this function will also add the first tangent to the visible edges if needed
  InitActiveDiagonals() {
    if (this.tangents.length === 0)
      return;
    const t = this.tangents[0], e = t.start.point, i = t.End.point;
    for (const s of this.diagonals)
      zi.RayIntersectDiagonal(e, i, s) && (this.activeDiagonalComparer.PointOnTangentAndInsertedDiagonal = sl.IntersectDiagonalWithRay(e, i, s), this.InsertActiveDiagonal(s));
    if (t.Diagonal.RbNode === this.activeDiagonalTree.treeMinimum() && this.AddVisibleEdge(t), t.IsLow === !1) {
      const s = t.Diagonal;
      this.RemoveDiagonalFromActiveNodes(s);
    }
  }
  RemoveDiagonalFromActiveNodes(t) {
    const e = this.activeDiagonalTree.deleteSubTree(t.RbNode);
    e != null && e.item != null && (e.item.RbNode = e), t.LeftTangent.Diagonal = null, t.RightTangent.Diagonal = null;
  }
  InsertActiveDiagonal(t) {
    t.RbNode = this.activeDiagonalTree.insert(t), zi.MarkDiagonalAsActiveInTangents(t);
  }
  static MarkDiagonalAsActiveInTangents(t) {
    t.LeftTangent.Diagonal = t, t.RightTangent.Diagonal = t;
  }
  static RayIntersectDiagonal(t, e, i) {
    const s = i.Start, n = i.End;
    return u.getTriangleOrientation(t, s, n) === L.Counterclockwise && u.getTriangleOrientation(t, e, s) !== L.Counterclockwise && u.getTriangleOrientation(t, e, n) !== L.Clockwise;
  }
  // compare tangents by measuring the counterclockwise angle between the tangent and the edge
  static TangentComparison(t, e) {
    return _s.CompareVectorsByAngleToXAxis(t.End.point.sub(t.start.point), e.End.point.sub(e.start.point));
  }
  *AllObstacles() {
    for (const t of this.addedPolygons)
      yield t;
    if (this.polygons)
      for (const t of this.polygons)
        yield t;
  }
  OrganizeTangents() {
    for (const t of this.AllObstacles())
      t !== this.currentPolygon && this.ProcessPolygonQ(t);
    this.tangents.sort(zi.TangentComparison);
  }
  ProcessPolygonQ(t) {
    const e = new eo(this.currentPolygon, t);
    this.useLeftPTangents ? e.CalculateLeftTangents() : e.CalculateRightTangents();
    let i = this.useLeftPTangents ? e.leftPLeftQ : e.rightPLeftQ;
    const s = new il(this.currentPolygon.pp(i[0]), t.pp(i[1]));
    s.IsLow = !0, s.SeparatingPolygons = !this.useLeftPTangents, i = this.useLeftPTangents ? e.leftPRightQ : e.rightPRightQ;
    const n = new il(this.currentPolygon.pp(i[0]), t.pp(i[1]));
    n.IsLow = !1, n.SeparatingPolygons = this.useLeftPTangents, s.Comp = n, n.Comp = s, this.tangents.push(s), this.tangents.push(n), this.diagonals.push(new el(s, n));
  }
  constructor(t, e, i) {
    super(null), this.polygons = [], this.activeDiagonalComparer = new sl(), this.polygons = t, this.visibilityGraph = i, this.addedPolygons = e;
  }
}
function nl(a, t) {
  return a.FindVertex(t.point);
}
class fa {
  get Pivot() {
    return this.pivot;
  }
  set Pivot(t) {
    this.pivot = t;
  }
  get IntersectionOfTheRayAndInsertedEdge() {
    return this.pointOnTheRay;
  }
  set IntersectionOfTheRayAndInsertedEdge(t) {
    this.pointOnTheRay = t;
  }
  Compare(t, e) {
    return u.getTriangleOrientation(this.IntersectionOfTheRayAndInsertedEdge, e.point, e.nextOnPolyline.point) === L.Counterclockwise ? -1 : 1;
  }
  IntersectionPointBelongsToTheInsertedEdge(t) {
    const e = t.point.sub(this.IntersectionOfTheRayAndInsertedEdge), i = t.nextOnPolyline.point.sub(this.IntersectionOfTheRayAndInsertedEdge);
    return Math.abs(e.x * i.y - i.x * e.y) < m.distanceEpsilon;
  }
  IntersectEdgeWithRayPPP(t, e, i) {
    const s = Ji.solve(e.x - t.x, -i.x, this.Pivot.x - t.x, e.y - t.y, -i.y, this.Pivot.y - t.y);
    if (!(-m.tolerance <= s.x && s.x <= 1 + m.tolerance))
      throw new Error();
    if (!s)
      throw new Error();
    return this.Pivot.add(i.mul(s.y));
  }
  IntersectEdgeWithRay(t, e) {
    return this.IntersectEdgeWithRayPPP(t.point, t.nextOnPolyline.point, e);
  }
  static constructorPP(t, e) {
    const i = new fa();
    return i.pivot = t, i.pointOnTheRay = e, i;
  }
}
class hn {
  get Start() {
    return this.start;
  }
  set Start(t) {
    this.start = t;
  }
  get End() {
    return this.end;
  }
  set End(t) {
    this.end = t;
  }
  constructor(t, e) {
    this.start = t, this.end = e;
  }
  *Sides() {
    let t = this.start;
    for (; t !== this.end; ) {
      const e = t;
      yield e, t = e.nextOnPolyline;
    }
  }
  MoveStartClockwise() {
    return this.Start !== this.End ? (this.Start = this.Start.nextOnPolyline, !0) : !1;
  }
  toString() {
    return Gt.String.format("Stem({0},{1})", this.Start, this.End);
  }
}
class xi {
  get QVertex() {
    return this.qV;
  }
  set QVertex(t) {
    this.qV = t;
  }
  // "point" can belong to the boundary of one of the holes
  // tangent or regural visibility
  // "qVertex" : the graph vertex corresponding to the pivot
  static CalculatePointVisibilityGraph(t, e, i, s) {
    const n = e.FindVertex(i);
    if (n != null)
      return n;
    const r = new xi(t, e, i, s);
    return r.FillGraph(), r.QVertex;
  }
  FillGraph() {
    this.ComputeHoleBoundariesPossiblyVisibleFromQ(), this.visibleBoundaries.size > 0 && (this.SortSAndInitActiveSides(), this.Sweep());
  }
  // sorts the set of potentially visible vertices around point q
  SortSAndInitActiveSides() {
    this.InitHeapAndInsertActiveSides();
    for (let t = this.heapForSorting.GetMinimum(); this.sortedListOfPolypoints.push(t.Start), t.MoveStartClockwise() ? this.heapForSorting.ChangeMinimum(t) : this.heapForSorting.Dequeue(), this.heapForSorting.Count !== 0; t = this.heapForSorting.GetMinimum())
      ;
  }
  InitHeapAndInsertActiveSides() {
    for (const t of this.GetInitialVisibleBoundaryStemsAndInsertActiveSides())
      this.heapForSorting.Enqueue(t);
  }
  // these are chuncks of the visible boundaries growing from the polyline  point just above its crossing with the horizontal ray or
  // from the visible part start
  // In the general case we have two stems from one polyline
  *GetInitialVisibleBoundaryStemsAndInsertActiveSides() {
    for (const [t, e] of this.visibleBoundaries) {
      let i = !1;
      for (const s of e.Sides()) {
        const n = s;
        if (n.point.y < this.q.y) {
          if (s.nextOnPolyline.point.y >= this.q.y) {
            const r = u.getTriangleOrientation(this.q, n.point, s.nextOnPolyline.point);
            if (r === L.Counterclockwise || r === L.Collinear) {
              i = !0, yield new hn(e.Start, s), yield new hn(s.nextOnPolyline, e.End), this.RegisterActiveSide(s);
              break;
            }
          }
        } else {
          if (n.point.y > this.q.y)
            break;
          if (s.point.x >= this.q.x) {
            i = !0, yield new hn(s, e.End), s !== e.Start && (yield new hn(e.Start, t.prev(n))), this.RegisterActiveSide(s);
            break;
          }
        }
      }
      i || (yield e);
    }
  }
  RegisterActiveSide(t) {
    this.activeEdgeComparer.IntersectionOfTheRayAndInsertedEdge = this.activeEdgeComparer.IntersectEdgeWithRay(t, new u(1, 0)), this.sideNodes.set(t, this.activeSidesTree.insert(t));
  }
  // private Polyline GetPolylineBetweenPolyPointsTest(Polyline hole, PolylinePoint p0, PolylinePoint p1) {
  //    Polyline ret = new Polyline();
  //    while (p0 !== p1) {
  //        ret.AddPoint(p0.Point);
  //        p0 = hole.Next(p0);
  //    }
  //    ret.AddPoint(p1.Point);
  //    return ret;
  // }
  constructor(t, e, i, s) {
    this.sideNodes = /* @__PURE__ */ new Map(), this.visibleBoundaries = /* @__PURE__ */ new Map(), this.sortedListOfPolypoints = new Array(), this.holes = Array.from(t), this.visibilityGraph = e, this.q = i, this.qPolylinePoint = ei.mkFromPoint(this.q), this.QVertex = this.visibilityGraph.AddVertexP(this.qPolylinePoint.point), this.visibilityKind = s;
    const n = new _s(this.q);
    this.heapForSorting = new aa(n.IComparer.bind(n));
  }
  Sweep() {
    for (const t of this.sortedListOfPolypoints)
      this.SweepPolylinePoint(t);
  }
  // this code will work for convex holes
  SweepPolylinePoint(t) {
    const e = xi.GetIncomingSide(t), i = this.GetOutgoingSide(t);
    this.activeEdgeComparer.IntersectionOfTheRayAndInsertedEdge = t.point;
    let s;
    if (s = this.sideNodes.get(e)) {
      if (s === this.activeSidesTree.treeMinimum() && this.AddEdge(t), i != null)
        s.item = i, this.sideNodes.set(i, s);
      else {
        const n = this.activeSidesTree.deleteSubTree(s);
        n != null && n.item != null && this.sideNodes.set(n.item, n);
      }
      this.sideNodes.delete(e);
    } else if (i != null) {
      let n;
      (n = this.sideNodes.get(i)) || (n = this.activeSidesTree.insert(i), this.sideNodes.set(i, n), n === this.activeSidesTree.treeMinimum() && this.AddEdge(t));
    } else
      throw new Error();
  }
  AddEdge(t) {
    (this.visibilityKind === Oi.Regular || this.visibilityKind === Oi.Tangent && xi.LineTouchesPolygon(this.QVertex.point, t)) && this.visibilityGraph.AddEdgeF(this.QVertex.point, t.point, (e, i) => new pi(e, i));
  }
  static LineTouchesPolygon(t, e) {
    const i = e.polyline.prev(e).point, s = e.polyline.next(e).point, n = e.point;
    return u.signedDoubledTriangleArea(t, n, i) * u.signedDoubledTriangleArea(t, n, s) >= 0;
  }
  // ReSharper disable UnusedMember.Local
  /*
        DrawActiveEdgesAndVisibleGraph() {
            // ReSharper restore UnusedMember.Local
            let l = new Array<ICurve>();
            for (let pe: VisibilityEdge in this.visibilityGraph.Edges) {
                l.Add(new LineSegment(pe.SourcePoint, pe.TargetPoint));
            }
            
            for (let pe: PolylinePoint in this.activeSidesTree) {
                l.Add(new LineSegment(pe.Point, pe.NextOnPolyline.Point));
            }
            
            l.Add(new Ellipse(0.1, 0.1, this.q));
            LayoutAlgorithmSettings.Show(l.ToArray());
        }
  */
  GetOutgoingSide(t) {
    const e = this.visibleBoundaries.get(t.polyline);
    return t === e.End ? null : t;
  }
  static GetIncomingSide(t) {
    return t.prevOnPolyline;
  }
  ComputeHoleBoundariesPossiblyVisibleFromQ() {
    this.InitActiveEdgesAndActiveEdgesComparer();
    for (const t of this.holes)
      this.ComputeVisiblePartOfTheHole(t);
  }
  InitActiveEdgesAndActiveEdgesComparer() {
    this.activeEdgeComparer = new fa(), this.activeEdgeComparer.pivot = this.q, this.activeSidesTree = new we(this.activeEdgeComparer.Compare.bind(this.activeEdgeComparer));
  }
  ComputeVisiblePartOfTheHole(t) {
    let e, i = !0;
    for (e = t.startPoint; !this.HoleSideIsVisibleFromQ(t, e); e = t.next(e))
      i = !1;
    let s = t.next(e);
    if (i)
      for (; this.HoleSideIsVisibleFromQ(t, t.prev(e)); )
        e = t.prev(e);
    for (; this.HoleSideIsVisibleFromQ(t, s); s = t.next(s))
      ;
    this.visibleBoundaries.set(t, new hn(e, s));
  }
  HoleSideIsVisibleFromQ(t, e) {
    return u.signedDoubledTriangleArea(this.q, e.point, t.next(e).point) >= -m.squareOfDistanceEpsilon;
  }
}
class tt extends ht {
  constructor() {
    super(...arguments), this.IgnoreTightPadding = !0, this.activeRectangle = T.mkEmpty(), this.activePolygons = new Array(), this.alreadyAddedOrExcludedPolylines = /* @__PURE__ */ new Set(), this.UseEdgeLengthMultiplier = !1, this.UseInnerPolylingShortcutting = !0, this.UsePolylineEndShortcutting = !0, this.AllowedShootingStraightLines = !0, this.LookForRoundedVertices = !1;
  }
  rerouteEdge(t) {
    const e = t.smoothedPolyline ? B.mkFromPoints(t.smoothedPolyline) : B.mkFromPoints(t.getSmoothPolyPoints());
    this.pathOptimizer.run(e), t.curve = this.pathOptimizer.poly.toCurve();
  }
  static constructorANNN(t, e, i, s) {
    return tt.constructorANNNB(t, e, i, s, !1);
  }
  get Obstacles() {
    return this.obstacles_;
  }
  set Obstacles(t) {
    this.obstacles_ = t;
  }
  get EnteringAngleBound() {
    return this.enteringAngleBound_;
  }
  set EnteringAngleBound(t) {
    this.enteringAngleBound_ = t;
  }
  get SourceTightPolyline() {
    return this._sourceTightPolyline;
  }
  set SourceTightPolyline(t) {
    this._sourceTightPolyline = t;
  }
  get TargetTightPolyline() {
    return this.targetTightPolyline;
  }
  set TargetTightPolyline(t) {
    this.targetTightPolyline = t;
  }
  get TargetLoosePolyline() {
    return this.targetLoosePolyline;
  }
  set TargetLoosePolyline(t) {
    this.targetLoosePolyline = t;
  }
  get VisibilityGraph() {
    return this.visibilityGraph;
  }
  set VisibilityGraph(t) {
    this.visibilityGraph = t;
  }
  // the port of the edge start
  get SourcePort() {
    return this.sourcePort;
  }
  set SourcePort(t) {
    if (this.sourcePort = t, this.sourcePort != null)
      if (this.SourceTightPolyline = tt.GetFirstHitPolyline(this.sourcePort.Location, this.ObstacleCalculator.RootOfTightHierarchy), this.sourcePort instanceof Te)
        this.alreadyAddedOrExcludedPolylines.add(this.SourceLoosePolyline), this.StartPointOfEdgeRouting = this.SourcePort.Location;
      else {
        const e = this.sourcePort;
        this.StartPointOfEdgeRouting = this.TakeBoundaryPortOutsideOfItsLoosePolyline(e.Curve, e.Parameter, this.SourceLoosePolyline);
      }
  }
  // the port of the edge end
  get TargetPort() {
    return this.targetPort;
  }
  set TargetPort(t) {
    this.targetPort = t;
  }
  // we further pad each node but not more than LoosePadding.
  get LoosePadding() {
    return this.loosePadding;
  }
  set LoosePadding(t) {
    this.loosePadding = t, this.ObstacleCalculator != null && (this.ObstacleCalculator.LoosePadding = t);
  }
  get OffsetForPolylineRelaxing() {
    return this.TightPadding * 0.75;
  }
  get StartPointOfEdgeRouting() {
    return this.startPointOfRouting_;
  }
  set StartPointOfEdgeRouting(t) {
    this.startPointOfRouting_ = t;
  }
  ExtendVisibilityGraphToLocation(t) {
    this.VisibilityGraph == null && (this.VisibilityGraph = new wt());
    let e = null;
    if (!this.activeRectangle.contains(t)) {
      this.activeRectangle.isEmpty ? this.activeRectangle = T.mkPP(this.SourcePort.Location, t) : this.activeRectangle.add(t), e = this.GetAddedPolygonesAndMaybeExtendActiveRectangle();
      for (const i of e)
        this.VisibilityGraph.AddHole(i.Polyline);
    }
    e == null || e.length === 0 ? (this.targetVV != null && this.VisibilityGraph.RemoveVertex(this.targetVV), this.CalculateEdgeTargetVisibilityGraph(t)) : (this.RemovePointVisibilityGraphs(), new zi(e, this.activePolygons, this.VisibilityGraph).run(), Di(this.activePolygons, e), this.CalculateEdgeTargetVisibilityGraph(t), this.CalculateSourcePortVisibilityGraph());
  }
  RemovePointVisibilityGraphs() {
    this.targetVV != null && this.VisibilityGraph.RemoveVertex(this.targetVV), this.sourceVV != null && this.VisibilityGraph.RemoveVertex(this.sourceVV);
  }
  CalculateEdgeTargetVisibilityGraph(t) {
    this.targetVV = xi.CalculatePointVisibilityGraph(Array.from(this.GetActivePolylines()), this.VisibilityGraph, t, Oi.Tangent);
  }
  CalculateSourcePortVisibilityGraph() {
    this.sourceVV = xi.CalculatePointVisibilityGraph(Array.from(this.GetActivePolylines()), this.VisibilityGraph, this.StartPointOfEdgeRouting, Oi.Tangent);
  }
  TakeBoundaryPortOutsideOfItsLoosePolyline(t, e, i) {
    const s = t.value(e);
    let n = t.leftDerivative(e).normalize().add(t.rightDerivative(e).normalize()).normalize();
    u.getTriangleOrientation(tt.PointInsideOfConvexCurve(t), s, s.add(n)) == L.Counterclockwise && (n = n.mul(-1)), n = n.rotate(Math.PI / 2);
    const r = i.boundingBox.diagonal;
    let o = v.mkPP(s, s.add(n.mul(r)));
    const l = g.intersectionOne(o, i, !1).x;
    let h = n.mul(l.sub(s).length / 2);
    for (; ; ) {
      o = v.mkPP(s, l.add(h));
      let c = !1;
      for (const d of tt.IntersectionsOfLineAndRectangleNodeOverPolylineLR(o, this.ObstacleCalculator.RootOfLooseHierarchy))
        if (d.seg1 !== i) {
          h = h.div(1.5), c = !0;
          break;
        }
      if (!c)
        break;
    }
    return o.end;
  }
  static PointInsideOfConvexCurve(t) {
    return t.value(0).add(t.value(1.5)).div(2);
  }
  // Point TakeSourcePortOutsideOfLoosePolyline() {
  //    CurvePort bp = SourcePort as CurvePort;
  //    ICurve nodeBoundary = bp.Node.BoundaryCurve;
  //    Point location = bp.Location;
  //    Point tangent = (nodeBoundary.LeftDerivative(bp.Parameter).Normalize() + nodeBoundary.RightDerivative(bp.Parameter).Normalize()).Normalize();
  //    if (Point.GetTriangleOrientation(bp.Node.Center, location, location + tangent) === TriangleOrientation.Counterclockwise)
  //        tangent = -tangent;
  //    tangent = tangent.Rotate(Math.PI / 2);
  //    Number len = this.sourceLoosePolyline.BoundingBox.Diagonal;
  //    Point portLocation = bp.Location;
  //    LineSegment ls = LineSegment.mkPP(portLocation, portLocation + len * tangent);
  //    Point p = Curve.GetAllIntersections(ls, this.SourceLoosePolyline, false)[0].x;
  //    Point del = tangent * this.OffsetForPolylineRelaxing * 2;
  //    while (true) {
  //        ls = LineSegment.mkPP(portLocation, p + del);
  //        bool foundIntersectionsOutsideOfSource = false;
  //        foreach (IntersectionInfo ii in IntersectionsOfLineAndRectangleNodeOverPolyline(ls, this.obstacleCalculator.RootOfLooseHierarchy))
  //            if (ii.seg1 !== this.SourceLoosePolyline) {
  //                del /= 1.5;
  //                foundIntersectionsOutsideOfSource = true;
  //                break;
  //            }
  //        if (!foundIntersectionsOutsideOfSource)
  //            break;
  //    }
  //    return ls.End;
  // }
  *GetActivePolylines() {
    for (const t of this.activePolygons)
      yield t.Polyline;
  }
  GetAddedPolygonesAndMaybeExtendActiveRectangle() {
    const t = this.activeRectangle, e = new Array();
    let i;
    do {
      i = !1;
      for (const s of this.ObstacleCalculator.RootOfLooseHierarchy.GetNodeItemsIntersectingRectangle(this.activeRectangle))
        this.alreadyAddedOrExcludedPolylines.has(s) || (t.addRec(s.boundingBox), e.push(new ue(s)), this.alreadyAddedOrExcludedPolylines.add(s), i = !0);
      i && (this.activeRectangle = t);
    } while (i);
    return e;
  }
  PolylineSegmentIntersectsTightHierarchy(t, e) {
    return this.PolylineIntersectsPolyRectangleNodeOfTightHierarchyPPR(t, e, this.ObstacleCalculator.RootOfTightHierarchy);
  }
  PolylineIntersectsPolyRectangleNodeOfTightHierarchyPPR(t, e, i) {
    return this.PolylineIntersectsPolyRectangleNodeOfTightHierarchy(v.mkPP(t, e), i);
  }
  PolylineIntersectsPolyRectangleNodeOfTightHierarchy(t, e) {
    if (!t.boundingBox.intersects(e.irect))
      return !1;
    if (e.UserData != null) {
      for (const i of g.getAllIntersections(t, e.UserData, !1))
        if (i.seg1 !== this.SourceTightPolyline && i.seg1 !== this.TargetTightPolyline || (i.seg1 === this.SourceTightPolyline && this.SourcePort) instanceof Oe || (i.seg1 === this.TargetTightPolyline && this.TargetPort) instanceof Oe)
          return !0;
      return !1;
    }
    return this.PolylineIntersectsPolyRectangleNodeOfTightHierarchy(t, e.Left) || this.PolylineIntersectsPolyRectangleNodeOfTightHierarchy(t, e.Right);
  }
  static IntersectionsOfLineAndRectangleNodeOverPolylineLR(t, e) {
    const i = new Array();
    return tt.IntersectionsOfLineAndRectangleNodeOverPolyline(t, e, i), i;
  }
  static IntersectionsOfLineAndRectangleNodeOverPolyline(t, e, i) {
    if (e != null && t.boundingBox.intersects(e.irect)) {
      if (e.UserData != null) {
        Di(i, g.getAllIntersections(t, e.UserData, !0));
        return;
      }
      tt.IntersectionsOfLineAndRectangleNodeOverPolyline(t, e.Left, i), tt.IntersectionsOfLineAndRectangleNodeOverPolyline(t, e.Right, i);
    }
  }
  LineCanBeAcceptedForRouting(t) {
    const e = this.SourcePort instanceof Te, i = this.TargetPort instanceof Te;
    if (!e && !this.targetIsInsideOfSourceTightPolyline && !this.InsideOfTheAllowedConeOfBoundaryPort(t.end, this.SourcePort) || !i && this.TargetPort != null && !this.sourceIsInsideOfTargetTightPolyline && !this.InsideOfTheAllowedConeOfBoundaryPort(t.start, this.TargetPort))
      return !1;
    const s = tt.IntersectionsOfLineAndRectangleNodeOverPolylineLR(t, this.ObstacleCalculator.RootOfTightHierarchy);
    for (const n of s)
      if (n.seg1 !== this.SourceTightPolyline && n.seg1 !== this.targetTightPolyline)
        return !1;
    return !0;
  }
  InsideOfTheAllowedConeOfBoundaryPort(t, e) {
    const i = e.Curve, s = G.CurveIsClockwise(i, tt.PointInsideOfConvexCurve(i)), n = e.Location, r = this.GetPointOnTheRightBoundaryPortConeSide(n, i, s, e.Parameter), o = this.GetPointOnTheLeftBoundaryPortConeSide(n, i, s, e.Parameter);
    return u.getTriangleOrientation(n, r, t) !== L.Clockwise && u.getTriangleOrientation(n, t, o) !== L.Clockwise;
  }
  GetPointOnTheRightBoundaryPortConeSide(t, e, i, s) {
    const n = i ? e.rightDerivative(s) : e.leftDerivative(s).neg();
    return t.add(n.rotate(this.EnteringAngleBound));
  }
  GetPointOnTheLeftBoundaryPortConeSide(t, e, i, s) {
    const n = i ? e.leftDerivative(s).neg() : e.rightDerivative(s);
    return t.add(n.rotate(-this.EnteringAngleBound));
  }
  // ShowPolylineAndObstacles(params curves: ICurve[]) {
  //    //  ReSharper restore UnusedMember.Local
  //    let ls: Array<DebugCurve> = this.GetDebugCurves(curves);
  //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(ls);
  // }
  // GetDebugCurves(params curves: ICurve[]): Array<DebugCurve> {
  //    let ls = this.CreateListWithObstaclesAndPolyline(curves);
  //    // ls.AddRange(this.VisibilityGraph.Edges.Select(e => new DebugCurve(100,0.1, e is TollFreeVisibilityEdge?"red":"green", LineSegment.mkPP(e.SourcePoint, e.TargetPoint))));
  //    if ((this._sourceVisibilityVertex != null)) {
  //        ls.Add(new DebugCurve("red", CurveFactory.CreateDiamond(4, 4, this._sourceVisibilityVertex.point)));
  //    }
  //    if ((this.targetVisibilityVertex != null)) {
  //        ls.Add(new DebugCurve("purple", new Ellipse(4, 4, this.targetVisibilityVertex.Point)));
  //    }
  //    let anywerePort = (<HookUpAnywhereFromInsidePort>(this.targetPort));
  //    if ((anywerePort != null)) {
  //        ls.Add(new DebugCurve("purple", anywerePort.LoosePolyline));
  //    }
  //    return ls;
  // }
  // CreateListWithObstaclesAndPolyline(params curves: ICurve[]): Array<DebugCurve> {
  //    let ls = new Array<DebugCurve>(this.ObstacleCalculator.RootOfLooseHierarchy.GetAllLeaves().select(() => {  }, new DebugCurve(100, 0.01, "green", e)));
  //    ls.AddRange(curves.Select(() => {  }, new DebugCurve(100, 0.01, "red", c)));
  //    ls.AddRange(this.ObstacleCalculator.RootOfTightHierarchy.GetAllLeaves().select(() => {  }, new DebugCurve(100, 0.01, "blue", e)));
  //    //  ls.AddRange(visibilityGraph.Edges.Select(e => (ICurve) LineSegment.mkPP(e.SourcePoint, e.TargetPoint)));
  //    if ((this._polyline != null)) {
  //        ls.Add(new DebugCurve(100, 0.03, "blue", this._polyline));
  //    }
  //    return ls;
  // }
  // smoothing the corners of the polyline
  SmoothenCorners(t) {
    let e = t.headSite, i = { b: null, c: null };
    for (; i = g.findCorner(e); )
      e = this.SmoothOneCorner(e, i.c, i.b);
  }
  SmoothOneCorner(t, e, i) {
    let r = 0.5, o, l, h;
    t.prev == null ? (h = 2, l = 1) : e.next == null ? (h = 1, l = 2) : h = l = 1;
    do
      o = g.createBezierSeg(r * h, r * l, t, i, e), i.previouisBezierCoefficient = r * h, i.nextBezierCoefficient = r * l, r /= 1.5;
    while (c() > this.loosePadding && r > 0.01);
    return r *= 1.5, r < 0.5 && r > 0.01 && (r = 0.5 * (r + r * 1.5), o = g.createBezierSeg(r * h, r * l, t, i, e), c() > this.loosePadding && (i.previouisBezierCoefficient = r * h, i.nextBezierCoefficient = r * l)), i;
    function c() {
      const d = o.closestParameter(i.point);
      return i.point.sub(o.value(d)).length;
    }
  }
  TryToRemoveInflectionsAndCollinearSegments(t) {
    let e = !0;
    const i = { s: null };
    for (; e; )
      for (e = !1, i.s = t.headSite; i.s != null && i.s.next != null; i.s = i.s.next)
        i.s.turn * i.s.next.turn < 0 && (e = this.TryToRemoveInflectionEdge(i) || e);
  }
  TryToRemoveInflectionEdge(t) {
    if (!this.ObstacleCalculator.ObstaclesIntersectLine(t.s.prev.point, t.s.next.point)) {
      const e = t.s.prev, i = t.s.next;
      return e.next = i, i.prev = e, t.s = e, !0;
    }
    if (!this.ObstacleCalculator.ObstaclesIntersectLine(t.s.prev.point, t.s.next.next.point)) {
      const e = t.s.prev, i = t.s.next.next;
      return e.next = i, i.prev = e, t.s = e, !0;
    }
    if (!this.ObstacleCalculator.ObstaclesIntersectLine(t.s.point, t.s.next.next.point)) {
      const e = t.s.next.next;
      return t.s.next = e, e.prev = t.s, !0;
    }
    return !1;
  }
  // internal Point TargetPoint {
  //    get {
  //        CurvePort tp = this.TargetPort as CurvePort;
  //        if (tp != null)
  //            return this.Target.BoundaryCurve[tp.Parameter];
  //        else
  //            return (this.TargetPort as FloatingPort).Location;
  //    }
  // }
  // internal Point SourcePoint {
  //    get {
  //        CurvePort sp = this.SourcePort as CurvePort;
  //        if (sp != null)
  //            return this.Source.BoundaryCurve[sp.Parameter];
  //        else
  //            return (this.SourcePort as FloatingPort).Location;
  //    }
  // }
  GetShortestPolyline(t, e) {
    this.CleanTheGraphForShortestPath();
    const s = new Br(this.visibilityGraph, t, e).GetPath(this.UseEdgeLengthMultiplier);
    if (s == null)
      return null;
    let n = B.mkFromPoints(Array.from(s).map((r) => r.point)).RemoveCollinearVertices();
    return this.pathOptimizer && (this.pathOptimizer.run(n), n = this.pathOptimizer.poly), n;
  }
  // private ShowIsPassable(sourceVisVertex: VisibilityVertex, targetVisVertex: VisibilityVertex) {
  //    let dd = new Array<DebugCurve>(this.visibilityGraph.Edges.Select(() => {  }, new DebugCurve(100, 0.5, "green", LineSegment.mkPP(e.SourcePoint, e.TargetPoint))));
  //    // TODO: Warning!!!, inline IF is not supported ?
  //    ((e.IsPassable == null )
  //                || e.IsPassable());
  //    "red";
  //    if ((sourceVisVertex != null)) {
  //        dd.Add(new DebugCurve(CurveFactory.CreateDiamond(3, 3, sourceVisVertex.point)));
  //    }
  //    if ((targetVisVertex != null)) {
  //        dd.Add(new DebugCurve(CurveFactory.CreateEllipse(3, 3, targetVisVertex.point)));
  //    }
  //    if ((this.Obstacles != null)) {
  //        dd.AddRange(this.Obstacles.Select(() => {  }, new DebugCurve(o)));
  //    }
  //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(dd);
  // }
  CleanTheGraphForShortestPath() {
    this.visibilityGraph.ClearPrevEdgesTable();
  }
  // returns true if the nodes overlap or just positioned too close
  get OverlapsDetected() {
    return this.ObstacleCalculator.OverlapsDetected;
  }
  get TightHierarchy() {
    return this.ObstacleCalculator.RootOfTightHierarchy;
  }
  set TightHierarchy(t) {
    this.ObstacleCalculator.RootOfTightHierarchy = t;
  }
  get LooseHierarchy() {
    return this.ObstacleCalculator.RootOfLooseHierarchy;
  }
  set LooseHierarchy(t) {
    this.ObstacleCalculator.RootOfLooseHierarchy = t;
  }
  CalculateObstacles() {
    this.ObstacleCalculator = new G(this.Obstacles, this.TightPadding, this.LoosePadding, this.IgnoreTightPadding), this.ObstacleCalculator.Calculate();
  }
  static constructorANNNB(t, e, i, s, n) {
    const r = new tt(null);
    return r.IgnoreTightPadding = n, r.EnteringAngleBound = 80 * (Math.PI / 180), r.TightPadding = e, r.LoosePadding = i, s > 0 ? (lt.assert(s > Math.PI / 180), lt.assert(s <= 90 * (Math.PI / 180)), r.UseSpanner = !0, r.ExpectedProgressSteps = Us.GetTotalSteps(s)) : r.ExpectedProgressSteps = t.length, r.ConeSpannerAngle = s, r.Obstacles = t, r.CalculateObstacles(), r;
  }
  RouteEdgeToLocation(t) {
    this.TargetPort = new Te(null, t), this.TargetTightPolyline = null, this.TargetLoosePolyline = null;
    const e = new Kt(null);
    let i = v.mkPP(this.SourcePort.Location, t);
    if (this.LineCanBeAcceptedForRouting(i)) {
      this._polyline = new B(), this._polyline.addPoint(i.start), this._polyline.addPoint(i.end);
      const s = Tt.mkFromPoints(this._polyline);
      return e.curve = s.createCurve(), e;
    }
    return this.SourcePort instanceof Oe && (i = v.mkPP(this.StartPointOfEdgeRouting, t), tt.IntersectionsOfLineAndRectangleNodeOverPolylineLR(i, this.ObstacleCalculator.RootOfTightHierarchy).length == 0) ? (this._polyline = new B(), this._polyline.addPoint(this.SourcePort.Location), this._polyline.addPoint(i.start), this._polyline.addPoint(i.end), e.curve = Tt.mkFromPoints(this._polyline).createCurve(), e) : (this.ExtendVisibilityGraphToLocation(t), this._polyline = this.GetShortestPolyline(this.sourceVV, this.targetVV), this.SourcePort instanceof Oe && this._polyline.PrependPoint(this.SourcePort.Location), e.curve = Tt.mkFromPoints(this._polyline).createCurve(), e);
  }
  // routes the edge to the port
  //
  RouteEdgeToPort(t, e, i, s) {
    return this.ObstacleCalculator.IsEmpty() ? this.sourcePort != null && this.targetPort != null ? (s.smoothedPolyline = this.SmoothedPolylineFromTwoPoints(this.sourcePort.Location, this.targetPort.Location), v.mkPP(this.sourcePort.Location, this.targetPort.Location)) : null : (this.TargetPort = t, this.TargetTightPolyline = tt.GetFirstHitPolyline(t.Location, this.ObstacleCalculator.RootOfTightHierarchy), t instanceof Oe ? this.RouteEdgeToBoundaryPort(e, i, s) : this.RouteEdgeToFloatingPortOfNode(e, i, s));
  }
  SmoothedPolylineFromTwoPoints(t, e) {
    return this._polyline = new B(), this._polyline.addPoint(t), this._polyline.addPoint(e), Tt.mkFromPoints(this._polyline);
  }
  RouteEdgeToFloatingPortOfNode(t, e, i) {
    return this.sourcePort instanceof Te ? this.RouteFromFloatingPortToFloatingPort(t, e, i) : this.RouteFromBoundaryPortToFloatingPort(t, e, i);
  }
  RouteFromBoundaryPortToFloatingPort(t, e, i) {
    const s = this.SourcePort.Location, n = this.targetPort.Location;
    let r = v.mkPP(s, n);
    if (this.LineCanBeAcceptedForRouting(r))
      return i.smoothedPolyline = this.SmoothedPolylineFromTwoPoints(r.start, r.end), r;
    if (!this.targetIsInsideOfSourceTightPolyline) {
      const l = this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.SourcePort.Curve, this.SourcePort.Parameter, this.SourceLoosePolyline);
      if (r = v.mkPP(l, n), this.LineAvoidsTightHierarchyLP(r, t))
        return i.smoothedPolyline = this.SmoothedPolylineFromTwoPoints(r.start, r.end), r;
    }
    this.ExtendVisibilityGraphToLocationOfTargetFloatingPort(t), this._polyline = this.GetShortestPolyline(this.sourceVV, this.targetVV);
    const o = this.SourceTightPolyline;
    return this.targetIsInsideOfSourceTightPolyline || (this.SourceTightPolyline = null), this.SourceTightPolyline = o, this._polyline.PrependPoint(s), this.SmoothCornersAndReturnCurve(e, i);
  }
  SmoothCornersAndReturnCurve(t, e) {
    return e.smoothedPolyline = Tt.mkFromPoints(this._polyline), t && this.SmoothenCorners(e.smoothedPolyline), e.smoothedPolyline.createCurve();
  }
  RouteFromFloatingPortToFloatingPort(t, e, i) {
    return this.ExtendVisibilityGraphToLocationOfTargetFloatingPort(t), this._polyline = this.GetShortestPolyline(this.sourceVV, this.targetVV), this._polyline == null ? null : (i.smoothedPolyline = Tt.mkFromPoints(this._polyline), this.SmoothCornersAndReturnCurve(e, i));
  }
  TryShortcutPolyPoint(t) {
    return this.LineAvoidsTightHierarchyLPP(v.mkPP(t.point, t.next.next.point), this.SourceTightPolyline, this.targetTightPolyline) ? (t.next = t.next.next, t.next.prev = t, !0) : !1;
  }
  ExtendVisibilityGraphToLocationOfTargetFloatingPort(t) {
    this.VisibilityGraph == null && (this.VisibilityGraph = new wt());
    let e = null;
    const i = this.targetPort.Location;
    if (!this.activeRectangle.contains(i)) {
      this.activeRectangle.isEmpty ? this.activeRectangle = T.mkPP(this.SourcePort.Location, i) : this.activeRectangle.add(i), e = this.GetAddedPolygonesAndMaybeExtendActiveRectangle();
      for (const s of e)
        this.VisibilityGraph.AddHole(s.Polyline);
    }
    e == null ? (this.targetVV != null && this.VisibilityGraph.RemoveVertex(this.targetVV), this.CalculateEdgeTargetVisibilityGraphForFloatingPort(i, t), this.sourceVV == null && this.CalculateSourcePortVisibilityGraph()) : (this.RemovePointVisibilityGraphs(), new zi(e, this.activePolygons, this.VisibilityGraph).run(), Di(this.activePolygons, e), this.CalculateEdgeTargetVisibilityGraphForFloatingPort(i, t), this.CalculateSourcePortVisibilityGraph());
  }
  CalculateEdgeTargetVisibilityGraphForFloatingPort(t, e) {
    this.UseSpanner ? this.targetVV = this.AddTransientVisibilityEdgesForPort(t, e) : this.targetVV = xi.CalculatePointVisibilityGraph(this.GetActivePolylinesWithException(e), this.VisibilityGraph, t, Oi.Tangent);
  }
  AddTransientVisibilityEdgesForPort(t, e) {
    let i = this.GetVertex(t);
    if (i != null)
      return i;
    if (i = this.visibilityGraph.AddVertexP(t), e != null)
      for (const s of e)
        this.visibilityGraph.AddEdgeF(t, s, (n, r) => new pi(n, r));
    else
      i = xi.CalculatePointVisibilityGraph(this.GetActivePolylines(), this.VisibilityGraph, t, Oi.Tangent);
    return i;
  }
  GetVertex(t) {
    let e = this.visibilityGraph.FindVertex(t);
    return e == null && this.LookForRoundedVertices && (e = this.visibilityGraph.FindVertex(u.RoundPoint(t))), e;
  }
  *GetActivePolylinesWithException(t) {
    for (const e of this.activePolygons)
      e.Polyline !== t && (yield e.Polyline);
  }
  RouteEdgeToBoundaryPort(t, e, i) {
    return this.TargetLoosePolyline = t, this.sourcePort instanceof Te ? this.RouteFromFloatingPortToBoundaryPort(e, i) : this.RouteFromBoundaryPortToBoundaryPort(e, i);
  }
  RouteFromBoundaryPortToBoundaryPort(t, e) {
    const i = this.SourcePort.Location;
    let s;
    const n = this.targetPort.Location;
    let r = v.mkPP(i, n);
    if (this.LineCanBeAcceptedForRouting(r))
      this._polyline = new B(), this._polyline.addPoint(r.start), this._polyline.addPoint(r.end), e.smoothedPolyline = this.SmoothedPolylineFromTwoPoints(r.start, r.end), s = Tt.mkFromPoints(this._polyline).createCurve();
    else {
      const o = this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.targetPort.Curve, this.targetPort.Parameter, this.TargetLoosePolyline);
      if (r = v.mkPP(i, o), this.InsideOfTheAllowedConeOfBoundaryPort(o, this.SourcePort) && this.LineAvoidsTightHierarchyLP(r, this._sourceTightPolyline))
        this._polyline = new B(), this._polyline.addPoint(r.start), this._polyline.addPoint(r.end), this._polyline.addPoint(n), s = this.SmoothCornersAndReturnCurve(t, e);
      else if (r = v.mkPP(this.StartPointOfEdgeRouting, n), this.InsideOfTheAllowedConeOfBoundaryPort(this.StartPointOfEdgeRouting, this.TargetPort) && this.LineAvoidsTightHierarchy(r))
        this._polyline = new B(), this._polyline.addPoint(i), this._polyline.addPoint(r.start), this._polyline.addPoint(r.end), s = this.SmoothCornersAndReturnCurve(t, e);
      else {
        let l;
        if (l = v.IntersectPPPP(i, this.StartPointOfEdgeRouting, n, o))
          this._polyline = new B(), this._polyline.addPoint(i), this._polyline.addPoint(l), this._polyline.addPoint(n), s = this.SmoothCornersAndReturnCurve(t, e);
        else if (u.closeDistEps(this.StartPointOfEdgeRouting, o))
          this._polyline = new B(), this._polyline.addPoint(i), this._polyline.addPoint(o), this._polyline.addPoint(n), s = this.SmoothCornersAndReturnCurve(t, e);
        else if (this.LineAvoidsTightHierarchy(v.mkPP(this.StartPointOfEdgeRouting, o)))
          this._polyline = new B(), this._polyline.addPoint(i), this._polyline.addPoint(this.StartPointOfEdgeRouting), this._polyline.addPoint(o), this._polyline.addPoint(n), s = this.SmoothCornersAndReturnCurve(t, e);
        else {
          this.ExtendVisibilityGraphToTargetBoundaryPort(o), this._polyline = this.GetShortestPolyline(this.sourceVV, this.targetVV);
          const h = { tmpTargetTight: null }, c = this.HideSourceTargetTightsIfNeeded(h);
          this.RecoverSourceTargetTights(c, h.tmpTargetTight), this._polyline.PrependPoint(i), this._polyline.addPoint(n), s = this.SmoothCornersAndReturnCurve(t, e);
        }
      }
    }
    return s;
  }
  RecoverSourceTargetTights(t, e) {
    this.SourceTightPolyline = t, this.TargetTightPolyline = e;
  }
  HideSourceTargetTightsIfNeeded(t) {
    const e = this.SourceTightPolyline;
    return t.tmpTargetTight = this.TargetTightPolyline, this.TargetTightPolyline = null, this.SourceTightPolyline = null, e;
  }
  LineAvoidsTightHierarchy(t) {
    return tt.IntersectionsOfLineAndRectangleNodeOverPolylineLR(t, this.ObstacleCalculator.RootOfTightHierarchy).length === 0;
  }
  RouteFromFloatingPortToBoundaryPort(t, e) {
    const i = this.targetPort.Location;
    let s;
    if (this.InsideOfTheAllowedConeOfBoundaryPort(this.sourcePort.Location, this.targetPort) && (s = v.mkPP(this.SourcePort.Location, i), this.LineCanBeAcceptedForRouting(s)))
      return e.smoothedPolyline = this.SmoothedPolylineFromTwoPoints(s.start, s.end), s;
    const n = this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.TargetPort.Curve, this.TargetPort.Parameter, this.TargetLoosePolyline);
    if (s = v.mkPP(this.SourcePort.Location, n), this.LineAvoidsTightHierarchyLP(s, this._sourceTightPolyline))
      return this._polyline = B.mkFromPoints([s.start, s.end, i]), e.smoothedPolyline = Tt.mkFromPoints(this._polyline), e.smoothedPolyline.createCurve();
    this.ExtendVisibilityGraphToTargetBoundaryPort(n), this._polyline = this.GetShortestPolyline(this.sourceVV, this.targetVV), this._polyline.addPoint(i);
    const r = { smoothedPolyline: null };
    return this.SmoothCornersAndReturnCurve(t, r);
  }
  LineAvoidsTightHierarchyLP(t, e) {
    let i = !0;
    for (const s of tt.IntersectionsOfLineAndRectangleNodeOverPolylineLR(t, this.ObstacleCalculator.RootOfTightHierarchy))
      if (s.seg1 !== e) {
        i = !1;
        break;
      }
    return i;
  }
  LineAvoidsTightHierarchyLPP(t, e, i) {
    let s = !0;
    for (const n of tt.IntersectionsOfLineAndRectangleNodeOverPolylineLR(t, this.ObstacleCalculator.RootOfTightHierarchy))
      if (!(n.seg1 === e || n.seg1 === i)) {
        s = !1;
        break;
      }
    return s;
  }
  LineAvoidsTightHierarchyPPPP(t, e, i, s) {
    return this.LineAvoidsTightHierarchyLPP(v.mkPP(t, e), i, s);
  }
  ExtendVisibilityGraphToTargetBoundaryPort(t) {
    let e = null;
    if (this.VisibilityGraph == null && (this.VisibilityGraph = new wt()), !this.activeRectangle.contains(t) || !this.activeRectangle.containsRect(this.TargetLoosePolyline.boundingBox)) {
      this.activeRectangle.isEmpty ? (this.activeRectangle = this.TargetLoosePolyline.boundingBox.clone(), this.activeRectangle.add(this.SourcePort.Location), this.activeRectangle.add(this.StartPointOfEdgeRouting), this.activeRectangle.add(t)) : (this.activeRectangle.add(t), this.activeRectangle.addRec(this.TargetLoosePolyline.boundingBox)), e = this.GetAddedPolygonesAndMaybeExtendActiveRectangle();
      for (const i of e)
        this.VisibilityGraph.AddHole(i.Polyline);
    }
    e == null ? (this.targetVV != null && this.VisibilityGraph.RemoveVertex(this.targetVV), this.CalculateEdgeTargetVisibilityGraph(t)) : (this.RemovePointVisibilityGraphs(), new zi(e, this.activePolygons, this.VisibilityGraph).run(), Di(this.activePolygons, e), this.CalculateEdgeTargetVisibilityGraph(t), this.CalculateSourcePortVisibilityGraph());
  }
  // returns the hit object
  GetHitLoosePolyline(t) {
    return this.ObstacleCalculator.IsEmpty() || this.ObstacleCalculator.RootOfLooseHierarchy == null ? null : tt.GetFirstHitPolyline(t, this.ObstacleCalculator.RootOfLooseHierarchy);
  }
  static GetFirstHitPolyline(t, e) {
    const i = tt.GetFirstHitRectangleNode(t, e);
    return i ? i.UserData : null;
  }
  static GetFirstHitRectangleNode(t, e) {
    return e == null ? null : e.FirstHitNodeWithPredicate(t, (i, s) => g.PointRelativeToCurveLocation(i, s) !== F.Outside ? at.Stop : at.Continue);
  }
  //
  Clean() {
    this.TargetPort = null, this.SourcePort = null, this.SourceTightPolyline = null, this.SourceLoosePolyline = null, this.TargetLoosePolyline = null, this.targetTightPolyline = null, this.VisibilityGraph = null, this.targetVV = null, this.sourceVV = null, this.activePolygons = [], this.alreadyAddedOrExcludedPolylines.clear(), this.activeRectangle.setToEmpty();
  }
  // setting source port and the loose polyline of the port
  SetSourcePortAndSourceLoosePolyline(t, e) {
    this.SourceLoosePolyline = e, this.sourcePort = t, this.sourcePort != null && (this.SourceTightPolyline = tt.GetFirstHitPolyline(this.sourcePort.Location, this.ObstacleCalculator.RootOfTightHierarchy), this.sourcePort instanceof Te ? (this.alreadyAddedOrExcludedPolylines.add(this.SourceLoosePolyline), this.StartPointOfEdgeRouting = this.SourcePort.Location) : this.StartPointOfEdgeRouting = this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.SourcePort.Curve, this.sourcePort.Parameter, this.SourceLoosePolyline));
  }
  run() {
    this.CalculateWholeTangentVisibilityGraph();
  }
  CalculateWholeTangentVisibilityGraph() {
    this.VisibilityGraph = new wt(), this.CalculateWholeVisibilityGraphOnExistingGraph();
  }
  CalculateWholeVisibilityGraphOnExistingGraph() {
    this.activePolygons = Array.from(this.AllPolygons());
    for (const e of this.ObstacleCalculator.LooseObstacles)
      this.VisibilityGraph.AddHole(e);
    let t;
    this.UseSpanner ? t = new Us(this.ObstacleCalculator.LooseObstacles, this.VisibilityGraph) : t = new zi(new Array(), this.activePolygons, this.visibilityGraph), t.run();
  }
  RouteSplineFromPortToPortWhenTheWholeGraphIsReady(t, e, i, s) {
    const n = t instanceof Te && e instanceof Oe || t instanceof $t;
    if (n) {
      const o = t;
      t = e, e = o;
    }
    this.sourcePort = t, this.targetPort = e, this.FigureOutSourceTargetPolylinesAndActiveRectangle();
    let r = this.GetEdgeGeomByRouting(i, s);
    return r == null ? null : (this.targetVV = null, this.sourceVV = null, n && (r = r.reverse()), r);
  }
  GetEdgeGeomByRouting(t, e) {
    this.sourceIsInsideOfTargetTightPolyline = this.TargetTightPolyline == null || g.PointRelativeToCurveLocation(this.sourcePort.Location, this.TargetTightPolyline) === F.Inside;
    let i;
    if (this.sourcePort instanceof Oe) {
      const s = this.sourcePort;
      this.StartPointOfEdgeRouting = this.targetIsInsideOfSourceTightPolyline ? s.Location : this.TakeBoundaryPortOutsideOfItsLoosePolyline(s.Curve, s.Parameter, this.SourceLoosePolyline), this.CalculateSourcePortVisibilityGraph();
      const n = { smoothedPolyline: null };
      this.targetPort instanceof Oe ? i = this.RouteFromBoundaryPortToBoundaryPort(t, n) : i = this.RouteFromBoundaryPortToFloatingPort(this.targetLoosePolyline, t, n);
    } else this.targetPort instanceof Te ? (this.ExtendVisibilityGraphFromFloatingSourcePort(), i = this.RouteFromFloatingPortToFloatingPort(this.targetLoosePolyline, t, e)) : i = this.RouteFromFloatingPortToAnywherePort(this.targetPort.LoosePolyline, t, e, this.targetPort);
    return i;
  }
  RouteFromFloatingPortToAnywherePort(t, e, i, s) {
    return s.Curve.boundingBox.contains(this.sourcePort.Location) ? (this.sourceVV = this.GetVertex(this.sourcePort.Location), this._polyline = this.GetShortestPolylineToMulitpleTargets(this.sourceVV, Array.from(this.Targets(t))), this._polyline == null ? null : (this.FixLastPolylinePointForAnywherePort(s), s.HookSize > 0 && this.BuildHook(s), this.SmoothCornersAndReturnCurve(e, i))) : (i.smoothedPolyline = null, null);
  }
  BuildHook(t) {
    const e = t.Curve, i = j.mkFullEllipseNNP(t.HookSize, t.HookSize, this._polyline.end), s = g.getAllIntersections(e, i, !0);
    u.getTriangleOrientation(s[0].x, this._polyline.end, this._polyline.endPoint.prev.point) == L.Counterclockwise && s.reverse();
    const n = this._polyline.end.sub(this._polyline.endPoint.prev.point).normalize(), r = e.derivative(s[0].par0).normalize(), o = r.dot(n);
    if (Math.abs(o) < 0.2)
      this.ExtendPolyline(r, s[0], n, t);
    else {
      const l = e.derivative(s[1].par0).normalize();
      l.dot(n) < o ? this.ExtendPolyline(l, s[1], n, t) : this.ExtendPolyline(r, s[0], n, t);
    }
  }
  ExtendPolyline(t, e, i, s) {
    let n = t.rotate(Math.PI / 2);
    n.dot(i) < 0 && (n = n.neg());
    const r = e.x.add(n.mul(s.HookSize));
    let o;
    (o = u.lineLineIntersection(r, r.add(t), this._polyline.end, this._polyline.end.add(i))) && (this._polyline.addPoint(o), this._polyline.addPoint(r), this._polyline.addPoint(e.x));
  }
  FixLastPolylinePointForAnywherePort(t) {
    for (; ; ) {
      const e = this.GetLastPointInsideOfCurveOnPolyline(t.Curve);
      e.next.next = null, this._polyline.endPoint = e.next;
      let i = e.next.point.sub(e.point);
      i = i.normalize().mul(t.Curve.boundingBox.diagonal);
      const s = i.rotate(t.AdjustmentAngle * -1), n = i.rotate(t.AdjustmentAngle), r = g.intersectionOne(t.Curve, v.mkPP(e.point, e.point.add(s)), !0), o = g.intersectionOne(t.Curve, v.mkPP(e.point, e.point.add(n)), !0);
      if (r == null || o == null)
        return;
      const l = tt.GetTrimmedCurveForHookingUpAnywhere(t.Curve, e, r, o), h = l.value(l.closestParameter(e.point));
      if (!this.LineAvoidsTightHierarchyLPP(v.mkPP(e.point, h), this.SourceTightPolyline, null)) {
        const c = g.intersectionOne(t.Curve, v.mkPP(e.point, e.next.point), !1);
        if (c == null)
          return;
        this._polyline.endPoint.point = c.x;
        break;
      }
      if (this._polyline.endPoint.point = h, e.prev == null || !this.TryShortcutPolyPoint(e.prev))
        break;
    }
  }
  static GetTrimmedCurveForHookingUpAnywhere(t, e, i, s) {
    const n = u.getTriangleOrientation(s.x, i.x, e.point) === L.Clockwise, r = i.par0, o = s.par0;
    let l, h, c;
    return n ? r < o ? t.trim(r, o) : (h = t.trim(r, t.parEnd), l = t.trim(t.parStart, o), c = new g(), c.addSegs([h, l])) : o < r ? t.trim(o, r) : (h = t.trim(o, t.parEnd), l = t.trim(t.parStart, r), c = new g(), c.addSegs([h, l]));
  }
  GetLastPointInsideOfCurveOnPolyline(t) {
    for (let e = this._polyline.endPoint.prev; e != null; e = e.prev)
      if (e.prev == null || g.PointRelativeToCurveLocation(e.point, t) === F.Inside)
        return e;
    throw new Error();
  }
  GetShortestPolylineToMulitpleTargets(t, e) {
    this.CleanTheGraphForShortestPath();
    const s = new Ln(t, e, this.VisibilityGraph).GetPath();
    if (s == null)
      return null;
    const n = new B();
    for (const r of s)
      n.addPoint(r.point);
    return n.RemoveCollinearVertices();
  }
  Targets(t) {
    return Array.from(t).map((e) => this.visibilityGraph.FindVertex(e));
  }
  ExtendVisibilityGraphFromFloatingSourcePort() {
    const t = this.sourcePort;
    this.StartPointOfEdgeRouting = t.Location, this.UseSpanner ? this.sourceVV = this.AddTransientVisibilityEdgesForPort(this.sourcePort.Location, this.SourceLoosePolyline) : this.sourceVV = xi.CalculatePointVisibilityGraph(Array.from(this.GetActivePolylines()).filter((e) => e !== this.SourceLoosePolyline), this.VisibilityGraph, this.StartPointOfEdgeRouting, Oi.Tangent);
  }
  FigureOutSourceTargetPolylinesAndActiveRectangle() {
    let t = this.sourcePort.Curve.value(this.sourcePort.Curve.parStart);
    this._sourceTightPolyline = tt.GetFirstHitPolyline(t, this.ObstacleCalculator.RootOfTightHierarchy), this.SourceLoosePolyline = tt.GetFirstHitPolyline(t, this.ObstacleCalculator.RootOfLooseHierarchy), t = this.targetPort.Curve.value(this.targetPort.Curve.parStart), this.targetTightPolyline = tt.GetFirstHitPolyline(t, this.ObstacleCalculator.RootOfTightHierarchy), this.targetLoosePolyline = tt.GetFirstHitPolyline(t, this.ObstacleCalculator.RootOfLooseHierarchy), this.activeRectangle = T.mkPP(new u(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY), new u(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY));
  }
  *AllPolygons() {
    for (const t of this.ObstacleCalculator.LooseObstacles)
      yield new ue(t);
  }
  //
  GetVisibilityGraph() {
    return this.VisibilityGraph;
  }
  // ShowObstaclesAndVisGraph() {
  //    let obs = this.ObstacleCalculator.LooseObstacles.Select(() => {  }, new DebugCurve(100, 1, "blue", o));
  //    let edges = this.visibilityGraph.Edges.Select(() => {  }, new DebugCurve(70, 1, (e instanceof  "red"), LineSegment.mkPP(e.SourcePoint, e.TargetPoint)));
  //    // TODO: Warning!!!, inline IF is not supported ?
  //    TransientVisibilityEdge;
  //    "green";
  //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(obs.Concat(edges));
  // }
  AddActivePolygons(t) {
    Di(this.activePolygons, t);
  }
  ClearActivePolygons() {
    this.activePolygons = [];
  }
}
class vt {
  toJSON() {
    let t = "{";
    return this.tipPosition && (t += '"tipPosition": ' + this.tipPosition.toJSON()), t += "}", t;
  }
  clone() {
    const t = new vt();
    return t.length = this.length, t.width = this.width, t.tipPosition = this.tipPosition, t;
  }
  constructor() {
    this.length = vt.defaultArrowheadLength, this.width = 0, this.length = vt.defaultArrowheadLength;
  }
  // the edgeGeometry.Curve is trimmed already by the node boundaries</param>
  static calculateArrowheads(t) {
    if (t.sourceArrowhead == null && t.targetArrowhead == null)
      return !0;
    const e = vt.findTrimStartForArrowheadAtSource(t);
    if (e == null)
      return !1;
    const i = vt.findTrimEndForArrowheadAtTarget(t);
    if (i == null || e > i - m.intersectionEpsilon || g.closeIntersectionPoints(t.curve.value(e), t.curve.value(i)))
      return !1;
    const s = t.curve.trim(e, i);
    return s == null ? !1 : (t.sourceArrowhead != null && (t.sourceArrowhead.tipPosition = t.curve.start), t.targetArrowhead != null && (t.targetArrowhead.tipPosition = t.curve.end), t.curve = s, !0);
  }
  static getIntersectionsWithArrowheadCircle(t, e, i) {
    const s = j.mkFullEllipseNNP(e, e, i);
    return g.getAllIntersections(s, t, !0);
  }
  // we need to pass arrowhead length here since the original length mibh
  static findTrimEndForArrowheadAtTarget(t) {
    const e = m.distanceEpsilon * m.distanceEpsilon;
    let i = t.curve.parEnd;
    if (t.targetArrowhead == null || t.targetArrowhead.length <= m.distanceEpsilon)
      return i;
    const s = t.curve;
    let n = t.targetArrowhead.length, r, o, l = 10;
    do {
      if (l--, l === 0)
        return;
      o = vt.getIntersectionsWithArrowheadCircle(s, n, s.end), i = o.length !== 0 ? Math.max(...o.map((h) => h.par1)) : s.parEnd, r = t.curve.value(i), n /= 2;
    } while (r.sub(s.start).lengthSquared < e || o.length === 0);
    return i;
  }
  static findTrimStartForArrowheadAtSource(t) {
    if (t.sourceArrowhead == null || t.sourceArrowhead.length <= m.distanceEpsilon)
      return t.curve.parStart;
    const e = m.distanceEpsilon * m.distanceEpsilon;
    let i = t.sourceArrowhead.length, s;
    const n = t.curve;
    let r, o = 10, l;
    for (; --o > 0; ) {
      if (r = vt.getIntersectionsWithArrowheadCircle(n, i, n.start), r.length === 0)
        return n.parStart;
      if (l = Math.min(...r.map((h) => h.par1)), s = r.filter((h) => h.par1 === l)[0].x, s.sub(n.end).lengthSquared >= e)
        return l;
      i /= 2;
    }
  }
  // trim the edge curve with the node boundaries
  static trimSplineAndCalculateArrowheads(t, e, i) {
    return vt.trimSplineAndCalculateArrowheadsII(t, t.source.boundaryCurve, t.target.boundaryCurve, e, i);
  }
  // trim the edge curve with the node boundaries
  static trimSplineAndCalculateArrowheadsII(t, e, i, s, n) {
    if (t.curve = g.trimEdgeSplineWithNodeBoundaries(e, i, s, n), t.curve == null)
      return !1;
    if ((t.sourceArrowhead == null || t.sourceArrowhead.length < m.distanceEpsilon) && (t.targetArrowhead == null || t.targetArrowhead.length < m.distanceEpsilon))
      return !0;
    let r = !1;
    const o = t.sourceArrowhead != null ? t.sourceArrowhead.length : 0, l = t.targetArrowhead != null ? t.targetArrowhead.length : 0, h = t.curve.end.sub(t.curve.start).length;
    t.sourceArrowhead != null && (t.sourceArrowhead.length = Math.min(h, o)), t.targetArrowhead != null && (t.targetArrowhead.length = Math.min(h, l));
    let c = 10;
    for (; (t.sourceArrowhead != null && t.sourceArrowhead.length > m.intersectionEpsilon || t.targetArrowhead != null && t.targetArrowhead.length > m.intersectionEpsilon) && !r && (r = vt.calculateArrowheads(t), r || (t.sourceArrowhead != null && (t.sourceArrowhead.length *= 0.5), t.targetArrowhead != null && (t.targetArrowhead.length *= 0.5)), c--, c !== 0); )
      ;
    return r || (t.sourceArrowhead != null && (t.sourceArrowhead.tipPosition = s.start), t.targetArrowhead != null && (t.targetArrowhead.tipPosition = s.end)), t.sourceArrowhead != null && (t.sourceArrowhead.length = o), t.targetArrowhead != null && (t.targetArrowhead.length = l), r;
  }
  /** Creates a spline between two nodes big enough to draw arrowheads */
  static createBigEnoughSpline(t) {
    const e = t.source.center;
    let i = t.target.center;
    const s = i.sub(e), n = s.length;
    let r;
    n < 1e-3 ? (r = new u(1, 0), i = e.add(r.rotate(Math.PI / 2))) : r = s.rotate(Math.PI / 2);
    let o = 1;
    t.sourceArrowhead != null && (o += t.sourceArrowhead.length), t.targetArrowhead != null && (o += t.targetArrowhead.length), r = r.normalize().mul(1.5 * o);
    for (let l = 1; l < 1e4; l = l * 2) {
      const h = g.createBezierSegN(e, i, r, l);
      if (vt.trimSplineAndCalculateArrowheadsII(t, t.source.boundaryCurve, t.target.boundaryCurve, h, !1))
        return;
    }
    vt.createEdgeCurveWithNoTrimming(t, e, i);
  }
  // this method should never be called: it is a super emergency measure
  static createEdgeCurveWithNoTrimming(t, e, i) {
    const s = i.sub(e).normalize();
    let n = e, r = i;
    const o = t.targetArrowhead;
    o != null && (o.tipPosition = i, r = i.sub(s.mul(o.length)));
    const l = t.sourceArrowhead;
    l != null && (l.tipPosition = e, n = e.add(s.mul(l.length))), t.curve = v.mkPP(n, r);
  }
}
vt.defaultArrowheadLength = 5;
class Rn {
  constructor() {
    this.m = /* @__PURE__ */ new Map();
  }
  clear() {
    this.m.clear();
  }
  get size() {
    return this.m.size;
  }
  set(t, e) {
    this.m.set(nr(t), e);
  }
  delete(t) {
    this.m.delete(nr(t));
  }
  has(t) {
    return this.m.has(nr(t));
  }
  getPP(t, e) {
    return this.get(new ie(t, e));
  }
  get(t) {
    return this.m.get(nr(t));
  }
  *keys() {
    for (const t of this.m.keys())
      yield rl(t);
  }
  *[Symbol.iterator]() {
    for (const [t, e] of this.m)
      yield [rl(t), e];
  }
  *values() {
    yield* this.m.values();
  }
}
function rl(a) {
  const t = a.split(" "), e = t[0], i = t[1];
  let s = e.split(",");
  const n = new u(Number(s[0]), Number(s[1]));
  s = i.split(",");
  const r = new u(Number(s[0]), Number(s[1]));
  return new ie(n, r);
}
function Qd(a, t) {
  return [ol(a), ol(t)].sort().join(" ");
}
function nr(a) {
  return Qd(a.first, a.second);
}
function ol(a) {
  return a.x.toString() + "," + a.y.toString();
}
class le {
  /**  For a given graph finds the obstacles for nodes and clusters, correctly parenting the obstacles
       according to the cluster hierarchy
       graph with edges to route and nodes/clusters to route around.
       Returns the set of obstacles with correct cluster hierarchy and ports
  */
  static GetShapes(t, e = Array.from(t.shallowEdges)) {
    const i = /* @__PURE__ */ new Map();
    _h(t, i);
    for (const s of e) {
      let n = i.get(s.source);
      n && s.sourcePort != null && n.Ports.add(s.sourcePort), n = i.get(s.target), n && s.targetPort != null && n.Ports.add(s.targetPort);
    }
    return Array.from(i.values());
  }
  /**   Creates a shape with a RelativeFloatingPort for the node center, attaches it to the shape and all edges */
  static CreateShapeWithCenterPort(t) {
    const e = new Do(t), i = Zi.mk(() => t.boundaryCurve, () => t.center);
    e.Ports.add(i);
    for (const s of t.inEdges())
      le.FixPortAtTarget(i, s);
    for (const s of t.outEdges())
      le.FixPortAtSource(i, s);
    for (const s of t.selfEdges())
      le.FixPortAtSource(i, s), le.FixPortAtTarget(i, s);
    return e;
  }
  /**   Creates a ClusterBoundaryPort for the cluster boundary, attaches it to the shape and all edges */
  static CreateShapeWithClusterBoundaryPort(t) {
    const e = new Do(t), i = Ve.mk(() => t.boundaryCurve, () => t.center);
    e.Ports.add(i);
    let s;
    for (const n of t.inEdges())
      n.EdgeToAncestor() === fs.ToAncestor ? (s == null && (s = new $t(() => t.boundaryCurve)), n.targetPort = s) : le.FixPortAtTarget(i, n);
    for (const n of t.outEdges())
      n.EdgeToAncestor() === fs.FromAncestor ? (s == null && (s = new $t(() => t.boundaryCurve)), n.sourcePort = s) : le.FixPortAtSource(i, n);
    for (const n of t.selfEdges())
      le.FixPortAtSource(i, n), le.FixPortAtTarget(i, n);
    return e;
  }
  static FixPortAtSource(t, e) {
    e != null && e.sourcePort == null && (e.sourcePort = t);
  }
  static FixPortAtTarget(t, e) {
    e != null && e.targetPort == null && (e.targetPort = t);
  }
}
function _h(a, t) {
  for (const e of a.shallowNodes)
    if (e instanceof Nt) {
      const i = le.CreateShapeWithClusterBoundaryPort(e);
      t.set(e, i);
      const s = e;
      if (!s.isCollapsed) {
        _h(s, t);
        for (const n of s.shallowNodes)
          i.AddChild(t.get(n));
      }
    } else
      t.set(e, le.CreateShapeWithCenterPort(e));
}
var Ci;
(function(a) {
  a[a.NotVisited = 0] = "NotVisited", a[a.InStack = 1] = "InStack", a[a.Visited = 2] = "Visited";
})(Ci || (Ci = {}));
let Yd = class {
  constructor(t, e) {
    this.v = t, this.i = e;
  }
};
class $i {
  static getFeedbackSetWithConstraints(t, e) {
    throw new Error("Method not implemented.");
  }
  static push(t, e, i, s) {
    e[i] = Ci.InStack, t.push(new Yd(i, s));
  }
  static getFeedbackSet(t) {
    const e = new Ki();
    if (t == null || t.nodeCount === 0)
      return [];
    const i = new Array(t.nodeCount).fill(Ci.NotVisited);
    for (let s = 0; s < t.nodeCount; s++) {
      if (i[s] === Ci.Visited)
        continue;
      const n = new mt.Stack();
      let r = 0;
      for ($i.push(n, i, s, r); n.size > 0; ) {
        const o = n.pop();
        s = o.v, i[s] = Ci.Visited, r = o.i;
        let l = t.outEdges[s];
        for (; r < l.length; r++) {
          const h = l[r];
          if (h.source === h.target)
            continue;
          const c = i[h.target];
          c === Ci.InStack ? e.set(h.source, h.target, h) : c === Ci.NotVisited && ($i.push(n, i, s, r + 1), s = h.target, i[h.target] = Ci.Visited, l = t.outEdges[s], r = -1);
        }
      }
    }
    return Array.from(e.values());
  }
}
class ji {
  constructor() {
    this.isEmpty = !0;
  }
  AddValue(t) {
    this.isEmpty ? (this.max = t, this.min = t, this.isEmpty = !1) : t < this.min ? this.min = t : t > this.max && (this.max = t);
  }
  get length() {
    return this.max - this.min;
  }
  // 0  if value is close to zero;
  // 1  if value is strictly greater than zero;
  // -1 if value is strictly lower than zero;
  static sign(t) {
    return t > m.distanceEpsilon ? 1 : t < -m.distanceEpsilon ? -1 : 0;
  }
}
class Nn {
  SetActiveState(t, e) {
    this.IsActive = t, this.VectorIndex = e, this.IsActive ? (this.Left.ActiveConstraintCount++, this.Right.ActiveConstraintCount++) : (this.Left.ActiveConstraintCount--, this.Right.ActiveConstraintCount--);
  }
  SetVectorIndex(t) {
    this.VectorIndex = t;
  }
  Reinitialize() {
    this.IsActive = !1, this.IsUnsatisfiable = !1, this.ClearDfDv();
  }
  // This is an  function, not a propset, because we only want it called by the Solver.
  UpdateGap(t) {
    this.Gap = t;
  }
  // The Constraint constructor takes the two variables and their required distance.
  // The constraints will be generated either manually or by ConstraintGenerator,
  // both of which know about the sizes when the constraints are generated (as
  // well as any necessary padding), so the sizes are accounted for at that time
  // and ProjectionSolver classes are not aware of Variable sizes.
  static constructorVVNB(t, e, i, s) {
    const n = new Nn(t);
    return n.Left = t, n.Right = e, n.Gap = i, n.IsEquality = s, n.Lagrangian = 0, n.IsActive = !1, n;
  }
  // For Solver.ComputeDfDv's DummyParentNode's constraint only.
  constructor(t) {
    this.Right = t, this.Left = t;
  }
  // Generates a string representation of the Constraint.
  // <returns>A string representation of the Constraint.</returns>
  ToString() {
    return Gt.String.format("  Cst: [{0}] [{1}] {2} {3:F5} vio {4:F5} Lm {5:F5}/{6:F5} {7}actv", this.Left, this.Right, this.IsEquality ? "==" : ">=", this.Gap, this.Violation, this.Lagrangian, this.Lagrangian * 2, this.IsActive ? "+" : this.IsUnsatisfiable ? "!" : "-");
  }
  get Violation() {
    return this.Left.ActualPos * this.Left.Scale + (this.Gap - this.Right.ActualPos * this.Right.Scale);
  }
  ClearDfDv() {
    this.Lagrangian = 0;
  }
  // Compare this Constraint to rhs by their Variables in ascending order (this === lhs, other === rhs).
  // The object being compared to.
  // <returns>-1 if this.Left/Right are "less"; +1 if this.Left/Right are "greater"; 0 if this.Left/Right
  //         and rhs.Left/Right are equal.</returns>
  CompareTo(t) {
    let e = this.Left.CompareTo(t.Left);
    return e === 0 && (e = this.Right.CompareTo(t.Right)), e === 0 && (e = yt(this.Gap, t.Gap)), e;
  }
}
class Pn {
  static constructorDCVV(t, e, i, s) {
    const n = new Pn(e);
    return n.Set(t, e, i, s), n;
  }
  // For DummyParentNode only.
  constructor(t) {
    this.ConstraintToEval = t, this.Depth = -1;
  }
  Set(t, e, i, s) {
    return this.Parent = t, this.ConstraintToEval = e, this.VariableToEval = i, this.VariableDoneEval = s, this.Depth = 0, this.ChildrenHaveBeenPushed = !1, e.Lagrangian = 0, this;
  }
  get IsLeftToRight() {
    return this.VariableToEval === this.ConstraintToEval.Right;
  }
  toString() {
    return Gt.String.format("{0} {1}{2} - {3}{4} ({5})", "", this.IsLeftToRight ? "" : "*", this.ConstraintToEval.Left.Name, this.IsLeftToRight ? "*" : "", this.ConstraintToEval.Right.Name, this.Depth);
  }
}
class Jd {
  constructor(t, e) {
    this.Constraint = t, this.IsForward = e;
  }
}
class Gr {
  constructor(t, e) {
    this.Variables = new Array(), t != null && this.AddVariable(t), this.allConstraints = e;
  }
  // Generate a string representation of the Block.
  // <returns>A string representation of the Block.</returns>
  toString() {
    return Gt.String.format("[Block: nvars = {0} refpos = {1:F5} scale = {2:F5}]", this.Variables.length, this.ReferencePos, this.Scale);
  }
  ComputeDfDv(t) {
    this.allConstraints.DfDvStack = new mt.Stack();
    const e = new Nn(t);
    this.dfDvDummyParentNode = new Pn(e);
    const i = this.GetDfDvNode(this.dfDvDummyParentNode, e, t, null);
    for (this.allConstraints.DfDvStack.push(i); ; ) {
      const s = this.allConstraints.DfDvStack.top, n = this.allConstraints.DfDvStack.length;
      if (!s.ChildrenHaveBeenPushed) {
        s.ChildrenHaveBeenPushed = !0;
        for (const r of s.VariableToEval.LeftConstraints)
          if (r.IsActive && r.Right !== s.VariableDoneEval) {
            const o = this.GetDfDvNode(s, r, r.Right, s.VariableToEval);
            r.Right.ActiveConstraintCount === 1 ? this.ProcessDfDvLeafNodeDirectly(o) : this.PushDfDvNode(o);
          }
        for (const r of s.VariableToEval.RightConstraints)
          if (r.IsActive && r.Left !== s.VariableDoneEval) {
            const o = this.GetDfDvNode(s, r, r.Left, s.VariableToEval);
            r.Left.ActiveConstraintCount === 1 ? this.ProcessDfDvLeafNodeDirectly(o) : this.PushDfDvNode(o);
          }
        if (this.allConstraints.DfDvStack.length > n)
          continue;
      }
      if (this.allConstraints.DfDvStack.pop(), this.ProcessDfDvLeafNode(s), s === i)
        break;
    }
  }
  // end ComputeDfDv()
  ProcessDfDvLeafNode(t) {
    const e = t.VariableToEval.DfDv;
    t.IsLeftToRight ? (t.ConstraintToEval.Lagrangian = t.ConstraintToEval.Lagrangian + e, t.Parent.ConstraintToEval.Lagrangian = t.Parent.ConstraintToEval.Lagrangian + t.ConstraintToEval.Lagrangian) : (t.ConstraintToEval.Lagrangian = (t.ConstraintToEval.Lagrangian + e) * -1, t.Parent.ConstraintToEval.Lagrangian = t.Parent.ConstraintToEval.Lagrangian - t.ConstraintToEval.Lagrangian), this.CheckForConstraintPathTarget(t), this.Debug_CheckForViolatedActiveConstraint(t.ConstraintToEval), this.allConstraints.RecycleDfDvNode(t);
  }
  Debug_CheckForViolatedActiveConstraint(t) {
    t.Violation > this.allConstraints.SolverParameters.GapTolerance;
  }
  // Directly evaluate a leaf node rather than defer it to stack push/pop.
  ProcessDfDvLeafNodeDirectly(t) {
    this.ProcessDfDvLeafNode(t);
  }
  GetDfDvNode(t, e, i, s) {
    const n = this.allConstraints.DfDvRecycleStack.size > 0 ? this.allConstraints.DfDvRecycleStack.pop().Set(t, e, i, s) : Pn.constructorDCVV(t, e, i, s);
    return n.Depth = n.Parent.Depth + 1, this.allConstraints.MaxConstraintTreeDepth < n.Depth && (this.allConstraints.MaxConstraintTreeDepth = n.Depth), n;
  }
  // Called by ComputeDfDv.
  PushDfDvNode(t) {
    this.PushOnDfDvStack(t);
  }
  // Called by RecurseGetConnectedVariables.
  AddVariableAndPushDfDvNode(t, e) {
    t.push(e.VariableToEval), this.PushOnDfDvStack(e);
  }
  PushOnDfDvStack(t) {
    this.allConstraints.DfDvStack.push(t);
  }
  CheckForConstraintPathTarget(t) {
    if (this.pathTargetVariable === t.VariableToEval) {
      for (; t.Parent !== this.dfDvDummyParentNode; )
        this.constraintPath.push(new Jd(t.ConstraintToEval, t.IsLeftToRight)), t = t.Parent;
      this.pathTargetVariable = null;
    }
  }
  Expand(t) {
    this.constraintPath == null && (this.constraintPath = new Array()), this.constraintPath = [], this.pathTargetVariable = t.Right, this.ComputeDfDv(t.Left);
    let e = null;
    if (this.constraintPath.length > 0) {
      for (const r of this.constraintPath)
        r.IsForward && (e == null || r.Constraint.Lagrangian < e.Lagrangian) && (r.Constraint.IsEquality || (e = r.Constraint));
      e != null && this.allConstraints.DeactivateConstraint(e);
    }
    if (this.constraintPath = [], this.pathTargetVariable = null, e == null) {
      t.IsUnsatisfiable = !0, this.allConstraints.NumberOfUnsatisfiableConstraints++;
      return;
    }
    const i = new Array();
    this.GetConnectedVariables(i, t.Right, t.Left);
    const s = t.Violation, n = i.length;
    for (let r = 0; r < n; r++)
      i[r].OffsetInBlock = i[r].OffsetInBlock + s;
    this.allConstraints.ActivateConstraint(t), t.ClearDfDv(), this.UpdateReferencePos();
  }
  // end Expand()
  Split(t) {
    if (t && this.UpdateReferencePos(), this.Variables.length < 2)
      return null;
    let e = null;
    this.ComputeDfDv(this.Variables[0]);
    let i = this.allConstraints.SolverParameters.Advanced.MinSplitLagrangianThreshold;
    const s = this.Variables.length;
    for (let n = 0; n < s; n++)
      for (const r of this.Variables[n].LeftConstraints)
        r.IsActive && !r.IsEquality && r.Lagrangian < i && (e = r, i = r.Lagrangian);
    return e == null ? null : this.SplitOnConstraint(e);
  }
  SplitOnConstraint(t) {
    this.allConstraints.DeactivateConstraint(t);
    let e = new Gr(null, this.allConstraints);
    return this.TransferConnectedVariables(e, t.Right, t.Left), e.Variables.length > 0 ? (this.UpdateReferencePos(), e.UpdateReferencePos()) : e = null, e;
  }
  // end Split()
  AddVariable(t) {
    this.Variables.push(t), t.Block = this, this.Variables.length === 1 ? (this.Scale = t.Scale, this.ReferencePos = t.ActualPos, this.sumAd = t.ActualPos * t.Weight, this.sumAb = 0, this.sumA2 = t.Weight, t.OffsetInBlock = 0) : this.AddVariableToBlockSums(t);
  }
  UpdateReferencePos() {
    this.Scale = this.Variables[0].Scale, this.sumAd = 0, this.sumAb = 0, this.sumA2 = 0;
    const t = this.Variables.length;
    for (let e = 0; e < t; e++)
      this.AddVariableToBlockSums(this.Variables[e]);
    this.UpdateReferencePosFromSums();
  }
  AddVariableToBlockSums(t) {
    const e = this.Scale / t.Scale, i = t.OffsetInBlock / t.Scale, s = e * t.Weight;
    this.sumAd += s * t.DesiredPos, this.sumAb += s * i, this.sumA2 += s * e;
  }
  UpdateReferencePosFromSums() {
    if (!(Number.isFinite(this.sumAd) && Number.isFinite(this.sumAb) && Number.isFinite(this.sumA2)))
      throw new Error("infinite numbers");
    this.ReferencePos = (this.sumAd - this.sumAb) / this.sumA2, this.UpdateVariablePositions();
  }
  UpdateVariablePositions() {
    const t = this.Scale * this.ReferencePos, e = this.Variables.length;
    for (let i = 0; i < e; i++) {
      const s = this.Variables[i];
      s.ActualPos = (t + s.OffsetInBlock) / s.Scale;
    }
  }
  GetConnectedVariables(t, e, i) {
    this.RecurseGetConnectedVariables(t, e, i);
  }
  RecurseGetConnectedVariables(t, e, i) {
    this.allConstraints.DfDvStack = new mt.Stack();
    const s = new Nn(e);
    for (this.dfDvDummyParentNode = new Pn(s), this.allConstraints.DfDvStack.push(this.GetDfDvNode(this.dfDvDummyParentNode, s, e, i)), t.push(e); this.allConstraints.DfDvStack.length > 0; ) {
      const n = this.allConstraints.DfDvStack.top, r = this.allConstraints.DfDvStack.length;
      if (!n.ChildrenHaveBeenPushed) {
        n.ChildrenHaveBeenPushed = !0;
        for (const o of n.VariableToEval.LeftConstraints)
          o.IsActive && o.Right !== n.VariableDoneEval && (o.Right.ActiveConstraintCount === 1 ? t.push(o.Right) : this.AddVariableAndPushDfDvNode(t, this.GetDfDvNode(n, o, o.Right, n.VariableToEval)));
        for (const o of n.VariableToEval.RightConstraints)
          o.IsActive && o.Left !== n.VariableDoneEval && (o.Left.ActiveConstraintCount === 1 ? t.push(o.Left) : this.AddVariableAndPushDfDvNode(t, this.GetDfDvNode(n, o, o.Left, n.VariableToEval)));
      }
      this.allConstraints.DfDvStack.length > r || this.allConstraints.RecycleDfDvNode(this.allConstraints.DfDvStack.pop());
    }
  }
  TransferConnectedVariables(t, e, i) {
    this.GetConnectedVariables(t.Variables, e, i);
    const s = t.Variables.length;
    for (let r = 0; r < s; r++)
      t.Variables[r].Block = t;
    let n = this.Variables.length - 1;
    for (let r = this.Variables.length - 1; r >= 0; r--)
      this.Variables[r].Block === t && (r < n && (this.Variables[r] = this.Variables[n]), n--);
    if (this.Variables = this.Variables.slice(0, n + 1), this.Variables.length === 0) {
      for (let r = 0; r < s; r++) {
        const o = t.Variables[r];
        this.Variables.push(o), o.Block = this;
      }
      t.Variables = [];
    }
  }
}
class Kd {
  get Count() {
    return this.Vector.length;
  }
  item(t) {
    return this.Vector[t];
  }
  constructor() {
    this.Vector = new Array();
  }
  Add(t) {
    t.VectorIndex = this.Vector.length, this.Vector.push(t);
  }
  Remove(t) {
    const e = this.Vector[this.Vector.length - 1];
    this.Vector[t.VectorIndex] = e, e.VectorIndex = t.VectorIndex, this.Vector.pop();
  }
  toString() {
    return this.Vector.toString();
  }
}
class Zd {
  constructor() {
    this.nextConstraintIndex = 0, this.DfDvStack = new mt.Stack(), this.DfDvRecycleStack = new mt.Stack();
  }
  get IsEmpty() {
    return this.Vector == null;
  }
  Create(t) {
    this.Vector = new Array(t), this.firstActiveConstraintIndex = t;
  }
  Add(t) {
    t.SetVectorIndex(this.nextConstraintIndex), this.Vector[this.nextConstraintIndex++] = t;
  }
  ActivateConstraint(t) {
    this.firstActiveConstraintIndex--, this.SwapConstraint(t);
  }
  DeactivateConstraint(t) {
    this.SwapConstraint(t), this.firstActiveConstraintIndex++;
  }
  SwapConstraint(t) {
    const e = this.Vector[this.firstActiveConstraintIndex];
    e.SetVectorIndex(t.VectorIndex), this.Vector[t.VectorIndex] = e, this.Vector[this.firstActiveConstraintIndex] = t, t.SetActiveState(!t.IsActive, this.firstActiveConstraintIndex);
  }
  Reinitialize() {
    if (this.Vector != null) {
      for (const t of this.Vector)
        t.Reinitialize();
      this.firstActiveConstraintIndex = this.Vector.length;
    }
  }
  RecycleDfDvNode(t) {
    this.DfDvRecycleStack.length < 1024 && this.DfDvRecycleStack.push(t);
  }
  toString() {
    return this.Vector.toString();
  }
}
class ga {
  // Constructor.
  constructor() {
    this.GapTolerance = 1e-4, this.QpscConvergenceEpsilon = 1e-5, this.QpscConvergenceQuotient = 1e-6, this.OuterProjectIterationsLimit = -1, this.InnerProjectIterationsLimit = -1, this.TimeLimit = -1, this.Advanced = new pa();
  }
  // Deep-copy the AdvancedParameters.
  Clone() {
    const t = this.MemberwiseClone();
    return t.Advanced = this.Advanced.Clone(), t;
  }
  MemberwiseClone() {
    const t = new ga();
    return t.GapTolerance = this.GapTolerance, t.QpscConvergenceEpsilon = this.QpscConvergenceEpsilon, t.QpscConvergenceQuotient = this.QpscConvergenceQuotient, t.OuterProjectIterationsLimit = this.OuterProjectIterationsLimit, t.InnerProjectIterationsLimit = this.InnerProjectIterationsLimit, t.TimeLimit = this.TimeLimit, t;
  }
}
class pa {
  // Constructor.
  constructor() {
    this.ForceQpsc = !1, this.ScaleInQpsc = !0, this.MinSplitLagrangianThreshold = -1e-7, this.UseViolationCache = !0, this.ViolationCacheMinBlocksDivisor = 10, this.ViolationCacheMinBlocksCount = 100;
  }
  // Shallow-copy the object (there is nothing requiring deep-copy).
  Clone() {
    const t = new pa();
    return t.ForceQpsc = this.ForceQpsc, t.ScaleInQpsc = this.ScaleInQpsc, t.MinSplitLagrangianThreshold = this.MinSplitLagrangianThreshold, t.UseViolationCache = this.UseViolationCache, t.ViolationCacheMinBlocksDivisor = this.ViolationCacheMinBlocksDivisor, t.ViolationCacheMinBlocksCount = this.ViolationCacheMinBlocksCount, t;
  }
}
class $d {
  constructor(t) {
    this.Variable = t, this.OrigWeight = t.Weight, this.OrigScale = t.Scale, this.OrigDesiredPos = this.Variable.DesiredPos;
  }
}
class tf {
  constructor(t, e) {
    this.Value = t, this.Column = e;
  }
}
class ge {
  constructor(t, e) {
    this.newMatrixRow = new Array(), this.previousFunctionValue = Number.MAX_VALUE, this.solverParameters = t, this.matrixQ = new Array(e).fill(0), this.vectorWiDi = new Array(e).fill(0), this.vectorQpscVars = new Array(e).fill(0), this.gradientVector = new Array(e).fill(0), this.vectorQg = new Array(e).fill(0), this.vectorPrevY = new Array(e).fill(0), this.vectorCurY = new Array(e).fill(0);
  }
  //
  // solver.SolveQpsc drives the Qpsc instance as follows:
  // Initialization:
  //    Qpsc qpsc = new Qpsc(numVariables);
  //    foreach (variable in (foreach block))
  //       qpsc.AddVariable(variable)
  //    qpsc.VariablesComplete()
  // Per iteration:
  //    if (!qpsc.PreProject()) break;
  //    solver.SplitBlocks()
  //    solver.Project()
  //    if (!qpsc.PostProject()) break;
  // Done:
  //    qpsc.ProjectComplete()
  AddVariable(t) {
    if (this.isFirstProjectCall = !0, this.vectorWiDi[t.Ordinal] = 2 * (t.Weight * t.DesiredPos) * -1, this.vectorPrevY[t.Ordinal] = t.Weight, t.Neighbors != null)
      for (const e of t.Neighbors)
        this.vectorPrevY[t.Ordinal] = this.vectorPrevY[t.Ordinal] + e.Weight, this.vectorPrevY[e.Neighbor.Ordinal] = this.vectorPrevY[e.Neighbor.Ordinal] - e.Weight;
    for (let e = 0; e < this.vectorPrevY.length; e++)
      this.vectorPrevY[e] !== 0 && (this.newMatrixRow.push(new tf(this.vectorPrevY[e] * 2, e)), this.vectorPrevY[e] = 0);
    this.matrixQ[t.Ordinal] = Array.from(this.newMatrixRow), this.newMatrixRow = [], this.vectorQpscVars[t.Ordinal] = new $d(t), t.Weight = 1;
  }
  // end AddVariable()
  VariablesComplete() {
    for (const t of this.vectorQpscVars) {
      const e = t.Variable;
      for (const i of this.matrixQ[e.Ordinal])
        i.Column === e.Ordinal && (this.solverParameters.Advanced.ScaleInQpsc && (e.Scale = 1 / Math.sqrt(Math.abs(i.Value)), Number.isFinite(e.Scale) || (e.Scale = 1), e.Scale, this.vectorWiDi[e.Ordinal] = this.vectorWiDi[e.Ordinal] * e.Scale), this.vectorCurY[e.Ordinal] = e.ActualPos, e.DesiredPos = e.ActualPos);
    }
    if (this.solverParameters.Advanced.ScaleInQpsc)
      for (let t = 0; t < this.matrixQ.length; t++) {
        const e = this.matrixQ[t];
        for (let i = 0; i < e.length; i++)
          e[i].Column === t ? e[i].Value = 1 : e[i].Value = e[i].Value * (this.vectorQpscVars[t].Variable.Scale * this.vectorQpscVars[e[i].Column].Variable.Scale);
      }
  }
  // end VariablesComplete()
  // Called by SolveQpsc before the split/project phase.  Returns false if the difference in the
  // function value on the current vs. previous iteration is sufficiently small that we're done.
  // @@PERF: Right now this is distinct matrix/vector operations.  Profiling shows most time
  // in Qpsc is taken by MatrixVectorMultiply.  We could gain a bit of performance by combining
  // some things but keep it simple unless that's needed.
  PreProject() {
    if (this.isFirstProjectCall)
      for (const s of this.vectorQpscVars)
        this.vectorCurY[s.Variable.Ordinal] = s.Variable.ActualPos;
    if (this.MatrixVectorMultiply(this.vectorCurY, this.gradientVector), this.HasConverged())
      return !1;
    ge.VectorVectorAdd(this.gradientVector, this.vectorWiDi, this.gradientVector);
    const t = ge.VectorVectorMultiply(this.gradientVector, this.gradientVector);
    let e = 0;
    if (t !== 0 && (this.MatrixVectorMultiply(this.gradientVector, this.vectorQg), e = ge.VectorVectorMultiply(this.vectorQg, this.gradientVector)), e === 0)
      return !1;
    const i = t / e;
    ge.VectorCopy(this.vectorPrevY, this.vectorCurY), ge.VectorScaledVectorSubtract(this.vectorPrevY, i, this.gradientVector, this.vectorCurY);
    for (let s = 0; s < this.vectorCurY.length; s++)
      this.vectorQpscVars[s].Variable.DesiredPos = this.vectorCurY[s];
    return !0;
  }
  // end PreProject()
  // Called by SolveQpsc after the split/project phase.
  PostProject() {
    for (const i of this.vectorQpscVars)
      this.vectorCurY[i.Variable.Ordinal] = i.Variable.ActualPos;
    ge.VectorVectorSubtract(this.vectorPrevY, this.vectorCurY, this.vectorCurY);
    const t = ge.VectorVectorMultiply(this.gradientVector, this.vectorCurY);
    let e = 0;
    if (t !== 0) {
      this.MatrixVectorMultiply(this.vectorCurY, this.vectorQg);
      const i = ge.VectorVectorMultiply(this.vectorQg, this.vectorCurY);
      e = i === 0 ? 1 : t / i, e > 1 ? e = 1 : e < 0 && (e = 0);
    }
    return ge.VectorScaledVectorSubtract(this.vectorPrevY, e, this.vectorCurY, this.vectorCurY), this.isFirstProjectCall = !1, e > 0;
  }
  // end PostProject()
  QpscComplete() {
    for (const t of this.vectorQpscVars)
      t.Variable.Weight = t.OrigWeight, t.Variable.DesiredPos = t.OrigDesiredPos, this.solverParameters.Advanced.ScaleInQpsc && (t.Variable.ActualPos = t.Variable.ActualPos * t.Variable.Scale, t.Variable.Scale = t.OrigScale);
    return this.previousFunctionValue;
  }
  HasConverged() {
    const t = this.GetFunctionValue(this.vectorCurY);
    let e = !1;
    if (!this.isFirstProjectCall) {
      const i = this.previousFunctionValue - t;
      let s = 0;
      if (i !== 0) {
        const n = this.previousFunctionValue !== 0 ? this.previousFunctionValue : t;
        s = Math.abs(i / n);
      }
      (Math.abs(i) < this.solverParameters.QpscConvergenceEpsilon || Math.abs(s) < this.solverParameters.QpscConvergenceQuotient) && (e = !0);
    }
    return this.previousFunctionValue = t, e;
  }
  GetFunctionValue(t) {
    return ge.VectorVectorMultiply(this.gradientVector, t) / 2 + ge.VectorVectorMultiply(this.vectorWiDi, t);
  }
  // Returns the dot product of two column vectors (with an "implicit transpose").
  static VectorVectorMultiply(t, e) {
    let i = 0;
    for (let s = 0; s < t.length; s++)
      i = i + t[s] * e[s];
    return i;
  }
  // Multiplies matrixQ with the column vector rhs leaving the result in column vector in result[].
  MatrixVectorMultiply(t, e) {
    let i = 0;
    for (const s of this.matrixQ) {
      let n = 0;
      for (const r of s)
        n = n + r.Value * t[r.Column];
      e[i++] = n;
    }
  }
  // Returns the addition result in result[] (which may be lhs or rhs or a different vector).
  static VectorVectorAdd(t, e, i) {
    for (let s = 0; s < t.length; s++)
      i[s] = t[s] + e[s];
  }
  // Returns the subtraction result in result[] (which may be lhs or rhs or a different vector).
  static VectorVectorSubtract(t, e, i) {
    for (let s = 0; s < t.length; s++)
      i[s] = t[s] - e[s];
  }
  // Same as VectorVectorSubtract except that rhs is multiplied by the scale value.
  static VectorScaledVectorSubtract(t, e, i, s) {
    for (let n = 0; n < t.length; n++)
      s[n] = t[n] - e * i[n];
  }
  // Copies src to dest
  static VectorCopy(t, e) {
    for (let i = 0; i < e.length; i++)
      t[i] = e[i];
  }
}
class Mr {
  constructor() {
    this.NumberOfUnsatisfiableConstraints = 0, this.OuterProjectIterations = 0, this.InnerProjectIterationsTotal = 0, this.MinInnerProjectIterations = 0, this.MaxInnerProjectIterations = 0, this.MaxConstraintTreeDepth = 0, this.GoalFunctionValue = 0, this.TimeLimitExceeded = !1, this.OuterProjectIterationsLimitExceeded = !1, this.InnerProjectIterationsLimitExceeded = !1;
  }
  // Indicates whether one or more execution limits were exceeded.
  get ExecutionLimitExceeded() {
    return this.TimeLimitExceeded || this.OuterProjectIterationsLimitExceeded || this.InnerProjectIterationsLimitExceeded;
  }
  // Shallow-copy everything, including the contained list.
  Clone() {
    const t = new Mr();
    return t.GoalFunctionValue = this.GoalFunctionValue, t.InnerProjectIterationsLimitExceeded = this.InnerProjectIterationsLimitExceeded, t.InnerProjectIterationsTotal = this.InnerProjectIterationsTotal, t.MaxConstraintTreeDepth = this.MaxConstraintTreeDepth, t.OuterProjectIterations = this.OuterProjectIterations, t.OuterProjectIterationsLimitExceeded = this.OuterProjectIterationsLimitExceeded, t.AlgorithmUsed = this.AlgorithmUsed, t.NumberOfUnsatisfiableConstraints = this.NumberOfUnsatisfiableConstraints, t.MaxInnerProjectIterations = this.MaxInnerProjectIterations, t;
  }
}
var Fr;
(function(a) {
  a[a.ProjectOnly = 0] = "ProjectOnly", a[a.QpscWithScaling = 1] = "QpscWithScaling", a[a.QpscWithoutScaling = 2] = "QpscWithoutScaling";
})(Fr || (Fr = {}));
class ef {
  constructor(t, e) {
    this.Neighbor = t, this.Weight = e;
  }
}
class sf {
  // The derivative value - essentially the weighted difference in position.
  get DfDv() {
    return 2 * (this.Weight * (this.ActualPos - this.DesiredPos)) / this.Scale;
  }
  constructor(t, e, i, s, n) {
    if (this.ActiveConstraintCount = 0, s <= 0)
      throw new Error("weight");
    if (n <= 0)
      throw new Error("scale");
    let r = i * s;
    if (!Number.isFinite(r) || Number.isNaN(r))
      throw new Error("desiredPos");
    if (r = i * n, !Number.isFinite(r) || Number.isNaN(r))
      throw new Error("desiredPos");
    this.Ordinal = t, this.UserData = e, this.DesiredPos = i, this.Weight = s, this.Scale = n, this.OffsetInBlock = 0, this.ActualPos = this.DesiredPos;
  }
  Reinitialize() {
    this.ActiveConstraintCount = 0, this.OffsetInBlock = 0, this.ActualPos = this.DesiredPos;
  }
  AddNeighbor(t, e) {
    this.Neighbors == null && (this.Neighbors = new Array()), this.Neighbors.push(new ef(t, e));
  }
  // Gets a string representation of the Variable; calls UserData.ToString as part of this.
  // <returns>A string representation of the variable.</returns>
  toString() {
    return Gt.String.format("{0} {1:F5} ({2:F5}) {3:F5} {4:F5}", this.Name, this.ActualPos, this.DesiredPos, this.Weight, this.Scale);
  }
  // Gets the string representation of UserData.
  // <returns>A string representation of Node.Object.</returns>
  get Name() {
    return this.UserData == null ? "-0-" : this.UserData.toString();
  }
  SetConstraints(t, e) {
    this.LeftConstraints = t, this.RightConstraints = e;
  }
  // Compare the Variables by their ordinals, in ascending order (this === lhs, other === rhs).
  // The object being compared to.
  // <returns>-1 if this.Ordinal is "less"; +1 if this.Ordinal is "greater"; 0 if this.Ordinal
  //         and rhs are equal.</returns>
  CompareTo(t) {
    return yt(this.Ordinal, t.Ordinal);
  }
}
class Bn {
  get IsFull() {
    return this.numConstraints === Bn.MaxConstraints;
  }
  Clear() {
    this.LowViolation = 0, this.numConstraints = 0, this.constraints || (this.constraints = new Array(Bn.MaxConstraints));
  }
  FilterBlock(t) {
    this.LowViolation = Number.MAX_VALUE;
    const e = this.numConstraints > 0;
    for (let i = this.numConstraints - 1; i >= 0; i--) {
      const s = this.constraints[i];
      if (s.Left.Block === t || s.Right.Block === t || s.IsActive || s.IsUnsatisfiable)
        i < this.numConstraints - 1 && (this.constraints[i] = this.constraints[this.numConstraints - 1]), this.numConstraints--;
      else {
        const n = s.Left.ActualPos * s.Left.Scale + (s.Gap - s.Right.ActualPos * s.Right.Scale);
        n < this.LowViolation && (this.LowViolation = n);
      }
    }
    return this.numConstraints === 0 && (this.LowViolation = 0), e;
  }
  // Find the highest constraint with a greater violation than targetViolation.
  FindIfGreater(t) {
    let e = null;
    for (let i = 0; i < this.numConstraints; i++) {
      const s = this.constraints[i], n = s.Left.ActualPos * s.Left.Scale + (s.Gap - s.Right.ActualPos * s.Right.Scale);
      n > t && (t = n, e = s);
    }
    return e;
  }
  Insert(t, e) {
    let i = 0, s = e, n = e;
    for (let r = 0; r < this.numConstraints; r++) {
      const o = this.constraints[r], l = o.Left.ActualPos * o.Left.Scale + (o.Gap - o.Right.ActualPos * o.Right.Scale);
      l < s ? (n = s, i = r, s = l) : l < n && (n = l);
    }
    this.IsFull ? (this.constraints[i] = t, this.LowViolation = n) : (this.constraints[this.numConstraints++] = t, this.IsFull && (this.LowViolation = s));
  }
}
Bn.MaxConstraints = 20;
class al {
  constructor(t, e) {
    this.NumberOfLeftConstraints = 0, this.Constraints = t, this.NumberOfLeftConstraints = e;
  }
}
class nf {
  constructor() {
    this.allBlocks = new Kd(), this.allConstraints = new Zd(), this.numberOfConstraints = 0, this.numberOfVariables = 0, this.equalityConstraints = new Array(), this.loadedVariablesAndConstraintLists = /* @__PURE__ */ new Map(), this.emptyConstraintList = new Array(0), this.updatedConstraints = new Array(), this.violationCache = new Bn(), this.violationCacheMinBlockCutoff = 0, this.nextVariableOrdinal = 0, this.solverParams = new ga(), this.solverSolution = new Mr();
  }
  get IsQpsc() {
    return this.hasNeighbourPairs || this.solverParams.Advanced.ForceQpsc;
  }
  // Add a Variable (for example, wrapping a node on one axis of the graph) to the Solver.
  // a tag or other user data - can be null
  // The position of the variable, such as the coordinate of a node along one axis.
  // <returns>The created variable</returns>
  AddVariableAN(t, e) {
    return this.AddVariableANNN(t, e, 1, 1);
  }
  // Add a Variable (for example, wrapping a node on one axis of the graph) to the Solver.
  // a tag or other user data - can be null
  // The position of the variable, such as the coordinate of a node along one axis.
  // The weight of the variable (makes it less likely to move if the weight is high).
  AddVariableANN(t, e, i) {
    return this.AddVariableANNN(t, e, i, 1);
  }
  // Add a Variable (for example, wrapping a node on one axis of the graph) to the Solver.
  // a tag or other user data - can be null
  // The position of the variable, such as the coordinate of a node along one axis.
  // The weight of the variable (makes it less likely to move if the weight is high).
  // The scale of the variable, for improving convergence.
  // <returns>The created variable</returns>
  AddVariableANNN(t, e, i, s) {
    if (!this.allConstraints.IsEmpty)
      throw new Error("Cannot add Variables or Constraints once Solve() has been called");
    const n = new sf(this.nextVariableOrdinal++, t, e, i, s), r = new Gr(n, this.allConstraints);
    return n.Block = r, this.allBlocks.Add(r), this.numberOfVariables++, this.loadedVariablesAndConstraintLists.set(n, new al(new Array(), 0)), n;
  }
  // end AddVariable()
  // Must be called before Solve() if the caller has updated variable Initial positions; this
  // reconciles internals such as Block.ReferencePos.
  UpdateVariables() {
    for (const t of this.allBlocks.Vector)
      t.UpdateReferencePos();
  }
  // end UpdateVariables()
  // This enumerates all Variables created by AddVariable.
  get Variables() {
    return Qn(this.allBlocks.Vector, (t) => t.Variables);
  }
  // The number of variables added to the Solver.
  get VariableCount() {
    return this.numberOfVariables;
  }
  // This enumerates all Constraints created by AddConstraint (which in turn may have
  // been called from OverlapRemoval.ConstraintGenerator.Generate()).
  *Constraints() {
    if (this.allConstraints.IsEmpty)
      for (const t of this.loadedVariablesAndConstraintLists.keys()) {
        const e = this.loadedVariablesAndConstraintLists.get(t);
        if (e.Constraints != null) {
          const i = e.Constraints.length;
          for (let s = 0; s < i; s++) {
            const n = e.Constraints[s];
            if (t === n.Left)
              return yield, n;
          }
        }
      }
    else
      for (const t of this.allConstraints.Vector)
        yield t;
  }
  // end Constraints property
  // The number of constraints added to the Solver.
  get ConstraintCount() {
    return this.numberOfConstraints;
  }
  // Add a constraint 'left + gap' is equal to right
  AddEqualityConstraint(t, e, i) {
    return this.AddConstraintVVNB(t, e, i, !0);
  }
  // Add a constraint 'left + gap' is less than or equal to 'right'
  // The gap required between the variables.
  // <returns>The new constraint.</returns>
  AddConstraintVVNB(t, e, i, s) {
    if (!this.allConstraints.IsEmpty)
      throw new Error("Cannot add Variables or Constraints once Solve() has been called");
    if (t === e)
      throw new Error("Cannot add a constraint between a variable and itself");
    const n = this.loadedVariablesAndConstraintLists.get(t), r = this.loadedVariablesAndConstraintLists.get(e), o = Nn.constructorVVNB(t, e, i, s);
    return this.loadedVariablesAndConstraintLists.set(t, new al(n.Constraints, n.NumberOfLeftConstraints + 1)), n.Constraints.push(o), r.Constraints.push(o), this.numberOfConstraints++, s && this.equalityConstraints.push(o), o;
  }
  // Add a constraint 'left + gap' is less than or equal to 'right'
  // The gap required between the variables.
  // <returns>The new constraint.</returns>
  AddConstraint(t, e, i) {
    return this.AddConstraintVVNB(t, e, i, !1);
  }
  // Register an update to a constraint's gap; this defers the actual update until Solve() is called.
  // The constraint to update
  // The new gap
  SetConstraintUpdate(t, e) {
    e !== t.Gap && this.updatedConstraints.push([t, e]);
  }
  // Add a pair of connected variables for goal functions of the form (x1-x2)^2.  These are
  // minimally satisfied, along with the default (x-i)^2 goal function, while also satisfying
  // all constraints.
  // The first variable
  // The second variable
  // The weight of the relationship
  AddNeighborPair(t, e, i) {
    if (i <= 0 || Number.isNaN(i) || !Number.isFinite(i))
      throw new Error("relationshipWeight");
    if (t === e)
      throw new Error();
    t.AddNeighbor(e, i), e.AddNeighbor(t, i), this.hasNeighbourPairs = !0;
  }
  // end AddNeighborPair()
  // Sets Variable.ActualPos to the positions of the Variables that minimally satisfy the constraints
  // along this axis.  This overload uses default solution parameter values.
  // <returns>A Solution object.</returns>
  Solve() {
    return this.SolvePar(null);
  }
  // Sets Variable.ActualPos to the positions of the Variables that minimally satisfy the constraints
  // along this axis.  This overload takes a parameter specification.
  // Solution-generation options.
  // <returns>The only failure condition is if there are one or more unsatisfiable constraints, such as cycles
  //         or mutually exclusive equality constraints; if these are encountered, a list of lists of these
  //         constraints is returned, where each list contains a single cycle, which may be of length one for
  //         unsatisfiable equality constraints.  Otherwise, the return value is null.</returns>
  SolvePar(t) {
    t && (this.solverParams = t.Clone()), this.solverParams.OuterProjectIterationsLimit < 0 && (this.solverParams.OuterProjectIterationsLimit = 100 * (Math.floor(Math.log2(this.numberOfVariables)) + 1)), this.solverParams.InnerProjectIterationsLimit < 0 && (this.solverParams.InnerProjectIterationsLimit = this.numberOfConstraints * 2 + 100 * (Math.max(0, Math.floor(Math.log2(this.numberOfConstraints))) + 1));
    const e = !this.allConstraints.IsEmpty;
    if (this.CheckForUpdatedConstraints(), this.solverSolution = new Mr(), this.solverSolution.MinInnerProjectIterations = Number.MAX_VALUE, this.allConstraints.MaxConstraintTreeDepth = 0, this.allConstraints.SolverParameters = this.solverParams, this.numberOfConstraints === 0) {
      if (!this.IsQpsc)
        return this.solverSolution.Clone();
    } else e || this.SetupConstraints();
    return this.allConstraints.NumberOfUnsatisfiableConstraints = 0, this.MergeEqualityConstraints(), this.IsQpsc ? this.SolveQpsc() : (this.SolveByStandaloneProject(), this.CalculateStandaloneProjectGoalFunctionValue()), this.solverSolution.MinInnerProjectIterations > this.solverSolution.MaxInnerProjectIterations && (this.solverSolution.MinInnerProjectIterations = this.solverSolution.MaxInnerProjectIterations), this.solverSolution.NumberOfUnsatisfiableConstraints = this.allConstraints.NumberOfUnsatisfiableConstraints, this.solverSolution.MaxConstraintTreeDepth = this.allConstraints.MaxConstraintTreeDepth, this.solverSolution.Clone();
  }
  // end Solve()
  CheckForUpdatedConstraints() {
    if (this.updatedConstraints.length === 0)
      return;
    let t = this.IsQpsc;
    for (const [e, i] of this.updatedConstraints) {
      const s = e;
      if (s.UpdateGap(i), !t && !s.IsEquality) {
        this.SplitOnConstraintIfActive(s);
        continue;
      }
      t = !0;
    }
    this.updatedConstraints = [], t && this.ReinitializeBlocks();
  }
  SplitOnConstraintIfActive(t) {
    if (t.IsActive) {
      const e = t.Left.Block.SplitOnConstraint(t);
      e != null && this.allBlocks.Add(e);
    }
  }
  SetupConstraints() {
    this.allConstraints.Create(this.numberOfConstraints);
    for (const t of this.loadedVariablesAndConstraintLists.keys()) {
      const e = this.loadedVariablesAndConstraintLists.get(t), i = e.Constraints;
      let s = 0, n = 0, r = 0;
      i != null && (s = i.length, n = e.NumberOfLeftConstraints, r = s - n);
      let o = this.emptyConstraintList;
      n !== 0 && (o = new Array(n));
      let l = this.emptyConstraintList;
      r !== 0 && (l = new Array(r)), t.SetConstraints(o, l);
      let h = 0, c = 0;
      for (let d = 0; d < s; d++) {
        const f = i[d];
        t === f.Left ? o[h++] = f : l[c++] = f;
      }
      for (const d of t.LeftConstraints)
        this.allConstraints.Add(d);
    }
    this.loadedVariablesAndConstraintLists.clear(), this.violationCacheMinBlockCutoff = Number.MAX_VALUE, this.solverParams.Advanced.UseViolationCache && this.solverParams.Advanced.ViolationCacheMinBlocksDivisor > 0 && (this.violationCacheMinBlockCutoff = Math.min(this.allBlocks.Count / this.solverParams.Advanced.ViolationCacheMinBlocksDivisor, this.solverParams.Advanced.ViolationCacheMinBlocksCount));
  }
  SolveByStandaloneProject() {
    for (; ; ) {
      if (!this.RunProject())
        return;
      if (!this.SplitBlocks())
        break;
    }
  }
  RunProject() {
    return this.solverSolution.OuterProjectIterations++, this.Project(), !this.CheckForLimitsExceeded();
  }
  CheckForLimitsExceeded() {
    return this.solverParams.OuterProjectIterationsLimit > 0 && this.solverSolution.OuterProjectIterations >= this.solverParams.OuterProjectIterationsLimit ? (this.solverSolution.OuterProjectIterationsLimitExceeded = !0, !0) : !!this.solverSolution.InnerProjectIterationsLimitExceeded;
  }
  CalculateStandaloneProjectGoalFunctionValue() {
    this.solverSolution.GoalFunctionValue = 0;
    const t = this.allBlocks.Count;
    for (let e = 0; e < t; e++) {
      const i = this.allBlocks.item(e), s = i.Variables.length;
      for (let n = 0; n < s; n++) {
        const r = i.Variables[n];
        this.solverSolution.GoalFunctionValue += r.Weight * (r.ActualPos * r.ActualPos), this.solverSolution.GoalFunctionValue -= 2 * (r.Weight * (r.DesiredPos * r.ActualPos));
      }
    }
  }
  // Implements the full solve_QPSC from the Ipsep_Cola and Scaling papers.
  SolveQpsc() {
    if (this.solverSolution.AlgorithmUsed = this.solverParams.Advanced.ScaleInQpsc ? Fr.QpscWithScaling : Fr.QpscWithoutScaling, !this.QpscMakeFeasible())
      return;
    const t = new ge(this.solverParams, this.numberOfVariables);
    for (const i of this.allBlocks.Vector)
      for (const s of i.Variables)
        t.AddVariable(s);
    t.VariablesComplete(), this.ReinitializeBlocks(), this.MergeEqualityConstraints();
    let e = !1;
    for (; !(!t.PreProject() && !e || (e = this.SplitBlocks(), !this.RunProject()) || !t.PostProject() && !e); )
      ;
    this.solverSolution.GoalFunctionValue = t.QpscComplete();
  }
  QpscMakeFeasible() {
    return this.RunProject();
  }
  ReinitializeBlocks() {
    const t = Array.from(this.allBlocks.Vector);
    this.allBlocks.Vector = [];
    for (const e of t)
      for (const i of e.Variables) {
        i.Reinitialize();
        const s = new Gr(i, this.allConstraints);
        this.allBlocks.Add(s);
      }
    this.allConstraints.Reinitialize(), this.violationCache.Clear();
  }
  MergeEqualityConstraints() {
    for (const t of this.equalityConstraints) {
      if (t.Left.Block === t.Right.Block) {
        Math.abs(t.Violation) > this.solverParams.GapTolerance && (t.IsUnsatisfiable = !0, this.allConstraints.NumberOfUnsatisfiableConstraints++);
        continue;
      }
      this.MergeBlocks(t);
    }
  }
  Project() {
    if (this.numberOfConstraints === 0)
      return !1;
    this.violationCache.Clear(), this.lastModifiedBlock = null;
    let t = this.allBlocks.Count > this.violationCacheMinBlockCutoff, e = 1;
    const i = { maxViolation: 0 };
    let s = this.GetMaxViolatedConstraint(i, t);
    if (!s)
      return !1;
    for (; s; ) {
      if (s.Left.Block === s.Right.Block ? (s.Left.Block.Expand(s), s.IsUnsatisfiable && this.violationCache.Clear(), this.lastModifiedBlock = s.Left.Block) : this.lastModifiedBlock = this.MergeBlocks(s), this.solverParams.InnerProjectIterationsLimit > 0 && e >= this.solverParams.InnerProjectIterationsLimit) {
        this.solverSolution.InnerProjectIterationsLimitExceeded = !0;
        break;
      }
      t = this.allBlocks.Count > this.violationCacheMinBlockCutoff, t || this.violationCache.Clear(), e++;
      const n = { maxViolation: 0 };
      s = this.GetMaxViolatedConstraint(n, t);
    }
    return this.solverSolution.InnerProjectIterationsTotal = this.solverSolution.InnerProjectIterationsTotal + e, this.solverSolution.MaxInnerProjectIterations < e && (this.solverSolution.MaxInnerProjectIterations = e), this.solverSolution.MinInnerProjectIterations > e && (this.solverSolution.MinInnerProjectIterations = e), !0;
  }
  // end Project()
  MergeBlocks(t) {
    let e = t.Left.Block, i = t.Right.Block, s = t.Left.OffsetInBlock + (t.Gap - t.Right.OffsetInBlock);
    i.Variables.length > e.Variables.length && (e = t.Right.Block, i = t.Left.Block, s = -s);
    const n = i.Variables.length;
    for (let r = 0; r < n; r++) {
      const o = i.Variables[r];
      o.OffsetInBlock += s, e.AddVariable(o);
    }
    return e.UpdateReferencePosFromSums(), this.allConstraints.ActivateConstraint(t), this.allBlocks.Remove(i), e;
  }
  // end MergeBlocks()
  SplitBlocks() {
    const t = new Array(), e = this.allBlocks.Count;
    for (let s = 0; s < e; s++) {
      const r = this.allBlocks.item(s).Split(this.IsQpsc);
      r != null && t.push(r);
    }
    const i = t.length;
    for (let s = 0; s < i; s++) {
      const n = t[s];
      this.allBlocks.Add(n);
    }
    return t.length !== 0;
  }
  // end SplitBlocks
  GetMaxViolatedConstraint(t, e) {
    t.maxViolation = this.solverParams.GapTolerance;
    const i = this.SearchViolationCache(t.maxViolation);
    return i ?? this.SearchAllConstraints(t.maxViolation, e);
  }
  // end GetMaxViolatedConstraint()
  SearchViolationCache(t) {
    let e = null;
    if (this.lastModifiedBlock == null)
      return;
    this.lastModifiedBlock.Variables.length < this.numberOfVariables + 1 && this.violationCache.FilterBlock(this.lastModifiedBlock);
    const i = this.lastModifiedBlock.Variables.length;
    for (let n = 0; n < i; n++) {
      const r = this.lastModifiedBlock.Variables[n];
      for (const o of r.LeftConstraints)
        if (!o.IsActive && !o.IsUnsatisfiable) {
          const l = o.Left.ActualPos * o.Left.Scale + (o.Gap - o.Right.ActualPos * o.Right.Scale);
          uo(l, t) && (e != null && t > this.violationCache.LowViolation && this.violationCache.Insert(e, t), t = o.Violation, e = o);
        }
      for (const o of r.RightConstraints)
        if (!o.IsActive && !o.IsUnsatisfiable && o.Left.Block !== this.lastModifiedBlock) {
          const l = o.Left.ActualPos * o.Left.Scale + (o.Gap - o.Right.ActualPos * o.Right.Scale);
          uo(l, t) && (e != null && t > this.violationCache.LowViolation && this.violationCache.Insert(e, t), t = l, e = o);
        }
    }
    const s = this.violationCache.FindIfGreater(t);
    return s != null && (e != null && t > this.violationCache.LowViolation && this.violationCache.Insert(e, t), e = s), e;
  }
  SearchAllConstraints(t, e) {
    let i = null;
    this.violationCache.Clear();
    for (const s of this.allConstraints.Vector) {
      if (s.IsActive)
        break;
      if (s.IsUnsatisfiable)
        continue;
      const n = s.Left.ActualPos * s.Left.Scale + (s.Gap - s.Right.ActualPos * s.Right.Scale);
      let r = null, o = 0;
      uo(n, t) && (t > this.violationCache.LowViolation && (r = i, o = t), t = n, i = s), e && (r == null && s !== i && (!this.violationCache.IsFull || n > this.violationCache.LowViolation) && (r = s, o = n), r != null && o > this.violationCache.LowViolation && this.violationCache.Insert(r, o));
    }
    return i;
  }
}
class Gn {
  // Constructor.
  constructor() {
    this.variables = /* @__PURE__ */ new Map(), this.fixedVars = /* @__PURE__ */ new Map(), this.FailToAdjustEpsilon = 1e-3, this.InitSolver();
  }
  // Add a node that we would like as close to position i as possible, with the requested weight.
  // Caller's unique identifier for this node
  // Desired position
  // The weight of the corresponding term in the goal function
  AddVariableWithIdealPositionNNN(t, e, i) {
    this.variables.set(t, this.solver.AddVariableANN(t, e, i));
  }
  // Add a node that we would like as close to position i as possible, with the requested weight.
  AddVariableWithIdealPositionNN(t, e) {
    this.AddVariableWithIdealPositionNNN(t, e, 1);
  }
  // Add a constraint that leftNode+gap eq|leq RightNode.
  // Caller's unique identifier for the left node
  // Caller's unique identifier for the right node
  // Required gap
  // Gap is exact rather than minimum
  AddLeftRightSeparationConstraintNNNB(t, e, i, s) {
    const n = this.GetVariable(t);
    if (n == null)
      return;
    const r = this.GetVariable(e);
    r != null && this.solver.AddConstraintVVNB(n, r, i, s);
  }
  // Add a constraint that leftNode+gap leq RightNode.
  // Caller's unique identifier for the left node
  // Caller's unique identifier for the right node
  // Required minimal gap
  AddLeftRightSeparationConstraintNNN(t, e, i) {
    this.AddLeftRightSeparationConstraintNNNB(t, e, i, !1);
  }
  // Add a goal that minimizes the distance between two nodes, i.e. weight*((id1-id2)^2).
  // Caller's unique identifier for the first node.
  // Caller's unique identifier for the second node.
  // The weight of the corresponding term in the goal function
  AddGoalTwoVariablesAreCloseNNN(t, e, i) {
    const s = this.GetVariable(t);
    if (s == null)
      return;
    const n = this.GetVariable(e);
    n != null && this.solver.AddNeighborPair(s, n, i);
  }
  //
  AddGoalTwoVariablesAreClose(t, e) {
    this.AddGoalTwoVariablesAreCloseNNN(t, e, 1);
  }
  GetVariable(t) {
    return this.variables.get(t);
  }
  // Execute the solver, filling in the Solution object and the values to be returned by GetVariableResolvedPosition.
  Solve() {
    this.SolveP(null);
  }
  // Execute the solver, filling in the Solution object and the values to be returned by GetVariableResolvedPosition.
  // Parameter object class specific to the underlying solver
  // <returns>Pass or fail</returns>
  SolveP(t) {
    const e = { executionLimitExceeded: !1 };
    this.SolvePNS(t, e);
  }
  // Execute the solver, filling in the Solution object and the values to be returned by GetVariableResolvedPosition.
  // Parameter object class specific to the underlying solver
  //         or timeout were exceeded</param>
  // <returns>Pass or fail</returns>
  SolvePNS(t, e) {
    let i;
    do {
      this.solution = null;
      let s = null;
      if (t != null && (s = t, s == null))
        throw new Error("parameters");
      this.solution = this.solver.SolvePar(s), e.executionLimitExceeded = this.solution.ExecutionLimitExceeded, i = this.AdjustConstraintsForMovedFixedVars();
    } while (i && this.solution.ExecutionLimitExceeded === !1);
    return this.solution.ExecutionLimitExceeded === !1;
  }
  //        void DumpToFile(string fileName) {
  //            var file = new StreamWriter(fileName);
  //            file.WriteLine("digraph {");
  //            foreach (var v in solver.Variables) {
  //                var s = v.Weight > 100 ? "color=\"red\"" : "";
  //                file.WriteLine(v.UserData + " [ label=" + "\"" + v.UserData +"\\n" +
  //                               v.DesiredPos + "\" " +s+ "]");
  //
  //            }
  //
  //            foreach (var cs in solver.Constraints) {
  //                file.WriteLine(cs.Left.UserData + " -> " + cs.Right.UserData + " [ label=\"" + cs.Gap + "\"]");
  //            }
  //            file.WriteLine("}");
  //            file.Close();
  //        }
  AdjustConstraintsForMovedFixedVars() {
    const t = /* @__PURE__ */ new Set();
    for (const [e, i] of this.fixedVars.entries())
      Gn.Close(i, this.GetVariableResolvedPosition(e)) || t.add(e);
    return t.size === 0 ? !1 : this.AdjustConstraintsForMovedFixedVarSet(t);
  }
  static Close(t, e) {
    return Math.abs(t - e) < 5e-4;
  }
  AdjustConstraintsForMovedFixedVarSet(t) {
    for (; t.size > 0; ) {
      let e;
      for (const i of t) {
        e = i;
        break;
      }
      if (!this.AdjustSubtreeOfFixedVar(e, t))
        return !1;
    }
    return !0;
  }
  AdjustSubtreeOfFixedVar(t, e) {
    const i = { successInAdjusting: !1 }, s = this.AdjustConstraintsOfNeighborsOfFixedVariable(t, i);
    if (!i.successInAdjusting || s.length === 0)
      return !1;
    for (const n of s)
      e.delete(n);
    return !0;
  }
  // returns the block of the fixed variable
  AdjustConstraintsOfNeighborsOfFixedVariable(t, e) {
    const i = this.variables.get(t).Block.Variables, s = new ji(), n = new ji();
    let r = 1;
    for (const o of i)
      this.fixedVars.has(o.UserData) && (s.AddValue(o.ActualPos), n.AddValue(o.DesiredPos), n.length > 0 && (r = Math.max(r, s.length / n.length)));
    return r === 1 && (r = 2), e.successInAdjusting = this.FixActiveConstraints(i, r), i.map((o) => o.UserData);
  }
  FixActiveConstraints(t, e) {
    let i = !1;
    for (const s of t)
      for (const n of s.LeftConstraints)
        n.IsActive && (n.Gap > this.FailToAdjustEpsilon && (i = !0), this.solver.SetConstraintUpdate(n, n.Gap / e));
    return i;
  }
  // Obtain the solved position for a node.
  // Caller's unique identifier for the node.
  // <returns>The node's solved position.</returns>
  GetVariableResolvedPosition(t) {
    const e = this.GetVariable(t);
    return e == null ? 0 : e.ActualPos;
  }
  //
  InitSolver() {
    this.solver = new nf(), this.variables.clear();
  }
  // Add a variable with a known and unchanging position.
  // Caller's unique identifier for the node
  // Desired position.
  AddFixedVariable(t, e) {
    this.AddVariableWithIdealPositionNNN(t, e, Gn.FixedVarWeight), this.fixedVars.set(t, e);
  }
  //
  ContainsVariable(t) {
    return this.variables.has(t);
  }
  // returns the ideal position of the node that had been set at the variable construction
  GetVariableIdealPosition(t) {
    return this.variables.get(t).DesiredPos;
  }
  // Returns the solution object class specific to the underlying solver, or null if there has
  // been no call to Solve() or it threw an exception.
  get Solution() {
    return this.solution;
  }
}
Gn.FixedVarWeight = 1e9;
class rf {
  constructor() {
    this.lowBound = Number.NEGATIVE_INFINITY, this.upperBound = Number.POSITIVE_INFINITY;
  }
  get Position() {
    return this.position;
  }
  set Position(t) {
    t < this.lowBound ? this.position = this.lowBound : t > this.upperBound ? this.position = this.upperBound : this.position = t;
  }
  get LowBound() {
    return this.lowBound;
  }
  set LowBound(t) {
    this.lowBound = t;
  }
  get UpperBound() {
    return this.upperBound;
  }
  set UpperBound(t) {
    this.upperBound = t;
  }
  toString() {
    return this.lowBound + (" " + (this.Position + (" " + this.upperBound)));
  }
}
class of {
  // desired variable separation
  constructor(t) {
    this.idealPositions = /* @__PURE__ */ new Map(), this.varList = new Array(), this.constraints = /* @__PURE__ */ new Set(), this.solverShell = new Gn(), this.boundsToInt = /* @__PURE__ */ new Map(), this.varSepartion = t;
  }
  //        delegate Array<NudgerConstraint> Edges(int i);
  //
  //        delegate int End(NudgerConstraint constraint);
  //        Edges outEdgesDel;
  //        Edges inEdgesDel;
  //        End sourceDelegate;
  //        End targetDelegate;
  //        Supremum minDel;
  //        Supremum maxDel;
  SetLowBound(t, e) {
    const i = this.Var(e);
    i.LowBound = Math.max(t, i.LowBound);
  }
  Var(t) {
    return this.varList[t];
  }
  SetUpperBound(t, e) {
    const i = this.Var(t);
    i.UpperBound = Math.min(e, i.UpperBound);
  }
  Solve() {
    this.SolveByRegularSolver();
  }
  SolveByRegularSolver() {
    this.CreateVariablesForBounds();
    for (let t = 0; t < this.varList.length; t++) {
      const e = this.varList[t];
      e.IsFixed ? this.solverShell.AddFixedVariable(t, e.Position) : (this.solverShell.AddVariableWithIdealPositionNN(t, this.idealPositions.get(t)), e.LowBound !== Number.NEGATIVE_INFINITY && this.constraints.add(new U(this.GetBoundId(e.LowBound), t)), e.UpperBound !== Number.POSITIVE_INFINITY && this.constraints.add(new U(t, this.GetBoundId(e.UpperBound))));
    }
    this.CreateGraphAndRemoveCycles();
    for (const t of this.graph.edges) {
      let e = 0;
      t.x < this.varList.length && (e += this.varList[t.x].Width), t.y < this.varList.length && (e += this.varList[t.y].Width), e /= 2, this.solverShell.AddLeftRightSeparationConstraintNNN(t.x, t.y, this.varSepartion + e);
    }
    this.solverShell.Solve();
    for (let t = 0; t < this.varList.length; t++)
      this.varList[t].Position = this.solverShell.GetVariableResolvedPosition(t);
  }
  GetBoundId(t) {
    return this.boundsToInt.get(t);
  }
  CreateVariablesForBounds() {
    for (const t of this.varList)
      t.IsFixed || (t.LowBound !== Number.NEGATIVE_INFINITY && this.RegisterBoundVar(t.LowBound), t.UpperBound !== Number.POSITIVE_INFINITY && this.RegisterBoundVar(t.UpperBound));
  }
  RegisterBoundVar(t) {
    if (!this.boundsToInt.has(t)) {
      const e = this.varList.length + this.boundsToInt.size;
      this.boundsToInt.set(t, e), this.solverShell.AddFixedVariable(e, t);
    }
  }
  CreateGraphAndRemoveCycles() {
    this.graph = fi(Array.from(this.constraints), this.varList.length + this.boundsToInt.size);
    const t = $i.getFeedbackSet(this.graph);
    if (t != null)
      for (const e of t)
        this.graph.removeEdge(e);
  }
  GetVariablePosition(t) {
    return this.varList[t].Position;
  }
  AddConstraint(t, e) {
    this.constraints.add(new U(t, e));
  }
  AddVariableNNNN(t, e, i, s) {
    this.idealPositions.set(t, i), this.AddVariableNNBN(t, e, !1, s);
  }
  AddFixedVariable(t, e) {
    this.AddVariableNNBN(t, e, !0, 0);
  }
  AddVariableNNBN(t, e, i, s) {
    const n = new rf();
    n.Position = e, n.IsFixed = i, n.Width = s, this.varList.push(n);
  }
}
class q {
  clone() {
    const t = new q();
    return t.transparency = this.transparency, t.width = this.width, t.color = this.color, t.icurve = this.icurve.clone(), t.label = this.label, t.dashArray = this.dashArray, t.drawPN = this.drawPN, t;
  }
  static mkDebugCurveTWCILD(t, e, i, s, n, r, o = !1) {
    const l = new q();
    return l.transparency = t, l.width = e, l.color = i, l.icurve = s, l.label = n, l.dashArray = r, l.drawPN = o, l;
  }
  static mkDebugCurveTWCI(t, e, i, s) {
    return q.mkDebugCurveTWCILD(t, e, i, s, null, null);
  }
  static mkDebugCurveWCI(t, e, i) {
    return q.mkDebugCurveTWCI(255, t, e, i);
  }
  static mkDebugCurveCI(t, e) {
    return q.mkDebugCurveWCI(1, t, e);
  }
  static mkDebugCurveI(t) {
    return q.mkDebugCurveCI("Black", t);
  }
}
q.colors = [
  "DeepSkyBlue",
  "IndianRed",
  "Orange",
  "Gold",
  "DarkRed",
  "Plum",
  "Red",
  "Violet",
  "Indigo",
  "Yellow",
  "OrangeRed",
  "Tomato",
  "Purple",
  "SaddleBrown",
  "Green",
  "Navy",
  "Aqua",
  "Pink",
  "Bisque",
  "Black",
  "BlanchedAlmond",
  "Blue",
  "BlueViolet",
  "Brown",
  "Lime",
  "BurlyWood",
  "Chocolate",
  "Coral",
  "CornflowerBlue",
  "Cornsilk",
  "Crimson",
  "Cyan",
  "CadetBlue",
  "Chartreuse",
  "DarkBlue",
  "DarkCyan",
  "DarkGoldenrod",
  "DarkGray",
  "DarkGreen",
  "DarkKhaki",
  "DarkMagenta",
  "DarkOliveGreen",
  "DarkOrange",
  "DarkOrchid",
  "DarkSalmon",
  "DarkSeaGreen",
  "DarkSlateBlue",
  "DarkSlateGray",
  "DarkTurquoise",
  "DarkViolet",
  "DeepPink",
  "DimGray",
  "DodgerBlue",
  "Firebrick",
  "FloralWhite",
  "ForestGreen",
  "Fuchsia",
  "CodeAnalysis",
  "Gainsboro",
  "GhostWhite",
  "Goldenrod",
  "Gray",
  "GreenYellow",
  "Honeydew",
  "HotPink",
  "Ivory",
  "Lavender",
  "LavenderBlush",
  "LawnGreen",
  "LemonChiffon",
  "LightBlue",
  "LightCoral",
  "LightCyan",
  "LightGoldenrodYellow",
  "LightGray",
  "LightGreen",
  "LightPink",
  "LightSalmon",
  "LightSeaGreen",
  "LightSkyBlue",
  "LightSlateGray",
  "LightSteelBlue",
  "LightYellow",
  "LimeGreen",
  "Linen",
  "Magenta",
  "Maroon",
  "MediumAquamarine",
  "MediumBlue",
  "MediumOrchid",
  "MediumPurple",
  "MediumSeaGreen",
  "MediumSlateBlue",
  "MediumSpringGreen",
  "MediumTurquoise",
  "MediumVioletRed",
  "MidnightBlue",
  "MintCream",
  "MistyRose",
  "Moccasin",
  "NavajoWhite",
  "OldLace",
  "Olive",
  "OliveDrab",
  "Orchid",
  "PaleGoldenrod",
  "PaleGreen",
  "PaleTurquoise",
  "PaleVioletRed",
  "PapayaWhip",
  "PeachPuff",
  "Peru",
  "PowderBlue",
  "RosyBrown",
  "RoyalBlue",
  "Salmon",
  "SandyBrown",
  "SeaGreen",
  "CodeAnalysis",
  "SeaShell",
  "Sienna",
  "Silver",
  "SkyBlue",
  "SlateBlue",
  "SlateGray",
  "Snow",
  "SpringGreen",
  "SteelBlue",
  "Tan",
  "Teal",
  "Thistle",
  "Transparent",
  "Turquoise",
  "Aquamarine",
  "Azure",
  "Beige",
  "Wheat",
  "White",
  "WhiteSmoke",
  "YellowGreen",
  "Khaki",
  "AntiqueWhite"
];
class af extends ce {
  constructor(t, e) {
    super(t, e), this.RightNeighbors = /* @__PURE__ */ new Set(), this.setOfLongestSegs = /* @__PURE__ */ new Set(), this.RightBound = Number.POSITIVE_INFINITY, this.LeftBound = Number.NEGATIVE_INFINITY, this.Direction = E.DirectionFromPointToPoint(t.point, e.point);
  }
  AddRightNeighbor(t) {
    this.RightNeighbors.add(t);
  }
  get LongestNudgedSegments() {
    return this.setOfLongestSegs;
  }
  AddLongestNudgedSegment(t) {
    this.setOfLongestSegs.add(t);
  }
  BoundFromRight(t) {
    t = Math.max(t, this.LeftBound), this.RightBound = Math.min(t, this.RightBound);
  }
  BoundFromLeft(t) {
    t = Math.min(t, this.RightBound), this.LeftBound = Math.max(t, this.LeftBound);
  }
}
class Ni {
  constructor(t) {
    this.Point = t;
  }
  *GetEnumerator() {
    let t;
    for (t = this; t != null; t = t.Next)
      yield t.Point;
  }
  get X() {
    return this.Point.x;
  }
  get Y() {
    return this.Point.y;
  }
  InsertVerts(t, e, i) {
    for (e--; t < e; e--)
      this.SetNewNext(i[e]);
  }
  InsertVertsInReverse(t, e, i) {
    for (t++; t < e; t++)
      this.SetNewNext(i[t]);
  }
  SetNewNext(t) {
    const e = new Ni(t), i = this.Next;
    this.Next = e, e.Next = i;
  }
}
class Vr {
  toString() {
    return this.Source + (" " + this.Target);
  }
  constructor(t, e) {
    this.IsFixed = !1, this.Reversed = !1, this.index = -1, this.AxisEdge = t, this.Width = e;
  }
  // It is the offset of the edge from the underlying line segment
  // [VisibilityEdge.SourcePoint, VisibilityEdge.TargetPoint] in to the direction of the VisibilityEdge.Perpendicular.
  // Offset holder is the same for the maximal parallel sequence of connected PathEdges
  get LongestNudgedSegment() {
    return this.longestNudgedSegment;
  }
  set LongestNudgedSegment(t) {
    this.longestNudgedSegment = t, this.longestNudgedSegment != null && (this.longestNudgedSegment.AddEdge(this), this.AxisEdge.AddLongestNudgedSegment(this.longestNudgedSegment));
  }
  get Source() {
    return this.Reversed ? this.AxisEdge.TargetPoint : this.AxisEdge.SourcePoint;
  }
  get Target() {
    return this.Reversed ? this.AxisEdge.SourcePoint : this.AxisEdge.TargetPoint;
  }
  static VectorsAreParallel(t, e) {
    return D(t.x * e.y - t.y * e.x, 0);
  }
  static EdgesAreParallel(t, e) {
    return Vr.VectorsAreParallel(t.AxisEdge.TargetPoint.sub(t.AxisEdge.SourcePoint), e.AxisEdge.TargetPoint.sub(e.AxisEdge.SourcePoint));
  }
  get Direction() {
    return this.Reversed ? E.OppositeDir(this.AxisEdge.Direction) : this.AxisEdge.Direction;
  }
  // not set yet
  // the index of the edge in the order
  get Index() {
    return this.index;
  }
  set Index(t) {
    this.index = t;
  }
}
class Vt {
  get PathVisibilityGraph() {
    return this.pathVisibilityGraph;
  }
  constructor(t) {
    this.pathVisibilityGraph = new wt(), this.axisEdgesToPathOrders = /* @__PURE__ */ new Map(), this.OriginalPaths = t;
  }
  GetOrder() {
    return this.FillTheVisibilityGraphByWalkingThePaths(), this.InitPathOrder(), this.OrderPaths(), this.axisEdgesToPathOrders;
  }
  FillTheVisibilityGraphByWalkingThePaths() {
    for (const t of this.OriginalPaths)
      this.FillTheVisibilityGraphByWalkingPath(t);
  }
  FillTheVisibilityGraphByWalkingPath(t) {
    const e = this.CreatePathEdgesFromPoints(s(), t.Width);
    let i = e.next();
    for (i.done || t.SetFirstEdge(i.value); (i = e.next()).done === !1; )
      t.AddEdge(i.value);
    function* s() {
      if (t.PathPoints instanceof Ni)
        for (let n = t.PathPoints; n != null; n = n.Next)
          yield n.Point;
      else
        for (const n of t.PathPoints)
          yield n;
    }
  }
  *CreatePathEdgesFromPoints(t, e) {
    let i = t.next(), s = i.value;
    for (; !(i = t.next()).done; )
      yield this.CreatePathEdge(s, i.value, e), s = i.value;
  }
  CreatePathEdge(t, e, i) {
    switch (E.DirectionFromPointToPoint(t, e)) {
      case S.East:
      case S.North:
        return new Vr(this.GetAxisEdge(t, e), i);
      case S.South:
      case S.West: {
        const n = new Vr(this.GetAxisEdge(e, t), i);
        return n.Reversed = !0, n;
      }
      default:
        throw new Error("Not a rectilinear path");
    }
  }
  GetAxisEdge(t, e) {
    return this.PathVisibilityGraph.AddEdgeF(t, e, (i, s) => new af(i, s));
  }
  InitPathOrder() {
    for (const t of this.PathVisibilityGraph.Edges)
      this.axisEdgesToPathOrders.set(t, new Array());
    for (const t of this.OriginalPaths)
      for (const e of t.PathEdges())
        this.axisEdgesToPathOrders.get(e.AxisEdge).push(e);
  }
  OrderPaths() {
    for (const t of Vt.WalkGraphEdgesInTopologicalOrderIfPossible(this.PathVisibilityGraph))
      this.OrderPathEdgesSharingEdge(t);
  }
  OrderPathEdgesSharingEdge(t) {
    const e = this.PathOrderOfVisEdge(t);
    e.sort(Vt.CompareTwoPathEdges);
    let i = 0;
    for (const s of e)
      s.Index = i++;
  }
  static CompareTwoPathEdges(t, e) {
    if (t === e)
      return 0;
    const i = Vt.CompareInDirectionStartingFromAxisEdge(t, e, t.AxisEdge, t.AxisEdge.Direction);
    return i !== 0 ? i : -Vt.CompareInDirectionStartingFromAxisEdge(t, e, t.AxisEdge, E.OppositeDir(t.AxisEdge.Direction));
  }
  //
  // axisEdge together with the axisEdgeIsReversed parameter define direction of the movement over the paths
  static CompareInDirectionStartingFromAxisEdge(t, e, i, s) {
    for (; ; ) {
      if (t = Vt.GetNextPathEdgeInDirection(t, i, s), t == null || (e = Vt.GetNextPathEdgeInDirection(e, i, s), e == null))
        return 0;
      if (t.AxisEdge === e.AxisEdge) {
        s = Vt.FindContinuedDirection(i, s, t.AxisEdge), i = t.AxisEdge;
        const h = Vt.GetExistingOrder(t, e);
        if (h === Vt.NotOrdered)
          continue;
        return s === i.Direction ? h : -h;
      }
      const n = s === i.Direction ? i.Target : i.Source, r = Vt.OtherVertex(t.AxisEdge, n), o = Vt.OtherVertex(e.AxisEdge, n), l = Vt.ProjectionForCompare(i, s !== i.Direction);
      return yt(l(r.point), l(o.point));
    }
  }
  static FindContinuedDirection(t, e, i) {
    return t.Direction === e ? i.Source === t.Target ? i.Direction : E.OppositeDir(i.Direction) : i.Source === t.Source ? i.Direction : E.OppositeDir(i.Direction);
  }
  static OtherVertex(t, e) {
    return t.Source === e ? t.Target : t.Source;
  }
  static ProjectionForCompare(t, e) {
    return t.Direction === S.North ? e ? (i) => -i.x : (i) => i.x : e ? (i) => i.y : (i) => -i.y;
  }
  static GetNextPathEdgeInDirection(t, e, i) {
    return e.Direction === i ? t.Reversed ? t.Prev : t.Next : t.Reversed ? t.Next : t.Prev;
  }
  static GetExistingOrder(t, e) {
    const i = t.Index;
    if (i === -1)
      return Vt.NotOrdered;
    const s = e.Index;
    return yt(i, s);
  }
  PathOrderOfVisEdge(t) {
    return this.axisEdgesToPathOrders.get(t);
  }
  static InitQueueOfSources(t, e, i) {
    for (const s of i.Vertices()) {
      const n = s.InEdgesLength();
      e.set(s, n), n === 0 && t.enqueue(s);
    }
  }
  static *WalkGraphEdgesInTopologicalOrderIfPossible(t) {
    const e = new We.Queue(), i = /* @__PURE__ */ new Map();
    for (Vt.InitQueueOfSources(e, i, t); e.length > 0; ) {
      const s = e.dequeue();
      for (const n of s.OutEdges) {
        const r = i.get(n.Target);
        i.set(n.Target, r - 1), r === 1 && e.enqueue(n.Target), yield n;
      }
    }
  }
}
Vt.NotOrdered = Number.MAX_VALUE;
class lf extends Gi {
  constructor(t, e) {
    super(), this.site = e, this.AxisEdge = t;
  }
  get Site() {
    return this.site;
  }
}
class ll extends Gi {
  constructor(t, e) {
    super(), this.site = e, this.AxisEdge = t;
  }
  get Site() {
    return this.site;
  }
}
class hf {
  get Edges() {
    return this.edges;
  }
  AddEdge(t) {
    this.UpPoint = t.TargetPoint, this.edges.add(t);
  }
  constructor(t) {
    this.edges = /* @__PURE__ */ new Set(), this.Source = t;
  }
  RemoveAxis(t) {
    this.edges.delete(t);
  }
  IsEmpty() {
    return this.edges.size === 0;
  }
}
class Ei extends Dh {
  //
  // edges to find the empty space around
  constructor(t, e, i, s, n) {
    super(e, new E(t).ToPoint()), this.DirectionPerp = new E(t).Right.ToPoint(), this.PathOrders = s, this.xProjection = t === S.North ? (r) => r.x : (r) => -r.y, this.edgeContainersTree = new we((r, o) => this.CompareAA(r, o)), this.SweepPole = E.VectorDirection(this.SweepDirection), this.AxisEdges = n, this.AxisEdgesToObstaclesTheyOriginatedFrom = i;
  }
  //   Array<Path> EdgePaths { get; set; }
  // VisibilityGraph PathVisibilityGraph { get; set; }
  // calculates the right offsets
  FindFreeSpace() {
    this.InitTheQueueOfEvents(), this.ProcessEvents();
  }
  ProcessEvents() {
    for (; this.EventQueue.Count > 0; )
      this.ProcessEvent(this.EventQueue.Dequeue());
  }
  ProcessEvent(t) {
    t instanceof en ? this.ProcessVertexEvent(t) : (this.Z = this.GetZP(t.Site), t instanceof ll ? this.ProcessLowEdgeEvent(t) : this.ProcessHighEdgeEvent(t));
  }
  ProcessHighEdgeEvent(t) {
    const e = t.AxisEdge;
    this.RemoveEdge(e), this.ConstraintEdgeWithObstaclesAtZ(e, e.Target.point);
  }
  ProcessLowEdgeEvent(t) {
    const e = t.AxisEdge, i = this.GetOrCreateAxisEdgesContainer(e);
    i.item.AddEdge(e);
    const s = this.edgeContainersTree.previous(i);
    if (s != null)
      for (const r of s.item.edges)
        for (const o of i.item.edges)
          this.TryToAddRightNeighbor(r, o);
    const n = this.edgeContainersTree.next(i);
    if (n != null)
      for (const r of i.item.Edges)
        for (const o of n.item.edges)
          this.TryToAddRightNeighbor(r, o);
    this.ConstraintEdgeWithObstaclesAtZ(e, e.Source.point);
  }
  TryToAddRightNeighbor(t, e) {
    this.ProjectionsOfEdgesOverlap(t, e) && t.AddRightNeighbor(e);
  }
  ProjectionsOfEdgesOverlap(t, e) {
    return this.SweepPole === S.North ? !(t.TargetPoint.y < e.SourcePoint.y - m.distanceEpsilon || e.TargetPoint.y < t.SourcePoint.y - m.distanceEpsilon) : !(t.TargetPoint.x < e.SourcePoint.x - m.distanceEpsilon || e.TargetPoint.x < t.SourcePoint.x - m.distanceEpsilon);
  }
  // DebShowEdge(edge: AxisEdge, point: Point) {
  //    //  ReSharper restore UnusedMember.Local
  //    //  if (InterestingEdge(edge))
  //    this.ShowEdge(edge, point);
  // }
  // // ReSharper disable SuggestBaseTypeForParameter
  // ShowEdge(edge: AxisEdge, point: Point) {
  //    //  ReSharper restore SuggestBaseTypeForParameter
  //    let dd = this.GetObstacleBoundaries("black");
  //    let seg = new DebugCurve(1, "red", new LineSegment(edge.Source.point, edge.Target.point));
  //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(dd.Concat(new, [));
  //    seg;
  //    new DebugCurve("blue", CurveFactory.CreateEllipse(3, 3, point));
  // }
  GetObstacleBoundaries(t) {
    return this.Obstacles.map((e) => q.mkDebugCurveWCI(1, t, e));
  }
  //
  // a point on the edge on Z level
  ConstraintEdgeWithObstaclesAtZ(t, e) {
    this.ConstraintEdgeWithObstaclesAtZFromLeft(t, e), this.ConstraintEdgeWithObstaclesAtZFromRight(t, e);
  }
  ConstraintEdgeWithObstaclesAtZFromRight(t, e) {
    const i = this.GetActiveSideFromRight(e);
    if (i == null || this.NotRestricting(t, i.item.Polyline))
      return;
    const s = this.ObstacleSideComparer.IntersectionOfSideAndSweepLine(i.item);
    t.BoundFromRight(s.dot(this.DirectionPerp));
  }
  GetActiveSideFromRight(t) {
    return this.LeftObstacleSideTree.findFirst((e) => Ei.PointToTheLeftOfLineOrOnLineLocal(t, e.Start, e.End));
  }
  ConstraintEdgeWithObstaclesAtZFromLeft(t, e) {
    const i = this.GetActiveSideFromLeft(e);
    if (i == null || this.NotRestricting(t, i.item.Polyline))
      return;
    const s = this.ObstacleSideComparer.IntersectionOfSideAndSweepLine(i.item);
    t.BoundFromLeft(s.dot(this.DirectionPerp));
  }
  static PointToTheLeftOfLineOrOnLineLocal(t, e, i) {
    return u.signedDoubledTriangleArea(t, e, i) > -Ei.AreaComparisonEpsilon;
  }
  static PointToTheRightOfLineOrOnLineLocal(t, e, i) {
    return u.signedDoubledTriangleArea(e, i, t) < Ei.AreaComparisonEpsilon;
  }
  GetActiveSideFromLeft(t) {
    return this.RightObstacleSideTree.findLast((e) => Ei.PointToTheRightOfLineOrOnLineLocal(t, e.Start, e.End));
  }
  // ReSharper disable UnusedMember.Local
  // ShowPointAndEdge(point: Point, edge: AxisEdge) {
  //    //  ReSharper restore UnusedMember.Local
  //    let curves: Array<ICurve> = this.GetCurves(point, edge);
  //    LayoutAlgorithmSettings.Show(curves.ToArray());
  // }
  // // ReSharper disable UnusedMember.Local
  // ShowPointAndEdgeWithSweepline(point: Point, edge: AxisEdge) {
  //    //  ReSharper restore UnusedMember.Local
  //    let curves: Array<ICurve> = this.GetCurves(point, edge);
  //    curves.Add(new LineSegment(((this.SweepDirection * this.Z) + (10 * this.DirectionPerp)), ((this.SweepDirection * this.Z) - (10 * this.DirectionPerp))));
  //    LayoutAlgorithmSettings.Show(curves.ToArray());
  // }
  // GetCurves(point: Point, edge: AxisEdge): Array<ICurve> {
  //    let ellipse = CurveFactory.CreateEllipse(3, 3, point);
  //    let curves = new Array<ICurve>(this.Obstacles.select(() => {  }, (<ICurve>(o))));
  //    if ((edge.RightBound < Number.POSITIVE_INFINITY)) {
  //        let rightOffset: number = edge.RightBound;
  //        let del = (this.DirectionPerp * rightOffset);
  //        curves.Add(new LineSegment((edge.Source.point + del), (edge.Target.point + del)));
  //    }
  //    if ((edge.LeftBound > Number.NEGATIVE_INFINITY)) {
  //        let leftOffset: number = edge.LeftBound;
  //        let del = (this.DirectionPerp * leftOffset);
  //        curves.Add(new LineSegment((edge.Source.point + del), (edge.Target.point + del)));
  //    }
  //    curves.AddRange(from, e, in, this.PathOrders.keys, let, a=e.SourcePoint, let, b=e.TargetPoint, select, new CubicBezierSegment(a, ((a * 0.8)
  //                        + (b * 0.2)), ((a * 0.2)
  //                        + (b * 0.8)), b)).Cast();
  //    return curves;
  // }
  // GetCurvesTest(point: Point): Array<DebugCurve> {
  //    let ellipse = CurveFactory.CreateEllipse(3, 3, point);
  //    let curves = new Array<DebugCurve>(this.Obstacles.select(() => {  }, new DebugCurve(100, 1, "black", o)));
  //    curves.AddRange(from, e, in, this.edgeContainersTree, from, axisEdge, in, e, let, a=axisEdge.Source.Point, let, b=axisEdge.Target.Point, select, new DebugCurve(100, 1, "green", new LineSegment(a, b)));
  //    curves.AddRange(FreeSpaceFinder.RightNeighborsCurvesTest(this.edgeContainersTree));
  //    return curves;
  // }
  // static RightNeighborsCurvesTest(rbTree: Array<AxisEdgesContainer>): Array<DebugCurve> {
  //    for (let container of rbTree) {
  //        for (let edge of container) {
  //            for (let rn of edge.RightNeighbors) {
  //                yield;
  //                return new DebugCurve(100, 1, "brown", new LineSegment(FreeSpaceFinder.EdgeMidPoint(edge), FreeSpaceFinder.EdgeMidPoint(rn)));
  //            }
  //        }
  //    }
  // }
  static EdgeMidPoint(t) {
    return u.middle(t.SourcePoint, t.TargetPoint);
  }
  // ShowAxisEdges() {
  //    //  ReSharper restore UnusedMember.Local
  //    let dd = new Array<DebugCurve>(this.GetObstacleBoundaries("black"));
  //    let i: number = 0;
  //    for (let axisEdge of this.AxisEdges) {
  //        let color = DebugCurve.colors[i];
  //        dd.Add(new DebugCurve(200, 1, color, new LineSegment(axisEdge.Source.point, axisEdge.Target.point)));
  //        let perp: Point = new Point(0, 1);
  //        // TODO: Warning!!!, inline IF is not supported ?
  //        (axisEdge.Direction === Direction.East);
  //        new Point(-1, 0);
  //        if ((axisEdge.LeftBound !== Number.NEGATIVE_INFINITY)) {
  //            dd.Add(new DebugCurve(200, 0.5, color, new LineSegment((axisEdge.Source.point
  //                                    + (axisEdge.LeftBound * perp)), (axisEdge.Target.point
  //                                    + (axisEdge.LeftBound * perp)))));
  //        }
  //        if ((axisEdge.RightBound !== Number.POSITIVE_INFINITY)) {
  //            dd.Add(new DebugCurve(200, 0.5, color, new LineSegment((axisEdge.Source.point
  //                                    - (axisEdge.RightBound * perp)), (axisEdge.Target.point
  //                                    - (axisEdge.RightBound * perp)))));
  //        }
  //        i = ((i + 1)
  //                    % DebugCurve.colors.length);
  //    }
  //    DebugCurveCollection.WriteToFile(dd, "c:/tmp/ae");
  //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(dd);
  // }
  // // ReSharper disable UnusedMember.Local
  // ShowAtPoint(point: Point) {
  //    //  ReSharper restore UnusedMember.Local
  //    let curves = this.GetCurvesTest(point);
  //    LayoutAlgorithmSettings.ShowDebugCurves(curves.ToArray());
  // }
  GetOrCreateAxisEdgesContainer(t) {
    const e = t.Source.point, i = this.GetAxisEdgesContainerNode(e);
    return i ?? this.edgeContainersTree.insert(new hf(e));
  }
  //
  // the point has to be on the same line as the container
  GetAxisEdgesContainerNode(t) {
    const e = this.xProjection(t), i = this.edgeContainersTree.findFirst((s) => this.xProjection(s.Source) >= e - m.distanceEpsilon / 2);
    return i != null && this.xProjection(i.item.Source) <= e + m.distanceEpsilon / 2 ? i : null;
  }
  ProcessVertexEvent(t) {
    this.Z = this.GetZS(t), t instanceof ls ? this.ProcessLeftVertex(t, t.Vertex.nextOnPolyline) : t instanceof hs ? this.ProcessRightVertex(t, t.Vertex.prevOnPolyline) : (this.ProcessLeftVertex(t, t.Vertex.nextOnPolyline), this.ProcessRightVertex(t, t.Vertex.prevOnPolyline));
  }
  ProcessRightVertex(t, e) {
    const i = t.Site;
    this.ProcessPrevSegmentForRightVertex(t, i);
    const s = e.point.sub(t.Site), n = s.dot(this.DirectionPerp), r = s.dot(this.SweepDirection);
    r <= m.distanceEpsilon ? n > 0 && r >= 0 ? this.EnqueueEvent(new hs(e)) : this.RestrictEdgeContainerToTheRightOfEvent(t.Vertex) : (this.InsertRightSide(new Gs(t.Vertex)), this.EnqueueEvent(new hs(e)), this.RestrictEdgeContainerToTheRightOfEvent(t.Vertex));
  }
  RestrictEdgeContainerToTheRightOfEvent(t) {
    const e = t.point, i = this.xProjection(e), s = this.edgeContainersTree.findFirst((n) => i <= this.xProjection(n.Source));
    if (s != null)
      for (const n of s.item.Edges)
        this.NotRestricting(n, t.polyline) || n.BoundFromLeft(this.DirectionPerp.dot(e));
  }
  NotRestricting(t, e) {
    return this.AxisEdgesToObstaclesTheyOriginatedFrom.get(t) === e;
  }
  ProcessPrevSegmentForRightVertex(t, e) {
    const i = t.Vertex.nextOnPolyline.point;
    e.sub(i).dot(this.SweepDirection) > m.distanceEpsilon && this.RemoveRightSide(new Gs(t.Vertex.nextOnPolyline));
  }
  RemoveEdge(t) {
    const e = this.GetAxisEdgesContainerNode(t.Source.point);
    e.item.RemoveAxis(t), e.item.IsEmpty() && this.edgeContainersTree.deleteNodeInternal(e);
  }
  ProcessLeftVertex(t, e) {
    const i = t.Site;
    this.ProcessPrevSegmentForLeftVertex(t, i);
    const s = e.point.sub(t.Site), n = s.dot(this.DirectionPerp), r = s.dot(this.SweepDirection);
    r <= m.distanceEpsilon ? n < 0 && r >= 0 && this.EnqueueEvent(new ls(e)) : (this.InsertLeftSide(new Bs(t.Vertex)), this.EnqueueEvent(new ls(e))), this.RestrictEdgeFromTheLeftOfEvent(t.Vertex);
  }
  RestrictEdgeFromTheLeftOfEvent(t) {
    const e = t.point, i = this.GetContainerNodeToTheLeftOfEvent(e);
    if (i != null)
      for (const s of i.item.Edges)
        this.NotRestricting(s, t.polyline) || s.BoundFromRight(e.dot(this.DirectionPerp));
  }
  GetContainerNodeToTheLeftOfEvent(t) {
    const e = this.xProjection(t);
    return this.edgeContainersTree.findLast((i) => this.xProjection(i.Source) <= e);
  }
  ProcessPrevSegmentForLeftVertex(t, e) {
    const i = t.Vertex.prevOnPolyline.point;
    e.sub(i).dot(this.SweepDirection) > m.distanceEpsilon && this.RemoveLeftSide(new Bs(t.Vertex.prevOnPolyline));
  }
  InitTheQueueOfEvents() {
    this.InitQueueOfEvents();
    for (const t of this.AxisEdges)
      this.EnqueueEventsForEdge(t);
  }
  EnqueueEventsForEdge(t) {
    this.EdgeIsParallelToSweepDir(t) && (this.EnqueueEvent(Ei.EdgeLowPointEvent(t, t.Source.point)), this.EnqueueEvent(Ei.EdgeHighPointEvent(t, t.Target.point)));
  }
  EdgeIsParallelToSweepDir(t) {
    return t.Direction === this.SweepPole || t.Direction === E.OppositeDir(this.SweepPole);
  }
  static EdgeHighPointEvent(t, e) {
    return new lf(t, e);
  }
  static EdgeLowPointEvent(t, e) {
    return new ll(t, e);
  }
  CompareAA(t, e) {
    return yt(t.Source.dot(this.DirectionPerp), e.Source.dot(this.DirectionPerp));
  }
}
Ei.AreaComparisonEpsilon = m.intersectionEpsilon;
class cf extends ha {
  constructor(t) {
    super(), this.CompassDirection = S.None, this.edges = new Array(), this._isFixed = !1, this.Id = -1, this.IdealPosition = 0, this.Id = t;
  }
  get Start() {
    return this.start;
  }
  get End() {
    return this.end;
  }
  // the list of edges holding the same offset and direction
  get Edges() {
    return this.edges;
  }
  AddEdge(t) {
    if (this.Edges.length === 0) {
      let e = E.VectorDirectionPP(t.Source, t.Target);
      switch (e) {
        case S.South:
          e = S.North;
          break;
        case S.West:
          e = S.East;
          break;
      }
      this.CompassDirection = e, this.start = t.Source, this.end = t.Source;
    }
    switch (this.CompassDirection) {
      case S.North:
        this.TryPointForStartAndEndNorth(t.Source), this.TryPointForStartAndEndNorth(t.Target);
        break;
      case S.East:
        this.TryPointForStartAndEndEast(t.Source), this.TryPointForStartAndEndEast(t.Target);
        break;
    }
    this.Edges.push(t);
  }
  TryPointForStartAndEndNorth(t) {
    t.y < this.start.y ? this.start = t : t.y > this.end.y && (this.end = t);
  }
  TryPointForStartAndEndEast(t) {
    t.x < this.start.x ? this.start = t : t.x > this.end.x && (this.end = t);
  }
  // the segments constraining "this" from the right
  get IsFixed() {
    return this._isFixed;
  }
  set IsFixed(t) {
    this._isFixed = t;
  }
  // the maximal width of the edges
  get Width() {
    let t = 0;
    for (const e of this.edges)
      t = Math.max(t, e.Width);
    return t;
  }
  GetLeftBound() {
    if (!this.IsFixed) {
      let t = Number.NEGATIVE_INFINITY;
      for (const e of this.edges)
        t = Math.max(t, e.AxisEdge.LeftBound);
      return t;
    }
    return this.CompassDirection === S.North ? this.Edges[0].Source.x : -this.Edges[0].Source.y;
  }
  GetRightBound() {
    if (!this.IsFixed) {
      let t = Number.POSITIVE_INFINITY;
      for (const e of this.edges)
        t = Math.min(t, e.AxisEdge.RightBound);
      return t;
    }
    return this.Position();
  }
  Position() {
    return this.CompassDirection === S.North ? this.Edges[0].Source.x : -this.Edges[0].Source.y;
  }
}
class oi {
  //
  // no two horizontal segs overlap, but they can share an end point
  // no two vertical segs overlap, but they can share an end point
  constructor(t, e) {
    this.tree = new we((i, s) => yt(i.Point.x, s.Point.x)), this.VerticalPoints = e, this.HorizontalPoints = t;
  }
  SplitPoints() {
    this.VerticalPoints.length === 0 || this.HorizontalPoints.length === 0 || (this.InitEventQueue(), this.ProcessEvents());
  }
  ProcessEvents() {
    for (; !this.Queue.IsEmpty(); ) {
      const t = { priority: 0 }, e = this.Queue.DequeueAndGetPriority(t);
      this.ProcessEvent(e, t.priority);
    }
  }
  ProcessEvent(t, e) {
    D(t.Next.Point.x, t.Point.x) ? e === oi.Low(t) ? this.ProcessLowLinkedPointEvent(t) : this.ProcessHighLinkedPointEvent(t) : this.IntersectWithTree(t);
  }
  IntersectWithTree(t) {
    let e, i, s;
    const n = t.Y;
    if (t.Point.x < t.Next.Point.x ? (i = t.Point.x, e = t.Next.Point.x, s = !0) : (e = t.Point.x, i = t.Next.Point.x, s = !1), s)
      for (let r = this.tree.findFirst((o) => i <= o.Point.x); r != null && r.item.Point.x <= e; r = this.tree.next(r)) {
        const o = new u(r.item.Point.x, n);
        t = oi.TrySplitHorizontalPoint(t, o, !0), oi.TrySplitVerticalPoint(r.item, o);
      }
    else
      for (let r = this.tree.findLast((o) => o.Point.x <= e); r != null && r.item.Point.x >= i; r = this.tree.previous(r)) {
        const o = new u(r.item.Point.x, n);
        t = oi.TrySplitHorizontalPoint(t, o, !1), oi.TrySplitVerticalPoint(r.item, o);
      }
  }
  static TrySplitVerticalPoint(t, e) {
    oi.Low(t) + m.distanceEpsilon < e.y && e.y + m.distanceEpsilon < oi.High(t) && t.SetNewNext(e);
  }
  static TrySplitHorizontalPoint(t, e, i) {
    return i && t.X + m.distanceEpsilon < e.x && e.x + m.distanceEpsilon < t.Next.X || !i && t.Next.X + m.distanceEpsilon < e.x && e.x + m.distanceEpsilon < t.X ? (t.SetNewNext(e), t.Next) : t;
  }
  ProcessHighLinkedPointEvent(t) {
    this.tree.remove(t);
  }
  ProcessLowLinkedPointEvent(t) {
    this.tree.insert(t);
  }
  InitEventQueue() {
    this.Queue = new is(yt);
    for (const t of this.VerticalPoints)
      this.Queue.Enqueue(t, oi.Low(t));
    for (const t of this.HorizontalPoints)
      this.Queue.Enqueue(t, t.Point.y);
  }
  static Low(t) {
    return Math.min(t.Point.y, t.Next.Point.y);
  }
  static High(t) {
    return Math.max(t.Point.y, t.Next.Point.y);
  }
}
class Ms {
  constructor(t) {
    this.verticesToPathOffsets = new ii(), this.Paths = t;
  }
  // Avoid a situation where two paths cross each other more than once. Remove self loops.
  MergePaths() {
    this.InitVerticesToPathOffsetsAndRemoveSelfCycles();
    for (const t of this.Paths)
      this.ProcessPath(t);
  }
  ProcessPath(t) {
    const e = /* @__PURE__ */ new Map();
    let i = null;
    for (let s = t.PathPoints; s != null; s = s.Next) {
      const n = this.verticesToPathOffsets.get(s.Point);
      if (i != null) {
        if (e.size > 0)
          for (const [r, o] of n) {
            const l = e.get(r);
            l && (this.CollapseLoopingPath(r, l, o, t, s), e.delete(r));
          }
        for (const [r, o] of i)
          n.has(r) || e.set(r, o);
      }
      i = n;
    }
  }
  //        bool Correct() {
  //            foreach (var kv of verticesToPathOffsets) {
  //                Point p = kv.Key;
  //                Map<Path, LinkedPoint> pathOffs = kv.Value;
  //                foreach (var pathOff of pathOffs) {
  //                    var path = pathOff.Key;
  //                    var linkedPoint = pathOff.Value;
  //                    if (linkedPoint.Point !== p)
  //                        return false;
  //                    if (FindLinkedPointInPath(path, p) == null ) {
  //                        return false;
  //                    }
  //                }
  //            }
  //            return true;
  //        }
  CollapseLoopingPath(t, e, i, s, n) {
    const r = Ms.FindLinkedPointInPath(s, e.Point), o = Array.from(Ms.GetPointsInBetween(r, n));
    Ms.Before(e, i) ? (this.CleanDisappearedPiece(e, i, t), this.ReplacePiece(e, i, o, t)) : (this.CleanDisappearedPiece(i, e, t), this.ReplacePiece(i, e, o.reverse(), t));
  }
  static *GetPointsInBetween(t, e) {
    for (let i = t.Next; i !== e; i = i.Next)
      yield i.Point;
  }
  ReplacePiece(t, e, i, s) {
    let n = t;
    for (const r of i) {
      const o = new Ni(r);
      n.Next = o, n = o, this.verticesToPathOffsets.get(r).set(s, n);
    }
    n.Next = e;
  }
  CleanDisappearedPiece(t, e, i) {
    for (const s of Ms.GetPointsInBetween(t, e))
      this.verticesToPathOffsets.get(s).delete(i);
  }
  // checks that a is before b of the path
  // <returns>true is a is before b of the path</returns>
  static Before(t, e) {
    for (t = t.Next; t != null; t = t.Next)
      if (t === e)
        return !0;
    return !1;
  }
  static FindLinkedPointInPath(t, e) {
    for (let i = t.PathPoints; ; i = i.Next)
      if (i.Point.equal(e))
        return i;
  }
  InitVerticesToPathOffsetsAndRemoveSelfCycles() {
    for (const t of this.Paths)
      for (let e = t.PathPoints; e != null; e = e.Next) {
        let i = this.verticesToPathOffsets.get(e.Point);
        i || this.verticesToPathOffsets.set(e.Point, i = /* @__PURE__ */ new Map());
        const s = i.get(t);
        s ? (this.CleanDisappearedPiece(s, e, t), s.Next = e.Next) : i.set(t, e);
      }
  }
}
class zt {
  static RefinePaths(t, e) {
    zt.AdjustPaths(t);
    const i = zt.CreatePathsToFirstLinkedVerticesMap(t);
    zt.Refine(Array.from(i.values())), zt.CrossVerticalAndHorizontalSegs(i.values()), zt.ReconstructPathsFromLinkedVertices(i), e && new Ms(t).MergePaths();
  }
  // make sure that every two different points of paths are separated by at least 10e-6
  static AdjustPaths(t) {
    for (const e of t)
      e.PathPoints = zt.AdjustPathPoints(e.PathPoints);
  }
  static AdjustPathPoints(t) {
    if (!t || t.length === 0)
      return;
    const e = [];
    let i = u.RoundPoint(t[0]);
    e.push(i);
    for (let s = 1; s < t.length; s++) {
      const n = u.RoundPoint(t[s]);
      i.equal(n) || (i = n, e.push(i));
    }
    return e;
  }
  static CrossVerticalAndHorizontalSegs(t) {
    const e = new Array(), i = new Array();
    for (const s of t)
      for (let n = s; n.Next != null; n = n.Next)
        D(n.Point.x, n.Next.Point.x) ? i.push(n) : e.push(n);
    new oi(e, i).SplitPoints();
  }
  static ReconstructPathsFromLinkedVertices(t) {
    for (const [e, i] of t)
      e.PathPoints = i;
  }
  static Refine(t) {
    zt.RefineInDirection(S.North, t), zt.RefineInDirection(S.East, t);
  }
  // refines all segments that are parallel to "direction"
  static *groupByProj(t, e) {
    const i = /* @__PURE__ */ new Map();
    for (const s of e) {
      const n = t(s.Point);
      let r = i.get(n);
      r || (r = new Array(), i.set(n, r)), r.push(s);
    }
    for (const s of i.values())
      yield s;
  }
  static RefineInDirection(t, e) {
    const i = {
      projectionToPerp: void 0,
      projectionToDirection: void 0
    };
    zt.GetProjectionsDelegates(t, i);
    const s = Array.from(zt.GetAllLinkedVertsInDirection(i.projectionToPerp, e)), n = zt.groupByProj(i.projectionToPerp, s);
    for (const r of n)
      zt.RefineCollinearBucket(r, i.projectionToDirection);
  }
  static GetProjectionsDelegates(t, e) {
    t === S.East ? (e.projectionToDirection = (i) => i.x, e.projectionToPerp = (i) => i.y) : (e.projectionToPerp = (i) => i.x, e.projectionToDirection = (i) => i.y);
  }
  static *GetAllLinkedVertsInDirection(t, e) {
    for (const i of e)
      for (let s = i; s.Next != null; s = s.Next)
        D(t(s.Point), t(s.Next.Point)) && (yield s);
  }
  // refine vertices belonging to a bucket;
  // pathLinkedVertices belong to a line parallel to the direction of the refinement
  static RefineCollinearBucket(t, e) {
    const i = /* @__PURE__ */ new Set(), s = new Array();
    for (const o of t) {
      let l = e(o.Point);
      i.has(l) || (i.add(l), s.push([o.Point, l])), l = e(o.Next.Point), i.has(l) || (i.add(l), s.push([o.Next.Point, l]));
    }
    s.sort((o, l) => o[1] - l[1]);
    const n = s.map((o) => o[0]), r = /* @__PURE__ */ new Map();
    for (let o = 0; o < s.length; o++)
      r.set(s[o][1], o);
    for (const o of t) {
      const l = r.get(e(o.Point)), h = r.get(e(o.Next.Point));
      Math.abs(h - l) > 1 && zt.InsertPoints(o, n, l, h);
    }
  }
  static InsertPoints(t, e, i, s) {
    i < s ? t.InsertVerts(i, s, e) : t.InsertVertsInReverse(s, i, e);
  }
  static CreatePathsToFirstLinkedVerticesMap(t) {
    const e = /* @__PURE__ */ new Map();
    for (const i of t)
      e.set(i, zt.CreateLinkedVertexOfEdgePath(i));
    return e;
  }
  static CreateLinkedVertexOfEdgePath(t) {
    const e = t.PathPoints;
    let i = new Ni(e[0]);
    const s = i;
    for (let n = 1; n < e.length; n++)
      i.Next = new Ni(e[n]), i = i.Next;
    return s;
  }
}
class ns {
  // offset
  constructor(t, e) {
    this.Points = t, this.I = e;
  }
  static equal(t, e) {
    return t.I === e.I && t.Points === e.Points;
  }
  get Start() {
    return this.Points[this.I];
  }
  get End() {
    return this.Points[this.I + 1];
  }
}
class rs {
  constructor(t, e) {
    this.segTree = new Lr(null), this.crossedOutPaths = /* @__PURE__ */ new Set(), this.HierarchyOfObstacles = new Lr(e), this.Paths = t;
  }
  static RemoveStaircases(t, e) {
    new rs(t, e).Calculate();
  }
  Calculate() {
    this.InitHierarchies();
    let t;
    do {
      t = !1;
      for (const e of this.Paths.filter((i) => !this.crossedOutPaths.has(i)))
        this.ProcessPath(e) && (t = !0);
    } while (t);
  }
  ProcessPath(t) {
    const e = { pts: t.PathPoints, canHaveStaircase: !1 };
    return this.ProcessPoints(e) ? (t.PathPoints = e.pts, !0) : (e.canHaveStaircase || this.crossedOutPaths.add(t), !1);
  }
  ProcessPoints(t) {
    const e = this.FindStaircaseStart(t);
    return e < 0 ? !1 : (t.pts = this.RemoveStaircasePN(t.pts, e), !0);
  }
  FindStaircaseStart(t) {
    if (t.canHaveStaircase = !1, t.pts.length < 5)
      return -1;
    const e = [new ns(t.pts, 0), new ns(t.pts, 1), new ns(t.pts, 2), new ns(t.pts, 3)];
    let i = 0;
    for (let s = 0; ; ) {
      const n = { canHaveStaircaseAtI: !1 };
      if (this.IsStaircase(t.pts, s, e, n))
        return t.canHaveStaircase = !0, s;
      if (t.canHaveStaircase = t.canHaveStaircase || n.canHaveStaircaseAtI, s++, t.pts.length < s + 5)
        return -1;
      e[i] = new ns(t.pts, s + 3), i++, i %= 4;
    }
  }
  static GetFlippedPoint(t, e) {
    return D(t[e].y, t[e + 1].y) ? new u(t[e + 4].x, t[e].y) : new u(t[e].x, t[e + 4].y);
  }
  // ignoring crossing at a
  Crossing(t, e, i) {
    return rs.IsCrossing(v.mkPP(t, e), this.segTree, i);
  }
  // ignoring crossing at ls.Start
  static IsCrossing(t, e, i) {
    for (const s of e.GetAllIntersecting(t.boundingBox))
      if (i.findIndex((n) => n === s) === -1)
        return !0;
    return !1;
  }
  IntersectObstacleHierarchyPPP(t, e, i) {
    return this.IntersectObstacleHierarchyL(v.mkPP(t, e)) || this.IntersectObstacleHierarchyL(v.mkPP(e, i));
  }
  IntersectObstacleHierarchyL(t) {
    return this.HierarchyOfObstacles.GetAllIntersecting(t.boundingBox).some((e) => g.intersectionOne(t, e, !1) != null);
  }
  IsStaircase(t, e, i, s) {
    const n = t[e], r = t[e + 1];
    let o = t[e + 2];
    const l = t[e + 3], h = t[e + 4];
    return s.canHaveStaircaseAtI = !1, E.DirectionFromPointToPoint(n, r) !== E.DirectionFromPointToPoint(o, l) || E.DirectionFromPointToPoint(r, o) !== E.DirectionFromPointToPoint(l, h) || (o = rs.GetFlippedPoint(t, e), this.IntersectObstacleHierarchyPPP(r, o, l)) ? !1 : (s.canHaveStaircaseAtI = !0, !this.Crossing(r, o, i));
  }
  RemoveStaircasePN(t, e) {
    const i = t[e], s = t[e + 1], n = Math.abs(i.y - s.y) < m.distanceEpsilon / 2;
    return this.RemoveStaircasePNB(t, e, n);
  }
  RemoveStaircasePNB(t, e, i) {
    this.RemoveSegs(t);
    const s = new Array(t.length - 2);
    df(t, s, e + 1);
    const n = t[e + 1], r = t[e + 3];
    return s[e + 1] = i ? new u(r.x, n.y) : new u(n.x, r.y), uf(t, e + 4, s, e + 2, s.length - e - 2), this.InsertNewSegs(s, e), s;
  }
  RemoveSegs(t) {
    for (let e = 0; e < t.length - 1; e++)
      this.RemoveSeg(new ns(t, e));
  }
  RemoveSeg(t) {
    this.segTree.Remove(rs.Rect(t), t);
  }
  InsertNewSegs(t, e) {
    this.InsSeg(t, e), this.InsSeg(t, e + 1);
  }
  InitHierarchies() {
    for (const t of this.Paths)
      this.InsertPathSegs(t);
  }
  InsertPathSegs(t) {
    this.InsertSegs(t.PathPoints);
  }
  InsertSegs(t) {
    for (let e = 0; e < t.length - 1; e++)
      this.InsSeg(t, e);
  }
  InsSeg(t, e) {
    const i = new ns(t, e);
    this.segTree.Add(rs.Rect(i), i);
  }
  static Rect(t) {
    return T.mkPP(t.Start, t.End);
  }
}
function uf(a, t, e, i, s) {
  for (; s-- > 0; )
    e[i++] = a[t++];
}
function df(a, t, e) {
  let i = 0;
  for (; e-- > 0; )
    t[i++] = a[i++];
}
class nt {
  get HasGroups() {
    return this.HierarchyOfGroups != null && this.HierarchyOfGroups.Count > 0;
  }
  //  "nudges" paths to decrease the number of intersections and stores the results inside WidePaths of "paths"
  // paths through the graph
  // two parallel paths should be separated by this distance if it is feasible
  // polygonal convex obstacles organized  of a tree; the obstacles here are padded original obstacles
  //
  constructor(t, e, i, s) {
    this.AncestorsSets = s, this.HierarchyOfGroups = Et(Array.from(s.keys()).filter((n) => n.IsGroup).map((n) => Bt(n, n.BoundingBox))), this.Obstacles = i, this.EdgeSeparation = 2 * e, this.Paths = t, this.HierarchyOfObstacles = Et(i.map((n) => Bt(n, n.boundingBox))), this.MapPathsToTheirObstacles();
  }
  MapPathsToTheirObstacles() {
    this.PathToObstacles = /* @__PURE__ */ new Map();
    for (const t of this.Paths)
      this.MapPathToItsObstacles(t);
  }
  MapPathToItsObstacles(t) {
    if (!t.PathPoints || t.PathPoints.length === 0)
      return;
    const e = t.PathPoints, i = this.HierarchyOfObstacles.FirstHitNodeWithPredicate(e[0], nt.ObstacleTest), s = this.HierarchyOfObstacles.FirstHitNodeWithPredicate(e[e.length - 1], nt.ObstacleTest);
    i != null && s != null && this.PathToObstacles.set(t, [i.UserData, s.UserData]);
  }
  static ObstacleTest(t, e) {
    return g.PointRelativeToCurveLocation(t, e) !== F.Outside ? at.Stop : at.Continue;
  }
  Calculate(t, e) {
    this.NudgingDirection = t, zt.RefinePaths(this.Paths, e), this.GetPathOrdersAndPathGraph(), this.MapAxisEdgesToTheirObstacles(), this.DrawPaths();
  }
  MapAxisEdgesToTheirObstacles() {
    this.axisEdgesToObstaclesTheyOriginatedFrom = /* @__PURE__ */ new Map();
    for (const t of this.Paths)
      this.MapPathEndAxisEdgesToTheirObstacles(t);
    for (const t of this.Paths)
      this.UmmapPathInteriourFromStrangerObstacles(t);
  }
  UmmapPathInteriourFromStrangerObstacles(t) {
    const e = this.FindFirstUnmappedEdge(t);
    if (e == null)
      return;
    const i = this.FindLastUnmappedEdge(t);
    for (let s = e; s != null && s !== i; s = s.Next)
      this.axisEdgesToObstaclesTheyOriginatedFrom.delete(s.AxisEdge);
  }
  FindLastUnmappedEdge(t) {
    for (let e = t.LastEdge; e != null; e = e.Prev)
      if (e.AxisEdge.Direction !== this.NudgingDirection)
        return e;
    return null;
  }
  FindFirstUnmappedEdge(t) {
    for (let e = t.FirstEdge; e != null; e = e.Next)
      if (e.AxisEdge.Direction !== this.NudgingDirection)
        return e;
    return null;
  }
  MapPathEndAxisEdgesToTheirObstacles(t) {
    const e = this.PathToObstacles.get(t);
    e && (this.ProcessThePathStartToMapAxisEdgesToTheirObstacles(t, e[0]), this.ProcessThePathEndToMapAxisEdgesToTheirObstacles(t, e[1]));
  }
  ProcessThePathEndToMapAxisEdgesToTheirObstacles(t, e) {
    for (let i = t.LastEdge; i != null && E.DirectionsAreParallel(i.Direction, this.NudgingDirection); i = i.Prev)
      this.axisEdgesToObstaclesTheyOriginatedFrom.set(i.AxisEdge, e);
  }
  ProcessThePathStartToMapAxisEdgesToTheirObstacles(t, e) {
    for (let i = t.FirstEdge; i != null && E.DirectionsAreParallel(i.Direction, this.NudgingDirection); i = i.Next)
      this.axisEdgesToObstaclesTheyOriginatedFrom.set(i.AxisEdge, e);
  }
  GetPathOrdersAndPathGraph() {
    const t = new Vt(this.Paths);
    this.PathOrders = t.GetOrder(), this.PathVisibilityGraph = t.PathVisibilityGraph;
  }
  static GetCurvesForShow(t, e) {
    const i = new Array();
    for (const s of t) {
      const n = new B();
      for (const r of s.PathPoints)
        n.addPoint(r);
      i.push(n);
    }
    return i.concat(Array.from(e));
  }
  DrawPaths() {
    this.SetWidthsOfArrowheads(), this.CreateLongestNudgedSegments(), this.FindFreeSpaceInDirection(Array.from(this.PathVisibilityGraph.Edges)), this.MoveLongestSegsIdealPositionsInsideFeasibleIntervals(), this.PositionShiftedEdqges();
  }
  SetWidthsOfArrowheads() {
    for (const t of this.Paths)
      nt.SetWidthsOfArrowheadsForEdge(t);
  }
  static SetWidthsOfArrowheadsForEdge(t) {
    const e = t.GeomEdge;
    if (e.targetArrowhead != null) {
      const i = t.LastEdge;
      i.Width = Math.max(e.targetArrowhead.width, i.Width);
    }
    if (e.sourceArrowhead != null) {
      const i = t.FirstEdge;
      i.Width = Math.max(e.sourceArrowhead.width, i.Width);
    }
  }
  PositionShiftedEdqges() {
    this.Solver = new of(this.EdgeSeparation);
    for (let t = 0; t < this.LongestNudgedSegs.length; t++)
      this.CreateVariablesOfLongestSegment(this.LongestNudgedSegs[t]);
    this.CreateConstraintsOfTheOrder(), this.CreateConstraintsBetweenLongestSegments(), this.Solver.SolveByRegularSolver(), this.ShiftPathEdges();
  }
  MoveLongestSegsIdealPositionsInsideFeasibleIntervals() {
    for (let t = 0; t < this.LongestNudgedSegs.length; t++) {
      const e = this.LongestNudgedSegs[t];
      nt.MoveLongestSegIdealPositionsInsideFeasibleInterval(e);
    }
  }
  static MoveLongestSegIdealPositionsInsideFeasibleInterval(t) {
    if (t.IsFixed)
      return;
    const e = t.GetLeftBound(), i = t.GetRightBound();
    t.IdealPosition < e ? t.IdealPosition = e : t.IdealPosition > i && (t.IdealPosition = i);
  }
  ShiftPathEdges() {
    for (const t of this.Paths)
      t.PathPoints = this.GetShiftedPoints(t);
  }
  GetShiftedPoints(t) {
    return nt.RemoveSwitchbacksAndMiddlePoints(this.GetShiftedPointsSimple(t));
  }
  // sometimes we have very small mistakes  of the positions that have to be fixed
  static Rectilinearise(t, e) {
    if (t.x === e.x || t.y === e.y)
      return e;
    const i = Math.abs(t.x - e.x), s = Math.abs(t.y - e.y);
    return i < s ? new u(t.x, e.y) : new u(e.x, t.y);
  }
  GetShiftedPointsSimple(t) {
    const e = [], i = t.FirstEdge;
    e.push(this.ShiftedPoint(i.Source, i.LongestNudgedSegment));
    for (const s of t.PathEdges())
      e.push(this.ShiftedEdgePositionOfTarget(s));
    return e;
  }
  ShiftedEdgePositionOfTarget(t) {
    return t.LongestNudgedSegment != null || t.Next == null ? this.ShiftedPoint(t.Target, t.LongestNudgedSegment) : this.ShiftedPoint(t.Next.Source, t.Next.LongestNudgedSegment);
  }
  ShiftedPoint(t, e) {
    if (e == null)
      return t;
    const i = this.Solver.GetVariablePosition(e.Id);
    return this.NudgingDirection === S.North ? new u(i, t.y) : new u(t.x, -i);
  }
  // static ShowPathsFromPoints(paths: Array<Path>, enumerable: Array<Polyline>) {
  //    let dd = new Array<DebugCurve>();
  //    if ((enumerable != null)) {
  //        dd=dd.concat(Nudger.GetObstacleBoundaries(enumerable, "grey"));
  //    }
  //    let i: number = 0;
  //    for (let p  of paths) {
  //        dd = dd.concat(Nudger.PathDebugCurvesFromPoints(p, DebugCurve.colors[Math.min(DebugCurve.colors.length, i++)]));
  //    }
  //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(dd);
  // }
  // static PathDebugCurvesFromPoints(path: Path, color: string): Array<DebugCurve> {
  //    const let startWidth: number = 0.01;
  //    const let endWidth: number = 3;
  //    let pts = path.PathPoints.toArray();
  //    let delta: number = ((endWidth - startWidth)
  //                / (pts.length - 1));
  //    for (let i: number = 0; (i
  //                < (pts.length - 1)); i++) {
  //        yield;
  //    }
  //    return new DebugCurve((startWidth
  //                    + (delta * i)), color, new LineSegment(pts[i], pts[(i + 1)]));
  // }
  // static ShowParamPaths(s: Point, e: Point, params paths: Path[]) {
  //    Nudger.ShowOrderedPaths(null, paths, s, e);
  // }
  // //         ReSharper disable UnusedMember.Local
  // static ShowOrderedPaths(obstacles: Array<Polyline>, paths: Array<Path>, s: Point, e: Point) {
  //    //            ReSharper restore UnusedMember.Local
  //    let colors: string[] = [
  //            "red",
  //            "green",
  //            "blue",
  //            "violet",
  //            "rose",
  //            "black"];
  //    const let startWidth: number = 0.001;
  //    const let endWidth: number = 0.1;
  //    let dd = new Array<DebugCurve>();
  //    if ((obstacles != null)) {
  //        dd.AddRange(Nudger.GetObstacleBoundaries(obstacles, "grey"));
  //    }
  //    let i: number = 0;
  //    for (let path  of paths) {
  //        dd.AddRange(Nudger.GetTestPathAsDebugCurve(startWidth, endWidth, colors[Math.min((colors.length - 1), i++)], path));
  //    }
  //    let ell = new DebugCurve(1, "black", new Ellipse(0.01, 0.01, s));
  //    dd.Add(ell);
  //    dd.Add(new DebugCurve(1, "black", new Ellipse(0.02, 0.02, e)));
  //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(dd.concat(Nudger.GetObstacleBoundaries(obstacles, "lightblue")));
  // }
  // static GetTestPathAsDebugCurve(startWidth: number, endWidth: number, color: string, path: Path): Array<DebugCurve> {
  //    if ((path.PathEdges.Count() > 0)) {
  //        let count: number = path.PathEdges.Count();
  //        let deltaW: number = ((endWidth - startWidth)
  //                    / (count - 1));
  //        // TODO: Warning!!!, inline IF is not supported ?
  //        (count > 1);
  //        1;
  //        // if count ==1 the value of deltaW does not matter
  //        let i: number = 0;
  //        for (let e  of path.PathEdges) {
  //            yield;
  //        }
  //        return new DebugCurve(150, (startWidth
  //                        + (deltaW
  //                        * (i + 1))), color, new LineSegment(e.Source, e.Target));
  //    }
  //    else {
  //        let count: number = path.PathPoints.count();
  //        let pts = path.PathPoints.toArray();
  //        let deltaW = ((endWidth - startWidth)
  //                    / (count - 1));
  //        // TODO: Warning!!!, inline IF is not supported ?
  //        (count > 1);
  //        1;
  //        // if count ==1 the value of deltaW does not matter
  //        for (let i: number = 0; (i
  //                    < (count - 1)); i++) {
  //            yield;
  //        }
  //        return new DebugCurve(150, (startWidth
  //                        + (deltaW * i)), color, new LineSegment(pts[i], pts[(i + 1)]));
  //    }
  // }
  // static GetTestEdgePathAsDebugCurves(startWidth: number, endWidth: number, color: string, path: Path): Array<DebugCurve> {
  //    let count: number = path.PathPoints.count();
  //    let deltaW: number = ((endWidth - startWidth)
  //                / (count - 1));
  //    // TODO: Warning!!!, inline IF is not supported ?
  //    (count > 1);
  //    1;
  //    // if count ==1 the value of deltaW does not matter
  //    let points = path.PathPoints.toArray();
  //    for (let i: number = 0; (i
  //                < (points.length - 1)); i++) {
  //        yield;
  //    }
  //    return new DebugCurve(125, (startWidth
  //                    + (deltaW * i)), color, new LineSegment(points[i], points[(i + 1)]));
  // }
  // static GetEdgePathFromPathEdgesAsDebugCurves(startWidth: number, endWidth: number, color: string, path: Path): Array<DebugCurve> {
  //    let points = path.PathPoints.toArray();
  //    let count: number = points.length;
  //    let deltaW: number = ((endWidth - startWidth)
  //                / (count - 1));
  //    // TODO: Warning!!!, inline IF is not supported ?
  //    (count > 1);
  //    1;
  //    // if count ==1 the value of deltaW does not matter
  //    for (let i: number = 0; (i
  //                < (points.length - 1)); i++) {
  //        yield;
  //    }
  //    return new DebugCurve(120, (startWidth
  //                    + (deltaW * i)), color, new LineSegment(points[i], points[(i + 1)]));
  // }
  // // ReSharper disable UnusedMember.Local
  // static ShowEdgePaths(obstacles: Array<Polyline>, edgePaths: Array<Path>) {
  //    //  ReSharper restore UnusedMember.Local
  //    let debCurves: Array<DebugCurve> = Nudger.GetDebCurvesOfPaths(obstacles, edgePaths);
  //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(debCurves);
  // }
  // static GetDebCurvesOfPaths(enumerable: Array<Polyline>, edgePaths: Array<Path>): Array<DebugCurve> {
  //    let debCurves = Nudger.GetObstacleBoundaries(enumerable, "black");
  //    let i: number = 0;
  //    for (let edgePath  of edgePaths) {
  //        debCurves.AddRange(Nudger.GetTestEdgePathAsDebugCurves(0.2, 4, DebugCurve.colors[((i + 1)
  //                            % DebugCurve.colors.length)], edgePath));
  //    }
  //    return debCurves;
  // }
  // static ShowPathsInLoop(enumerable: Array<Polyline>, edgePaths: Array<Path>, point: Point) {
  //    for (let edgePath  of edgePaths.where(() => {  }, (((path.PathPoints.First() - point).Length < 1)
  //                    || ((path.PathPoints.Last() - point).Length < 1)))) {
  //        let debCurves = Nudger.GetObstacleBoundaries(enumerable, "black");
  //        debCurves.AddRange(Nudger.GetTestEdgePathAsDebugCurves(0.1, 4, "red", edgePath));
  //        LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(debCurves);
  //    }
  // }
  // // ReSharper disable UnusedMember.Local
  // ShowLongSegsWithIdealPositions(dir: Direction) {
  //    //  ReSharper restore UnusedMember.Local
  //    let debCurves = Nudger.GetObstacleBoundaries(this.Obstacles, "black");
  //    let i: number = 0;
  //    debCurves.AddRange(this.LongestNudgedSegs.Select(() => {  }, Nudger.DebugCurveOfLongSeg(ls, DebugCurve.colors[i++, Percent, DebugCurve.colors.length], dir)));
  //    DebugCurveCollection.WriteToFile(debCurves, "c:/tmp/longSegs");
  //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(debCurves);
  // }
  // static DebugCurveOfLongSeg(ls: LongestNudgedSegment, s: string, dir: Direction): DebugCurve {
  //    return new DebugCurve(1, s, Nudger.LineSegOfLongestSeg(ls, dir));
  // }
  static LineSegOfLongestSeg(t, e) {
    const i = e === S.East ? (n) => n.x : (n) => n.y, s = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
    for (const n of t.Edges)
      nt.UpdateMinMaxWithPoint(s, i, n.Source), nt.UpdateMinMaxWithPoint(s, i, n.Target);
    return e === S.East ? new v(s.min, -t.IdealPosition, s.max, -t.IdealPosition) : new v(t.IdealPosition, s.min, t.IdealPosition, s.max);
  }
  static UpdateMinMaxWithPoint(t, e, i) {
    const s = e(i);
    t.min > s && (t.min = s), t.max < s && (t.max = s);
  }
  // ShowPathsDebug(edgePaths: Array<Path>) {
  //    let debCurves = Nudger.GetObstacleBoundaries(this.Obstacles, "black");
  //    let i: number = 0;
  //    for (let edgePath  of edgePaths) {
  //        debCurves.AddRange(Nudger.GetEdgePathFromPathEdgesAsDebugCurves(0.01, 0.4, DebugCurve.colors[((i + 1)
  //                            % DebugCurve.colors.length)], edgePath));
  //    }
  //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(debCurves);
  // }
  // static PathDebugCurves(path: Path, color: string): Array<DebugCurve> {
  //    let d = path.PathEdges.Select(() => {  }, new DebugCurve(70, 0.5, color, new LineSegment(e.Source, e.Target)));
  //    return d.Concat(Nudger.MarkPathVerts(path));
  // }
  // private static MarkPathVerts(path: Path): Array<DebugCurve> {
  //    let first: boolean = true;
  //    let p = new Point();
  //    for (let p0  of path.PathPoints) {
  //        if (first) {
  //            yield;
  //            return new DebugCurve(200, 1, "violet", CurveFactory.CreateDiamond(5, 5, p0));
  //            first = false;
  //        }
  //        else {
  //            yield;
  //        }
  //        return new DebugCurve(100, 0.5, "brown", CurveFactory.CreateEllipse(1.5, 1.5, p0));
  //        p = p0;
  //    }
  //    yield;
  //    return new DebugCurve(200, 1, "green", CurveFactory.CreateDiamond(3, 3, p));
  // }
  // static PathDebugCurvesFromPoint(path: Path): Array<DebugCurve> {
  //    let l = new Array<Point>(path.PathPoints);
  //    for (let i: number = 0; (i
  //                < (l.Count - 1)); i++) {
  //        yield;
  //    }
  //    return new DebugCurve(4, "red", new LineSegment(l[i], l[(i + 1)]));
  // }
  //
  // ReSharper disable UnusedMember.Local
  //        void ShowEdgesOfEdgePath(Path path){
  // ReSharper restore UnusedMember.Local
  //            string[] colors = {"red", "brown", "purple"};
  //            const double w0 = 1;
  //            const double w1 = 3;
  //            double dw = (w1 - w0)/path.OrientedSubpaths.Count;
  //            int i = 0;
  //            var dc = new Array<DebugCurve>();
  //            foreach (var s  of path.OrientedSubpaths){
  //                dc.AddRange(SubpathDebugCurves(w0 + dw*i, colors[Math.Min(i++, colors.Length - 1)], s));
  //            }
  //            LayoutAlgorithmSettings.ShowDebugCurves(dc.ToArray());
  //        }
  //
  //        static Array<DebugCurve> SubpathDebugCurves(double w, string color, OrientedSubpath subpath){
  //            return subpath.LinkedPath.Select(e => new DebugCurve(w, color, new LineSegment(e.Source.Point, e.Target.Point)));
  //        }
  // static GetObstacleBoundaries(obstacles: Array<Polyline>, color: string): Array<DebugCurve> {
  //    let debugCurves = new Array<DebugCurve>();
  //    if ((obstacles != null)) {
  //        debugCurves.AddRange(obstacles.select(() => {  }, new DebugCurve(50, 0.3, color, poly)));
  //    }
  //    return debugCurves;
  // }
  CreateConstraintsBetweenLongestSegments() {
    for (const t of this.LongestNudgedSegs)
      this.CreateConstraintsBetweenLongestSegmentsForSegment(t);
  }
  CreateConstraintsBetweenLongestSegmentsForSegment(t) {
    const e = /* @__PURE__ */ new Set();
    for (const i of t.Edges) {
      const s = i.AxisEdge;
      if (s != null)
        for (const n of s.RightNeighbors)
          for (const r of n.LongestNudgedSegments)
            e.add(r);
    }
    for (const i of e)
      this.ConstraintTwoLongestSegs(t, i);
  }
  CreateConstraintsOfTheOrder() {
    for (const t of this.PathOrders)
      nt.ParallelToDirection(t[0], this.NudgingDirection) && this.CreateConstraintsOfThePathOrder(t[1]);
  }
  static ParallelToDirection(t, e) {
    switch (e) {
      case S.North:
      case S.South:
        return D(t.SourcePoint.x, t.TargetPoint.x);
      default:
        return D(t.SourcePoint.y, t.TargetPoint.y);
    }
  }
  CreateConstraintsOfThePathOrder(t) {
    let e = null;
    for (const i of t.filter((s) => s.LongestNudgedSegment != null))
      e != null && this.ConstraintTwoLongestSegs(e.LongestNudgedSegment, i.LongestNudgedSegment), e = i;
  }
  ConstraintTwoLongestSegs(t, e) {
    (!t.IsFixed || !e.IsFixed) && this.Solver.AddConstraint(t.Id, e.Id);
  }
  CreateVariablesOfLongestSegment(t) {
    if (t.IsFixed)
      this.Solver.AddFixedVariable(t.Id, nt.SegmentPosition(t, this.NudgingDirection));
    else {
      const e = t.GetLeftBound(), i = t.GetRightBound();
      e >= i ? (this.Solver.AddFixedVariable(t.Id, nt.SegmentPosition(t, this.NudgingDirection)), t.IsFixed = !0) : (this.Solver.AddVariableNNNN(t.Id, nt.SegmentPosition(t, this.NudgingDirection), t.IdealPosition, t.Width), e !== Number.NEGATIVE_INFINITY && this.Solver.SetLowBound(e, t.Id), i !== Number.POSITIVE_INFINITY && this.Solver.SetUpperBound(t.Id, i));
    }
  }
  static SegmentPosition(t, e) {
    return e === S.North ? t.Start.x : -t.Start.y;
  }
  FindFreeSpaceInDirection(t) {
    this.BoundAxisEdgesByRectsKnownInAdvance(), new Ei(this.NudgingDirection, this.Obstacles, this.axisEdgesToObstaclesTheyOriginatedFrom, this.PathOrders, t).FindFreeSpace();
  }
  BoundAxisEdgesByRectsKnownInAdvance() {
    for (const t of this.Paths)
      this.HasGroups && this.BoundPathByMinCommonAncestors(t), this.BoundAxisEdgesAdjacentToSourceAndTargetOnEdge(t);
  }
  BoundPathByMinCommonAncestors(t) {
    for (const e of this.GetMinCommonAncestors(t.GeomEdge)) {
      const i = e.BoundingBox;
      for (const s of t.PathEdges()) {
        const n = s.AxisEdge;
        n.Direction === this.NudgingDirection && this.BoundAxisEdgeByRect(i, n);
      }
    }
  }
  GetMinCommonAncestors(t) {
    this.PortToShapes == null && (this.PortToShapes = nt.MapPortsToShapes(this.AncestorsSets.keys()));
    const e = ff(this.AncestorsForPort(t.sourcePort), this.AncestorsForPort(t.targetPort));
    return Array.from(e).filter((i) => !i.Children.some((s) => e.has(s)));
  }
  AncestorsForPort(t) {
    const e = this.PortToShapes.get(t);
    return e ? this.AncestorsSets.get(e) : new Set(this.HierarchyOfGroups.AllHitItems(T.mkPP(t.Location, t.Location), null));
  }
  BoundAxisEdgeAdjacentToObstaclePort(t, e) {
    t.Curve == null ? this.BoundAxisByPoint(t.Location, e) : t.Curve.boundingBox.contains(t.Location) && this.BoundAxisEdgeByRect(t.Curve.boundingBox, e);
  }
  BoundAxisByPoint(t, e) {
    e != null && e.Direction === this.NudgingDirection && (this.NudgingDirection === S.North ? (e.BoundFromLeft(t.x), e.BoundFromRight(t.x)) : (e.BoundFromLeft(-t.y), e.BoundFromRight(-t.y)));
  }
  BoundAxisEdgesAdjacentToSourceAndTargetOnEdge(t) {
    this.BoundAxisEdgeAdjacentToObstaclePort(t.GeomEdge.sourcePort, t.FirstEdge.AxisEdge), this.BoundAxisEdgeAdjacentToObstaclePort(t.GeomEdge.targetPort, t.LastEdge.AxisEdge);
  }
  BoundAxisEdgeByRect(t, e) {
    e != null && e.Direction === this.NudgingDirection && (this.NudgingDirection === S.North ? (e.BoundFromLeft(t.left), e.BoundFromRight(t.right)) : (e.BoundFromLeft(t.top * -1), e.BoundFromRight(t.bottom * -1)));
  }
  CreateLongestNudgedSegments() {
    const t = this.NudgingDirection === S.East ? (e) => -e.y : (e) => e.x;
    this.LongestNudgedSegs = new Array();
    for (let e = 0; e < this.Paths.length; e++)
      this.CreateLongestNudgedSegmentsForPath(this.Paths[e], t);
  }
  CreateLongestNudgedSegmentsForPath(t, e) {
    this.GoOverPathAndCreateLongSegs(t), nt.CalculateIdealPositionsForLongestSegs(t, e);
  }
  static CalculateIdealPositionsForLongestSegs(t, e) {
    let i = null, s = null, n = e(t.Start);
    for (const r of t.PathEdges())
      if (r.LongestNudgedSegment != null) {
        if (i = r.LongestNudgedSegment, s != null) {
          let o;
          nt.SetIdealPositionForSeg(s, o = e(s.start), n, e(i.Start)), n = o, s = null;
        }
      } else i != null && (s = i, i = null);
    s != null ? nt.SetIdealPositionForSeg(s, e(s.Start), n, e(t.End)) : i != null && (i.IdealPosition = e(i.Start));
  }
  static SetIdealPositionForSeg(t, e, i, s) {
    const n = Math.max(i, s), r = Math.min(i, s);
    r + m.distanceEpsilon < e ? e < n ? t.IdealPosition = 0.5 * (n + r) : t.IdealPosition = n : t.IdealPosition = r;
  }
  GoOverPathAndCreateLongSegs(t) {
    let e = null;
    const i = E.OppositeDir(this.NudgingDirection);
    for (const s of t.PathEdges()) {
      const n = s.Direction;
      n === this.NudgingDirection || n === i ? (e == null ? (s.LongestNudgedSegment = e = new cf(this.LongestNudgedSegs.length), this.LongestNudgedSegs.push(e)) : s.LongestNudgedSegment = e, s.IsFixed && (e.IsFixed = !0)) : (s.LongestNudgedSegment = null, e = null);
    }
  }
  static BuildPolylineForPath(t) {
    const e = { points: t.PathPoints.map((i) => i.clone()) };
    return nt.ExtendPolylineToPorts(e, t), e.points;
  }
  static ExtendPolylineToPorts(t, e) {
    nt.ExtendPolylineToSourcePort(t, e.GeomEdge.sourcePort.Location), nt.ExtendPolylineToTargetPort(t, e.GeomEdge.targetPort.Location), t.points.length < 2 && (t.points = new Array(2), t.points[0] = e.GeomEdge.sourcePort.Location, t.points[1] = e.GeomEdge.targetPort.Location);
  }
  static ExtendPolylineToTargetPort(t, e) {
    const i = t.points.length - 1, s = E.VectorDirectionPP(t.points[i - 1], t.points[i]);
    if (nt.ProjectionsAreClose(t.points[i - 1], s, e)) {
      t.points = t.points.slice(0, i);
      return;
    }
    const n = t.points[i];
    s === S.East || s === S.West ? t.points[i] = new u(e.x, n.y) : t.points[i] = new u(n.x, e.y);
  }
  static ProjectionsAreClose(t, e, i) {
    return e === S.East || e === S.West ? D(t.x, i.x) : D(t.y, i.y);
  }
  static ExtendPolylineToSourcePort(t, e) {
    const i = E.VectorDirectionPP(t.points[0], t.points[1]);
    if (nt.ProjectionsAreClose(t.points[1], i, e)) {
      t.points = t.points.slice(1);
      return;
    }
    const s = t.points[0];
    i === S.East || i === S.West ? t.points[0] = new u(e.x, s.y) : t.points[0] = new u(s.x, e.y);
  }
  static RemoveSwitchbacksAndMiddlePoints(t) {
    const e = [];
    let i = t[0];
    e.push(i);
    let s = t[1], n = E.VectorDirectionPP(i, s), r = 1;
    for (; ++r < t.length; ) {
      const o = E.VectorDirectionPP(s, t[r]);
      o === n || E.OppositeDir(o) === n || o === S.None || (u.closeDistEps(i, s) || e.push(i = nt.Rectilinearise(i, s)), n = o), s = t[r];
    }
    return u.closeDistEps(i, s) || e.push(nt.Rectilinearise(i, s)), e;
  }
  // this function defines the final path coordinates
  // the set of paths, point sequences
  // the radius of the arc inscribed into the path corners
  // an enumeration of padded obstacles
  //
  //
  // <returns>the mapping of the path to its modified path</returns>
  static NudgePaths(t, e, i, s, n) {
    if (t.length === 0)
      return;
    const r = new nt(t, e, i, s);
    r.Calculate(S.North, !0), r.Calculate(S.East, !1), r.Calculate(S.North, !1), n && r.RemoveStaircases();
    for (const o of t)
      o.GeomEdge.curve = B.mkFromPoints(nt.BuildPolylineForPath(o));
  }
  RemoveStaircases() {
    rs.RemoveStaircases(this.Paths, this.HierarchyOfObstacles);
  }
  static MapPortsToShapes(t) {
    const e = /* @__PURE__ */ new Map();
    for (const i of t)
      for (const s of i.Ports)
        e.set(s, i);
    return e;
  }
  // ShowPathsDebug(edgePaths: Iterable<Path>, fn: string) {
  //  const debCurves = GetObstacleBoundaries(this.Obstacles, 'black')
  //  const i = 0
  //  for (const edgePath of edgePaths) {
  //    for (const c of Nudger.GetEdgePathFromPathEdgesAsDebugCurves(
  //      0.1,
  //      1.0,
  //      DebugCurve.colors[(i + 1) % DebugCurve.colors.length],
  //      edgePath,
  //    )) {
  //      debCurves.push(c)
  //    }
  //  }
  //  SvgDebugWriter.dumpDebugCurves(fn, debCurves)
  // }
  static *GetEdgePathFromPathEdgesAsDebugCurves(t, e, i, s) {
    const n = s.ArrayOfPathPoints(), r = n.length, o = r > 1 ? (e - t) / (r - 1) : 1;
    for (let l = 0; l < n.length - 1; l++)
      yield q.mkDebugCurveTWCI(200, t + o * l, i, v.mkPP(n[l], n[l + 1]));
  }
}
function ff(a, t) {
  const e = /* @__PURE__ */ new Set();
  if (a.size < t.size)
    for (const i of a)
      t.has(i) && e.add(i);
  else
    for (const i of t)
      a.has(i) && e.add(i);
  return e;
}
class gf {
  constructor(t, e) {
    this.Crossings = [], this.Location = t, this.Crossings = e;
  }
}
class Sn {
  Count() {
    return this.ListOfPointsAndCrossings.length;
  }
  constructor() {
    this.ListOfPointsAndCrossings = [], this.index = 0, this.ListOfPointsAndCrossings = new Array();
  }
  Add(t, e) {
    this.ListOfPointsAndCrossings.push(new gf(t, e));
  }
  Pop() {
    return this.ListOfPointsAndCrossings[this.index++];
  }
  CurrentIsBeforeOrAt(t) {
    return this.index >= this.ListOfPointsAndCrossings.length ? !1 : b.ComparePP(this.ListOfPointsAndCrossings[this.index].Location, t) <= 0;
  }
  get First() {
    return this.ListOfPointsAndCrossings[0];
  }
  get Last() {
    return this.ListOfPointsAndCrossings[this.ListOfPointsAndCrossings.length - 1];
  }
  Reset() {
    this.index = 0;
  }
  MergeFrom(t) {
    if (this.Reset(), t == null)
      return;
    const e = this.ListOfPointsAndCrossings.length;
    let i = 0;
    const s = t.ListOfPointsAndCrossings.length;
    let n = 0;
    const r = new Array(this.ListOfPointsAndCrossings.length);
    for (; i < e || n < s; ) {
      if (i >= e) {
        r.push(t.ListOfPointsAndCrossings[n++]);
        continue;
      }
      if (n >= s) {
        r.push(this.ListOfPointsAndCrossings[i++]);
        continue;
      }
      const o = this.ListOfPointsAndCrossings[i], l = t.ListOfPointsAndCrossings[n], h = b.ComparePP(o.Location, l.Location);
      h === 0 ? (r.push(o), ++i, ++n) : h === -1 ? (r.push(o), ++i) : (r.push(l), ++n);
    }
    this.ListOfPointsAndCrossings = r;
  }
  Trim(t, e) {
    this.Reset(), !(this.ListOfPointsAndCrossings == null || this.ListOfPointsAndCrossings.length === 0) && (this.ListOfPointsAndCrossings = this.ListOfPointsAndCrossings.filter((i) => b.ComparePP(i.Location, t) >= 0 && b.ComparePP(i.Location, e) <= 0));
  }
  // For a single vertex point, split its Array of crossings in both directions into an array in each (opposite)
  // direction.  CLR Array iteration is much faster than Array.
  static ToCrossingArray(t, e) {
    let i = 0;
    const s = t.length;
    for (let o = 0; o < s; o++)
      t[o].DirectionToInside === e && i++;
    if (i === 0)
      return null;
    const n = new Array(i);
    let r = 0;
    for (let o = 0; o < s; o++)
      t[o].DirectionToInside === e && (n[r++] = t[o]);
    return n;
  }
  ToString() {
    return Gt.String.format("{0} [{1}]", this.ListOfPointsAndCrossings.length, this.index);
  }
}
class O {
  // Determine the direction of an edge.
  static EdgeDirectionVE(t) {
    return O.EdgeDirectionVV(t.Source, t.Target);
  }
  static EdgeDirectionVV(t, e) {
    return b.GetDirections(t.point, e.point);
  }
  static GetEdgeEnd(t, e) {
    const i = O.EdgeDirectionVE(t);
    return e === i ? t.Target : t.Source;
  }
  static FindAdjacentVertex(t, e) {
    for (const i of t.InEdges)
      if (b.GetDirections(t.point, i.SourcePoint) === e)
        return i.Source;
    for (const i of t.OutEdges)
      if (b.GetDirections(t.point, i.TargetPoint) === e)
        return i.Target;
    return null;
  }
  static FindAdjacentEdge(t, e) {
    for (const i of t.InEdges)
      if (b.GetDirections(i.SourcePoint, t.point) === e)
        return i;
    for (const i of t.OutEdges)
      if (b.GetDirections(t.point, i.TargetPoint) === e)
        return i;
    return null;
  }
  static FindBendPointBetween(t, e, i) {
    return O.IsVerticalD(i) ? new u(e.x, t.y) : new u(t.x, e.y);
  }
  static SegmentIntersectionPPP(t, e, i) {
    const s = b.GetDirections(t, e);
    return O.IsVerticalD(s) ? new u(t.x, i.y) : new u(i.x, t.y);
  }
  static SegmentIntersectionSP(t, e) {
    return O.SegmentIntersectionPPP(t.Start, t.End, e);
  }
  static SegmentsIntersection(t, e) {
    return O.IntervalsIntersect(t.Start, t.End, e.Start, e.End);
  }
  static SegmentsIntersectLL(t, e) {
    return O.IntervalsIntersect(t.start, t.end, e.start, e.end);
  }
  static IntervalsOverlapSS(t, e) {
    return O.IntervalsOverlapPPPP(t.Start, t.End, e.Start, e.End);
  }
  static IntervalsOverlapPPPP(t, e, i, s) {
    return O.IntervalsAreCollinear(t, e, i, s) && b.ComparePP(t, s) !== b.ComparePP(e, i);
  }
  static IntervalsAreCollinear(t, e, i, s) {
    const n = O.IsVerticalPP(t, e);
    return O.IsVerticalPP(i, s) === n ? n ? b.Equal(t.x, i.x) : b.Equal(t.y, i.y) : !1;
  }
  static IntervalsAreSame(t, e, i, s) {
    return b.EqualPP(t, i) && b.EqualPP(e, s);
  }
  static IntervalsIntersect(t, e, i, s) {
    const n = O.SegmentIntersectionPPP(t, e, i);
    return O.PointIsOnSegmentPPP(t, e, n) && O.PointIsOnSegmentPPP(i, s, n) ? n : void 0;
  }
  static SegmentIntersectionEP(t, e) {
    return O.SegmentIntersectionPPP(t.SourcePoint, t.TargetPoint, e);
  }
  static PointIsOnSegmentPPP(t, e, i) {
    return b.EqualPP(t, i) || b.EqualPP(e, i) || b.GetDirections(t, i) === b.GetDirections(i, e);
  }
  static PointIsOnSegmentSP(t, e) {
    return O.PointIsOnSegmentPPP(t.Start, t.End, e);
  }
  static IsVerticalD(t) {
    return (t & (S.North | S.South)) !== 0;
  }
  static IsVerticalE(t) {
    return O.IsVerticalD(b.GetDirections(t.SourcePoint, t.TargetPoint));
  }
  static IsVerticalPP(t, e) {
    return O.IsVerticalD(b.GetDirections(t, e));
  }
  static IsVertical(t) {
    return O.IsVerticalD(b.GetDirections(t.start, t.end));
  }
  static IsAscending(t) {
    return (t & (S.North | S.East)) !== 0;
  }
  static Slope(t, e, i) {
    const s = e.sub(t);
    return s.dot(i.PerpDirectionAsPoint) / s.dot(i.DirectionAsPoint);
  }
  static SortAscending(t, e) {
    const i = b.GetDirections(t, e);
    return S.None === i || O.IsAscending(i) ? [t, e] : [e, t];
  }
  static RectangleBorderIntersect(t, e, i) {
    switch (i) {
      case S.North:
      case S.South:
        return new u(e.x, O.GetRectangleBound(t, i));
      case S.East:
      case S.West:
        return new u(O.GetRectangleBound(t, i), e.y);
      default:
        throw new Error();
    }
  }
  static GetRectangleBound(t, e) {
    switch (e) {
      case S.North:
        return t.top;
      case S.South:
        return t.bottom;
      case S.East:
        return t.right;
      case S.West:
        return t.left;
      default:
        throw new Error();
    }
  }
  static RectangleInteriorsIntersect(t, e) {
    return b.Compare(t.bottom, e.top) < 0 && b.Compare(e.bottom, t.top) < 0 && b.Compare(t.left, e.right) < 0 && b.Compare(e.left, t.right) < 0;
  }
  static PointIsInRectangleInterior(t, e) {
    return b.Compare(t.y, e.top) < 0 && b.Compare(e.bottom, t.y) < 0 && b.Compare(t.x, e.right) < 0 && b.Compare(e.left, t.x) < 0;
  }
}
class Pt {
  get Dir() {
    return this.dir;
  }
  set Dir(t) {
    this.dir = t;
  }
  // Use the internal static xxxInstance properties to get an instance.
  constructor(t) {
    this.Dir = t, this.DirectionAsPoint = E.toPoint(this.Dir), this.PerpDirection = S.North === t ? S.East : S.North, this.PerpDirectionAsPoint = E.toPoint(this.PerpDirection), this.OppositeDirection = E.OppositeDir(t);
  }
  get IsHorizontal() {
    return S.East === this.Dir;
  }
  get IsVertical() {
    return S.North === this.Dir;
  }
  // Compare in perpendicular direction first, then parallel direction.
  Compare(t, e) {
    const i = this.ComparePerpCoord(t, e);
    return i !== 0 ? i : this.CompareScanCoord(t, e);
  }
  CompareScanCoord(t, e) {
    return b.Compare(t.sub(e).dot(this.DirectionAsPoint), 0);
  }
  ComparePerpCoord(t, e) {
    return b.Compare(t.sub(e).dot(this.PerpDirectionAsPoint), 0);
  }
  IsFlatS(t) {
    return this.IsFlatPP(t.Start, t.End);
  }
  IsFlatPP(t, e) {
    return b.Equal(e.sub(t).dot(this.PerpDirectionAsPoint), 0);
  }
  IsPerpendicularS(t) {
    return this.IsPerpendicularPP(t.Start, t.End);
  }
  IsPerpendicularPP(t, e) {
    return b.Equal(e.sub(t).dot(this.DirectionAsPoint), 0);
  }
  Coord(t) {
    return t.dot(this.DirectionAsPoint);
  }
  Min(t, e) {
    return this.Compare(t, e) <= 0 ? t : e;
  }
  Max(t, e) {
    return this.Compare(t, e) >= 0 ? t : e;
  }
  get PerpendicularInstance() {
    return this.IsHorizontal ? Pt.VerticalInstance : Pt.HorizontalInstance;
  }
  static GetInstance(t) {
    return O.IsVerticalD(t) ? Pt.VerticalInstance : Pt.HorizontalInstance;
  }
  ToString() {
    return this.Dir.toString();
  }
}
Pt.HorizontalInstance = new Pt(S.East);
Pt.VerticalInstance = new Pt(S.North);
class W extends ha {
  static mk(t, e) {
    return new W(
      t,
      e,
      W.NormalWeight,
      /* gbcList:*/
      null
    );
  }
  constructor(t, e, i, s) {
    super(), this.Update(t, e), this.Weight = i, this.GroupBoundaryPointAndCrossingsList = s;
  }
  get Start() {
    return this.startPoint;
  }
  get End() {
    return this.endPoint;
  }
  get IsVertical() {
    return W.IsVerticalSegment(this.Start, this.End);
  }
  get ScanDirection() {
    return this.IsVertical ? Pt.VerticalInstance : Pt.HorizontalInstance;
  }
  // For overlaps, we will need to create a VisibilityVertex at the junction of overlapped/nonoverlapped
  // segments, but we don't want to create this for non-overlapped situations.
  get IsOverlapped() {
    return W.OverlappedWeight === this.Weight;
  }
  get IsReflection() {
    return W.ReflectionWeight === this.Weight;
  }
  static IsVerticalSegment(t, e) {
    return t.x === e.x;
  }
  MergeGroupBoundaryCrossingList(t) {
    t != null && (this.GroupBoundaryPointAndCrossingsList == null && (this.GroupBoundaryPointAndCrossingsList = new Sn()), this.GroupBoundaryPointAndCrossingsList.MergeFrom(t));
  }
  TrimGroupBoundaryCrossingList() {
    this.GroupBoundaryPointAndCrossingsList != null && this.GroupBoundaryPointAndCrossingsList.Trim(this.Start, this.End);
  }
  // ctor
  Update(t, e) {
    this.startPoint = t, this.endPoint = e;
  }
  SetInitialVisibilityVertex(t) {
    this.LowestVisibilityVertex = t, this.HighestVisibilityVertex = t;
  }
  AppendVisibilityVertex(t, e) {
    if (this.HighestVisibilityVertex == null)
      this.AddGroupCrossingsBeforeHighestVisibilityVertex(t, e) || this.SetInitialVisibilityVertex(e);
    else {
      if (b.IsPureLower(e.point, this.HighestVisibilityVertex.point))
        return;
      this.AddGroupCrossingsBeforeHighestVisibilityVertex(t, e) || this.AppendHighestVisibilityVertex(e);
    }
  }
  AddVisibilityEdge(t, e) {
    const i = new ce(t, e, this.Weight);
    return wt.AddEdge(i), i;
  }
  AppendHighestVisibilityVertex(t) {
    b.EqualPP(this.HighestVisibilityVertex.point, t.point) || (this.AddVisibilityEdge(this.HighestVisibilityVertex, t), this.HighestVisibilityVertex = t);
  }
  LoadStartOverlapVertexIfNeeded(t) {
    if (this.NeedStartOverlapVertex) {
      const e = t.FindVertex(this.Start);
      this.AppendVisibilityVertex(t, e ?? t.AddVertexP(this.Start));
    }
  }
  LoadEndOverlapVertexIfNeeded(t) {
    if (this.NeedEndOverlapVertex) {
      const e = t.FindVertex(this.End);
      this.AppendVisibilityVertex(t, e ?? t.AddVertexP(this.End));
    }
  }
  OnSegmentIntersectorBegin(t) {
    this.AppendGroupCrossingsThroughPoint(t, this.Start) || this.LoadStartOverlapVertexIfNeeded(t);
  }
  OnSegmentIntersectorEnd(t) {
    this.AppendGroupCrossingsThroughPoint(t, this.End), this.GroupBoundaryPointAndCrossingsList = null, (this.HighestVisibilityVertex == null || b.IsPureLower(this.HighestVisibilityVertex.point, this.End)) && this.LoadEndOverlapVertexIfNeeded(t);
  }
  // If we have collinear segments, then we may be able to just update the previous one
  // instead of growing the ScanSegmentTree.
  // - For multiple collinear OpenVertexEvents, neighbors to the high side have not yet
  //   been seen, so a segment is created that spans the lowest and highest neighbors.
  //   A subsequent collinear OpenVertexEvent will be to the high side and will add a
  //   subsegment of that segment, so we subsume it into LastAddedSegment.
  // - For multiple collinear CloseVertexEvents, closing neighbors to the high side are
  //   still open, so a segment is created from the lowest neighbor to the next-highest
  //   collinear obstacle to be closed.  When that next-highest CloseVertexEvent is
  //   encountered, it will extend LastAddedSegment.
  // - For multiple collinear mixed Open and Close events, we'll do all Opens first,
  //   followed by all closes (per EventQueue opening), so we may add multiple discrete
  //   segments, which ScanSegmentTree will merge.
  static Subsume(t, e, i, s, n, r, o, l) {
    return l.extendStart = !0, l.extendEnd = !0, t.seg == null || !O.IntervalsOverlapPPPP(t.seg.Start, t.seg.End, e, i) ? !1 : t.seg.Weight !== s ? t.seg.Start === e && t.seg.End === i ? (t.seg.Weight = Math.min(t.seg.Weight, s), !0) : !1 : (l.extendStart = r.CompareScanCoord(e, t.seg.Start) === -1, l.extendEnd = r.CompareScanCoord(i, t.seg.End) === 1, (l.extendStart || l.extendEnd) && (o.Remove(t.seg), t.seg.startPoint = r.Min(t.seg.Start, e), t.seg.endPoint = r.Max(t.seg.End, i), t.seg = o.InsertUnique(t.seg).item, t.seg.MergeGroupBoundaryCrossingList(n)), !0);
  }
  IntersectsSegment(t) {
    return O.SegmentsIntersection(this, t) !== void 0;
  }
  toString() {
    return "[" + this.Start + " -> " + this.End + (this.IsOverlapped ? " olap" : " free") + "]";
  }
  ContainsPoint(t) {
    return b.EqualPP(this.Start, t) || b.EqualPP(this.End, t) || b.GetDirections(this.Start, t) === b.GetDirections(t, this.End);
  }
  get HasSparsePerpendicularCoords() {
    return this.sparsePerpendicularCoords == null ? !1 : this.sparsePerpendicularCoords.size > 0;
  }
  CreatePointFromPerpCoord(t) {
    return this.IsVertical ? new u(this.Start.x, t) : new u(t, this.Start.y);
  }
  AddSparseVertexCoord(t) {
    this.sparsePerpendicularCoords == null && (this.sparsePerpendicularCoords = /* @__PURE__ */ new Set()), this.sparsePerpendicularCoords.add(t);
  }
  AddSparseEndpoint(t) {
    return this.sparsePerpendicularCoords.has(t) ? !1 : (this.sparsePerpendicularCoords.add(t), !0);
  }
  CreateSparseVerticesAndEdges(t) {
    var e;
    if (this.sparsePerpendicularCoords != null) {
      this.AppendGroupCrossingsThroughPoint(t, this.Start);
      for (const i of Array.from(this.sparsePerpendicularCoords.values()).sort(yt)) {
        const s = this.CreatePointFromPerpCoord(i);
        this.AppendVisibilityVertex(t, (e = t.FindVertex(s)) !== null && e !== void 0 ? e : t.AddVertexP(s));
      }
      this.AppendGroupCrossingsThroughPoint(t, this.End), this.GroupBoundaryPointAndCrossingsList = null, this.sparsePerpendicularCoords.clear(), this.sparsePerpendicularCoords = null;
    }
  }
  HasVisibility() {
    return this.LowestVisibilityVertex != null;
  }
  AddGroupCrossingsBeforeHighestVisibilityVertex(t, e) {
    return this.AppendGroupCrossingsThroughPoint(t, e.point) ? (b.IsPureLower(this.HighestVisibilityVertex.point, e.point) && (this.AddVisibilityEdge(this.HighestVisibilityVertex, e), this.HighestVisibilityVertex = e), !0) : !1;
  }
  AppendGroupCrossingsThroughPoint(t, e) {
    var i;
    if (this.GroupBoundaryPointAndCrossingsList == null)
      return !1;
    let s = !1;
    for (; this.GroupBoundaryPointAndCrossingsList.CurrentIsBeforeOrAt(e); ) {
      const n = this.GroupBoundaryPointAndCrossingsList.Pop();
      let r = null, o = null;
      b.ComparePP(n.Location, this.Start) > 0 && (r = Sn.ToCrossingArray(n.Crossings, this.ScanDirection.OppositeDirection)), b.ComparePP(n.Location, this.End) < 0 && (o = Sn.ToCrossingArray(n.Crossings, this.ScanDirection.Dir)), s = !0;
      const l = (i = t.FindVertex(n.Location)) !== null && i !== void 0 ? i : t.AddVertexP(n.Location);
      t.AddVertexP(n.Location), r != null || o != null ? (this.AddLowCrossings(t, l, r), this.AddHighCrossings(t, l, o)) : this.LowestVisibilityVertex == null ? this.SetInitialVisibilityVertex(l) : this.AppendHighestVisibilityVertex(l);
    }
    return s;
  }
  static GetCrossingInteriorVertex(t, e, i) {
    var s;
    const n = i.GetInteriorVertexPoint(e.point);
    return (s = t.FindVertex(n)) !== null && s !== void 0 ? s : t.AddVertexP(n);
  }
  AddCrossingEdge(t, e, i, s) {
    let n = null;
    this.HighestVisibilityVertex != null && (b.EqualPP(this.HighestVisibilityVertex.point, i.point) ? n = t.FindEdgePP(e.point, i.point) : this.AppendHighestVisibilityVertex(e)), n == null && (n = this.AddVisibilityEdge(e, i));
    const r = s.map((l) => l.Group.InputShape), o = n.IsPassable;
    o == null ? n.IsPassable = () => {
      for (const l of r)
        if (l.IsTransparent)
          return !0;
      return !1;
    } : n.IsPassable = () => {
      for (const l of r)
        if (l.IsTransparent || o())
          return !0;
      return !1;
    }, this.LowestVisibilityVertex == null && this.SetInitialVisibilityVertex(e), this.HighestVisibilityVertex = i;
  }
  AddLowCrossings(t, e, i) {
    if (i != null) {
      const s = W.GetCrossingInteriorVertex(t, e, i[0]);
      this.AddCrossingEdge(t, s, e, i);
    }
  }
  AddHighCrossings(t, e, i) {
    if (i != null) {
      const s = W.GetCrossingInteriorVertex(t, e, i[0]);
      this.AddCrossingEdge(t, e, s, i);
    }
  }
}
W.NormalWeight = ce.DefaultWeight;
W.ReflectionWeight = 5;
W.OverlappedWeight = 500;
class hl {
  // A class that records an entry from a specific direction for a vertex.
  // Vertex that this VertexEntry enters
  // The previous VertexEntry along this path; null for a path source
  // Length of the path up to this vertex
  // Number of bends in the path up to this vertex
  // Cost of the path up to this vertex
  constructor(t, e, i, s, n) {
    this.IsClosed = !1, this.Vertex = t, this.Direction = e != null ? E.DirectionFromPointToPoint(e.Vertex.point, t.point) : S.None, this.ResetEntry(e, i, s, n);
  }
  ResetEntry(t, e, i, s) {
    this.PreviousEntry = t, this.Length = e, this.NumberOfBends = i, this.Cost = s;
  }
  // The vertex that this VertexEntry is entered from
  get PreviousVertex() {
    return this.PreviousEntry == null ? null : this.PreviousEntry.Vertex;
  }
  toString() {
    return this.Vertex.point + (" " + (this.Direction + (" " + (this.IsClosed + (" " + this.Cost)))));
  }
}
class So {
  constructor() {
    this.Clear();
  }
  Set(t, e) {
    this.Vertex = t, this.Weight = e;
  }
  Clear() {
    this.Vertex = null, this.Weight = Number.NaN;
  }
}
class K {
  // The cost of the path calculation
  CombinedCost(t, e) {
    return this.LengthImportance * t + this.BendsImportance * e;
  }
  TotalCostFromSourceToVertex(t, e) {
    return this.CombinedCost(t, e) + this.sourceCostAdjustment;
  }
  constructor() {
    this.nextNeighbors = [new So(), new So(), new So()], this.LengthImportance = 1, this.BendsImportance = 1;
  }
  InitPath(t, e, i) {
    if (e === i || !this.InitEntryDirectionsAtTarget(i))
      return !1;
    this.Target = i, this.Source = e;
    const s = this.TotalCostFromSourceToVertex(0, 0) + this.HeuristicDistanceFromVertexToTarget(e.point, S.None);
    return s >= this.upperBoundOnCost ? !1 : (this.queue = new is(yt), this.visitedVertices = [e], t == null ? this.EnqueueInitialVerticesFromSource(s) : this.EnqueueInitialVerticesFromSourceEntries(t), this.queue.count > 0);
  }
  InitEntryDirectionsAtTarget(t) {
    this.EntryDirectionsToTarget = S.None;
    for (const e of t.OutEdges)
      this.EntryDirectionsToTarget = this.EntryDirectionsToTarget | E.DirectionFromPointToPoint(e.TargetPoint, t.point);
    for (const e of t.InEdges)
      this.EntryDirectionsToTarget = this.EntryDirectionsToTarget | E.DirectionFromPointToPoint(e.SourcePoint, t.point);
    return this.EntryDirectionsToTarget !== S.None;
  }
  static IsInDirs(t, e) {
    return t === (t & e);
  }
  MultistageAdjustedCostBound(t) {
    return Number.isFinite(t) ? t + this.BendsImportance : t;
  }
  // estimation from below for the distance
  HeuristicDistanceFromVertexToTarget(t, e) {
    const i = this.Target.point.sub(t);
    if (D(i.x, 0) && D(i.y, 0))
      return this.targetCostAdjustment;
    const s = E.VectorDirection(i);
    let n;
    return e === S.None ? (e = S.East | (S.North | (S.West | S.South)), n = this.GetNumberOfBends(e, s)) : n = this.GetNumberOfBends(e, s), this.CombinedCost(K.ManhattanDistance(t, this.Target.point), n) + this.targetCostAdjustment;
  }
  GetNumberOfBends(t, e) {
    return E.IsPureDirection(e) ? this.GetNumberOfBendsForPureDirection(t, e) : K.GetBendsForNotPureDirection(e, t, this.EntryDirectionsToTarget);
  }
  GetNumberOfBendsForPureDirection(t, e) {
    return (e & t) === e ? K.IsInDirs(e, this.EntryDirectionsToTarget) ? 0 : K.IsInDirs(K.Left(e), this.EntryDirectionsToTarget) || K.IsInDirs(K.Right(e), this.EntryDirectionsToTarget) ? 2 : 4 : this.GetNumberOfBendsForPureDirection(K.AddOneTurn[t], e) + 1;
  }
  static GetBendsForNotPureDirection(t, e, i) {
    const s = t & e;
    if (s === S.None)
      return K.GetBendsForNotPureDirection(t, K.AddOneTurn[e], i) + 1;
    const n = t & i;
    return n === S.None ? K.GetBendsForNotPureDirection(t, e, K.AddOneTurn[i]) + 1 : (s | n) === t ? 1 : 2;
  }
  static Left(t) {
    switch (t) {
      case S.None:
        return S.None;
      case S.North:
        return S.West;
      case S.East:
        return S.North;
      case S.South:
        return S.East;
      case S.West:
        return S.South;
      default:
        throw new Error("direction");
    }
  }
  static Right(t) {
    switch (t) {
      case S.None:
        return S.None;
      case S.North:
        return S.East;
      case S.East:
        return S.South;
      case S.South:
        return S.West;
      case S.West:
        return S.North;
      default:
        throw new Error("direction");
    }
  }
  static RestorePathV(t) {
    return K.RestorePath(t, null);
  }
  static RestorePath(t, e) {
    if (t.entry == null)
      return [];
    const i = new Array();
    let s = !1, n = S.None;
    for (; ; ) {
      n === t.entry.Direction ? s = !0 : (s = !1, i.push(t.entry.Vertex.point), n = t.entry.Direction);
      const r = t.entry.PreviousEntry;
      if (r == null || t.entry.Vertex === e)
        break;
      t.entry = r;
    }
    return s && i.push(t.entry.Vertex.point), i.reverse(), i;
  }
  QueueReversedEntryToNeighborVertexIfNeeded(t, e, i) {
    const s = { numberOfBends: 0, length: 0 }, n = e.PreviousVertex, r = K.GetLengthAndNumberOfBendsToNeighborVertex(t, n, i, s);
    if (this.CombinedCost(s.length, s.numberOfBends) < this.CombinedCost(e.Length, e.NumberOfBends) || t.Vertex.Degree === 1) {
      const o = this.TotalCostFromSourceToVertex(s.length, s.numberOfBends) + this.HeuristicDistanceFromVertexToTarget(n.point, r);
      this.EnqueueEntry(t, n, s.length, s.numberOfBends, o);
    }
  }
  UpdateEntryToNeighborVertexIfNeeded(t, e, i) {
    const s = {
      numberOfBends: 0,
      length: 0
    }, n = K.GetLengthAndNumberOfBendsToNeighborVertex(t, e.Vertex, i, s);
    if (this.CombinedCost(s.length, s.numberOfBends) < this.CombinedCost(e.Length, e.NumberOfBends)) {
      const r = this.TotalCostFromSourceToVertex(s.length, s.numberOfBends) + this.HeuristicDistanceFromVertexToTarget(e.Vertex.point, n);
      e.ResetEntry(t, s.length, s.numberOfBends, r), this.queue.DecreasePriority(e, r);
    }
  }
  CreateAndEnqueueEntryToNeighborVertex(t, e, i) {
    const s = { numberOfBends: 0, length: 0 }, n = K.GetLengthAndNumberOfBendsToNeighborVertex(t, e, i, s), r = this.TotalCostFromSourceToVertex(s.length, s.numberOfBends) + this.HeuristicDistanceFromVertexToTarget(e.point, n);
    r < this.upperBoundOnCost && (e.VertexEntries == null && this.visitedVertices.push(e), this.EnqueueEntry(t, e, s.length, s.numberOfBends, r));
  }
  EnqueueEntry(t, e, i, s, n) {
    const r = new hl(e, t, i, s, n);
    e.SetVertexEntry(r), this.queue.Enqueue(r, r.Cost);
  }
  static GetLengthAndNumberOfBendsToNeighborVertex(t, e, i, s) {
    s.length = t.Length + K.ManhattanDistance(t.Vertex.point, e.point) * i;
    const n = E.DirectionFromPointToPoint(t.Vertex.point, e.point);
    return s.numberOfBends = t.NumberOfBends, t.Direction !== S.None && n !== t.Direction && s.numberOfBends++, n;
  }
  static ManhattanDistance(t, e) {
    return Math.abs(e.x - t.x) + Math.abs(e.y - t.y);
  }
  GetPathWithCost(t, e, i, s, n, r, o) {
    if (this.upperBoundOnCost = o, this.sourceCostAdjustment = i, this.targetCostAdjustment = r, !this.InitPath(t, e, n))
      return null;
    for (; this.queue.count > 0; ) {
      const l = this.queue.Dequeue(), h = l.Vertex;
      if (h === this.Target) {
        if (s == null)
          return this.Cleanup(), l;
        if (l.Direction, this.EntryDirectionsToTarget === S.None) {
          let d = 0;
          for (const f of this.Target.VertexEntries)
            s[d++] = f;
          return this.Cleanup(), null;
        }
        this.upperBoundOnCost = Math.min(this.MultistageAdjustedCostBound(l.Cost), this.upperBoundOnCost);
        continue;
      }
      l.IsClosed = !0;
      for (const d of this.nextNeighbors)
        d.Clear();
      const c = K.Right(l.Direction);
      this.ExtendPathAlongInEdges(l, h.InEdges, c), this.ExtendPathAlongOutEdges(l, h.OutEdges, c);
      for (const d of this.nextNeighbors)
        d.Vertex != null && this.ExtendPathToNeighborVertex(l, d.Vertex, d.Weight);
    }
    if (s != null && this.Target.VertexEntries != null)
      for (let l = 0; l < this.Target.VertexEntries.length; l++)
        s[l] = this.Target.VertexEntries[l];
    return this.Cleanup(), null;
  }
  ExtendPathAlongInEdges(t, e, i) {
    for (const s of e)
      this.ExtendPathAlongEdge(t, s, !0, i);
  }
  ExtendPathAlongOutEdges(t, e, i) {
    let s = e.isEmpty() ? null : e.treeMinimum();
    for (; s != null; s = e.next(s))
      this.ExtendPathAlongEdge(t, s.item, !1, i);
  }
  ExtendPathAlongEdge(t, e, i, s) {
    if (!K.IsPassable(e))
      return;
    const n = i ? e.Source : e.Target;
    if (n === t.PreviousVertex) {
      if (t.Vertex.Degree > 1 || t.Vertex !== this.Source)
        return;
      this.ExtendPathToNeighborVertex(t, n, e.Weight);
      return;
    }
    const r = E.DirectionFromPointToPoint(t.Vertex.point, n.point);
    let o = this.nextNeighbors[2];
    r !== t.Direction && (o = this.nextNeighbors[r === s ? 1 : 0]), o.Set(n, e.Weight);
  }
  EnqueueInitialVerticesFromSource(t) {
    const e = new hl(this.Source, null, 0, 0, t);
    e.IsClosed = !0;
    for (const i of this.Source.OutEdges)
      K.IsPassable(i) && this.ExtendPathToNeighborVertex(e, i.Target, i.Weight);
    for (const i of this.Source.InEdges)
      K.IsPassable(i) && this.ExtendPathToNeighborVertex(e, i.Source, i.Weight);
  }
  EnqueueInitialVerticesFromSourceEntries(t) {
    for (const e of t)
      e != null && this.queue.Enqueue(e, e.Cost);
  }
  ExtendPathToNeighborVertex(t, e, i) {
    const s = E.DirectionFromPointToPoint(t.Vertex.point, e.point), n = e.VertexEntries != null ? e.VertexEntries[E.ToIndex(s)] : null;
    n == null ? this.CreateAndEnqueueReversedEntryToNeighborVertex(t, e, i) || this.CreateAndEnqueueEntryToNeighborVertex(t, e, i) : n.IsClosed || this.UpdateEntryToNeighborVertexIfNeeded(t, n, i);
  }
  CreateAndEnqueueReversedEntryToNeighborVertex(t, e, i) {
    if (t.Vertex.VertexEntries != null) {
      const s = E.DirectionFromPointToPoint(e.point, t.Vertex.point), n = t.Vertex.VertexEntries[E.ToIndex(s)];
      if (n != null)
        return this.QueueReversedEntryToNeighborVertexIfNeeded(t, n, i), !0;
    }
    return !1;
  }
  static IsPassable(t) {
    return t.IsPassable == null || t.IsPassable();
  }
  Cleanup() {
    for (const t of this.visitedVertices)
      t.RemoveVertexEntries();
    this.visitedVertices = [], this.queue = null;
  }
}
K.DefaultBendPenaltyAsAPercentageOfDistance = 4;
K.AddOneTurn = [
  S.None,
  S.North | S.East | S.West,
  S.North | S.East | S.South,
  15,
  S.East | S.South | S.West,
  15,
  15,
  15,
  13,
  15,
  15,
  15,
  15,
  15,
  15,
  15
  //15
];
class yn {
  constructor(t) {
    this.bendPenaltyAsAPercentageOfDistance = K.DefaultBendPenaltyAsAPercentageOfDistance, this.currentPassTargetEntries = new Array(4), this.bendPenaltyAsAPercentageOfDistance = t;
  }
  // Get the lowest-cost path from one of one or more sources to one of one or more targets, without waypoints.
  // One or more source vertices
  // One or more target vertices
  // <returns>A single enumeration of path points.</returns>
  GetPath(t, e) {
    const i = { entry: this.GetPathStage(null, t, null, e) };
    return K.RestorePathV(i);
  }
  // Route a single stage of a possibly multi-stage (due to waypoints) path.
  // The VertexEntry array that was in the source vertex if it was the target of a prior stage.
  // The enumeration of source vertices; must be only one if sourceVertexEntries is non-null.
  // The enumeration of target vertex entries; must be only one if targetVertexEntries is non-null.
  // The VertexEntry array that is in the target at the end of the stage.
  GetPathStage(t, e, i, s) {
    const n = new K(), r = {
      bestEntry: null,
      // This contains the best (lowest) path cost after normalizing origins to the center of the sources
      // and targets.  This is used to avoid selecting a vertex pair whose path has more bends than another pair of
      // vertices, but the bend penalty didn't total enough to offset the additional length between the "better" pair.
      // This also plays the role of an upper bound on the path length; if a path cost is greater than adjustedMinCost
      // then we stop exploring it, which saves considerable time after low-cost paths have been found.
      bestCost: Number.MAX_VALUE / W.OverlappedWeight
    };
    let o = Number.POSITIVE_INFINITY;
    const l = yn.Barycenter(e), h = yn.Barycenter(s), c = K.ManhattanDistance(l, h);
    n.BendsImportance = Math.max(1e-3, c * (this.bendPenaltyAsAPercentageOfDistance * 0.01));
    const d = n.LengthImportance, f = i != null ? this.currentPassTargetEntries : null, p = [];
    for (const C of e)
      for (const w of s)
        p.push([C, w]);
    p.sort(([C, w], [N, I]) => P(C, w) - P(N, I));
    for (const [C, w] of p) {
      if (u.closeDistEps(C.point, w.point))
        continue;
      const N = y(C, l) * d, I = y(w, h) * d;
      let x = r.bestCost;
      if (i != null) {
        for (let X = 0; X < f.length; X++)
          f[X] = null;
        x = n.MultistageAdjustedCostBound(r.bestCost);
      }
      const V = n.GetPathWithCost(t, C, N, f, w, I, x);
      if (f != null) {
        yn.UpdateTargetEntriesForEachDirection(i, f, r);
        continue;
      }
      if (V == null)
        continue;
      const M = V.Cost / P(C, w);
      (V.Cost < r.bestCost || D(V.Cost, r.bestCost) && M < o) && (r.bestCost = V.Cost, r.bestEntry = V, o = V.Cost / P(C, w));
    }
    return r.bestEntry;
    function P(C, w) {
      return K.ManhattanDistance(C.point, w.point);
    }
    function y(C, w) {
      return K.ManhattanDistance(C.point, w);
    }
  }
  static UpdateTargetEntriesForEachDirection(t, e, i) {
    for (let s = 0; s < e.length; s++) {
      const n = e[s];
      n != null && (t[s] == null || n.Cost < t[s].Cost) && (t[s] = n, n.Cost < i.bestCost && (i.bestCost = n.Cost, i.bestEntry = n));
    }
  }
  static Barycenter(t) {
    let e = new u(0, 0);
    for (const i of t)
      e = e.add(i.point);
    return e.div(t.length);
  }
}
class pf {
  get PathPoints() {
    return this._pathPoints;
  }
  set PathPoints(t) {
    this._pathPoints = t;
  }
  get Width() {
    return this.GeomEdge.lineWidth;
  }
  // constructor
  constructor(t) {
    this.GeomEdge = t;
  }
  get End() {
    return this.LastEdge.Target;
  }
  get Start() {
    return this.FirstEdge.Source;
  }
  ArrayOfPathPoints() {
    return this._pathPoints instanceof Ni ? Array.from(cl(this._pathPoints)) : this._pathPoints;
  }
  *PathEdges() {
    for (let t = this.FirstEdge; t != null; t = t.Next)
      yield t;
  }
  AddEdge(t) {
    t.Path = this, this.LastEdge.Next = t, t.Prev = this.LastEdge, this.LastEdge = t;
  }
  SetFirstEdge(t) {
    this.FirstEdge = t, this.LastEdge = t, t.Path = this;
  }
  //
  toString() {
    const t = new Gt.StringBuilder();
    this.PathPoints instanceof Ni && t.Append("L");
    for (const e of cl(this.PathPoints))
      t.Append(e.toString());
    return t.ToString();
  }
}
function* cl(a) {
  if (a instanceof Ni)
    for (let t = a; t != null; t = t.Next)
      yield t.Point;
  else
    for (const t of a)
      yield t;
}
class Wh extends ca {
  get Obstacle() {
    return this.obstacle;
  }
  set Obstacle(t) {
    this.obstacle = t;
  }
  constructor(t, e, i, s) {
    super(e), this.Slope = 0, this.SlopeInverse = 0, this.Obstacle = t, this.endVertex = s ? e.nextOnPolyline : e.prevOnPolyline, i.IsPerpendicularPP(e.point, this.endVertex.point) || (this.Slope = O.Slope(e.point, this.endVertex.point, i), this.SlopeInverse = 1 / this.Slope);
  }
  get EndVertex() {
    return this.endVertex;
  }
}
class Qe extends Wh {
  constructor(t, e, i) {
    super(t, e, i, i.IsHorizontal);
  }
}
class bn extends Wh {
  constructor(t, e, i) {
    super(t, e, i, i.IsVertical);
  }
}
class Ot {
  get PaddedPolyline() {
    return this._PaddedPolyline;
  }
  set PaddedPolyline(t) {
    this._PaddedPolyline = t;
  }
  get looseVisibilityPolyline() {
    return this._looseVisibilityPolyline == null && (this._looseVisibilityPolyline = Ot.CreateLoosePolyline(this.VisibilityPolyline)), this._looseVisibilityPolyline;
  }
  set looseVisibilityPolyline(t) {
    this._looseVisibilityPolyline = t;
  }
  GetPortChanges(t) {
    return t.addedPorts = zs(this.InputShape.Ports, this.Ports), t.removedPorts = zs(this.Ports, this.InputShape.Ports), t.addedPorts.size === 0 && t.removedPorts.size === 0 ? !1 : (this.Ports = new Set(this.InputShape.Ports), !0);
  }
  get IsInConvexHull() {
    return this.ConvexHull != null;
  }
  get IsGroup() {
    return this.InputShape != null && this.InputShape.IsGroup;
  }
  get VisibilityBoundingBox() {
    return this.VisibilityPolyline.boundingBox;
  }
  get VisibilityPolyline() {
    return this.ConvexHull != null ? this.ConvexHull.Polyline : this.PaddedPolyline;
  }
  static CreateSentinel(t, e, i, s) {
    const n = Ot.mk(t, e, s);
    return n.CreateInitialSides(n.PaddedPolyline.startPoint, i), n;
  }
  CreateInitialSides(t, e) {
    this.ActiveLowSide = new Qe(this, t, e), this.ActiveHighSide = new bn(this, t, e), e.IsFlatS(this.ActiveHighSide) && (this.ActiveHighSide = new bn(this, this.ActiveHighSide.EndVertex, e));
  }
  constructor(t, e) {
    t != null && (this.PaddedPolyline = G.PaddedPolylineBoundaryOfNode(t.BoundaryCurve, e), Ot.RoundVerticesAndSimplify(this.PaddedPolyline), this.IsRectangle = this.IsPolylineRectangle(), this.InputShape = t, this.Ports = new Set(this.InputShape.Ports));
  }
  static mk(t, e, i) {
    const s = new Ot(null, 0);
    return s.PaddedPolyline = B.mkClosedFromPoints([u.RoundPoint(t), u.RoundPoint(e)]), s.Ordinal = i, s;
  }
  IsPolylineRectangle() {
    if (this.PaddedPolyline.count !== 4)
      return !1;
    let t = this.PaddedPolyline.startPoint, e = t.nextOnPolyline, i = E.VectorDirectionPP(t.point, e.point);
    if (!E.IsPureDirection(i))
      return !1;
    do {
      t = e, e = t.nextOnPolyline;
      const s = E.DirectionFromPointToPoint(t.point, e.point);
      if (s !== E.RotateRight(i))
        return !1;
      i = s;
    } while (t !== this.PaddedPolyline.startPoint);
    return !0;
  }
  static RoundVerticesAndSimplify(t) {
    let e = t.startPoint;
    do
      e.point = u.RoundPoint(e.point), e = e.nextOnPolyline;
    while (e !== t.startPoint);
    Ot.RemoveCloseAndCollinearVerticesInPlace(t), t.setInitIsRequired();
  }
  // A single convex hull is shared by all obstacles contained by it and we only want one occurrence of that
  // convex hull's polyline in the visibility graph generation.
  get IsPrimaryObstacle() {
    return this.ConvexHull == null || this === this.ConvexHull.PrimaryObstacle;
  }
  static RemoveCloseAndCollinearVerticesInPlace(t) {
    const e = m.intersectionEpsilon * 10;
    for (let i = t.startPoint.next; i != null; i = i.next)
      u.close(i.prev.point, i.point, e) && (i.next == null ? t.RemoveEndPoint() : (i.prev.next = i.next, i.next.prev = i.prev));
    return u.close(t.start, t.end, e) && t.RemoveStartPoint(), t = t.RemoveCollinearVertices(), t.endPoint.prev != null && t.endPoint.prev !== t.startPoint && u.getTriangleOrientation(t.endPoint.prev.point, t.end, t.start) === L.Collinear && t.RemoveEndPoint(), t.startPoint.next != null && t.endPoint.prev !== t.startPoint && u.getTriangleOrientation(t.end, t.start, t.startPoint.next.point) === L.Collinear && t.RemoveStartPoint(), t.setInitIsRequired(), t;
  }
  get isOverlapped() {
    return this.clump !== void 0 && this.clump.length > 0;
  }
  get IsSentinel() {
    return this.InputShape == null;
  }
  IsInSameClump(t) {
    return this.isOverlapped && this.clump === t.clump;
  }
  Close() {
    this.ActiveLowSide = null, this.ActiveHighSide = null;
  }
  SetConvexHull(t) {
    this.clump = null, this.IsRectangle = !1, this.ConvexHull = t, this.looseVisibilityPolyline = null;
  }
  static CreateLoosePolyline(t) {
    const e = G.CreatePaddedPolyline(t, m.intersectionEpsilon * 10);
    return Ot.RoundVerticesAndSimplify(e), e;
  }
  get IsTransparentAncestor() {
    return this.InputShape == null ? !1 : this.InputShape.IsTransparent;
  }
  set IsTransparentAncestor(t) {
    this.InputShape.IsTransparent = t;
  }
}
Ot.FirstSentinelOrdinal = 1;
Ot.FirstNonSentinelOrdinal = 10;
class mf {
  get Obstacle() {
    return this.ObstaclePort.Obstacle;
  }
  get InitialWeight() {
    return this.IsOverlapped ? W.OverlappedWeight : W.NormalWeight;
  }
  get IsCollinearWithPort() {
    return E.IsPureDirection(b.GetDirections(this.VisibilityBorderIntersect, this.ObstaclePort.Location));
  }
  get IsVertical() {
    return O.IsVertical(this.MaxVisibilitySegment);
  }
  // If the port has entrances that are collinear, don't do the optimization for non-collinear ones.
  get WantVisibilityIntersection() {
    return !this.IsOverlapped && this.CanExtend && (!this.ObstaclePort.HasCollinearEntrances || this.IsCollinearWithPort);
  }
  get CanExtend() {
    return b.GetDirections(this.MaxVisibilitySegment.start, this.MaxVisibilitySegment.end) !== S.None;
  }
  constructor(t, e, i, s) {
    this.IsOverlapped = !1, this.unpaddedToPaddedBorderWeight = W.NormalWeight, this.ObstaclePort = t, this.UnpaddedBorderIntersect = e, this.OutwardDirection = i;
    const n = v.mkPP(this.UnpaddedBorderIntersect, O.RectangleBorderIntersect(t.Obstacle.VisibilityBoundingBox, this.UnpaddedBorderIntersect, i)), r = g.getAllIntersections(n, t.Obstacle.VisibilityPolyline, !0);
    this.VisibilityBorderIntersect = u.RoundPoint(r[0].x);
    const o = { pacList: null };
    this.MaxVisibilitySegment = s.CreateMaxVisibilitySegment(this.VisibilityBorderIntersect, this.OutwardDirection, o), this.pointAndCrossingsList = o.pacList, (this.Obstacle.isOverlapped || this.Obstacle.IsGroup && !this.Obstacle.IsInConvexHull) && (this.IsOverlapped = s.IntersectionIsInsideAnotherObstacle(null, this.Obstacle, this.VisibilityBorderIntersect, Pt.GetInstance(this.OutwardDirection)), (!this.Obstacle.IsGroup || this.IsOverlapped || this.InteriorEdgeCrossesObstacle(s)) && (this.unpaddedToPaddedBorderWeight = W.OverlappedWeight)), this.Obstacle.IsInConvexHull && this.unpaddedToPaddedBorderWeight === W.NormalWeight && this.SetUnpaddedToPaddedBorderWeightFromHullSiblingOverlaps(s);
  }
  SetUnpaddedToPaddedBorderWeightFromHullSiblingOverlaps(t) {
    (this.Obstacle.IsGroup ? this.InteriorEdgeCrossesObstacle(t) : this.InteriorEdgeCrossesConvexHullSiblings()) && (this.unpaddedToPaddedBorderWeight = W.OverlappedWeight);
  }
  InteriorEdgeCrossesObstacle(t) {
    const e = T.mkPP(this.UnpaddedBorderIntersect, this.VisibilityBorderIntersect);
    return this.InteriorEdgeCrossesObstacleRFI(e, (i) => i.VisibilityPolyline, Array.from(t.Root.GetLeafRectangleNodesIntersectingRectangle(e)).filter((i) => !i.UserData.IsGroup && i.UserData !== this.Obstacle).map((i) => i.UserData));
  }
  InteriorEdgeCrossesConvexHullSiblings() {
    const t = T.mkPP(this.UnpaddedBorderIntersect, this.VisibilityBorderIntersect);
    return this.InteriorEdgeCrossesObstacleRFI(t, (e) => e.PaddedPolyline, this.Obstacle.ConvexHull.Obstacles.filter((e) => e !== this.Obstacle));
  }
  InteriorEdgeCrossesObstacleRFI(t, e, i) {
    let s = null;
    for (const n of i) {
      const r = e(n);
      if (!O.RectangleInteriorsIntersect(t, r.boundingBox))
        continue;
      if (s = s ?? v.mkPP(this.UnpaddedBorderIntersect, this.VisibilityBorderIntersect), g.intersectionOne(
        s,
        r,
        /* liftIntersection:*/
        !1
      ) != null || F.Outside !== g.PointRelativeToCurveLocation(this.UnpaddedBorderIntersect, r))
        return !0;
    }
    return !1;
  }
  get HasGroupCrossings() {
    return this.pointAndCrossingsList != null && this.pointAndCrossingsList.Count() > 0;
  }
  HasGroupCrossingBeforePoint(t) {
    if (!this.HasGroupCrossings)
      return !1;
    const e = O.IsAscending(this.OutwardDirection) ? this.pointAndCrossingsList.First : this.pointAndCrossingsList.Last;
    return b.GetDirections(this.MaxVisibilitySegment.start, e.Location) === b.GetDirections(e.Location, t);
  }
  AddToAdjacentVertex(t, e, i, s) {
    let n = t.VisGraph.FindVertex(this.VisibilityBorderIntersect);
    if (n != null) {
      this.ExtendEdgeChain(t, n, n, i, s);
      return;
    }
    this.OutwardDirection === b.GetDirections(e.point, this.VisibilityBorderIntersect) ? (this.VisibilityBorderIntersect = e.point, n = e) : (n = t.FindOrAddVertex(this.VisibilityBorderIntersect), t.FindOrAddEdge(n, e, this.InitialWeight)), this.ExtendEdgeChain(t, n, e, i, s);
  }
  ExtendEdgeChain(t, e, i, s, n) {
    t.ExtendEdgeChainVRLPB(i, s, this.MaxVisibilitySegment, this.pointAndCrossingsList, this.IsOverlapped);
    const r = t.FindOrAddVertex(this.UnpaddedBorderIntersect);
    t.FindOrAddEdge(r, e, this.unpaddedToPaddedBorderWeight), n && t.ConnectVertexToTargetVertex(this.ObstaclePort.CenterVertex, r, this.OutwardDirection, this.InitialWeight);
  }
  toString() {
    return Gt.String.format("{0} {1}~{2} {3}", this.ObstaclePort.Location, this.UnpaddedBorderIntersect, this.VisibilityBorderIntersect, this.OutwardDirection);
  }
}
class Pf {
  constructor(t, e) {
    this.HasCollinearEntrances = !1, this.VisibilityRectangle = T.mkEmpty(), this.Port = t, this.Obstacle = e, this.PortEntrances = new Array(), this.Location = u.RoundPoint(this.Port.Location);
  }
  CreatePortEntrance(t, e, i) {
    const s = new mf(this, t, e, i);
    this.PortEntrances.push(s), this.VisibilityRectangle.add(s.MaxVisibilitySegment.end), this.HasCollinearEntrances = this.HasCollinearEntrances || s.IsCollinearWithPort;
  }
  ClearVisibility() {
    this.PortEntrances = [];
  }
  AddToGraph(t, e) {
    e && (this.CenterVertex = t.FindOrAddVertex(this.Location));
  }
  RemoveFromGraph() {
    this.CenterVertex = null;
  }
  // PortManager will recreate the Port if it detects this (this.Location has already been rounded).
  get LocationHasChanged() {
    return !u.closeDistEps(this.Location, u.RoundPoint(this.Port.Location));
  }
  // The curve associated with the port.
  get PortCurve() {
    return this.Port.Curve;
  }
  // The (unrounded) location of the port.
  get PortLocation() {
    return this.Port.Location;
  }
  toString() {
    return this.Port + this.Obstacle.toString();
  }
}
class Sf {
  get Point() {
    return this.Vertex.point;
  }
  get InitialWeight() {
    return this.IsOverlapped ? W.OverlappedWeight : W.NormalWeight;
  }
  get IsOutOfBounds() {
    return S.None !== this.OutOfBoundsDirectionFromGraph;
  }
  // Called if we must create the vertex.
  constructor(t, e) {
    this.maxVisibilitySegmentsAndCrossings = new Array(4), this.OutOfBoundsDirectionFromGraph = S.None, this.GetVertex(t, e);
  }
  GetVertex(t, e) {
    this.Vertex = t.FindOrAddVertex(e);
  }
  // Adds an edge from this.Vertex to a (possibly new) vertex at an intersection with an
  // existing Edge that adjoins the point.  We take 'dir' as an input parameter for edge
  // extension because we may be on the edge so can't calculate the direction.
  AddEdgeToAdjacentEdge(t, e, i, s) {
    const n = O.SegmentIntersectionEP(e, this.Point);
    let r = t.VisGraph.FindVertex(n);
    return r != null ? this.AddToAdjacentVertex(t, r, i, s) : r = t.AddEdgeToTargetEdge(this.Vertex, e, n), this.ExtendEdgeChain(t, r, i, s), r;
  }
  AddToAdjacentVertex(t, e, i, s) {
    b.EqualPP(this.Point, e.point) || t.FindOrAddEdge(this.Vertex, e, this.InitialWeight), this.ExtendEdgeChain(t, e, i, s);
  }
  ExtendEdgeChain(t, e, i, s) {
    let n = this.IsOverlapped;
    n && (n = t.ObstacleTree.PointIsInsideAnObstaclePD(e.point, i));
    const r = this.GetSegmentAndCrossings(this.IsOverlapped ? e : this.Vertex, i, t);
    t.ExtendEdgeChainVRLPB(e, s, r[0], r[1], n);
  }
  GetSegmentAndCrossings(t, e, i) {
    const s = E.ToIndex(e);
    let n = this.maxVisibilitySegmentsAndCrossings[s];
    if (n == null) {
      const r = { pacList: null };
      n = [i.ObstacleTree.CreateMaxVisibilitySegment(t.point, e, r), r.pacList], this.maxVisibilitySegmentsAndCrossings[s] = n;
    } else
      b.GetDirections(t.point, n[0].start) === e && (n[0].start = t.point);
    return n;
  }
  MaxVisibilityInDirectionForNonOverlappedFreePoint(t, e) {
    return this.GetSegmentAndCrossings(this.Vertex, t, e)[0].end;
  }
  AddOobEdgesFromGraphCorner(t, e) {
    const i = b.GetDirections(e, this.Vertex.point), s = t.VisGraph.FindVertex(e);
    t.ConnectVertexToTargetVertex(s, this.Vertex, i & (S.North | S.South), W.NormalWeight), t.ConnectVertexToTargetVertex(s, this.Vertex, i & (S.East | S.West), W.NormalWeight);
  }
  RemoveFromGraph() {
    this.Vertex = null;
  }
  toString() {
    return this.Vertex.toString();
  }
}
class ma {
  constructor(t, e) {
    this.BoundaryWidth = m.distanceEpsilon, this.Group = t, this.DirectionToInside = e;
  }
  GetInteriorVertexPoint(t) {
    return u.RoundPoint(t.add(E.toPoint(this.DirectionToInside).mul(this.BoundaryWidth)));
  }
  toString() {
    return Gt.String.format("{0} {1}", this.DirectionToInside, this.Group);
  }
}
ma.BoundaryWidth = m.distanceEpsilon;
class yo extends Gi {
  constructor(t) {
    super(), this.site = t;
  }
  get Site() {
    return this.site;
  }
}
class io extends en {
  constructor(t, e) {
    super(e), this.Obstacle = t;
  }
}
class cr extends io {
  constructor(t, e) {
    super(t, e);
  }
}
class yf {
  AddPendingPerpendicularCoord(t) {
    this.pendingPerpCoords == null && (this.pendingPerpCoords = new Array()), this.pendingPerpCoords.push(t);
  }
  // Restores state between intersection passes.
  ResetForIntersections() {
    this.CurrentSegment = this.FirstSegment;
  }
  // Indicates whether ScanSegments in this item are horizontally or vertically oriented.
  get IsHorizontal() {
    return !this.FirstSegment.IsVertical;
  }
  // Ctor, taking the parallel (constant) coordinate.
  // the parallel (constant) coordinate
  constructor(t) {
    this.Coord = t;
  }
  // Move along the linked list until we hit the ScanSegment that contains the point.
  TraverseToSegmentContainingPoint(t) {
    if (this.CurrentSegment.ContainsPoint(t))
      return !0;
    const e = this.IsHorizontal ? t.y : t.x;
    if (!b.Equal(this.Coord, e)) {
      for (; this.MoveNext(); )
        ;
      return !1;
    }
    for (; ; ) {
      if ((this.CurrentSegment.NextSegment == null || b.GetDirections(this.CurrentSegment.End, t) == b.GetDirections(t, this.CurrentSegment.NextSegment.Start)) && u.closeIntersections(this.CurrentSegment.End, t))
        return this.CurrentSegment.Update(this.CurrentSegment.Start, t), !0;
      if (!this.MoveNext())
        return !1;
      if (this.CurrentSegment.ContainsPoint(t))
        return !0;
      if (b.IsPureLower(t, this.CurrentSegment.Start))
        return this.CurrentSegment.Update(t, this.CurrentSegment.End), !0;
    }
  }
  MoveNext() {
    return this.CurrentSegment = this.CurrentSegment.NextSegment, this.HasCurrent;
  }
  get HasCurrent() {
    return this.CurrentSegment != null;
  }
  // Returns true if the point is the end of the current segment and there is an adjoining NextSegment.
  PointIsCurrentEndAndNextStart(t) {
    return t.equal(this.CurrentSegment.End) && this.CurrentSegment.NextSegment != null && t.equal(this.CurrentSegment.NextSegment.Start);
  }
  // Set Current to the ScanSegment containing the perpendicular coordinate, then add that coordinate to its
  // sparse-vector coordinate list.
  AddPerpendicularCoord(t) {
    const e = this.IsHorizontal ? new u(t, this.Coord) : new u(this.Coord, t);
    this.TraverseToSegmentContainingPoint(e), this.CurrentSegment.AddSparseVertexCoord(t);
  }
  toString() {
    return this.FirstSegment == null ? "-0- " + this.Coord : this.IsHorizontal ? "(H) Y === " + this.Coord : "(V) X === ";
  }
  AppendScanSegment(t) {
    this.FirstSegment == null ? this.FirstSegment = t : this.CurrentSegment.NextSegment = t, this.CurrentSegment = t;
  }
  AddPendingPerpendicularCoordsToScanSegments() {
    if (this.pendingPerpCoords != null) {
      this.ResetForIntersections();
      for (const t of this.pendingPerpCoords)
        this.AddPerpendicularCoord(t);
    }
  }
}
class ul {
  constructor(t, e) {
    this.CurrentSlotIndex = 0, this.vector = [], this.IsHorizontal = e;
    const i = Array.from(t).sort((s, n) => s > n ? 1 : s < n ? -1 : 0);
    for (const s of i)
      this.vector.push(new yf(s));
  }
  get Length() {
    return this.vector.length;
  }
  // The item at the index of the scan segment vector we're appending to on the ScanSegment-generation sweep.
  get CurrentSlot() {
    return this.vector[this.CurrentSlotIndex];
  }
  // The indexed item in the vector.
  Item(t) {
    return this.vector[t];
  }
  // Appends a ScanSegment to the linked list in the "Current" slot.
  CreateScanSegment(t, e, i, s) {
    this.CurrentSlot.AppendScanSegment(new W(t, e, i, s));
  }
  ScanSegmentsCompleteForCurrentSlot() {
    this.CurrentSlotIndex++;
  }
  ScanSegmentsComplete() {
    for (const t of this.vector)
      t.AddPendingPerpendicularCoordsToScanSegments();
  }
  // Returns an enumeration of the vector of ScanSegmentVectorItems.
  Items() {
    return this.vector;
  }
  // Reset vector state between passes.
  ResetForIntersections() {
    for (const t of this.vector)
      t.ResetForIntersections();
  }
  // Search the vector for the nearest slot in the specified direction.
  FindNearest(t, e) {
    let i = 0, s = this.vector.length - 1;
    if (t <= this.vector[i].Coord)
      return i;
    if (t >= this.vector[s].Coord)
      return s;
    for (; s - i > 2; ) {
      const n = i + (s - i >> 1), r = this.vector[n];
      if (t < r.Coord) {
        s = n;
        continue;
      }
      if (t > r.Coord) {
        i = n;
        continue;
      }
      return n;
    }
    for (i++; i <= s; i++) {
      const n = this.vector[i];
      if (t < n.Coord)
        return e > 0 ? i : i - 1;
      if (t === n.Coord)
        break;
    }
    return i;
  }
  CreateSparseVerticesAndEdges(t) {
    for (const e of this.vector) {
      e.ResetForIntersections();
      for (let i = e.FirstSegment; i != null; i = i.NextSegment)
        i.CreateSparseVerticesAndEdges(t);
    }
  }
  // Get the coordinate that remains constant along a segment in this vector.
  GetParallelCoord(t) {
    return this.IsHorizontal ? t.y : t.x;
  }
  // Get the coordinate that changes along a segment in this vector (and is thus the parallel
  // coord of an intersecting segment).
  GetPerpendicularCoord(t) {
    return this.IsHorizontal ? t.x : t.y;
  }
  ConnectAdjoiningSegmentEndpoints() {
    for (const t of this.vector) {
      t.ResetForIntersections();
      let e = t.FirstSegment;
      for (let i = e.NextSegment; i != null; i = i.NextSegment) {
        if (i.HasSparsePerpendicularCoords && e.HasSparsePerpendicularCoords && i.Start === e.End) {
          const s = this.GetPerpendicularCoord(i.Start);
          e.AddSparseEndpoint(s), i.AddSparseEndpoint(s);
        }
        e = i;
      }
    }
  }
  toString() {
    return (this.IsHorizontal ? "(H) count" : "(V) count === ") + this.vector.length;
  }
}
class Is extends Gi {
  // Called by StoreLookaheadSite only.
  constructor(t, e, i) {
    super(), this.InitialObstacle = t, this.ReflectingObstacle = e, this.site = i;
  }
  // Called by LowReflectionEvent or HighReflectionEvent ctors, which are called out of
  // AddReflectionEvent, which in turn is called by LoadLookaheadIntersections.
  // In this case we know the eventObstacle and initialObstacle are the same obstacle (the
  // one that the reflected ray bounced off of, to generate the Left/HighReflectionEvent).
  static mk(t, e, i) {
    const s = new Is(t.ReflectingObstacle, e, i);
    return s.PreviousSite = t, s;
  }
  // If true, we have a staircase situation.
  IsStaircaseStep(t) {
    return this.InitialObstacle === t;
  }
  get Site() {
    return this.site;
  }
}
class dl {
  constructor() {
    this.eventTree = new aa((t, e) => this.Compare(t, e));
  }
  Reset(t) {
    this.scanDirection = t;
  }
  Enqueue(t) {
    this.eventTree.Enqueue(t);
  }
  Dequeue() {
    return this.eventTree.Dequeue();
  }
  get Count() {
    return this.eventTree.Count;
  }
  Compare(t, e) {
    if (t === e)
      return 0;
    if (t == null)
      return -1;
    if (e == null)
      return 1;
    let i = this.scanDirection.ComparePerpCoord(t.Site, e.Site);
    if (i)
      return i;
    const s = t instanceof Is ? 0 : 1, n = e instanceof Is ? 0 : 1;
    return i = s - n, i || this.scanDirection.CompareScanCoord(t.Site, e.Site);
  }
}
class Hh {
  constructor() {
    this.pointCrossingMap = new ii(), this.pointList = new Array();
  }
  AddIntersection(t, e, i) {
    let s = this.pointCrossingMap.get(t);
    s || (s = new Array(), this.pointCrossingMap.set(t, s));
    const n = s.length;
    for (let o = 0; o < n; o++) {
      const l = s[o];
      if (l.Group === e)
        return l;
    }
    const r = new ma(e, i);
    return s.push(r), r;
  }
  Clear() {
    this.pointCrossingMap.clear();
  }
  GetOrderedListBetween(t, e) {
    if (this.pointCrossingMap.size === 0)
      return null;
    if (b.ComparePP(t, e) > 0) {
      const n = t;
      t = e, e = n;
    }
    this.pointList = [];
    for (const n of this.pointCrossingMap.keys())
      b.ComparePP(n, t) >= 0 && b.ComparePP(n, e) <= 0 && this.pointList.push(n);
    this.pointList.sort((n, r) => n.compareTo(r));
    const i = new Sn(), s = this.pointList.length;
    for (let n = 0; n < s; n++) {
      const r = this.pointList[n];
      i.Add(r, this.pointCrossingMap.get(r));
    }
    return i;
  }
  toString() {
    return Gt.String.format("{0}", this.pointCrossingMap.size);
  }
}
class fl extends Is {
  constructor(t, e, i) {
    super(t.ReflectingObstacle, e.Obstacle, i), this.Side = e;
  }
}
class bf {
  constructor(t) {
    this.staleSites = new Array(), this.scanDirection = t, this.eventTree = new we((e, i) => this.CompareBB(e, i)), this.findFirstPred = (e) => this.CompareToFindFirstPoint(e.Site) >= 0;
  }
  Add(t) {
    this.eventTree.insert(t);
  }
  // Buffer up the events that are known to be stale - that is, will never queued as events because the
  // event-load intersection is the same as the site.
  MarkStaleSite(t) {
    this.staleSites.push(t);
  }
  RemoveStaleSites() {
    const t = this.staleSites.length;
    if (t > 0) {
      for (let e = 0; e < t; e++)
        this.RemoveExact(this.staleSites[e]);
      this.staleSites = [];
    }
  }
  RemoveSitesForFlatBottom(t, e) {
    for (let i = this.FindFirstInRange(t, e); i != null; i = this.FindNextInRange(i, e))
      this.MarkStaleSite(i.item);
    this.RemoveStaleSites();
  }
  Find(t) {
    return this.FindFirstInRange(t, t);
  }
  RemoveExact(t) {
    const e = this.eventTree.find(t);
    return e != null && e.item.Site === t.Site ? (this.eventTree.deleteNodeInternal(e), !0) : !1;
  }
  FindFirstInRange(t, e) {
    this.findFirstPoint = t;
    const i = this.eventTree.findFirst(this.findFirstPred);
    return i != null && this.Compare(i.item.Site, e) <= 0 ? i : null;
  }
  CompareToFindFirstPoint(t) {
    return this.Compare(t, this.findFirstPoint);
  }
  FindNextInRange(t, e) {
    const i = this.eventTree.next(t);
    return i != null && this.Compare(i.item.Site, e) <= 0 ? i : null;
  }
  // For ordering Points in the lookahead list.  We just care about the coordinate that changes
  // parallel to the scanline, so for vertical sweep (sweeping up from bottom, scanning
  // horizontally) then order points by X only, else by Y only.
  CompareBB(t, e) {
    return this.scanDirection.CompareScanCoord(t.Site, e.Site);
  }
  Compare(t, e) {
    return this.scanDirection.CompareScanCoord(t, e);
  }
}
class gl extends io {
  constructor(t, e) {
    super(t, e);
  }
}
class pl extends io {
  constructor(t, e) {
    super(t, e);
  }
}
class ml extends io {
  constructor(t, e) {
    super(t, e);
  }
}
class Pl extends Is {
  constructor(t, e, i) {
    super(t.ReflectingObstacle, e.obstacle, i), this.Side = e;
  }
}
class Sl {
  // Dereferences the node if non-null to return the side Item.
  get LowNeighborSide() {
    return this.LowNeighbor == null ? null : this.LowNeighbor.item;
  }
  // Dereferences the node if non-null to return the side Item.
  get HighNeighborSide() {
    return this.HighNeighbor == null ? null : this.HighNeighbor.item;
  }
  Clear() {
    this.LowNeighbor = null, this.LowOverlapEnd = null, this.GroupSideInterveningBeforeLowNeighbor = null, this.HighNeighbor = null, this.HighOverlapEnd = null, this.GroupSideInterveningBeforeHighNeighbor = null;
  }
  SetSides(t, e, i, s) {
    if (O.IsAscending(t)) {
      this.HighNeighbor = e, this.HighOverlapEnd = i, this.GroupSideInterveningBeforeHighNeighbor = s;
      return;
    }
    this.LowNeighbor = e, this.LowOverlapEnd = i, this.GroupSideInterveningBeforeLowNeighbor = s;
  }
}
class ti {
  has(t) {
    return this.hasxy(t.x, t.y);
  }
  remove(t) {
    if (!(t.x < 0 || t.x >= this.arrayOfSets.length))
      return this.arrayOfSets[t.x].delete(t.y);
  }
  hasxy(t, e) {
    if (t < 0 || t >= this.arrayOfSets.length)
      return !1;
    const i = this.arrayOfSets[t];
    return i !== void 0 && i.has(e);
  }
  constructor() {
    this.arrayOfSets = new Array();
  }
  static mk(t) {
    const e = new ti();
    for (const i of t)
      e.add(i);
    return e;
  }
  *values() {
    for (let t = 0; t < this.arrayOfSets.length; t++) {
      const e = this.arrayOfSets[t];
      if (e)
        for (const i of e.values())
          yield new U(t, i);
    }
  }
  add(t) {
    let e = this.arrayOfSets[t.x];
    e == null && (this.arrayOfSets[t.x] = e = /* @__PURE__ */ new Set()), e.add(t.y);
  }
  addNN(t, e) {
    let i = this.arrayOfSets[t];
    i == null && (this.arrayOfSets[t] = i = /* @__PURE__ */ new Set()), i.add(e);
  }
  clear() {
    for (const t of this.arrayOfSets)
      t && t.clear();
  }
}
class yl {
  constructor(t, e) {
    this.Polyline = t, this.Obstacles = Array.from(e), this.PrimaryObstacle = this.Obstacles[0], Ot.RoundVerticesAndSimplify(this.Polyline);
  }
}
class Ys {
  // Most of the original contents of this file have been subsumed into ObstacleTree and TransientGraphUtility.
  static MungeClosestIntersectionInfo(t, e, i) {
    const s = e.seg1.boundingBox, n = u.RoundPoint(e.x).clone();
    return i ? new u(Ys.MungeIntersect(t.x, n.x, s.left, s.right), n.y) : new u(n.x, Ys.MungeIntersect(t.y, n.y, s.bottom, s.top));
  }
  // Make sure that we intersect the object space.
  static MungeIntersect(t, e, i, s) {
    if (t < e) {
      const n = Math.min(i, s);
      e < n && (e = n);
    } else if (t > e) {
      const n = Math.max(i, s);
      e > n && (e = n);
    }
    return u.RoundDouble(e);
  }
}
class ct {
  constructor() {
    this.CurrentGroupBoundaryCrossingMap = new Hh(), this.overlapPairs = new ti(), this.hasOverlaps = !1, this.lookupIntPair = new U(-1, -1);
  }
  get GraphBox() {
    return this.Root.irect;
  }
  //Create the tree hierarchy from the enumeration.
  Init(t, e, i) {
    this.CreateObstacleListAndOrdinals(t), this.AncestorSets = e, this.CreateRoot(), this.shapeIdToObstacleMap = i;
  }
  CreateObstacleListAndOrdinals(t) {
    this.allObstacles = Array.from(t);
    let e = Ot.FirstNonSentinelOrdinal;
    for (const i of this.allObstacles)
      i.Ordinal = e++;
  }
  OrdinalToObstacle(t) {
    return this.allObstacles[t - Ot.FirstNonSentinelOrdinal];
  }
  // Create the root with overlapping non-rectangular obstacles converted to their convex hulls, for more reliable calculations.
  CreateRoot() {
    this.Root = ct.CalculateHierarchy(this.GetAllObstacles()), this.OverlapsExist() && (this.AccreteClumps(), this.AccreteConvexHulls(), this.GrowGroupsToAccommodateOverlaps(), this.Root = ct.CalculateHierarchy(this.GetAllObstacles().filter((t) => t.IsPrimaryObstacle)));
  }
  OverlapsExist() {
    return this.Root == null ? !1 : (Xt(this.Root, this.Root, (t, e) => this.CheckForInitialOverlaps(t, e)), this.hasOverlaps);
  }
  OverlapPairAlreadyFound(t, e) {
    return this.lookupIntPair.x = e.Ordinal, this.lookupIntPair.y = t.Ordinal, this.overlapPairs.has(this.lookupIntPair);
  }
  CheckForInitialOverlaps(t, e) {
    if (this.hasOverlaps)
      return;
    const i = { bIsInsideA: !1, aIsInsideB: !1 };
    if (ct.ObstaclesIntersect(t, e, i)) {
      this.hasOverlaps = !0;
      return;
    }
    !i.aIsInsideB && !i.bIsInsideA || t.IsGroup && e.IsGroup || t.IsGroup && i.bIsInsideA || e.IsGroup && i.aIsInsideB || (this.hasOverlaps = !0);
  }
  AccreteClumps() {
    this.AccumulateObstaclesForClumps(), this.CreateClumps();
  }
  AccreteConvexHulls() {
    for (; ; )
      if (this.AccumulateObstaclesForConvexHulls(), !this.CreateConvexHulls())
        return;
  }
  static CalculateHierarchy(t) {
    const e = Array.from(t).map((i) => Bt(i, i.VisibilityBoundingBox));
    return Et(e);
  }
  AccumulateObstaclesForClumps() {
    this.overlapPairs.clear();
    const t = ct.CalculateHierarchy(this.GetAllObstacles().filter((e) => !e.IsGroup && e.IsRectangle));
    t != null && ae(t, t, (e, i) => this.EvaluateOverlappedPairForClump(e, i));
  }
  EvaluateOverlappedPairForClump(t, e) {
    if (t === e || this.OverlapPairAlreadyFound(t, e))
      return;
    const i = { bIsInsideA: !1, aIsInsideB: !1 };
    !ct.ObstaclesIntersect(t, e, i) && !i.aIsInsideB && !i.bIsInsideA || this.overlapPairs.add(new U(t.Ordinal, e.Ordinal));
  }
  AccumulateObstaclesForConvexHulls() {
    this.overlapPairs.clear();
    const t = ct.CalculateHierarchy(this.GetAllObstacles().filter((e) => e.IsPrimaryObstacle && !e.IsGroup));
    t != null && ae(t, t, (e, i) => this.EvaluateOverlappedPairForConvexHull(e, i));
  }
  EvaluateOverlappedPairForConvexHull(t, e) {
    if (t === e || this.OverlapPairAlreadyFound(t, e))
      return;
    const i = { bIsInsideA: !1, aIsInsideB: !1 };
    !ct.ObstaclesIntersect(t, e, i) && !i.aIsInsideB && !i.bIsInsideA || !t.IsInConvexHull && !e.IsInConvexHull && t.IsRectangle && e.IsRectangle || (this.overlapPairs.add(new U(t.Ordinal, e.Ordinal)), this.AddClumpToConvexHull(t), this.AddClumpToConvexHull(e), this.AddConvexHullToConvexHull(t), this.AddConvexHullToConvexHull(e));
  }
  GrowGroupsToAccommodateOverlaps() {
    for (; ; )
      if (this.AccumulateObstaclesForGroupOverlaps(), !this.GrowGroupsToResolveOverlaps())
        return;
  }
  AccumulateObstaclesForGroupOverlaps() {
    const t = ct.CalculateHierarchy(this.GetAllObstacles().filter((i) => i.IsGroup)), e = ct.CalculateHierarchy(this.GetAllObstacles().filter((i) => i.IsPrimaryObstacle));
    t == null || e == null || ae(t, e, (i, s) => this.EvaluateOverlappedPairForGroup(i, s));
  }
  EvaluateOverlappedPairForGroup(t, e) {
    if (t === e || this.OverlapPairAlreadyFound(t, e))
      return;
    const i = { bIsInsideA: !1, aIsInsideB: !1 }, s = ct.ObstaclesIntersect(t, e, i);
    if (!(!s && !i.aIsInsideB && !i.bIsInsideA)) {
      if (t.IsRectangle && e.IsRectangle) {
        e.IsGroup || (i.aIsInsideB || ct.FirstRectangleContainsACornerOfTheOther(e.VisibilityBoundingBox, t.VisibilityBoundingBox)) && (e.OverlapsGroupCorner = !0);
        return;
      }
      !s && (e.IsGroup || i.bIsInsideA) || this.overlapPairs.add(new U(t.Ordinal, e.Ordinal));
    }
  }
  static FirstRectangleContainsACornerOfTheOther(t, e) {
    return t.contains(e.leftBottom) || t.contains(e.leftTop) || t.contains(e.rightTop) || t.contains(e.rightBottom);
  }
  static FirstPolylineStartIsInsideSecondPolyline(t, e) {
    return g.PointRelativeToCurveLocation(t.start, e) !== F.Outside;
  }
  AddClumpToConvexHull(t) {
    if (t.isOverlapped) {
      for (const e of t.clump.filter((i) => i.Ordinal !== t.Ordinal))
        this.overlapPairs.add(new U(t.Ordinal, e.Ordinal));
      t.clump = [];
    }
  }
  AddConvexHullToConvexHull(t) {
    if (t.IsInConvexHull) {
      for (const e of t.ConvexHull.Obstacles.filter((i) => i.Ordinal !== t.Ordinal))
        this.overlapPairs.add(new U(t.Ordinal, e.Ordinal));
      t.ConvexHull.Obstacles = [];
    }
  }
  CreateClumps() {
    const t = Nr(Array.from(this.overlapPairs.values())), e = Qs(t);
    for (const i of e) {
      if (i.length === 1)
        continue;
      const s = i.map((n) => this.OrdinalToObstacle(n));
      for (const n of s)
        n.clump = s;
    }
  }
  CreateConvexHulls() {
    let t = !1;
    const e = Nr(Array.from(this.overlapPairs.values())), i = Qs(e);
    for (const s of i) {
      if (s.length === 1)
        continue;
      t = !0;
      const n = s.map(this.OrdinalToObstacle), r = Qn(n, (l) => l.VisibilityPolyline), o = new yl(Xe.createConvexHullAsClosedPolyline(r), n);
      for (const l of n)
        l.SetConvexHull(o);
    }
    return t;
  }
  GrowGroupsToResolveOverlaps() {
    let t = !1;
    for (const e of this.overlapPairs.values()) {
      t = !0;
      const i = this.OrdinalToObstacle(e.x), s = this.OrdinalToObstacle(e.y);
      ct.ResolveGroupAndGroupOverlap(i, s) || ct.ResolveGroupAndObstacleOverlap(i, s);
    }
    return this.overlapPairs.clear(), t;
  }
  static ResolveGroupAndGroupOverlap(t, e) {
    return e.IsGroup ? (t.VisibilityPolyline.boundingBox.area > e.VisibilityPolyline.boundingBox.area ? ct.ResolveGroupAndObstacleOverlap(t, e) : ct.ResolveGroupAndObstacleOverlap(e, t), !0) : !1;
  }
  static ResolveGroupAndObstacleOverlap(t, e) {
    let i = e.looseVisibilityPolyline;
    ct.GrowGroupAroundLoosePolyline(t, i);
    const s = { bIsInsideA: !1, aIsInsideB: !1 };
    for (; ct.ObstaclesIntersect(e, t, s) || !s.aIsInsideB; )
      i = Ot.CreateLoosePolyline(i), ct.GrowGroupAroundLoosePolyline(t, i);
  }
  static GrowGroupAroundLoosePolyline(t, e) {
    const i = Array.from(t.VisibilityPolyline).concat(Array.from(e));
    t.SetConvexHull(new yl(Xe.createConvexHullAsClosedPolyline(i), [t]));
  }
  static ObstaclesIntersect(t, e, i) {
    return g.CurvesIntersect(t.VisibilityPolyline, e.VisibilityPolyline) ? (i.aIsInsideB = !1, i.bIsInsideA = !1, !0) : (i.aIsInsideB = ct.FirstPolylineStartIsInsideSecondPolyline(t.VisibilityPolyline, e.VisibilityPolyline), i.bIsInsideA = !i.aIsInsideB && ct.FirstPolylineStartIsInsideSecondPolyline(e.VisibilityPolyline, t.VisibilityPolyline), t.IsRectangle && e.IsRectangle ? !1 : ct.ObstaclesAreCloseEnoughToBeConsideredTouching(t, e, i.aIsInsideB, i.bIsInsideA) ? (i.aIsInsideB = !1, i.bIsInsideA = !1, !0) : !1);
  }
  static ObstaclesAreCloseEnoughToBeConsideredTouching(t, e, i, s) {
    if (!i && !s)
      return g.CurvesIntersect(t.looseVisibilityPolyline, e.VisibilityPolyline);
    const n = i ? t.looseVisibilityPolyline : e.looseVisibilityPolyline, r = i ? e.VisibilityPolyline : t.VisibilityPolyline;
    for (const o of n)
      if (g.PointRelativeToCurveLocation(o, r) === F.Outside) {
        const l = g.ClosestPoint(r, o);
        if (!u.closeIntersections(o, l))
          return !0;
      }
    return !1;
  }
  //Add ancestors that are spatial parents - they may not be in the hierarchy, but we need to be
  //able to cross their boundaries if we're routing between obstacles on different sides of them.
  AdjustSpatialAncestors() {
    if (this.SpatialAncestorsAdjusted)
      return !1;
    for (const e of this.GetAllGroups()) {
      const i = e.VisibilityBoundingBox;
      for (const s of this.Root.GetNodeItemsIntersectingRectangle(i))
        if (s !== e && g.ClosedCurveInteriorsIntersect(s.VisibilityPolyline, e.VisibilityPolyline)) {
          if (s.IsInConvexHull)
            for (const n of s.ConvexHull.Obstacles)
              this.AncestorSets.get(n.InputShape).add(e.InputShape);
          this.AncestorSets.get(s.InputShape).add(e.InputShape);
        }
    }
    let t = new Array();
    for (const e of this.Root.GetAllLeaves()) {
      const i = e.VisibilityBoundingBox;
      t = t.concat(Array.from(this.AncestorSets.get(e.InputShape)).filter((s) => !i.intersects(this.shapeIdToObstacleMap.get(s).VisibilityBoundingBox)));
      for (const s of t)
        this.AncestorSets.get(e.InputShape).delete(s);
      t = [];
    }
    return this.SpatialAncestorsAdjusted = !0, !0;
  }
  GetAllGroups() {
    return this.GetAllObstacles().filter((t) => t.IsGroup);
  }
  //Clear the internal state.
  Clear() {
    this.Root = null, this.AncestorSets = null;
  }
  // Create a LineSegment that contains the max visibility from startPoint in the desired direction.
  CreateMaxVisibilitySegment(t, e, i) {
    const s = O.RectangleBorderIntersect(this.GraphBox, t, e);
    if (b.GetDirections(t, s) === S.None)
      return i.pacList = null, v.mkPP(t, t);
    const n = this.RestrictSegmentWithObstacles(t, s);
    return i.pacList = this.CurrentGroupBoundaryCrossingMap.GetOrderedListBetween(n.start, n.end), n;
  }
  // Convenience functions that call through to RectangleNode.
  GetAllObstacles() {
    return this.allObstacles;
  }
  // Returns a list of all primary obstacles - secondary obstacles inside a convex hull are not needed in the VisibilityGraphGenerator.
  GetAllPrimaryObstacles() {
    return this.Root.GetAllLeaves();
  }
  // Hit-testing.
  IntersectionIsInsideAnotherObstacle(t, e, i, s) {
    return this.insideHitTestIgnoreObstacle1 = e, this.insideHitTestIgnoreObstacle2 = t, this.insideHitTestScanDirection = s, this.Root.FirstHitNodeWithPredicate(i, this.InsideObstacleHitTest.bind(this)) != null;
  }
  PointIsInsideAnObstaclePD(t, e) {
    return this.PointIsInsideAnObstacle(t, Pt.GetInstance(e));
  }
  PointIsInsideAnObstacle(t, e) {
    return this.insideHitTestIgnoreObstacle1 = null, this.insideHitTestIgnoreObstacle2 = null, this.insideHitTestScanDirection = e, this.Root.FirstHitNodeWithPredicate(t, this.InsideObstacleHitTest.bind(this)) != null;
  }
  InsideObstacleHitTest(t, e) {
    if (e === this.insideHitTestIgnoreObstacle1 || e === this.insideHitTestIgnoreObstacle2 || e.IsGroup || !O.PointIsInRectangleInterior(t, e.VisibilityBoundingBox))
      return at.Continue;
    const i = O.RectangleBorderIntersect(e.VisibilityBoundingBox, t, this.insideHitTestScanDirection.dir).add(this.insideHitTestScanDirection.DirectionAsPoint), s = O.RectangleBorderIntersect(e.VisibilityBoundingBox, t, this.insideHitTestScanDirection.OppositeDirection).sub(this.insideHitTestScanDirection.DirectionAsPoint), n = v.mkPP(s, i), r = g.getAllIntersections(n, e.VisibilityPolyline, !0);
    if (r.length === 2) {
      const o = u.RoundPoint(r[0].x), l = u.RoundPoint(r[1].x);
      if (!b.EqualPP(t, o) && !b.EqualPP(t, l) && t.compareTo(o) !== t.compareTo(l) && !D(Math.floor(r[0].par1), Math.floor(r[1].par1)))
        return at.Stop;
    }
    return at.Continue;
  }
  SegmentCrossesAnObstacle(t, e) {
    this.stopAtGroups = !0, this.wantGroupCrossings = !1;
    const i = this.RestrictSegmentPrivate(t, e);
    return !b.EqualPP(i.end, e);
  }
  SegmentCrossesANonGroupObstacle(t, e) {
    this.stopAtGroups = !1, this.wantGroupCrossings = !1;
    const i = this.RestrictSegmentPrivate(t, e);
    return !b.EqualPP(i.end, e);
  }
  // TEST_MSAGL
  RestrictSegmentWithObstacles(t, e) {
    return this.stopAtGroups = !1, this.wantGroupCrossings = !0, this.RestrictSegmentPrivate(t, e);
  }
  RestrictSegmentPrivate(t, e) {
    return this.GetRestrictedIntersectionTestSegment(t, e), this.currentRestrictedRay = v.mkPP(t, e), this.restrictedRayLengthSquared = t.sub(e).lengthSquared, this.CurrentGroupBoundaryCrossingMap.Clear(), this.RecurseRestrictRayWithObstacles(this.Root), this.currentRestrictedRay;
  }
  GetRestrictedIntersectionTestSegment(t, e) {
    const i = b.GetDirections(t, e), s = S.West === i ? this.GraphBox.right : S.East === i ? this.GraphBox.left : t.x, n = S.West === i ? this.GraphBox.left : S.East === i ? this.GraphBox.right : e.x, r = S.South === i ? this.GraphBox.top * 2 : S.North === i ? this.GraphBox.bottom : t.y, o = S.South === i ? this.GraphBox.bottom : S.North === i ? this.GraphBox.top : t.y;
    this.restrictedIntersectionTestSegment = v.mkPP(new u(s, r), new u(n, o));
  }
  RecurseRestrictRayWithObstacles(t) {
    if (!O.RectangleInteriorsIntersect(this.currentRestrictedRay.boundingBox, t.irect))
      return;
    const e = t.UserData;
    if (e != null) {
      const i = g.getAllIntersections(this.restrictedIntersectionTestSegment, e.VisibilityPolyline, !0);
      if (!e.IsGroup || this.stopAtGroups) {
        this.LookForCloserNonGroupIntersectionToRestrictRay(i);
        return;
      }
      this.wantGroupCrossings && this.AddGroupIntersectionsToRestrictedRay(e, i);
      return;
    }
    this.RecurseRestrictRayWithObstacles(t.Left), this.RecurseRestrictRayWithObstacles(t.Right);
  }
  LookForCloserNonGroupIntersectionToRestrictRay(t) {
    let e = 0, i = null, s = this.restrictedRayLengthSquared;
    const n = b.GetDirections(this.restrictedIntersectionTestSegment.start, this.restrictedIntersectionTestSegment.end);
    for (const r of t) {
      const o = u.RoundPoint(r.x), l = b.GetDirections(this.currentRestrictedRay.start, o);
      if (l === E.OppositeDir(n))
        continue;
      if (e++, S.None === l) {
        s = 0, i = r;
        continue;
      }
      const h = o.sub(this.currentRestrictedRay.start).lengthSquared;
      if (h < s) {
        if (r.x.sub(this.currentRestrictedRay.start).lengthSquared < m.squareOfDistanceEpsilon)
          continue;
        s = h, i = r;
      }
    }
    if (i != null) {
      if (e === 1) {
        const r = u.RoundPoint(i.x);
        if (u.closeIntersections(r, this.currentRestrictedRay.start) || u.closeIntersections(r, this.currentRestrictedRay.end))
          return;
      }
      this.restrictedRayLengthSquared = s, this.currentRestrictedRay.end = Ys.MungeClosestIntersectionInfo(this.currentRestrictedRay.start, i, !O.IsVerticalPP(this.currentRestrictedRay.start, this.currentRestrictedRay.end));
    }
  }
  AddGroupIntersectionsToRestrictedRay(t, e) {
    for (const i of e) {
      const s = u.RoundPoint(i.x);
      if (s.sub(this.currentRestrictedRay.start).lengthSquared > this.restrictedRayLengthSquared)
        continue;
      const r = b.GetDirections(this.currentRestrictedRay.start, this.currentRestrictedRay.end), o = i.seg1, l = E.VectorDirection(o.derivative(i.par1));
      let h = r;
      (l & E.RotateRight(r)) !== 0 && (h = E.OppositeDir(h)), this.CurrentGroupBoundaryCrossingMap.AddIntersection(s, t, h);
    }
  }
}
class vf {
  constructor(t, e) {
    this.scanDirection = t, this.SideTree = new we((i, s) => this.Compare(i, s)), this.linePositionAtLastInsertOrRemove = e;
  }
  Insert(t, e) {
    return this.linePositionAtLastInsertOrRemove = e, this.SideTree.insert(t);
  }
  get Count() {
    return this.SideTree.count;
  }
  Remove(t, e) {
    this.linePositionAtLastInsertOrRemove = e, this.SideTree.remove(t);
  }
  Find(t) {
    return this.scanDirection.ComparePerpCoord(this.linePositionAtLastInsertOrRemove, t.Start) === -1 ? null : this.SideTree.find(t);
  }
  NextLowB(t) {
    return this.NextLowR(this.Find(t));
  }
  NextLowR(t) {
    return this.SideTree.previous(t);
  }
  NextHighB(t) {
    return this.NextHighR(this.Find(t));
  }
  NextHighR(t) {
    return this.SideTree.next(t);
  }
  Next(t, e) {
    return O.IsAscending(t) ? this.SideTree.next(e) : this.SideTree.previous(e);
  }
  Lowest() {
    return this.SideTree.treeMinimum();
  }
  // For ordering lines along the scanline at segment starts/ends.
  Compare(t, e) {
    if (t.Obstacle === e.Obstacle)
      return t === e ? 0 : t instanceof Qe ? -1 : 1;
    const i = ut.ScanLineIntersectSidePBS(this.linePositionAtLastInsertOrRemove, t, this.scanDirection), s = ut.ScanLineIntersectSidePBS(this.linePositionAtLastInsertOrRemove, e, this.scanDirection);
    let n = i.compareTo(s);
    if (n === 0) {
      const r = t instanceof Qe, o = e instanceof Qe;
      n = cd(r, o), n === 0 && (n = yt(t.Obstacle.Ordinal, e.Obstacle.Ordinal));
    }
    return n;
  }
}
class rr {
  constructor(t) {
    this.lookupSegment = W.mk(new u(0, 0), new u(0, 1)), this.ScanDirection = t, this.segmentTree = new we((e, i) => this.Compare(e, i)), this.findIntersectorPred = (e) => this.CompareIntersector(e), this.findPointPred = (e) => this.CompareToPoint(e);
  }
  get Segments() {
    return this.segmentTree.allNodes();
  }
  // If the seg is already in the tree it returns that instance, else it inserts the new
  // seg and returns that.
  InsertUnique(t) {
    this.AssertValidSegmentForInsertion(t);
    const e = this.segmentTree.find(t);
    return e ?? this.segmentTree.insert(t);
  }
  AssertValidSegmentForInsertion(t) {
  }
  Remove(t) {
    this.segmentTree.remove(t);
  }
  Find(t, e) {
    this.lookupSegment.Update(t, e);
    const i = this.segmentTree.find(this.lookupSegment);
    return i != null && b.EqualPP(i.item.End, e) ? i.item : null;
  }
  // Find the lowest perpendicular scanseg that intersects the segment endpoints.
  FindLowestIntersector(t, e) {
    const i = this.FindLowestIntersectorNode(t, e);
    return i != null ? i.item : null;
  }
  FindLowestIntersectorNode(t, e) {
    this.lookupSegment.Update(t, t);
    let i = this.segmentTree.findLast(this.findIntersectorPred);
    if (b.EqualPP(t, e))
      i != null && this.ScanDirection.Compare(i.item.End, t) < 0 && (i = null);
    else
      for (this.lookupSegment.Update(t, e); i != null && !i.item.IntersectsSegment(this.lookupSegment); ) {
        if (this.ScanDirection.Compare(i.item.Start, e) > 0)
          return null;
        i = this.segmentTree.next(i);
      }
    return i;
  }
  // Find the highest perpendicular scanseg that intersects the segment endpoints.
  FindHighestIntersector(t, e) {
    this.lookupSegment.Update(e, e);
    let i = this.segmentTree.findLast(this.findIntersectorPred);
    if (b.EqualPP(t, e))
      i != null && this.ScanDirection.Compare(i.item.End, t) < 0 && (i = null);
    else
      for (this.lookupSegment.Update(t, e); i != null && !i.item.IntersectsSegment(this.lookupSegment); ) {
        if (this.ScanDirection.Compare(i.item.End, t) < 0)
          return null;
        i = this.segmentTree.previous(i);
      }
    return i != null ? i.item : null;
  }
  CompareIntersector(t) {
    return this.ScanDirection.Compare(t.Start, this.lookupSegment.Start) <= 0;
  }
  FindSegmentContainingPoint(t, e) {
    return this.FindSegmentOverlappingPoints(t, t, e);
  }
  FindSegmentOverlappingPoints(t, e, i) {
    this.lookupSegment.Update(t, e);
    const s = this.segmentTree.findFirst(this.findPointPred);
    if (s != null) {
      const n = s.item;
      if (this.ScanDirection.Compare(n.Start, e) <= 0)
        return n;
    }
    return null;
  }
  CompareToPoint(t) {
    return this.ScanDirection.Compare(t.End, this.lookupSegment.Start) >= 0;
  }
  MergeAndRemoveNextNode(t, e) {
    return this.ScanDirection.Compare(t.End, e.item.End) === -1 && t.Update(t.Start, e.item.End), t.MergeGroupBoundaryCrossingList(e.item.GroupBoundaryPointAndCrossingsList), this.segmentTree.deleteNodeInternal(e), this.segmentTree.find(t);
  }
  MergeSegments() {
    if (this.segmentTree.count < 2)
      return;
    let t = this.segmentTree.treeMinimum(), e = this.segmentTree.next(t);
    for (; e != null; e = this.segmentTree.next(t))
      switch (this.ScanDirection.Compare(e.item.Start, t.item.End)) {
        case 1:
          t = e;
          break;
        case 0:
          e.item.IsOverlapped === t.item.IsOverlapped ? t = this.MergeAndRemoveNextNode(t.item, e) : (t.item.NeedEndOverlapVertex = !0, e.item.NeedStartOverlapVertex = !0, t = e);
          break;
        default:
          if (t.item.IsOverlapped !== e.item.IsOverlapped) {
            if (t.item.IsOverlapped)
              t.item.Start === e.item.Start ? t = this.MergeAndRemoveNextNode(e.item, t) : (t.item.Update(t.item.Start, e.item.Start), t = e);
            else if (t.item.End === e.item.End)
              t = this.MergeAndRemoveNextNode(t.item, e);
            else {
              const s = e.item, n = t.item;
              this.segmentTree.deleteNodeInternal(e), s.Update(n.End, s.End), this.segmentTree.insert(s), s.TrimGroupBoundaryCrossingList(), t = this.segmentTree.find(n);
            }
            break;
          }
          t = this.MergeAndRemoveNextNode(t.item, e);
          break;
      }
  }
  // For ordering the line segments inserted by the ScanLine. Assuming vertical sweep (sweeping up from
  // bottom, scanning horizontally) then order ScanSegments first by lowest Y coord, then by lowest X coord.
  Compare(t, e) {
    if (t === e)
      return 0;
    if (t == null)
      return -1;
    if (e == null)
      return 1;
    let i = this.ScanDirection.Compare(t.Start, e.Start);
    return i === 0 && (i = this.ScanDirection.Compare(t.End, e.End) * -1), i;
  }
}
class Cf extends ks {
  constructor(t) {
    super(t);
  }
  SetVertexEntry(t) {
    this.VertexEntries == null && (this.VertexEntries = new Array(4)), this.VertexEntries[E.ToIndex(t.Direction)] = t;
  }
  RemoveVertexEntries() {
    this.VertexEntries = null;
  }
}
class ut {
  constructor(t) {
    this.ObstacleTree = new ct(), this.CurrentGroupBoundaryCrossingMap = new Hh(), this.LowNeighborSides = new Sl(), this.HighNeighborSides = new Sl(), this.ScanDirection = Pt.HorizontalInstance, this.eventQueue = new dl(), this.HorizontalScanSegments = new rr(Pt.HorizontalInstance), this.VerticalScanSegments = new rr(Pt.VerticalInstance), this.wantReflections = t;
  }
  get ParallelScanSegments() {
    return this.ScanDirection.IsHorizontal ? this.HorizontalScanSegments : this.VerticalScanSegments;
  }
  get PerpendicularScanSegments() {
    return this.ScanDirection.IsHorizontal ? this.VerticalScanSegments : this.HorizontalScanSegments;
  }
  static NewVisibilityGraph() {
    const t = new wt();
    return t.VertexFactory = (e) => new Cf(e), t;
  }
  // Generate the visibility graph along which edges will be routed.
  GenerateVisibilityGraph() {
    if (this.ObstacleTree.Root == null)
      return;
    this.InitializeEventQueue(Pt.HorizontalInstance);
    let t = Ot.FirstSentinelOrdinal, e = new u(this.ObstacleTree.GraphBox.left - ut.SentinelOffset, this.ObstacleTree.GraphBox.bottom - ut.SentinelOffset), i = new u(this.ObstacleTree.GraphBox.left - ut.SentinelOffset, this.ObstacleTree.GraphBox.top + ut.SentinelOffset), s = Ot.CreateSentinel(e, i, this.ScanDirection, t++);
    this.scanLine.Insert(s.ActiveHighSide, this.ObstacleTree.GraphBox.leftBottom), e = new u(this.ObstacleTree.GraphBox.right + ut.SentinelOffset, this.ObstacleTree.GraphBox.bottom - ut.SentinelOffset), i = new u(this.ObstacleTree.GraphBox.right + ut.SentinelOffset, this.ObstacleTree.GraphBox.top + ut.SentinelOffset), s = Ot.CreateSentinel(e, i, this.ScanDirection, t++), this.scanLine.Insert(s.ActiveLowSide, this.ObstacleTree.GraphBox.leftBottom), this.ProcessEvents(), this.InitializeEventQueue(Pt.VerticalInstance), e = new u(this.ObstacleTree.GraphBox.left - ut.SentinelOffset, this.ObstacleTree.GraphBox.bottom - ut.SentinelOffset), i = new u(this.ObstacleTree.GraphBox.right + ut.SentinelOffset, this.ObstacleTree.GraphBox.bottom - ut.SentinelOffset), s = Ot.CreateSentinel(e, i, this.ScanDirection, t++), this.scanLine.Insert(s.ActiveHighSide, this.ObstacleTree.GraphBox.leftBottom), e = new u(this.ObstacleTree.GraphBox.left - ut.SentinelOffset, this.ObstacleTree.GraphBox.top + ut.SentinelOffset), i = new u(this.ObstacleTree.GraphBox.right + ut.SentinelOffset, this.ObstacleTree.GraphBox.top + ut.SentinelOffset), s = Ot.CreateSentinel(e, i, this.ScanDirection, t), this.scanLine.Insert(s.ActiveLowSide, this.ObstacleTree.GraphBox.leftBottom), this.ProcessEvents();
  }
  // // ReSharper disable InconsistentNaming
  // protected static Debug_AssertGraphIsRectilinear(graph: VisibilityGraph, this.ObstacleTree: this.ObstacleTree) {
  //    this.#if TEST_MSAGL
  //    if (graph.Edges.Any(edge => !PointComparer.IsPureDirection(PointComparer.GetDirections(edge.SourcePoint, edge.TargetPoint))))
  //    {
  //        StaticGraphUtility.Assert(false, "Generated VisibilityGraph contains non-rectilinear lines", this.ObstacleTree, graph);
  //        return;
  //    }
  //    this.#endif
  // }
  static ScanLineIntersectSidePBS(t, e, i) {
    const s = e.Direction;
    let n = e.Start.x, r = e.Start.y;
    return i.IsHorizontal ? (n += s.x / s.y * (t.y - e.Start.y), n = Ys.MungeIntersect(t.x, n, e.Start.x, e.End.x), r = t.y) : (n = t.x, r += s.y / s.x * (t.x - e.Start.x), r = Ys.MungeIntersect(t.y, r, e.Start.y, e.End.y)), new u(n, r);
  }
  GetOpenVertex(t) {
    let e = t.startPoint, i = this.TraversePolylineForEvents(e), s = this.PointCompare(i.point, e.point);
    for (; ; i = this.TraversePolylineForEvents(i)) {
      const n = this.PointCompare(i.point, e.point);
      if (n <= 0)
        e = i;
      else if (n > 0 && s <= 0)
        break;
      s = n;
    }
    return e;
  }
  TraversePolylineForEvents(t) {
    return this.ScanDirection.IsHorizontal ? t.nextOnPolyline : t.prevOnPolyline;
  }
  InitializeEventQueue(t) {
    this.ScanDirection = t, this.eventQueue.Reset(this.ScanDirection), this.EnqueueBottomVertexEvents(), this.scanLine = new vf(this.ScanDirection, this.ObstacleTree.GraphBox.leftBottom), this.lookaheadScan = new bf(this.ScanDirection);
  }
  EnqueueBottomVertexEvents() {
    for (const t of this.ObstacleTree.GetAllPrimaryObstacles()) {
      const e = this.GetOpenVertex(t.VisibilityPolyline);
      this.eventQueue.Enqueue(new cr(t, e));
    }
  }
  // end EnqueueBottomVertexEvents
  IsFlat(t) {
    return this.ScanDirection.IsFlatS(t);
  }
  IsPerpendicular(t) {
    return this.ScanDirection.IsPerpendicularS(t);
  }
  // Params are event site (vertex point) and the obstacle side adjacent to that site.
  ScanLineIntersectSide(t, e) {
    return ut.ScanLineIntersectSidePBS(t, e, this.ScanDirection);
  }
  SideReflectsUpward(t) {
    return t instanceof Qe ? this.ScanDirection.Coord(t.End) > this.ScanDirection.Coord(t.Start) : this.ScanDirection.Coord(t.End) < this.ScanDirection.Coord(t.Start);
  }
  SideReflectsDownward(t) {
    return t instanceof Qe ? this.ScanDirection.Coord(t.End) < this.ScanDirection.Coord(t.Start) : this.ScanDirection.Coord(t.End) > this.ScanDirection.Coord(t.Start);
  }
  // Calculate reflections from the lines, depending on line side (Low vs. High) and slope.
  // Because the low neighbor intersection is on a high side of its obstacle
  // and vice-versa, then the "side" of a lowNbor is a highSide, and vice versa.
  StoreLookaheadSite(t, e, i, s) {
    if (this.wantReflections && !this.IsPerpendicular(e)) {
      if (!s && !O.PointIsInRectangleInterior(i, e.Obstacle.VisibilityBoundingBox))
        return;
      this.SideReflectsUpward(e) && this.lookaheadScan.Find(i) == null && this.lookaheadScan.Add(new Is(t, e.Obstacle, i));
    }
  }
  // Load any lookahead scan ray intersections with a side we've just added.
  LoadReflectionEvents(t) {
    this.LoadReflectionEventsBB(t, t);
  }
  // sideWithRange is either the same as sideToQueue, if that side is being loaded by an
  // OpenVertexEvent, or is a different side that is just closing.
  LoadReflectionEventsBB(t, e) {
    if (t == null || this.SideReflectsUpward(t) || this.IsPerpendicular(t))
      return;
    const i = T.mkPP(t.Start, t.End), s = T.mkPP(e.Start, e.End);
    if (this.ScanDirection.IsHorizontal ? !i.intersectsOnX(s) : !i.intersectsOnY(s))
      return;
    const n = T.intersect(i, s), r = n.leftBottom, o = n.rightTop;
    let l = this.lookaheadScan.FindFirstInRange(r, o);
    for (; l != null; ) {
      const h = ut.ScanLineIntersectSidePBS(l.item.Site, t, this.ScanDirection.PerpendicularInstance);
      this.ScanDirection.ComparePerpCoord(h, l.item.Site) > 0 ? this.AddReflectionEvent(l.item, t, h) : l.item.ReflectingObstacle !== t.Obstacle && this.lookaheadScan.MarkStaleSite(l.item), l = this.lookaheadScan.FindNextInRange(l, o);
    }
    this.lookaheadScan.RemoveStaleSites();
  }
  // Determine whether the event is valid and do some common processing.
  AddPerpendicularReflectionSegment(t, e, i) {
    if (this.lookaheadScan.RemoveExact(t.PreviousSite)) {
      if (e == null)
        return !1;
      if (t.PreviousSite.IsStaircaseStep(t.ReflectingObstacle)) {
        if (!O.PointIsInRectangleInterior(t.Site, t.ReflectingObstacle.VisibilityBoundingBox) || !this.InsertPerpendicularReflectionSegment(t.PreviousSite.Site, t.Site))
          return !1;
        if (i != null && t.IsStaircaseStep(i.Obstacle))
          return this.ScanLineCrossesObstacle(t.Site, i.Obstacle);
      }
    }
    return !1;
  }
  AddParallelReflectionSegment(t, e, i, s) {
    {
      const n = this.ScanLineIntersectSide(s.Site, e ?? i), r = e != null ? n : s.Site, o = e != null ? s.Site : n;
      return e == null ? e = this.scanLine.NextLowB(i).item : i = this.scanLine.NextHighB(e).item, this.InsertParallelReflectionSegment(r, o, t, e, i, s);
    }
  }
  AddReflectionEvent(t, e, i) {
    const s = e;
    s != null ? this.eventQueue.Enqueue(new Pl(t, s, i)) : this.eventQueue.Enqueue(new fl(t, e, i));
  }
  AddSideToScanLine(t, e) {
    const i = this.scanLine.Insert(t, e);
    return this.LoadReflectionEvents(t), i;
  }
  RemoveSideFromScanLine(t, e) {
    this.scanLine.Remove(t.item, e);
  }
  PointCompare(t, e) {
    return this.ScanDirection.Compare(t, e);
  }
  Clear() {
    this.ObstacleTree.Clear(), this.eventQueue = new dl(), this.HorizontalScanSegments = new rr(Pt.HorizontalInstance), this.VerticalScanSegments = new rr(Pt.VerticalInstance), this.VisibilityGraph = null;
  }
  ProcessEvents() {
    for (; this.eventQueue.Count > 0; ) {
      const t = this.eventQueue.Dequeue();
      t instanceof cr ? this.ProcessEventO(t) : t instanceof gl ? this.ProcessEventLB(t) : t instanceof pl ? this.ProcessEventHB(t) : t instanceof ml ? this.ProcessEventCV(t) : t instanceof Pl ? this.ProcessEventLR(t) : t instanceof fl ? this.ProcessEventHR(t) : this.ProcessCustomEvent(t), this.LowNeighborSides.Clear(), this.HighNeighborSides.Clear();
    }
  }
  ProcessCustomEvent(t) {
  }
  ScanLineCrossesObstacle(t, e) {
    return this.ScanDirection.ComparePerpCoord(t, e.VisibilityBoundingBox.leftBottom) > 0 && this.ScanDirection.ComparePerpCoord(t, e.VisibilityBoundingBox.rightTop) < 0;
  }
  FindInitialNeighborSides(t, e) {
    e.lowNborSideNode = this.scanLine.NextLowR(t), e.highNborSideNode = this.scanLine.NextHighR(t);
  }
  // As described in the doc, we stop at the first neighbor of the appropriate side type that we touch
  // the border of, even if that's just skimming along the extreme vertex of it, because those will
  // continue the chain of open/close+addSegment, and we don't want to follow the full length of the
  // segment each time if there are a lot of collinear obstacle open/close events.
  FindNeighborsBRR(t, e, i) {
    this.LowNeighborSides.Clear(), this.HighNeighborSides.Clear(), this.FindNeighbors(t, e, this.LowNeighborSides), this.FindNeighbors(t, i, this.HighNeighborSides);
  }
  FindNeighbors(t, e, i) {
    const s = t instanceof cr ? e.item.Start : e.item.End, n = { lowNborSideNode: null, highNborSideNode: null };
    this.FindInitialNeighborSides(e, n), this.SkipToNeighbor(this.ScanDirection.OppositeDirection, e.item, s, n.lowNborSideNode, i), this.SkipToNeighbor(this.ScanDirection.Dir, e.item, s, n.highNborSideNode, i);
  }
  SkipToNeighbor(t, e, i, s, n) {
    let r = null, o = null;
    for (; ; s = this.scanLine.Next(t, s))
      if (s.item.Obstacle !== e.Obstacle) {
        if (s.item.Obstacle.IsGroup) {
          this.ProcessGroupSideEncounteredOnTraversalToNeighbor(s, i, t) && o == null && (o = s.item);
          continue;
        }
        if (s.item instanceof bn === O.IsAscending(t)) {
          this.ScanLineCrossesObstacle(i, s.item.Obstacle) && (r = s, o = null);
          continue;
        }
        break;
      }
    n.SetSides(t, s, r, o);
  }
  // end this.ProcessEvent(CloseVertexEvent)
  ProcessGroupSideEncounteredOnTraversalToNeighbor(t, e, i) {
    if (!this.ScanLineCrossesObstacle(e, t.item.Obstacle))
      return !1;
    const s = t.item instanceof Qe === O.IsAscending(i) ? i : E.OppositeDir(i), n = this.ScanLineIntersectSide(e, t.item);
    return this.CurrentGroupBoundaryCrossingMap.AddIntersection(n, t.item.Obstacle, s), !0;
  }
  FindNeighborsAndProcessVertexEvent(t, e, i) {
    this.CurrentGroupBoundaryCrossingMap.Clear(), this.FindNeighborsBRR(i, t, e), this.ProcessVertexEvent(t, e, i), this.CurrentGroupBoundaryCrossingMap.Clear();
  }
  ProcessEventO(t) {
    var e, i;
    const s = t.Obstacle;
    s.CreateInitialSides(t.Vertex, this.ScanDirection), this.AddSideToScanLine(s.ActiveLowSide, t.Site);
    const n = this.AddSideToScanLine(s.ActiveHighSide, t.Site), r = this.scanLine.Find(s.ActiveLowSide);
    this.FindNeighborsAndProcessVertexEvent(r, n, t);
    const o = (e = this.LowNeighborSides.GroupSideInterveningBeforeLowNeighbor) !== null && e !== void 0 ? e : this.LowNeighborSides.LowNeighborSide;
    this.SideReflectsUpward(o) && this.LoadReflectionEvents(s.ActiveLowSide);
    const l = (i = this.HighNeighborSides.GroupSideInterveningBeforeHighNeighbor) !== null && i !== void 0 ? i : this.HighNeighborSides.HighNeighborSide;
    if (this.SideReflectsUpward(l) && this.LoadReflectionEvents(s.ActiveHighSide), s.ActiveHighSide.Start !== s.ActiveLowSide.Start) {
      const h = new bn(s, t.Vertex, this.ScanDirection);
      this.lookaheadScan.RemoveSitesForFlatBottom(h.Start, h.End);
    }
    this.EnqueueLowBendVertexEvent(s.ActiveLowSide), this.EnqueueHighBendOrCloseVertexEvent(s.ActiveHighSide);
  }
  // end this.ProcessEvent(OpenVertexEvent)
  ProcessEventLB(t) {
    const e = t.Obstacle, i = new Qe(e, t.Vertex, this.ScanDirection);
    this.ScanDirection.ComparePerpCoord(i.End, i.Start) > 0 && (this.RemoveSideFromScanLine(this.scanLine.Find(e.ActiveLowSide), t.Site), this.AddSideToScanLine(i, t.Site), e.ActiveLowSide = i, this.EnqueueLowBendVertexEvent(i));
  }
  // end this.ProcessEvent(LowBendVertexEvent)
  EnqueueLowBendVertexEvent(t) {
    this.eventQueue.Enqueue(new gl(t.Obstacle, t.EndVertex));
  }
  ProcessEventHB(t) {
    const e = t.Obstacle, i = new bn(e, t.Vertex, this.ScanDirection);
    this.RemoveSideFromScanLine(this.scanLine.Find(e.ActiveHighSide), t.Site);
    const s = this.AddSideToScanLine(i, t.Site);
    if (e.ActiveHighSide = i, this.EnqueueHighBendOrCloseVertexEvent(e.ActiveHighSide), this.wantReflections && this.ScanDirection.IsHorizontal && i.Start.x === e.VisibilityBoundingBox.right && this.SideReflectsUpward(i)) {
      const n = this.scanLine.NextHighR(s);
      n.item instanceof Qe && this.SideReflectsDownward(n.item) && (!e.isOverlapped || !this.ObstacleTree.PointIsInsideAnObstacle(i.Start, this.ScanDirection)) && (this.StoreLookaheadSite(n.item.Obstacle, i, i.Start, !0), this.LoadReflectionEvents(n.item));
    }
  }
  EnqueueHighBendOrCloseVertexEvent(t) {
    const e = t.Obstacle, i = this.ScanDirection.IsHorizontal ? t.EndVertex.prevOnPolyline : t.EndVertex.nextOnPolyline;
    this.ScanDirection.ComparePerpCoord(i.point, t.End) > 0 ? this.eventQueue.Enqueue(new pl(e, t.EndVertex)) : this.eventQueue.Enqueue(new ml(e, t.EndVertex));
  }
  // end this.ProcessEvent(HighBendVertexEvent)
  CreateCloseEventSegmentsAndFindNeighbors(t) {
    const e = t.Obstacle;
    let i = this.scanLine.Find(e.ActiveLowSide), s = this.scanLine.Find(e.ActiveHighSide);
    if (this.scanLine.Compare(e.ActiveLowSide, e.ActiveHighSide) === 1) {
      const n = i;
      i = s, s = n;
    }
    if (this.FindNeighborsAndProcessVertexEvent(i, s, t), this.wantReflections && e.isOverlapped)
      for (let n = this.scanLine.NextHighR(i); n.item !== s.item; n = this.scanLine.NextHighR(n))
        this.LoadReflectionEvents(n.item);
    this.scanLine.Remove(e.ActiveLowSide, t.Site), this.scanLine.Remove(e.ActiveHighSide, t.Site);
  }
  ProcessEventCV(t) {
    this.CreateCloseEventSegmentsAndFindNeighbors(t);
    const e = this.LowNeighborSides.LowNeighbor.item, i = this.HighNeighborSides.HighNeighbor.item, s = t.Obstacle;
    this.LoadReflectionEvents(e), this.LoadReflectionEvents(i), s.Close();
  }
  ProcessEventLR(t) {
    const e = t.Side.Obstacle, i = this.scanLine.NextLowB(t.Side).item;
    this.AddPerpendicularReflectionSegment(t, t.Side, i) && this.AddParallelReflectionSegment(e, i, null, t) && this.LoadReflectionEvents(e.ActiveLowSide);
  }
  // end this.ProcessEvent(LowReflectionEvent)
  ProcessEventHR(t) {
    const e = t.Side.Obstacle, i = this.scanLine.NextHighB(t.Side).item;
    this.AddPerpendicularReflectionSegment(t, t.Side, i) && this.AddParallelReflectionSegment(e, null, i, t) && this.LoadReflectionEvents(e.ActiveHighSide);
  }
  // end this.ProcessEvent(HighReflectionEvent)
  MakeInBoundsLocation(t) {
    const e = Math.max(t.x, this.ObstacleTree.GraphBox.left), i = Math.max(t.y, this.ObstacleTree.GraphBox.bottom);
    return new u(Math.min(e, this.ObstacleTree.GraphBox.right), Math.min(i, this.ObstacleTree.GraphBox.top));
  }
  IsInBoundsV(t) {
    return this.IsInBoundsP(t.point);
  }
  IsInBoundsP(t) {
    return b.EqualPP(t, this.MakeInBoundsLocation(t));
  }
}
ut.SentinelOffset = 1;
class Se extends ut {
  constructor() {
    super(
      /* wantReflections:*/
      !1
    ), this.horizontalVertexPoints = new xt(), this.verticalVertexPoints = new xt(), this.boundingBoxSteinerPoints = new xt(), this.xCoordAccumulator = /* @__PURE__ */ new Set(), this.yCoordAccumulator = /* @__PURE__ */ new Set(), this.horizontalCoordMap = /* @__PURE__ */ new Map(), this.verticalCoordMap = /* @__PURE__ */ new Map();
  }
  Clear() {
    super.Clear(), this.Cleanup();
  }
  Cleanup() {
    this.horizontalVertexPoints.clear(), this.verticalVertexPoints.clear(), this.boundingBoxSteinerPoints.clear(), this.xCoordAccumulator.clear(), this.yCoordAccumulator.clear(), this.horizontalCoordMap.clear(), this.verticalCoordMap.clear();
  }
  // Generate the visibility graph along which edges will be routed.
  GenerateVisibilityGraph() {
    this.AccumulateVertexCoords(), this.CreateSegmentVectorsAndPopulateCoordinateMaps(), this.RunScanLineToCreateSegmentsAndBoundingBoxSteinerPoints(), this.GenerateSparseIntersectionsFromVertexPoints(), this.CreateScanSegmentTrees(), this.Cleanup();
  }
  AccumulateVertexCoords() {
    for (const t of this.ObstacleTree.GetAllObstacles())
      this.xCoordAccumulator.add(t.VisibilityBoundingBox.left), this.xCoordAccumulator.add(t.VisibilityBoundingBox.right), this.yCoordAccumulator.add(t.VisibilityBoundingBox.top), this.yCoordAccumulator.add(t.VisibilityBoundingBox.bottom);
  }
  CreateSegmentVectorsAndPopulateCoordinateMaps() {
    this.horizontalScanSegmentVector = new ul(this.yCoordAccumulator, !0), this.verticalScanSegmentVector = new ul(this.xCoordAccumulator, !1);
    for (let t = 0; t < this.horizontalScanSegmentVector.Length; t++)
      this.horizontalCoordMap.set(this.horizontalScanSegmentVector.Item(t).Coord, t);
    for (let t = 0; t < this.verticalScanSegmentVector.Length; t++)
      this.verticalCoordMap.set(this.verticalScanSegmentVector.Item(t).Coord, t);
  }
  RunScanLineToCreateSegmentsAndBoundingBoxSteinerPoints() {
    super.GenerateVisibilityGraph(), this.horizontalScanSegmentVector.ScanSegmentsComplete(), this.verticalScanSegmentVector.ScanSegmentsComplete(), this.xCoordAccumulator.clear(), this.yCoordAccumulator.clear();
  }
  InitializeEventQueue(t) {
    super.InitializeEventQueue(t), this.SetVectorsAndCoordMaps(t), this.AddAxisCoordinateEvents(t);
  }
  AddAxisCoordinateEvents(t) {
    if (t.IsHorizontal) {
      for (const e of this.yCoordAccumulator)
        this.eventQueue.Enqueue(new yo(new u(this.ObstacleTree.GraphBox.left - Se.SentinelOffset, e)));
      return;
    }
    for (const e of this.xCoordAccumulator)
      this.eventQueue.Enqueue(new yo(new u(e, this.ObstacleTree.GraphBox.bottom - Se.SentinelOffset)));
  }
  ProcessCustomEvent(t) {
    this.ProcessAxisCoordinate(t) || this.ProcessCustomEvent(t);
  }
  ProcessAxisCoordinate(t) {
    return t instanceof yo ? (this.CreateScanSegmentsOnAxisCoordinate(t.Site), !0) : !1;
  }
  InsertPerpendicularReflectionSegment(t, e) {
    return !1;
  }
  InsertParallelReflectionSegment(t, e, i, s, n, r) {
    return !1;
  }
  ProcessVertexEvent(t, e, i) {
    const s = this.ScanDirection.IsHorizontal ? this.horizontalVertexPoints : this.verticalVertexPoints;
    s.add(i.Site);
    const n = this.LowNeighborSides.LowNeighbor.item, r = this.HighNeighborSides.HighNeighbor.item, o = this.ScanDirection.Dir, l = this.ScanDirection.OppositeDirection, h = this.ScanLineIntersectSide(i.Site, n), c = this.ScanLineIntersectSide(i.Site, r);
    if (this.ObstacleTree.GraphBox.contains(h)) {
      const f = O.RectangleBorderIntersect(n.Obstacle.VisibilityBoundingBox, h, o);
      b.IsPureLower(f, i.Site) && this.boundingBoxSteinerPoints.add(f);
    }
    if (this.ObstacleTree.GraphBox.contains(c)) {
      const f = O.RectangleBorderIntersect(r.Obstacle.VisibilityBoundingBox, c, l);
      b.IsPureLower(i.Site, f) && this.boundingBoxSteinerPoints.add(f);
    }
    const d = { lowCorner: void 0, highCorner: void 0 };
    Se.GetBoundingCorners(t.item.Obstacle.VisibilityBoundingBox, i instanceof cr, this.ScanDirection.IsHorizontal, d), (b.IsPureLower(h, d.lowCorner) || n.Obstacle.IsInSameClump(i.Obstacle)) && s.add(d.lowCorner), (b.IsPureLower(d.highCorner, c) || r.Obstacle.IsInSameClump(i.Obstacle)) && s.add(d.highCorner);
  }
  static GetBoundingCorners(t, e, i, s) {
    if (e) {
      s.lowCorner = t.leftBottom, s.highCorner = i ? t.rightBottom : t.leftTop;
      return;
    }
    s.lowCorner = i ? t.leftTop : t.rightBottom, s.highCorner = t.rightTop;
  }
  CreateScanSegmentsOnAxisCoordinate(t) {
    this.CurrentGroupBoundaryCrossingMap.Clear();
    const e = this.scanLine.Lowest();
    let i = this.scanLine.NextHighR(e), s = 0, n = t, r = !1;
    for (; i != null; i = this.scanLine.NextHighR(i)) {
      if (this.SkipSide(n, i.item))
        continue;
      if (i.item.Obstacle.IsGroup) {
        (s === 0 || r) && this.HandleGroupCrossing(t, i.item);
        continue;
      }
      if (i.item instanceof Qe) {
        if (s > 0) {
          s++;
          continue;
        }
        n = this.CreateScanSegment(n, i.item, W.NormalWeight), this.CurrentGroupBoundaryCrossingMap.Clear(), s = 1, r = i.item.Obstacle.isOverlapped;
        continue;
      }
      s++, !(s > 0) && (n = i.item.Obstacle.isOverlapped || i.item.Obstacle.OverlapsGroupCorner ? this.CreateScanSegment(n, i.item, W.OverlappedWeight) : this.ScanLineIntersectSide(n, i.item), this.CurrentGroupBoundaryCrossingMap.Clear(), r = !1);
    }
    const o = this.ScanDirection.IsHorizontal ? new u(this.ObstacleTree.GraphBox.right + Se.SentinelOffset, n.y) : new u(n.x, this.ObstacleTree.GraphBox.top + Se.SentinelOffset);
    this.parallelSegmentVector.CreateScanSegment(n, o, W.NormalWeight, this.CurrentGroupBoundaryCrossingMap.GetOrderedListBetween(n, o)), this.parallelSegmentVector.ScanSegmentsCompleteForCurrentSlot();
  }
  HandleGroupCrossing(t, e) {
    if (!this.ScanLineCrossesObstacle(t, e.Obstacle))
      return;
    const i = e instanceof Qe ? this.ScanDirection.Dir : this.ScanDirection.OppositeDirection, s = this.ScanLineIntersectSide(t, e), n = this.CurrentGroupBoundaryCrossingMap.AddIntersection(s, e.Obstacle, i);
    this.AddPerpendicularCoordForGroupCrossing(s);
    const r = n.GetInteriorVertexPoint(s);
    this.AddPerpendicularCoordForGroupCrossing(r);
  }
  AddPerpendicularCoordForGroupCrossing(t) {
    const e = this.FindPerpendicularSlot(t, 0);
    e !== -1 && this.perpendicularSegmentVector.Item(e).AddPendingPerpendicularCoord(this.parallelSegmentVector.CurrentSlot.Coord);
  }
  SkipSide(t, e) {
    if (e.Obstacle.IsSentinel)
      return !0;
    const i = e.Obstacle.VisibilityBoundingBox;
    return this.ScanDirection.IsHorizontal ? t.y === i.bottom || t.y === i.top : t.x === i.left || t.x === i.right;
  }
  CreateScanSegment(t, e, i) {
    const s = this.ScanLineIntersectSide(t, e);
    return t !== s && this.parallelSegmentVector.CreateScanSegment(t, s, i, this.CurrentGroupBoundaryCrossingMap.GetOrderedListBetween(t, s)), s;
  }
  GenerateSparseIntersectionsFromVertexPoints() {
    this.VisibilityGraph = Se.NewVisibilityGraph(), this.GenerateSparseIntersectionsAlongHorizontalAxis(), this.GenerateSparseIntersectionsAlongVerticalAxis(), this.ConnectAdjoiningScanSegments(), this.horizontalScanSegmentVector.CreateSparseVerticesAndEdges(this.VisibilityGraph), this.verticalScanSegmentVector.CreateSparseVerticesAndEdges(this.VisibilityGraph);
  }
  GenerateSparseIntersectionsAlongHorizontalAxis() {
    this.currentAxisPointComparer = lr;
    const t = Array.from(this.horizontalVertexPoints.values()).sort(this.currentAxisPointComparer), e = Array.from(this.boundingBoxSteinerPoints.values()).sort(this.currentAxisPointComparer);
    this.ScanDirection = Pt.HorizontalInstance, this.SetVectorsAndCoordMaps(this.ScanDirection), this.GenerateSparseIntersections(t, e);
  }
  GenerateSparseIntersectionsAlongVerticalAxis() {
    this.currentAxisPointComparer = (i, s) => i.compareTo(s);
    const t = Array.from(this.verticalVertexPoints.values()).sort(this.currentAxisPointComparer), e = Array.from(this.boundingBoxSteinerPoints.values()).sort(this.currentAxisPointComparer);
    this.ScanDirection = Pt.VerticalInstance, this.SetVectorsAndCoordMaps(this.ScanDirection), this.GenerateSparseIntersections(t, e);
  }
  SetVectorsAndCoordMaps(t) {
    t.IsHorizontal ? (this.parallelSegmentVector = this.horizontalScanSegmentVector, this.perpendicularSegmentVector = this.verticalScanSegmentVector, this.perpendicularCoordMap = this.verticalCoordMap) : (this.parallelSegmentVector = this.verticalScanSegmentVector, this.perpendicularSegmentVector = this.horizontalScanSegmentVector, this.perpendicularCoordMap = this.horizontalCoordMap);
  }
  ConnectAdjoiningScanSegments() {
    this.horizontalScanSegmentVector.ConnectAdjoiningSegmentEndpoints(), this.verticalScanSegmentVector.ConnectAdjoiningSegmentEndpoints();
  }
  GenerateSparseIntersections(t, e) {
    this.perpendicularSegmentVector.ResetForIntersections(), this.parallelSegmentVector.ResetForIntersections();
    let i = 1;
    const s = { j: 0 };
    for (const n of this.parallelSegmentVector.Items())
      for (; !(!n.CurrentSegment.ContainsPoint(t[i]) && (!this.AddSteinerPointsToInterveningSegments(t[i], e, s, n) || !n.TraverseToSegmentContainingPoint(t[i]))); ) {
        if (this.AddPointsToCurrentSegmentIntersections(e, s, n), this.GenerateIntersectionsFromVertexPointForCurrentSegment(t[i], n), n.PointIsCurrentEndAndNextStart(t[i])) {
          n.MoveNext();
          continue;
        }
        if (++i >= t.length)
          return;
      }
  }
  AddSteinerPointsToInterveningSegments(t, e, i, s) {
    for (; i.j < e.length && this.currentAxisPointComparer(e[i.j], t) === -1; ) {
      if (!s.TraverseToSegmentContainingPoint(e[i.j]))
        return !1;
      this.AddPointsToCurrentSegmentIntersections(e, i, s);
    }
    return !0;
  }
  AddPointsToCurrentSegmentIntersections(t, e, i) {
    for (; e.j < t.length && i.CurrentSegment.ContainsPoint(t[e.j]); e.j++) {
      const s = this.FindPerpendicularSlot(t[e.j], 0);
      this.AddSlotToSegmentIntersections(i, s);
    }
  }
  GenerateIntersectionsFromVertexPointForCurrentSegment(t, e) {
    const i = this.FindPerpendicularSlot(e.CurrentSegment.Start, 1), s = this.FindPerpendicularSlot(e.CurrentSegment.End, -1), n = this.FindPerpendicularSlot(t, 0);
    i >= s || (this.AddSlotToSegmentIntersections(e, i), this.AddSlotToSegmentIntersections(e, s), n > i && n < s && (this.AddSlotToSegmentIntersections(e, n), this.AddBinaryDivisionSlotsToSegmentIntersections(e, i, n, s)));
  }
  // These are called when the site may not be in the vector.
  FindPerpendicularSlot(t, e) {
    return Se.FindIntersectingSlot(this.perpendicularSegmentVector, this.perpendicularCoordMap, t, e);
  }
  static FindIntersectingSlot(t, e, i, s) {
    const n = t.GetParallelCoord(i), r = e.get(n);
    return r !== void 0 ? r : s === 0 ? -1 : t.FindNearest(n, s);
  }
  AddSlotToSegmentIntersections(t, e) {
    const i = this.perpendicularSegmentVector.Item(e);
    t.CurrentSegment.AddSparseVertexCoord(i.Coord), i.AddPerpendicularCoord(t.Coord);
  }
  AddBinaryDivisionSlotsToSegmentIntersections(t, e, i, s) {
    let n = 0, r = this.perpendicularSegmentVector.Length - 1;
    for (; r - n > 1; ) {
      const o = n + Math.floor((r - n) / 2);
      if (i <= o) {
        r = o, i < r && r <= s && this.AddSlotToSegmentIntersections(t, r);
        continue;
      }
      n = o, i > n && n >= e && this.AddSlotToSegmentIntersections(t, n);
    }
  }
  // Create the ScanSegmentTrees that functions as indexes for port-visibility splicing.
  CreateScanSegmentTrees() {
    Se.CreateScanSegmentTree(this.horizontalScanSegmentVector, this.HorizontalScanSegments), Se.CreateScanSegmentTree(this.verticalScanSegmentVector, this.VerticalScanSegments);
  }
  static CreateScanSegmentTree(t, e) {
    for (const i of t.Items())
      for (let s = i.FirstSegment; s != null; s = s.NextSegment)
        s.HasVisibility() && e.InsertUnique(s);
  }
}
class me {
  get ObstacleTree() {
    return this.GraphGenerator.ObstacleTree;
  }
  get VisGraph() {
    return this.GraphGenerator.VisibilityGraph;
  }
  get IsSparseVg() {
    return this.GraphGenerator instanceof Se;
  }
  constructor(t) {
    this.AddedVertices = new Array(), this.AddedEdges = new Array(), this.edgesToRestore = new Array(), this.LimitPortVisibilitySpliceToEndpointBoundingBox = !1, this.GraphGenerator = t;
  }
  AddVertex(t) {
    const e = this.VisGraph.AddVertexP(t);
    return this.AddedVertices.push(e), e;
  }
  FindOrAddVertex(t) {
    const e = this.VisGraph.FindVertex(t);
    return e ?? this.AddVertex(t);
  }
  FindOrAddEdgeVV(t, e) {
    return this.FindOrAddEdge(t, e, W.NormalWeight);
  }
  FindOrAddEdge(t, e, i) {
    const s = b.GetPureDirectionVV(t, e), n = {
      bracketSource: void 0,
      bracketTarget: void 0,
      splitVertex: void 0
    };
    me.GetBrackets(t, e, s, n);
    let r = this.VisGraph.FindEdgePP(n.bracketSource.point, n.bracketTarget.point);
    return r = r != null ? this.SplitEdge(r, n.splitVertex) : this.CreateEdge(n.bracketSource, n.bracketTarget, i), r;
  }
  static GetBrackets(t, e, i, s) {
    if (s.splitVertex = e, !me.FindBracketingVertices(t, e.point, i, s)) {
      const n = {
        bracketSource: null,
        bracketTarget: null
      };
      me.FindBracketingVertices(e, t.point, E.OppositeDir(i), n) && (s.bracketSource = n.bracketTarget, s.splitVertex = t), s.bracketTarget = n.bracketSource;
    }
  }
  static FindBracketingVertices(t, e, i, s) {
    for (s.bracketSource = t; s.bracketTarget = O.FindAdjacentVertex(s.bracketSource, i), s.bracketTarget != null; ) {
      if (u.closeDistEps(s.bracketTarget.point, e))
        return !0;
      if (i !== b.GetDirections(s.bracketTarget.point, e))
        break;
      s.bracketSource = s.bracketTarget;
    }
    return s.bracketTarget != null;
  }
  // DEVTRACE
  // ReSharper restore InconsistentNaming
  CreateEdge(t, e, i) {
    let s = t, n = e;
    b.IsPureLower(s.point, n.point) || (s = e, n = t);
    const r = new pi(s, n, i);
    return wt.AddEdge(r), this.AddedEdges.push(r), r;
  }
  RemoveFromGraph() {
    this.RemoveAddedVertices(), this.RemoveAddedEdges(), this.RestoreRemovedEdges();
  }
  RemoveAddedVertices() {
    for (const t of this.AddedVertices)
      this.VisGraph.FindVertex(t.point) != null && this.VisGraph.RemoveVertex(t);
    this.AddedVertices = [];
  }
  RemoveAddedEdges() {
    for (const t of this.AddedEdges)
      this.VisGraph.FindVertex(t.SourcePoint) != null && wt.RemoveEdge(t);
    this.AddedEdges = [];
  }
  RestoreRemovedEdges() {
    for (const t of this.edgesToRestore)
      wt.AddEdge(t);
    this.edgesToRestore = [];
  }
  FindNextEdge(t, e) {
    return O.FindAdjacentEdge(t, e);
  }
  FindPerpendicularOrContainingEdge(t, e, i) {
    for (; ; ) {
      const s = O.FindAdjacentVertex(t, e);
      if (s == null)
        break;
      const n = b.GetDirections(s.point, i);
      if ((E.OppositeDir(e) & n) !== 0)
        return this.VisGraph.FindEdgePP(t.point, s.point);
      t = s;
    }
    return null;
  }
  FindNearestPerpendicularOrContainingEdge(t, e, i) {
    let s;
    e & b.GetDirections(t.point, i);
    let n = t;
    const r = s;
    for (; S.None !== r; ) {
      const l = O.FindAdjacentVertex(n, s);
      if (l == null || (E.OppositeDir(s) & b.GetDirections(l.point, i)) !== 0)
        break;
      n = l, e & b.GetDirections(n.point, i);
    }
    let o;
    for (; o = this.FindPerpendicularOrContainingEdge(n, e, i), !(o != null || n === t); )
      n = O.FindAdjacentVertex(n, E.OppositeDir(s));
    return o;
  }
  ConnectVertexToTargetVertex(t, e, i, s) {
    if (u.closeDistEps(t.point, e.point))
      return;
    const n = b.GetDirections(t.point, e.point);
    if (b.IsPureDirectionD(n)) {
      this.FindOrAddEdgeVV(t, e);
      return;
    }
    const r = O.FindBendPointBetween(t.point, e.point, i), o = this.FindOrAddVertex(r);
    this.FindOrAddEdge(t, o, s), this.FindOrAddEdge(o, e, s);
  }
  AddEdgeToTargetEdge(t, e, i) {
    let s = this.VisGraph.FindVertex(i);
    return s == null && (s = this.AddVertex(i), this.SplitEdge(e, s)), this.FindOrAddEdgeVV(t, s), s;
  }
  SplitEdge(t, e) {
    return t == null ? null : u.closeDistEps(t.Source.point, e.point) || u.closeDistEps(t.Target.point, e.point) ? t : (t instanceof pi || this.edgesToRestore.push(t), wt.RemoveEdge(t), (this.IsSparseVg || t.Weight === W.OverlappedWeight) && e.Degree > 0 ? (this.FindOrAddEdge(e, t.Source, t.Weight), this.FindOrAddEdge(e, t.Target, t.Weight)) : (this.CreateEdge(e, t.Target, t.Weight), this.CreateEdge(t.Source, e, t.Weight)));
  }
  ExtendEdgeChainVRLPB(t, e, i, s, n) {
    const r = b.GetDirections(i.start, i.end);
    if (r === S.None)
      return;
    const o = O.GetRectangleBound(e, r), l = O.IsVerticalD(r) ? u.RoundPoint(new u(t.point.x, o)) : u.RoundPoint(new u(o, t.point.y));
    if (u.closeDistEps(l, t.point) || b.GetDirections(t.point, l) !== r)
      return;
    let h = i;
    b.GetDirections(l, h.end) === r && (h = v.mkPP(h.start, l)), this.ExtendEdgeChain(t, r, h, i, s, n);
  }
  ExtendEdgeChain(t, e, i, s, n, r) {
    if (b.GetDirections(t.point, i.end) !== e)
      return;
    let l = E.RotateLeft(e), h = O.FindAdjacentVertex(t, l);
    if (h == null && (l = E.OppositeDir(l), h = O.FindAdjacentVertex(t, l), h == null))
      return;
    const c = E.OppositeDir(l), d = { spliceTarget: null };
    this.ExtendSpliceWorker(h, e, c, i, s, r, d) && this.ExtendSpliceWorker(d.spliceTarget, e, l, i, s, r, d), this.SpliceGroupBoundaryCrossings(n, t, i);
  }
  SpliceGroupBoundaryCrossings(t, e, i) {
    if (t == null || t.Count() === 0)
      return;
    t.Reset();
    let s = i.start, n = i.end, r = b.GetDirections(s, n);
    O.IsAscending(r) || (s = i.end, n = i.start, r = E.OppositeDir(r)), e = me.TraverseToFirstVertexAtOrAbove(e, s, E.OppositeDir(r));
    for (let o = e; o != null; o = O.FindAdjacentVertex(o, r)) {
      const l = b.ComparePP(o.point, n) >= 0;
      for (; t.CurrentIsBeforeOrAt(o.point); ) {
        const h = t.Pop();
        b.ComparePP(h.Location, e.point) > 0 && b.ComparePP(h.Location, n) <= 0 && this.SpliceGroupBoundaryCrossing(o, h, E.OppositeDir(r)), b.ComparePP(h.Location, e.point) >= 0 && b.ComparePP(h.Location, n) < 0 && this.SpliceGroupBoundaryCrossing(o, h, r);
      }
      if (l)
        break;
    }
  }
  static TraverseToFirstVertexAtOrAbove(t, e, i) {
    let s = t;
    const n = E.OppositeDir(i);
    for (; ; ) {
      const r = O.FindAdjacentVertex(s, i);
      if (r == null || b.GetDirections(r.point, e) === n)
        break;
      s = r;
    }
    return s;
  }
  SpliceGroupBoundaryCrossing(t, e, i) {
    var s, n;
    const r = Sn.ToCrossingArray(e.Crossings, i);
    if (r != null) {
      const o = (s = this.VisGraph.FindVertex(e.Location)) !== null && s !== void 0 ? s : this.AddVertex(e.Location);
      t.point.equal(o.point) || this.FindOrAddEdgeVV(t, o);
      const l = r[0].GetInteriorVertexPoint(e.Location), h = (n = this.VisGraph.FindVertex(l)) !== null && n !== void 0 ? n : this.AddVertex(l), c = this.FindOrAddEdgeVV(o, h), d = r.map((f) => f.Group.InputShape);
      c.IsPassable = () => d.some((f) => f.IsTransparent);
    }
  }
  // The return value is whether we should try a second pass if this is called on the first pass,
  // using spliceTarget to wrap up dead-ends on the target side.
  ExtendSpliceWorker(t, e, i, s, n, r, o) {
    let l = O.FindAdjacentVertex(t, i);
    o.spliceTarget = O.FindAdjacentVertex(l, i);
    const h = { spliceSource: t };
    for (; me.GetNextSpliceSource(h, i, e); ) {
      const c = O.FindBendPointBetween(l.point, h.spliceSource.point, E.OppositeDir(i));
      if (me.IsPointPastSegmentEnd(n, c))
        break;
      if (o.spliceTarget = me.GetSpliceTarget(h, i, c), o.spliceTarget == null) {
        if (this.IsSkippableSpliceSourceWithNullSpliceTarget(h.spliceSource, e))
          continue;
        if (this.ObstacleTree.SegmentCrossesAnObstacle(h.spliceSource.point, c))
          return !1;
      }
      let d = this.VisGraph.FindVertex(c);
      if (d != null) {
        if (o.spliceTarget == null || this.VisGraph.FindEdgePP(l.point, c) != null)
          return o.spliceTarget == null && this.FindOrAddEdge(l, d, r ? W.OverlappedWeight : W.NormalWeight), !1;
      } else
        d = this.AddVertex(c);
      if (this.FindOrAddEdge(l, d, r ? W.OverlappedWeight : W.NormalWeight), this.FindOrAddEdge(h.spliceSource, d, r ? W.OverlappedWeight : W.NormalWeight), r && (r = this.SeeIfSpliceIsStillOverlapped(e, d)), l = d, (e & b.GetDirections(c, s.end)) === 0) {
        o.spliceTarget = null;
        break;
      }
    }
    return o.spliceTarget != null;
  }
  static GetNextSpliceSource(t, e, i) {
    let s = O.FindAdjacentVertex(t.spliceSource, i);
    if (s == null)
      for (s = t.spliceSource; ; ) {
        if (s = O.FindAdjacentVertex(s, E.OppositeDir(e)), s == null)
          return !1;
        const n = O.FindAdjacentVertex(s, i);
        if (n != null) {
          s = n;
          break;
        }
      }
    return t.spliceSource = s, !0;
  }
  static GetSpliceTarget(t, e, i) {
    const s = b.GetDirections(t.spliceSource.point, i);
    let n = s, r = t.spliceSource;
    for (; n === s && (t.spliceSource = r, r = O.FindAdjacentVertex(t.spliceSource, e), r != null); ) {
      if (u.closeDistEps(r.point, i)) {
        r = O.FindAdjacentVertex(r, e);
        break;
      }
      n = b.GetDirections(r.point, i);
    }
    return r;
  }
  SeeIfSpliceIsStillOverlapped(t, e) {
    let i = this.FindNextEdge(e, E.RotateLeft(t)), s = i == null ? !1 : W.NormalWeight === i.Weight;
    return s || (i = this.FindNextEdge(e, E.RotateRight(t)), s = i == null ? !1 : W.NormalWeight === i.Weight), !s || this.ObstacleTree.PointIsInsideAnObstaclePD(e.point, t);
  }
  IsSkippableSpliceSourceWithNullSpliceTarget(t, e) {
    if (me.IsSkippableSpliceSourceEdgeWithNullTarget(O.FindAdjacentEdge(t, e)))
      return !0;
    const i = O.FindAdjacentEdge(t, E.OppositeDir(e));
    return me.IsSkippableSpliceSourceEdgeWithNullTarget(i) || me.IsReflectionEdge(i);
  }
  static IsSkippableSpliceSourceEdgeWithNullTarget(t) {
    return t != null && t.IsPassable != null && D(t.Length, ma.BoundaryWidth);
  }
  static IsReflectionEdge(t) {
    return t != null && t.Weight === W.ReflectionWeight;
  }
  static IsPointPastSegmentEnd(t, e) {
    return b.GetDirections(t.start, t.end) === b.GetDirections(t.end, e);
  }
  toString() {
    return Gt.String.format("{0} {1}", this.AddedVertices.length, this.edgesToRestore.length);
  }
}
class vn {
  // Extension of port visibility splices into the visibility graph.
  get LimitPortVisibilitySpliceToEndpointBoundingBox() {
    return this.TransUtil.LimitPortVisibilitySpliceToEndpointBoundingBox;
  }
  set LimitPortVisibilitySpliceToEndpointBoundingBox(t) {
    this.TransUtil.LimitPortVisibilitySpliceToEndpointBoundingBox = t;
  }
  // Typing shortcuts
  get VisGraph() {
    return this.graphGenerator.VisibilityGraph;
  }
  get HScanSegments() {
    return this.graphGenerator.HorizontalScanSegments;
  }
  get VScanSegments() {
    return this.graphGenerator.VerticalScanSegments;
  }
  get ObstacleTree() {
    return this.graphGenerator.ObstacleTree;
  }
  get AncestorSets() {
    return this.ObstacleTree.AncestorSets;
  }
  constructor(t) {
    this.obstaclePortMap = /* @__PURE__ */ new Map(), this.freePointMap = new ii(), this.freePointLocationsUsedByRouteEdges = new xt(), this.RouteToCenterOfObstacles = !1, this.obstaclePortsInGraph = new Array(), this.freePointsInGraph = /* @__PURE__ */ new Set(), this.activeAncestors = new Array(), this.TransUtil = new me(t), this.graphGenerator = t;
  }
  Clear() {
    this.TransUtil.RemoveFromGraph(), this.obstaclePortMap.clear();
  }
  CreateObstaclePorts(t) {
    for (const e of t.Ports)
      this.CreateObstaclePort(t, e);
  }
  CreateObstaclePort(t, e) {
    if (e.Curve == null)
      return null;
    const i = u.RoundPoint(e.Location);
    if (F.Outside === g.PointRelativeToCurveLocation(i, t.InputShape.BoundaryCurve) || t.InputShape.BoundaryCurve !== e.Curve && F.Outside === g.PointRelativeToCurveLocation(i, e.Curve))
      return null;
    const s = new Pf(e, t);
    return this.obstaclePortMap.set(e, s), s;
  }
  FindVertices(t) {
    const e = new Array(), i = this.obstaclePortMap.get(t);
    if (i)
      if (this.RouteToCenterOfObstacles)
        e.push(i.CenterVertex);
      else
        for (const s of i.PortEntrances) {
          const n = this.VisGraph.FindVertex(s.UnpaddedBorderIntersect);
          n != null && e.push(n);
        }
    else
      e.push(this.VisGraph.FindVertex(u.RoundPoint(t.Location)));
    return e;
  }
  RemoveObstaclePorts(t) {
    for (const e of t.Ports)
      this.RemoveObstaclePort(e);
  }
  RemoveObstaclePort(t) {
    this.obstaclePortMap.delete(t);
  }
  // Add path control points - source, target, and any waypoints.
  AddControlPointsToGraph(t, e) {
    this.GetPortSpliceLimitRectangle(t), this.activeAncestors = [];
    const i = { oport: null }, s = { oport: null }, n = this.FindAncestorsAndObstaclePort(t.sourcePort, i), r = this.FindAncestorsAndObstaclePort(t.targetPort, s);
    if (this.AncestorSets.size > 0 && i.oport != null && s.oport != null) {
      const o = zs(r, n), l = zs(n, r);
      this.ActivateAncestors(l, o, e);
    }
    this.AddPortToGraph(t.sourcePort, i.oport), this.AddPortToGraph(t.targetPort, s.oport);
  }
  ConnectOobWaypointToEndpointVisibilityAtGraphBoundary(t, e) {
    if (t == null || !t.IsOutOfBounds)
      return;
    const i = this.FindVertices(e);
    let s = t.OutOfBoundsDirectionFromGraph & (S.North | S.South);
    this.ConnectToGraphAtPointsCollinearWithVertices(t, s, i), s = t.OutOfBoundsDirectionFromGraph & (S.East | S.West), this.ConnectToGraphAtPointsCollinearWithVertices(t, s, i);
  }
  ConnectToGraphAtPointsCollinearWithVertices(t, e, i) {
    if (S.None === e)
      return;
    const s = E.OppositeDir(e);
    for (const n of i) {
      const r = this.InBoundsGraphBoxIntersect(n.point, e), o = this.VisGraph.FindVertex(r);
      o != null && this.TransUtil.ConnectVertexToTargetVertex(t.Vertex, o, s, W.NormalWeight);
    }
  }
  SetAllAncestorsActive(t, e) {
    if (this.AncestorSets.size === 0)
      return !1;
    this.ObstacleTree.AdjustSpatialAncestors(), this.ClearActiveAncestors();
    const i = { oport: null }, s = { oport: null }, n = this.FindAncestorsAndObstaclePort(t.sourcePort, s), r = this.FindAncestorsAndObstaclePort(t.targetPort, i);
    return this.AncestorSets.size > 0 && n != null && r != null ? (this.ActivateAncestors(n, r, e), !0) : !1;
  }
  SetAllGroupsActive() {
    this.ClearActiveAncestors();
    for (const t of this.ObstacleTree.GetAllGroups())
      t.IsTransparentAncestor = !0, this.activeAncestors.push(t);
  }
  FindAncestorsAndObstaclePort(t, e) {
    return e.oport = this.FindObstaclePort(t), this.AncestorSets.size === 0 ? null : e.oport != null ? this.AncestorSets.get(e.oport.Obstacle.InputShape) : new Set(Array.from(this.ObstacleTree.Root.AllHitItems(T.mkPP(t.Location, t.Location), (i) => i.IsGroup)).map((i) => i.InputShape));
  }
  ActivateAncestors(t, e, i) {
    for (const s of js(t, e)) {
      const n = i.get(s);
      n.IsTransparentAncestor = !0, this.activeAncestors.push(n);
    }
  }
  ClearActiveAncestors() {
    for (const t of this.activeAncestors)
      t.IsTransparentAncestor = !1;
    this.activeAncestors = [];
  }
  RemoveControlPointsFromGraph() {
    this.ClearActiveAncestors(), this.RemoveObstaclePortsFromGraph(), this.RemoveFreePointsFromGraph(), this.TransUtil.RemoveFromGraph(), this.portSpliceLimitRectangle = T.mkEmpty();
  }
  RemoveObstaclePortsFromGraph() {
    for (const t of this.obstaclePortsInGraph)
      t.RemoveFromGraph();
    this.obstaclePortsInGraph = [];
  }
  RemoveFreePointsFromGraph() {
    for (const t of this.freePointsInGraph)
      t.RemoveFromGraph();
    this.freePointsInGraph.clear();
  }
  RemoveStaleFreePoints() {
    if (this.freePointMap.size > this.freePointLocationsUsedByRouteEdges.size) {
      const t = Array.from(this.freePointMap).filter((e) => !this.freePointLocationsUsedByRouteEdges.has(e[0]));
      for (const e of t)
        this.freePointMap.deleteP(e[0]);
    }
  }
  ClearVisibility() {
    this.freePointMap.clear();
    for (const t of this.obstaclePortMap.values())
      t.ClearVisibility();
  }
  BeginRouteEdges() {
    this.RemoveControlPointsFromGraph(), this.freePointLocationsUsedByRouteEdges.clear();
  }
  EndRouteEdges() {
    this.RemoveStaleFreePoints();
  }
  FindObstaclePort(t) {
    let e = this.obstaclePortMap.get(t);
    if (e) {
      const i = {
        removedPorts: null,
        addedPorts: null
      };
      if (e.Obstacle.GetPortChanges(i)) {
        for (const s of i.addedPorts)
          this.CreateObstaclePort(e.Obstacle, s);
        for (const s of i.removedPorts)
          this.RemoveObstaclePort(s);
        e = this.obstaclePortMap.get(t);
      }
    }
    return e;
  }
  AddPortToGraph(t, e) {
    if (e != null) {
      this.AddObstaclePortToGraph(e);
      return;
    }
    this.AddFreePointToGraph(t.Location);
  }
  AddObstaclePortToGraph(t) {
    if (!(t.LocationHasChanged && (this.RemoveObstaclePort(t.Port), t = this.CreateObstaclePort(t.Obstacle, t.Port), t == null))) {
      t.AddToGraph(this.TransUtil, this.RouteToCenterOfObstacles), this.obstaclePortsInGraph.push(t), this.CreateObstaclePortEntrancesIfNeeded(t);
      for (const e of t.PortEntrances)
        this.AddObstaclePortEntranceToGraph(e);
    }
  }
  CreateObstaclePortEntrancesIfNeeded(t) {
    t.PortEntrances.length > 0 || this.CreateObstaclePortEntrancesFromPoints(t);
  }
  GetPortVisibilityIntersection(t) {
    const e = this.FindObstaclePort(t.sourcePort), i = this.FindObstaclePort(t.targetPort);
    if (e == null || i == null || e.Obstacle.IsInConvexHull || i.Obstacle.IsInConvexHull || (this.CreateObstaclePortEntrancesIfNeeded(e), this.CreateObstaclePortEntrancesIfNeeded(i), !e.VisibilityRectangle.intersects(i.VisibilityRectangle)))
      return null;
    for (const s of e.PortEntrances)
      if (s.WantVisibilityIntersection)
        for (const n of i.PortEntrances) {
          if (!n.WantVisibilityIntersection)
            continue;
          const r = s.IsVertical === n.IsVertical ? vn.GetPathPointsFromOverlappingCollinearVisibility(s, n) : vn.GetPathPointsFromIntersectingVisibility(s, n);
          if (r != null)
            return r;
        }
    return null;
  }
  static GetPathPointsFromOverlappingCollinearVisibility(t, e) {
    return !O.IntervalsAreSame(t.MaxVisibilitySegment.start, t.MaxVisibilitySegment.end, e.MaxVisibilitySegment.end, e.MaxVisibilitySegment.start) || t.HasGroupCrossings || e.HasGroupCrossings || u.closeDistEps(t.UnpaddedBorderIntersect, e.UnpaddedBorderIntersect) ? null : [t.UnpaddedBorderIntersect, e.UnpaddedBorderIntersect];
  }
  static GetPathPointsFromIntersectingVisibility(t, e) {
    const i = O.SegmentsIntersectLL(t.MaxVisibilitySegment, e.MaxVisibilitySegment);
    return !i || t.HasGroupCrossingBeforePoint(i) || e.HasGroupCrossingBeforePoint(i) ? null : [t.UnpaddedBorderIntersect, i, e.UnpaddedBorderIntersect];
  }
  CreateObstaclePortEntrancesFromPoints(t) {
    const e = this.graphGenerator.ObstacleTree.GraphBox, i = T.mkPP(u.RoundPoint(t.PortCurve.boundingBox.leftBottom), u.RoundPoint(t.PortCurve.boundingBox.rightTop)), s = u.RoundPoint(t.PortLocation);
    let n = !1;
    const r = { xx0: null, xx1: null };
    if (!b.Equal(s.y, i.top) && !b.Equal(s.y, i.bottom)) {
      n = !0;
      const o = new v(e.left, s.y, e.right, s.y);
      this.GetBorderIntersections(s, o, t.PortCurve, r);
      let l = new u(Math.min(r.xx0.x, r.xx1.x), s.y);
      l.x < i.left && (l = new u(i.left, l.y));
      let h = new u(Math.max(r.xx0.x, r.xx1.x), s.y);
      h.x > i.right && (h = new u(i.right, h.y)), this.CreatePortEntrancesAtBorderIntersections(i, t, s, l, h);
    }
    if (!b.Equal(s.x, i.left) && !b.Equal(s.x, i.right)) {
      n = !0;
      const o = new v(s.x, e.bottom, s.x, e.top);
      this.GetBorderIntersections(s, o, t.PortCurve, r);
      let l = new u(s.x, Math.min(r.xx0.y, r.xx1.y));
      l.y < e.bottom && (l = new u(l.x, e.bottom));
      let h = new u(s.x, Math.max(r.xx0.y, r.xx1.y));
      h.y > e.top && (h = new u(h.x, e.top)), this.CreatePortEntrancesAtBorderIntersections(i, t, s, l, h);
    }
    n || this.CreateEntrancesForCornerPort(i, t, s);
  }
  GetBorderIntersections(t, e, i, s) {
    const n = g.getAllIntersections(e, i, !0);
    s.xx0 = u.RoundPoint(n[0].x), s.xx1 = u.RoundPoint(n[1].x);
  }
  CreatePortEntrancesAtBorderIntersections(t, e, i, s, n) {
    const r = b.GetDirections(s, n);
    b.EqualPP(s, i) || this.CreatePortEntrance(t, e, n, r), b.EqualPP(n, i) || this.CreatePortEntrance(t, e, s, E.OppositeDir(r));
  }
  static GetDerivative(t, e) {
    const i = t.PortCurve.closestParameter(e);
    let s = t.PortCurve.derivative(i);
    const n = (t.PortCurve.parStart + t.PortCurve.parEnd) / 2;
    return G.CurveIsClockwise(t.PortCurve, t.PortCurve.value(n)) || (s = s.mul(-1)), s;
  }
  CreatePortEntrance(t, e, i, s) {
    e.CreatePortEntrance(i, s, this.ObstacleTree);
    const n = Pt.GetInstance(s);
    let r = O.GetRectangleBound(t, s) - n.Coord(i);
    if (r < 0 && (r = -r), r > m.intersectionEpsilon) {
      const o = E.VectorDirection(vn.GetDerivative(e, i));
      let l;
      s | E.OppositeDir(s), S.None !== (s & o) && (l = E.OppositeDir(l)), e.CreatePortEntrance(i, l, this.ObstacleTree);
    }
  }
  CreateEntrancesForCornerPort(t, e, i) {
    let s = S.North;
    b.EqualPP(i, t.leftBottom) ? s = S.South : b.EqualPP(i, t.leftTop) ? s = S.West : b.EqualPP(i, t.rightTop) ? s = S.North : b.EqualPP(i, t.rightBottom) && (s = S.East), e.CreatePortEntrance(i, s, this.ObstacleTree), e.CreatePortEntrance(i, E.RotateRight(s), this.ObstacleTree);
  }
  AddObstaclePortEntranceToGraph(t) {
    const e = this.VisGraph.FindVertex(t.VisibilityBorderIntersect);
    if (e) {
      t.ExtendEdgeChain(this.TransUtil, e, e, this.portSpliceLimitRectangle, this.RouteToCenterOfObstacles);
      return;
    }
    const i = { targetVertex: null }, s = t.IsOverlapped ? W.OverlappedWeight : W.NormalWeight;
    this.FindorCreateNearestPerpEdgePPDNT(t.MaxVisibilitySegment.end, t.VisibilityBorderIntersect, t.OutwardDirection, s, i) != null && t.AddToAdjacentVertex(this.TransUtil, i.targetVertex, this.portSpliceLimitRectangle, this.RouteToCenterOfObstacles);
  }
  InBoundsGraphBoxIntersect(t, e) {
    return O.RectangleBorderIntersect(this.graphGenerator.ObstacleTree.GraphBox, t, e);
  }
  FindorCreateNearestPerpEdgePPDN(t, e, i, s) {
    const n = { targetVertex: null };
    return this.FindorCreateNearestPerpEdgePPDNT(t, e, i, s, n);
  }
  FindorCreateNearestPerpEdgePPDNT(t, e, i, s, n) {
    const r = O.SortAscending(t, e), o = r[0], l = r[1], h = O.IsVerticalD(i) ? this.HScanSegments : this.VScanSegments, c = O.IsAscending(i) ? h.FindLowestIntersector(o, l) : h.FindHighestIntersector(o, l);
    if (c == null)
      return n.targetVertex = null, null;
    const d = O.SegmentIntersectionSP(c, o);
    return this.FindOrCreateNearestPerpEdgeFromNearestPerpSegment(O.IsAscending(i) ? o : l, c, d, s, n);
  }
  FindOrCreateNearestPerpEdgeFromNearestPerpSegment(t, e, i, s, n) {
    var r;
    const o = {
      segsegVertex: this.VisGraph.FindVertex(i),
      targetVertex: null
    };
    if (o.segsegVertex == null) {
      const d = this.FindOrCreateSegmentIntersectionVertexAndAssociatedEdge(t, i, e, s, o);
      if (d != null)
        return d;
    } else if (b.EqualPP(t, i))
      return n.targetVertex = o.segsegVertex, this.TransUtil.FindNextEdge(n.targetVertex, E.OppositeDir(e.ScanDirection.Dir));
    const l = b.GetDirections(i, t);
    let h = b.GetDirections(o.segsegVertex.point, t);
    if (l === h) {
      const d = { bracketTarget: null, bracketSource: null };
      return me.FindBracketingVertices(o.segsegVertex, t, l, d), (r = this.TransUtil.FindNextEdge(d.bracketSource, E.RotateLeft(l))) !== null && r !== void 0 ? r : this.TransUtil.FindNextEdge(d.bracketSource, E.RotateRight(l));
    }
    h &= ~l;
    const c = this.TransUtil.FindNearestPerpendicularOrContainingEdge(o.segsegVertex, h, t);
    return c == null ? (n.targetVertex = this.TransUtil.AddVertex(i), this.TransUtil.FindOrAddEdge(n.targetVertex, e.HighestVisibilityVertex, e.Weight)) : (o.segsegVertex = O.GetEdgeEnd(c, E.OppositeDir(h)), i = O.SegmentIntersectionPPP(t, i, o.segsegVertex.point), b.EqualPP(o.segsegVertex.point, i) ? (n.targetVertex = o.segsegVertex, this.TransUtil.FindNextEdge(o.segsegVertex, h)) : (n.targetVertex = this.TransUtil.FindOrAddVertex(i), this.TransUtil.FindOrAddEdge(o.segsegVertex, n.targetVertex, s)));
  }
  FindOrCreateSegmentIntersectionVertexAndAssociatedEdge(t, e, i, s, n) {
    const o = (i.IsVertical ? this.HScanSegments : this.VScanSegments).FindHighestIntersector(i.Start, e);
    if (o == null)
      return n.segsegVertex = null, n.targetVertex = this.TransUtil.AddVertex(e), this.TransUtil.FindOrAddEdge(n.targetVertex, i.LowestVisibilityVertex, i.Weight);
    const l = O.SegmentsIntersection(i, o);
    if (n.segsegVertex = this.VisGraph.FindVertex(l), !n.segsegVertex) {
      n.segsegVertex = this.TransUtil.AddVertex(l);
      const h = this.AddEdgeToClosestSegmentEnd(i, n.segsegVertex, i.Weight);
      if (this.AddEdgeToClosestSegmentEnd(o, n.segsegVertex, o.Weight), b.EqualPP(n.segsegVertex.point, e))
        return n.targetVertex = n.segsegVertex, h;
    }
    return b.EqualPP(t, e) ? (n.targetVertex = this.TransUtil.FindOrAddVertex(e), this.TransUtil.FindOrAddEdge(n.segsegVertex, n.targetVertex, s)) : (n.targetVertex = null, null);
  }
  AddEdgeToClosestSegmentEnd(t, e, i) {
    return b.IsPureLower(t.HighestVisibilityVertex.point, e.point) ? this.TransUtil.FindOrAddEdge(t.HighestVisibilityVertex, e, i) : b.IsPureLower(e.point, t.LowestVisibilityVertex.point) ? this.TransUtil.FindOrAddEdge(e, t.LowestVisibilityVertex, i) : this.TransUtil.FindOrAddEdgeVV(t.LowestVisibilityVertex, e);
  }
  GetPortSpliceLimitRectangle(t) {
    if (!this.LimitPortVisibilitySpliceToEndpointBoundingBox) {
      this.portSpliceLimitRectangle = this.graphGenerator.ObstacleTree.GraphBox;
      return;
    }
    this.portSpliceLimitRectangle = this.GetPortRectangle(t.sourcePort), this.portSpliceLimitRectangle.addRecSelf(this.GetPortRectangle(t.targetPort));
  }
  GetPortRectangle(t) {
    const e = this.obstaclePortMap.get(t);
    return e ? e.Obstacle.VisibilityBoundingBox.clone() : T.mkOnPoints([u.RoundPoint(t.Location)]);
  }
  AddToLimitRectangle(t) {
    this.graphGenerator.IsInBoundsP(t) && this.portSpliceLimitRectangle.add(t);
  }
  FindOrCreateFreePoint(t) {
    let e = this.freePointMap.get(t);
    return e ? e.GetVertex(this.TransUtil, t) : (e = new Sf(this.TransUtil, t), this.freePointMap.set(t, e)), this.freePointsInGraph.add(e), this.freePointLocationsUsedByRouteEdges.add(t), e;
  }
  // This is private because it depends on LimitRectangle
  AddFreePointToGraph(t) {
    t = u.RoundPoint(t);
    const e = this.VisGraph.FindVertex(t), i = this.FindOrCreateFreePoint(t);
    if (e != null)
      return i;
    if (!this.graphGenerator.IsInBoundsP(t))
      return this.CreateOutOfBoundsFreePoint(i), i;
    i.IsOverlapped = this.ObstacleTree.PointIsInsideAnObstacle(i.Point, this.HScanSegments.ScanDirection), this.VScanSegments.FindSegmentContainingPoint(t, !0);
    let s = S.South;
    for (let n = 0; n < 4; n++)
      this.ConnectFreePointToLateralEdge(i, s), s = E.RotateLeft(s);
    return i;
  }
  CreateOutOfBoundsFreePoint(t) {
    const e = t.Point, i = this.graphGenerator.MakeInBoundsLocation(e), s = b.GetDirections(i, e);
    if (t.OutOfBoundsDirectionFromGraph = s, !b.IsPureDirectionD(s)) {
      t.AddOobEdgesFromGraphCorner(this.TransUtil, i);
      return;
    }
    let n = this.VisGraph.FindVertex(i);
    const r = E.OppositeDir(s);
    if (n != null)
      t.AddToAdjacentVertex(this.TransUtil, n, r, this.portSpliceLimitRectangle);
    else {
      const h = this.FindorCreateNearestPerpEdgePPDN(e, i, s, W.NormalWeight);
      h != null && (n = t.AddEdgeToAdjacentEdge(this.TransUtil, h, r, this.portSpliceLimitRectangle));
    }
    const o = O.FindAdjacentVertex(n, E.RotateLeft(r));
    o != null && this.TransUtil.ConnectVertexToTargetVertex(t.Vertex, o, r, W.NormalWeight);
    const l = O.FindAdjacentVertex(n, E.RotateRight(r));
    l != null && this.TransUtil.ConnectVertexToTargetVertex(t.Vertex, l, r, W.NormalWeight);
  }
  ConnectFreePointToLateralEdge(t, e) {
    const i = t.IsOverlapped ? this.InBoundsGraphBoxIntersect(t.Point, e) : t.MaxVisibilityInDirectionForNonOverlappedFreePoint(e, this.TransUtil), s = this.FindorCreateNearestPerpEdgePPDN(i, t.Point, e, t.InitialWeight);
    s != null && t.AddEdgeToAdjacentEdge(this.TransUtil, s, e, this.portSpliceLimitRectangle);
  }
}
class bt extends ht {
  // If true, route to obstacle centers.  Initially false for greater accuracy with the current
  // MultiSourceMultiTarget approach.
  get RouteToCenterOfObstacles() {
    return this.PortManager.RouteToCenterOfObstacles;
  }
  set RouteToCenterOfObstacles(t) {
    this.PortManager.RouteToCenterOfObstacles = t;
  }
  // If true, limits the extension of port visibility splices into the visibility graph to the rectangle defined by
  // the path endpoints.
  get LimitPortVisibilitySpliceToEndpointBoundingBox() {
    return this.PortManager.LimitPortVisibilitySpliceToEndpointBoundingBox;
  }
  set LimitPortVisibilitySpliceToEndpointBoundingBox(t) {
    this.PortManager.LimitPortVisibilitySpliceToEndpointBoundingBox = t;
  }
  // Add an GeomEdge to route
  AddEdgeGeometryToRoute(t) {
    u.closeDistEps(u.RoundPoint(t.sourcePort.Location), u.RoundPoint(t.targetPort.Location)) ? this.selfEdges.push(t) : this.EdgesToRoute.push(t);
  }
  // Array all edge routing specifications that are currently active.  We want to hide access to the
  // Array itself so people don't add or remove items directly.
  get EdgeGeometriesToRoute() {
    return this.EdgesToRoute;
  }
  // Remove all EdgeGeometries to route
  RemoveAllEdgeGeometriesToRoute() {
    this.EdgesToRoute = [];
  }
  // If true, this router uses a sparse visibility graph, which saves memory for large graphs but
  // may choose suboptimal paths.  Set on constructor.
  get UseSparseVisibilityGraph() {
    return this.GraphGenerator instanceof Se;
  }
  get Obstacles() {
    return Array.from(this.ShapeToObstacleMap.values()).map((t) => t.InputShape);
  }
  // The collection of padded obstacle boundary polylines around the input shapes to route around.
  get PaddedObstacles() {
    return Array.from(this.ShapeToObstacleMap.values()).map((t) => t.PaddedPolyline);
  }
  // Add obstacles to the router.
  AddObstacles(t) {
    this.AddShapes(t), this.RebuildTreeAndGraph();
  }
  AddShapes(t) {
    for (const e of t)
      this.AddObstacleWithoutRebuild(e);
  }
  // Add a single obstacle to the router.
  AddObstacle(t) {
    this.AddObstacleWithoutRebuild(t), this.RebuildTreeAndGraph();
  }
  // For each Shapes, update its position and reroute as necessary.
  UpdateObstacles(t) {
    for (const e of t)
      this.UpdateObstacleWithoutRebuild(e);
    this.RebuildTreeAndGraph();
  }
  // For each Shapes, update its position and reroute as necessary.
  UpdateObstacle(t) {
    this.UpdateObstacleWithoutRebuild(t), this.RebuildTreeAndGraph();
  }
  // Remove obstacles from the router.
  RemoveObstacles(t) {
    for (const e of t)
      this.RemoveObstacleWithoutRebuild(e);
    this.RebuildTreeAndGraph();
  }
  // Removes an obstacle from the router.
  // <returns>All EdgeGeometries affected by the re-routing and re-nudging in order to avoid the new obstacle.</returns>
  RemoveObstacle(t) {
    this.RemoveObstacleWithoutRebuild(t), this.RebuildTreeAndGraph();
  }
  // utilities
  AddObstacleWithoutRebuild(t) {
    if (t.BoundaryCurve == null)
      throw new Error("Shape must have a BoundaryCurve");
    this.CreatePaddedObstacle(t);
  }
  UpdateObstacleWithoutRebuild(t) {
    if (t.BoundaryCurve == null)
      throw new Error("Shape must have a BoundaryCurve");
    this.PortManager.RemoveObstaclePorts(this.ShapeToObstacleMap.get(t)), this.CreatePaddedObstacle(t);
  }
  CreatePaddedObstacle(t) {
    const e = new Ot(t, this.Padding);
    this.ShapeToObstacleMap.set(t, e), this.PortManager.CreateObstaclePorts(e);
  }
  RemoveObstacleWithoutRebuild(t) {
    const e = this.ShapeToObstacleMap.get(t);
    this.ShapeToObstacleMap.delete(t), this.PortManager.RemoveObstaclePorts(e);
  }
  // Remove all obstacles from the graph.
  RemoveAllObstacles() {
    this.InternalClear(
      /* retainObstacles:*/
      !1
    );
  }
  RebuildTreeAndGraph() {
    const t = this.ObsTree.Root != null, e = this.GraphGenerator.VisibilityGraph != null;
    this.InternalClear(
      /* retainObstacles:*/
      !0
    ), t && this.GenerateObstacleTree(), e && this.GenerateVisibilityGraph();
  }
  // The visibility graph generated by GenerateVisibilityGraph.
  get VisibilityGraph() {
    return this.GenerateVisibilityGraph(), this.GraphGenerator.VisibilityGraph;
  }
  // Clears all data set into the router.
  Clear() {
    this.InternalClear(
      /* retainObstacles:*/
      !1
    );
  }
  static constructorEmpty() {
    return bt.constructorC(null);
  }
  static constructorC(t) {
    return new bt([], bt.DefaultPadding, bt.DefaultCornerFitRadius);
  }
  // Constructor that takes the obstacles but uses defaults for other arguments.
  // as well as any intervening obstacles.</param>
  static constructorI(t) {
    return new bt(t, bt.DefaultPadding, bt.DefaultCornerFitRadius);
  }
  // Constructor for a router that does not use obstacle rectangles in the visibility graph.
  // as well as any intervening obstacles.</param>
  // The minimum padding from an obstacle's curve to its enclosing polyline.
  // The radius of the arc inscribed into path corners
  // but may select suboptimal paths</param>
  static constructorINN(t, e, i) {
    return new bt(t, e, i);
  }
  // Constructor specifying graph and shape information.
  // as well as any intervening obstacles.</param>
  // The minimum padding from an obstacle's curve to its enclosing polyline.
  // The radius of the arc inscribed into path corners
  // but may select suboptimal paths</param>
  // Use obstacle bounding boxes in visibility graph
  constructor(t, e, i) {
    super(null), this.Padding = 0, this.CornerFitRadius = 0, this.edgeSeparatian = 3, this.BendPenaltyAsAPercentageOfDistance = 0, this.ShapeToObstacleMap = /* @__PURE__ */ new Map(), this.EdgesToRoute = new Array(), this.removeStaircases = !0, this.selfEdges = new Array(), this.Padding = e, this.CornerFitRadius = i, this.BendPenaltyAsAPercentageOfDistance = K.DefaultBendPenaltyAsAPercentageOfDistance, this.GraphGenerator = new Se(), this.PortManager = new vn(this.GraphGenerator), this.AddShapes(t);
  }
  // The graph whose edges are being routed.
  // The minimum padding from an obstacle's curve to its enclosing polyline.
  // The radius of the arc inscribed into path corners
  // but may select suboptimal paths</param>
  // If true, use obstacle bounding boxes in visibility graph
  static constructorGNAN(t, e, i, s) {
    const n = new bt(le.GetShapes(t), i, s);
    if (e == null)
      for (const r of t.deepEdges)
        n.AddEdgeGeometryToRoute(r);
    else
      for (const r of e)
        n.AddEdgeGeometryToRoute(r);
    return n;
  }
  // Executes the algorithm.
  // Calculates the routed edges geometry, optionally forcing re-routing for existing paths.
  run() {
    this.GenerateVisibilityGraph(), this.GeneratePaths();
  }
  GeneratePaths() {
    const t = this.EdgesToRoute.map((e) => new pf(e));
    this.FillEdgePathsWithShortestPaths(t), this.NudgePaths(t), this.RouteSelfEdges(), this.FinaliseEdgeGeometries();
  }
  RouteSelfEdges() {
    for (const t of this.selfEdges) {
      const e = { smoothedPolyline: null };
      t.curve = Kt.RouteSelfEdge(t.sourcePort.Curve, Math.max(this.Padding, 2 * t.GetMaxArrowheadLength()), e);
    }
  }
  FillEdgePathsWithShortestPaths(t) {
    this.PortManager.BeginRouteEdges();
    const e = new yn(this.BendPenaltyAsAPercentageOfDistance);
    for (const i of t)
      this.AddControlPointsAndGeneratePath(e, i);
    this.PortManager.EndRouteEdges();
  }
  AddControlPointsAndGeneratePath(t, e) {
    const i = this.PortManager.GetPortVisibilityIntersection(e.GeomEdge);
    if (i != null) {
      this.GeneratePathThroughVisibilityIntersection(e, i);
      return;
    }
    this.SpliceVisibilityAndGeneratePath(t, e);
  }
  GeneratePathThroughVisibilityIntersection(t, e) {
    t.PathPoints = e;
  }
  SpliceVisibilityAndGeneratePath(t, e) {
    this.PortManager.AddControlPointsToGraph(e.GeomEdge, this.ShapeToObstacleMap), this.GeneratePath(t, e, !1) || this.RetryPathsWithAdditionalGroupsEnabled(t, e), this.PortManager.RemoveControlPointsFromGraph();
  }
  // ReSharper disable UnusedMember.Local
  GeneratePath(t, e, i) {
    const s = this.PortManager.FindVertices(e.GeomEdge.sourcePort), n = this.PortManager.FindVertices(e.GeomEdge.targetPort);
    return bt.GetSingleStagePath(e, t, s, n, i);
  }
  static GetSingleStagePath(t, e, i, s, n) {
    return t.PathPoints = e.GetPath(i, s), n && bt.EnsureNonNullPath(t), t.PathPoints != null && t.PathPoints.length > 0;
  }
  static EnsureNonNullPath(t) {
    t.PathPoints == null && (b.IsPureDirection(t.GeomEdge.sourcePort.Location, t.GeomEdge.targetPort.Location) ? t.PathPoints = [t.GeomEdge.sourcePort.Location, t.GeomEdge.targetPort.Location] : t.PathPoints = [
      t.GeomEdge.sourcePort.Location,
      new u(t.GeomEdge.sourcePort.Location.x, t.GeomEdge.targetPort.Location.y),
      t.GeomEdge.targetPort.Location
    ]);
  }
  RetryPathsWithAdditionalGroupsEnabled(t, e) {
    (!this.PortManager.SetAllAncestorsActive(e.GeomEdge, this.ShapeToObstacleMap) || !this.GeneratePath(t, e, !1)) && (this.PortManager.SetAllGroupsActive(), this.GeneratePath(t, e, !0));
  }
  // static ShowPointEnum(p: Iterable<Point>) {
  //    //  ReSharper disable InconsistentNaming
  //    const w0: number = 0.1;
  //    const w1: number = 3;
  //    let arr: Point[] = p.toArray();
  //    let d: number = ((w1 - w0)
  //                / (arr.length - 1));
  //    let l = new Array<DebugCurve>();
  //    for (let i: number = 0; (i
  //                < (arr.length - 1)); i++) {
  //        l.Add(new DebugCurve(100, (w0
  //                            + (i * d)), "blue", new LineSegment(arr[i], arr[(i + 1)])));
  //    }
  //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);
  //    //  ReSharper restore InconsistentNaming
  // }
  NudgePaths(t) {
    const e = this.ObsTree.SpatialAncestorsAdjusted ? it.GetAncestorSetsMap(this.Obstacles) : this.AncestorsSets;
    nt.NudgePaths(t, this.edgeSeparatian, this.PaddedObstacles, e, this.RemoveStaircases);
  }
  get RemoveStaircases() {
    return this.removeStaircases;
  }
  set RemoveStaircases(t) {
    this.removeStaircases = t;
  }
  FinaliseEdgeGeometries() {
    for (const t of this.EdgesToRoute.concat(this.selfEdges)) {
      if (t.curve == null)
        continue;
      t.curve instanceof B && (t.curve = bt.FitArcsIntoCorners(this.CornerFitRadius, Array.from(t.curve))), bt.CalculateArrowheads(t);
    }
  }
  CreateVisibilityGraph() {
    this.GraphGenerator.Clear(), this.InitObstacleTree(), this.GraphGenerator.GenerateVisibilityGraph();
  }
  // mkDC(): Array<DebugCurve> {
  //   const dc = new Array<DebugCurve>()
  //   dc.push(
  //     ...Array.from(this.VisibilityGraph.Edges).map((e) =>
  //       DebugCurve.mkDebugCurveTWCI(100, 1, 'Blue', LineSegment.mkPP(e.SourcePoint, e.TargetPoint)),
  //     ),
  //   )
  //   dc.push(...this.Obstacles.map((o) => DebugCurve.mkDebugCurveTWCI(100, 2, 'Red', o.BoundaryCurve)))
  //   return dc
  // }
  static CalculateArrowheads(t) {
    vt.trimSplineAndCalculateArrowheadsII(t, t.sourcePort.Curve, t.targetPort.Curve, t.curve, !0);
  }
  get ObsTree() {
    return this.GraphGenerator.ObstacleTree;
  }
  GenerateObstacleTree() {
    if (this.Obstacles == null || this.Obstacles.length === 0)
      throw new Error("No obstacles have been added");
    this.ObsTree.Root == null && this.InitObstacleTree();
  }
  InitObstacleTree() {
    this.AncestorsSets = it.GetAncestorSetsMap(this.Obstacles), this.ObsTree.Init(this.ShapeToObstacleMap.values(), this.AncestorsSets, this.ShapeToObstacleMap);
  }
  InternalClear(t) {
    this.GraphGenerator.Clear(), this.ClearShortestPaths(), t ? this.PortManager.ClearVisibility() : (this.PortManager.Clear(), this.ShapeToObstacleMap.clear(), this.EdgesToRoute = []);
  }
  ClearShortestPaths() {
    for (const t of this.EdgesToRoute)
      t.curve = null;
  }
  GenerateVisibilityGraph() {
    if (this.Obstacles == null || this.Obstacles.length === 0)
      throw new Error("No obstacles have been set");
    this.GraphGenerator.VisibilityGraph == null && this.CreateVisibilityGraph();
  }
  // ShowPathWithTakenEdgesAndGraph(path: Iterable<VisibilityVertex>, takenEdges: Set<VisibilityEdge>) {
  //    let list = new Array<VisibilityVertex>(path);
  //    let lines = new Array<LineSegment>();
  //    for (let i: number = 0; (i
  //                < (list.Count - 1)); i++) {
  //        lines.Add(new LineSegment(list[i].Point, list[(i + 1)].Point));
  //    }
  //    //  ReSharper disable InconsistentNaming
  //    let w0: number = 4;
  //    const let w1: number = 8;
  //    let delta: number = ((w1 - w0)
  //                / (list.Count - 1));
  //    let dc = new Array<DebugCurve>();
  //    for (let line: LineSegment of lines) {
  //        dc.Add(new DebugCurve(50, w0, "red", line));
  //        w0 = (w0 + delta);
  //    }
  //    dc.AddRange(takenEdges.Select(() => {  }, new DebugCurve(50, 2, "black", new LineSegment(edge.SourcePoint, edge.TargetPoint))));
  //    let k: Iterable<DebugCurve> = this.GetGraphDebugCurves();
  //    dc.AddRange(k);
  //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(dc);
  //    //  ReSharper restore InconsistentNaming
  // }
  static FitArcsIntoCorners(t, e) {
    if (t == 0)
      return B.mkFromPoints(e);
    const i = bt.GetFittedArcSegs(t, e), s = new g();
    let n = null;
    for (const r of i) {
      const o = bt.EllipseIsAlmostLineSegment(r);
      n != null ? o ? g.continueWithLineSegmentP(s, bt.CornerPoint(r)) : (g.continueWithLineSegmentP(s, r.start), s.addSegment(r)) : o ? g.addLineSegment(s, e[0], bt.CornerPoint(r)) : (g.addLineSegment(s, e[0], r.start), s.addSegment(r)), n = r;
    }
    return s.segs.length > 0 ? g.continueWithLineSegmentP(s, e[e.length - 1]) : g.addLineSegment(s, e[0], e[e.length - 1]), s;
  }
  static CornerPoint(t) {
    return t.center.add(t.aAxis.add(t.bAxis));
  }
  static EllipseIsAlmostLineSegment(t) {
    return t.aAxis.lengthSquared < 1e-4 || t.aAxis.lengthSquared < 1e-4;
  }
  static *GetFittedArcSegs(t, e) {
    let i = e[1].sub(e[0]), s = i.normalize(), n = Math.min(t, i.length / 2);
    for (let r = 1; r < e.length - 1; r++) {
      i = e[r + 1].sub(e[r]);
      const o = i.length;
      if (o < m.intersectionEpsilon) {
        yield new j(0, 0, new u(0, 0), new u(0, 0), e[r]);
        continue;
      }
      const l = i.div(o);
      Math.abs(l.dot(s)) > 0.9 && (yield new j(0, 0, new u(0, 0), new u(0, 0), e[r]));
      const h = Math.min(t, i.length / 2), c = l.mul(-h), d = s.mul(n);
      yield new j(0, Math.PI / 2, c, d, e[r].sub(d.add(c))), s = l, n = h;
    }
  }
}
bt.DefaultPadding = 1;
bt.DefaultCornerFitRadius = 3;
class qi {
  constructor(t, e, i, s = 1) {
    this.Source = t, this.Target = e, this.CrossingWeight = i, this.Weight = s;
  }
  toString() {
    return Gt.String.format("{0}->{1}", this.Source, this.Target);
  }
}
let If = class fn {
  static FindClosestPoints(t, e) {
    const i = g.minDistWithinIntervals(t, e, t.parStart, t.parEnd, e.parStart, e.parEnd, (t.parStart + t.parEnd) / 2, (e.parStart + e.parEnd) / 2);
    if (i)
      return {
        curveClosestPoint: i.aX,
        labelSideClosest: i.bX
      };
  }
  static GetSegmentInFrontOfLabel(t, e) {
    if (t instanceof g) {
      for (const i of t.segs)
        if ((i.start.y - e) * (i.end.y - e) <= 0)
          return i;
    }
    return null;
  }
  static ShiftLabel(t, e, i) {
    const s = t.lineWidth / 2, n = e.sub(i), r = n.length;
    r > s && t.label.positionCenter(t.label.center.add(n.div(r * (r - s))));
  }
  static updateLabel(t, e) {
    let i = null;
    e.labelIsToTheRightOfTheSpline ? (t.label.positionCenter(new u(e.x + e.rightAnchor / 2, e.y)), i = v.mkPP(t.label.boundingBox.leftTop, t.label.boundingBox.leftBottom)) : e.labelIsToTheLeftOfTheSpline && (t.label.positionCenter(new u(e.x - e.leftAnchor / 2, e.y)), i = v.mkPP(t.label.boundingBox.rightTop, t.label.boundingBox.rightBottom));
    const s = fn.GetSegmentInFrontOfLabel(t.curve, t.label.center.y);
    if (s != null && g.getAllIntersections(t.curve, g.polyFromBox(t.label.boundingBox), !1).length === 0) {
      const n = fn.FindClosestPoints(s, i);
      if (n)
        fn.ShiftLabel(t, n.curveClosestPoint, n.labelSideClosest);
      else {
        let r, o;
        const l = s.closestParameter(i.start), h = s.closestParameter(i.end);
        s.value(l).sub(i.start).length < s.value(h).sub(i.end).length ? (r = s.value(l), o = i.start) : (r = s.value(h), o = i.end), fn.ShiftLabel(t, r, o);
      }
    }
  }
};
class Ye {
  get CrossingWeight() {
    return 1;
  }
  constructor(t, e, i, s = 1, n = 1) {
    this.reversed = !1, this.source = t, this.target = e, this.edge = i, this.weight = s, this.separation = n;
  }
  get hasLabel() {
    return this.edge.label != null;
  }
  get labelWidth() {
    return this.edge.label.width;
  }
  get labelHeight() {
    return this.edge.label.height;
  }
  // This function changes the edge by swapping source and target.
  reverse() {
    const t = this.source;
    this.source = this.target, this.target = t, this.reversed = !this.reversed;
  }
  toString() {
    return "edge(" + this.source + "->" + this.target + ")";
  }
  get curve() {
    return this.edge.curve;
  }
  set curve(t) {
    this.edge.curve = t;
  }
  get underlyingPolyline() {
    return this.edge.smoothedPolyline;
  }
  get LayerSpan() {
    return this.LayerEdges != null ? this.LayerEdges.length : 0;
  }
  isSelfEdge() {
    return this.source === this.target;
  }
  reversedClone() {
    const t = new Ye(this.target, this.source, this.edge);
    if (this.LayerEdges != null) {
      const e = this.LayerEdges.length;
      t.LayerEdges = new Array(e);
      for (let i = 0; i < e; i++) {
        const s = this.LayerEdges[e - 1 - i];
        t.LayerEdges[i] = new qi(s.Target, s.Source, s.CrossingWeight);
      }
      t.LayerEdges[0].Source = this.target, t.LayerEdges[this.LayerEdges.length - 1].Target = this.source;
    }
    return t;
  }
  get count() {
    return this.LayerEdges.length;
  }
  getNode(t) {
    if (t >= 0) {
      if (t < this.LayerEdges.length)
        return this.LayerEdges[t].Source;
      if (t === this.LayerEdges.length)
        return this.LayerEdges[t - 1].Target;
    }
    throw new Error("wrong index " + t);
  }
  updateEdgeLabelPosition(t) {
    if (this.edge.label != null) {
      const e = this.LayerEdges.length / 2, i = this.LayerEdges[e];
      If.updateLabel(this.edge, t[i.Source]);
    }
  }
  [Symbol.iterator]() {
    return this.nodes();
  }
  // enumerates over virtual virtices corresponding to the original edge
  *nodes() {
    yield this.LayerEdges[0].Source;
    for (const t of this.LayerEdges)
      yield t.Target;
  }
}
class Ef {
  constructor() {
    this.maxLayerOfGeomGraph = /* @__PURE__ */ new Set(), this.minLayerOfGeomGraph = /* @__PURE__ */ new Set(), this.sameLayerConstraints = new Array(), this.upDownConstraints = new Array(), this.gluedUpDownIntConstraints = new ti(), this.sameLayerDictionaryOfRepresentatives = /* @__PURE__ */ new Map(), this.representativeToItsLayer = /* @__PURE__ */ new Map(), this.maxLayerInt = new Array(), this.minLayerInt = new Array(), this.sameLayerInts = new Array(), this.upDownInts = new Array();
  }
  getFeedbackSetExternal(t, e) {
    throw new Error("Method not implemented.");
  }
  // pins a node to max layer
  pinNodeToMaxLayer(t) {
    this.maxLayerOfGeomGraph.add(t);
  }
  // pins a node to min layer
  pinNodeToMinLayer(t) {
    this.minLayerOfGeomGraph.add(t);
  }
  get isEmpty() {
    return this.maxLayerOfGeomGraph.size === 0 && this.minLayerOfGeomGraph.size === 0 && this.sameLayerConstraints.length === 0 && this.upDownConstraints.length === 0;
  }
  clear() {
    this.maxLayerOfGeomGraph.clear(), this.minLayerOfGeomGraph.clear(), this.sameLayerConstraints = [], this.upDownConstraints = [];
  }
  getFeedbackSetImp(t, e) {
    return this.nodeIdToIndex = e, this.intGraph = t, this.maxRepresentative = -1, this.minRepresentative = -1, this.createIntegerConstraints(), this.glueTogetherSameConstraintsMaxAndMin(), this.addMaxMinConstraintsToGluedConstraints(), this.removeCyclesFromGluedConstraints(), this.getFeedbackSet();
  }
  removeCyclesFromGluedConstraints() {
    const t = fi(Array.from(this.gluedUpDownIntConstraints.values()), this.intGraph.nodeCount), e = $i.getFeedbackSetWithConstraints(t, null);
    for (const i of e)
      this.gluedUpDownIntConstraints.remove(i);
  }
  addMaxMinConstraintsToGluedConstraints() {
    if (this.maxRepresentative !== -1)
      for (let t = 0; t < this.intGraph.nodeCount; t++) {
        const e = this.nodeToRepr(t);
        e !== this.maxRepresentative && this.gluedUpDownIntConstraints.add(new U(this.maxRepresentative, e));
      }
    if (this.minRepresentative !== -1)
      for (let t = 0; t < this.intGraph.nodeCount; t++) {
        const e = this.nodeToRepr(t);
        e !== this.minRepresentative && this.gluedUpDownIntConstraints.add(new U(e, this.minRepresentative));
      }
  }
  glueTogetherSameConstraintsMaxAndMin() {
    this.createDictionaryOfSameLayerRepresentatives(), this.upDownInts.map(this.gluedIntPairNN), this.gluedUpDownIntConstraints = new ti();
  }
  gluedIntPairNN(t) {
    return new U(this.nodeToRepr(t[0]), this.nodeToRepr(t[1]));
  }
  gluedIntPairI(t) {
    return new U(this.nodeToRepr(t.source), this.nodeToRepr(t.target));
  }
  gluedIntPair(t) {
    return new U(this.nodeToRepr(t.source), this.nodeToRepr(t.target));
  }
  gluedIntEdge(t) {
    const e = this.nodeToRepr(t.source), i = this.nodeToRepr(t.target), s = new Ye(e, i, t.edge);
    return s.separation = t.separation, s.weight = 0, s;
  }
  nodeToRepr(t) {
    const e = this.sameLayerDictionaryOfRepresentatives.get(t);
    return e || t;
  }
  createDictionaryOfSameLayerRepresentatives() {
    const t = this.createGraphOfSameLayers();
    for (const e of Qs(t))
      this.glueSameLayerNodesOfALayer(e);
  }
  createGraphOfSameLayers() {
    return fi(this.createEdgesOfSameLayers(), this.intGraph.nodeCount);
  }
  createEdgesOfSameLayers() {
    const t = new Array();
    return this.maxRepresentative !== -1 && this.maxLayerInt.filter((e) => e !== this.maxRepresentative).map((e) => new U(this.maxRepresentative, e)).forEach((e) => t.push(e)), this.minRepresentative !== -1 && this.minLayerInt.filter((e) => e !== this.minRepresentative).map((e) => new U(this.minRepresentative, e)).forEach((e) => t.push(e)), this.sameLayerInts.forEach((e) => t.push(new U(e[0], e[1]))), t;
  }
  // maps all nodes of the component to one random representative
  glueSameLayerNodesOfALayer(t) {
    if (t.length > 1) {
      let e = -1;
      if (this.componentsIsMaxLayer(t))
        for (const i of t)
          this.sameLayerDictionaryOfRepresentatives.set(i, e = this.maxRepresentative);
      else if (this.componentIsMinLayer(t))
        for (const i of t)
          this.sameLayerDictionaryOfRepresentatives.set(i, e = this.minRepresentative);
      else
        for (const i of t)
          e === -1 && (e = i), this.sameLayerDictionaryOfRepresentatives.set(i, e);
      this.representativeToItsLayer.set(e, t);
    }
  }
  componentIsMinLayer(t) {
    return t.findIndex((e) => this.minRepresentative === e) >= 0;
  }
  componentsIsMaxLayer(t) {
    return t.findIndex((e) => this.maxRepresentative === e) >= 0;
  }
  createIntegerConstraints() {
    this.createMaxIntConstraints(), this.createMinIntConstraints(), this.createUpDownConstraints(), this.createSameLayerConstraints();
  }
  createSameLayerConstraints() {
    this.sameLayerInts = this.createIntConstraintsFromStringCouples(this.sameLayerConstraints);
  }
  createUpDownConstraints() {
    this.upDownInts = this.createIntConstraintsFromStringCouples(this.upDownConstraints);
  }
  createIntConstraintsFromStringCouples(t) {
    return t.map((e) => [this.nodeIndex(e[0]), this.nodeIndex(e[1])]).filter((e) => e[0] !== -1 && e[1] !== -1);
  }
  createMinIntConstraints() {
    this.minLayerInt = this.createIntConstraintsFromExtremeLayer(this.minLayerOfGeomGraph), this.minLayerInt.length > 0 && (this.minRepresentative = this.minLayerInt[0]);
  }
  createMaxIntConstraints() {
    this.maxLayerInt = this.createIntConstraintsFromExtremeLayer(this.maxLayerOfGeomGraph), this.maxLayerInt.length > 0 && (this.maxRepresentative = this.maxLayerInt[0]);
  }
  createIntConstraintsFromExtremeLayer(t) {
    return Array.from(t).map((e) => this.nodeIndex(e)).filter((e) => e !== -1);
  }
  nodeIndex(t) {
    const e = this.nodeIdToIndex.get(t.node.id);
    return e || -1;
  }
  getFeedbackSet() {
    return this.gluedIntGraph = this.createGluedGraph(), Array.from(this.unglueIntPairs($i.getFeedbackSetWithConstraints(this.gluedIntGraph, this.gluedUpDownIntConstraints)));
  }
  *unglueIntPairs(t) {
    for (const e of t)
      for (const i of this.unglueEdge(e))
        yield i;
  }
  *unglueEdge(t) {
    for (const e of this.unglueNode(t.source))
      for (const i of this.intGraph.outEdges[e])
        this.nodeToRepr(i.target) === t.target && (yield i);
  }
  createGluedGraph() {
    const t = new ti();
    return this.intGraph.edges.forEach((e) => t.add(this.gluedIntPairI(e))), fi(Array.from(t.values()), this.intGraph.nodeCount);
  }
  unglueNode(t) {
    const e = this.representativeToItsLayer.get(t);
    return e || [t];
  }
  getGluedNodeCounts() {
    const t = new Array(this.nodeIdToIndex.size).fill(0);
    for (let e = 0; e < t.length; e++)
      t[this.nodeToRepr(e)]++;
    return t;
  }
}
function wf(a, t) {
  return [a, t];
}
class Af {
  constructor() {
    this.leftRightConstraints = new Array(), this.leftRightNeighbors = new Array(), this.nodeToBlockRoot = /* @__PURE__ */ new Map(), this.upDownVerticalConstraints = new Array(), this.BlockRootToBlock = /* @__PURE__ */ new Map();
  }
  get IsEmpty() {
    return this.leftRightNeighbors.length === 0 && this.upDownVerticalConstraints.length === 0 && this.leftRightConstraints.length === 0;
  }
  AddSameLayerNeighbors(t) {
    for (let e = 0; e < t.length - 1; e++)
      this.AddSameLayerNeighborsPair(t[e], t[e + 1]);
  }
  AddSameLayerNeighborsPair(t, e) {
    this.leftRightNeighbors.push([t, e]);
  }
  NodeToBlockRootSoft(t) {
    const e = this.nodeToBlockRoot.get(t);
    return e || t;
  }
  CreateMappingOfNeibBlocks() {
    const t = this.BasicGraphFromLeftRightIntNeibs();
    for (let e = 0; e < t.nodeCount; e++)
      if (t.inEdges[e].length === 0 && !this.nodeToBlockRoot.has(e)) {
        const i = new Array();
        let s = e;
        for (let n = t.outEdges[s]; n.length > 0; n = t.outEdges[s])
          s = n[0].y, i.push(s), this.nodeToBlockRoot.set(s, e);
        i.length > 0 && this.BlockRootToBlock.set(e, i);
      }
  }
  BasicGraphFromLeftRightIntNeibs() {
    return Nr(Array.from(this.LeftRightIntNeibs.values()).map((t) => new U(t.x, t.y)));
  }
  NodeIndex(t) {
    const e = this.nodeIdToIndex.get(t.id);
    return e || -1;
  }
  PrepareForOrdering(t, e) {
    this.nodeIdToIndex = t, this.MapNodesToToIntegers(e), this.CreateMappingOfNeibBlocks(), this.LiftLeftRightRelationsToNeibBlocks();
  }
  //see UpDownMonotone.png
  //       void MakeUpDownRelationsMonotone(number[] yLayers) {
  //           BasicGraph<IntPair> upDownGraph = new BasicGraph<IntPair>(from c in this.verticalInts select new IntPair(c.First,c.Second));
  //           Array<Tuple<number, number>> upDownToRemove = new Array<Tuple<number, number>>();
  //           foreach (Array<number> componentNodes of ConnectedComponentCalculator<IntPair>.GetComponents(GraphOfLeftRightRelations())) {
  //               ResolveConflictsUboveComponent(upDownGraph, componentNodes, upDownToRemove, yLayers);
  //               ResolveConflictsBelowComponent(upDownGraph, componentNodes, upDownToRemove, yLayers);
  //           }
  //
  //           foreach (var v of upDownToRemove)
  //               this.verticalInts.Remove(v);
  //       }
  //makes left-right relations to be between neighb blocks and removes cycles in these relations
  LiftLeftRightRelationsToNeibBlocks() {
    this.LeftRighInts = ti.mk(this.leftRightConstraints.map((e) => wf(this.NodeIndex(e[0]), this.NodeIndex(e[1]))).filter((e) => e[0] !== -1 && e[1] !== -1).map((e) => new U(this.NodeToBlockRootSoft(e[0]), this.NodeToBlockRootSoft(e[1]))).filter((e) => e.x !== e.x));
    const t = $i.getFeedbackSet(Nr(Array.from(this.LeftRighInts.values())));
    for (const e of t)
      this.LeftRighInts.remove(new U(e.source, e.target));
  }
  MapNodesToToIntegers(t) {
    this.LeftRightIntNeibs = ti.mk(Array.from(this.leftRightNeighbors.values()).map((e) => [this.NodeIndex(e[0]), this.NodeIndex(e[1])]).filter((e) => e[0] !== -1 && e[1] !== -1).map((e) => new U(e[0], e[1]))), this.VerticalInts = ti.mk(this.upDownVerticalConstraints.map((e) => [this.NodeIndex(e[0]), this.NodeIndex(e[1])]).filter((e) => e[0] !== -1 && e[1] !== -1 && t[e[0]] > t[e[1]]).map((e) => new U(e[0], e[1])));
  }
}
var je;
(function(a) {
  a[a.TB = 0] = "TB", a[a.LR = 1] = "LR", a[a.BT = 2] = "BT", a[a.RL = 3] = "RL", a[a.None = 4] = "None";
})(je || (je = {}));
var Jt;
(function(a) {
  a[a.Spline = 0] = "Spline", a[a.SplineBundling = 1] = "SplineBundling", a[a.StraightLine = 2] = "StraightLine", a[a.SugiyamaSplines = 3] = "SugiyamaSplines", a[a.Rectilinear = 4] = "Rectilinear", a[a.RectilinearToCenter = 5] = "RectilinearToCenter", a[a.None = 6] = "None";
})(Jt || (Jt = {}));
class Mn {
  toJSON() {
    const t = {};
    return this.EdgeRoutingMode != Jt.Spline && (t.edgeRoutingMode = Jt.Spline), this.ConeAngle != 30 * (Math.PI / 180) && (t.coneAngle = this.ConeAngle), this.padding != 3 && (t.padding = this.padding), this.polylinePadding != 1.5 && (t.polylinePadding = this.polylinePadding), this.bundlingSettings && (t.bundlingSettingsJSON = this.bundlingSettings.toJSON()), t;
  }
  static fromJSON(t) {
    const e = new Mn();
    return t.edgeRoutingMode && (t.edgeRoutingMode = e.edgeRoutingMode), t.coneAngle && (e.coneAngle = t.coneAngle), t.padding && (e.padding = t.padding), t.polylinePadding && (e.polylinePadding = t.polylinePadding), t.bundlingSettingsJSON && (e.bundlingSettings = Dt.createFromJSON(t.bundlingSettingsJSON)), t.routingToParentConeAngle && (e.routingToParentConeAngle = t.routingToParentConeAngle), t.simpleSelfLoopsForParentEdgesThreshold && (e.simpleSelfLoopsForParentEdgesThreshold = t.simpleSelfLoopsForParentEdgesThreshold), t.incrementalRoutingThreshold && (e.incrementalRoutingThreshold = t.incrementalRoutingThreshold), t.routeMultiEdgesAsBundles && (e.routeMultiEdgesAsBundles = t.routeMultiEdgesAsBundles), t.KeepOriginalSpline && (e.KeepOriginalSpline = t.KeepOriginalSpline), e;
  }
  constructor() {
    this.coneAngle = 30 * (Math.PI / 180), this.padding = 2, this.polylinePadding = 1, this.routingToParentConeAngle = Math.PI / 6, this.simpleSelfLoopsForParentEdgesThreshold = 200, this.incrementalRoutingThreshold = 5e6, this.routeMultiEdgesAsBundles = !0, this.KeepOriginalSpline = !1, this.EdgeRoutingMode = Jt.Spline;
  }
  // defines the way edges are routed
  get EdgeRoutingMode() {
    return this.edgeRoutingMode;
  }
  set EdgeRoutingMode(t) {
    t === Jt.SplineBundling && this.bundlingSettings == null && this.bundlingSettings == null && (this.bundlingSettings = new Dt()), this.edgeRoutingMode = t;
  }
  // the angle in degrees of the cones in the routing with the spanner
  get ConeAngle() {
    return this.coneAngle;
  }
  set ConeAngle(t) {
    this.coneAngle = t;
  }
  // Amount of space to leave around nodes
  get Padding() {
    return this.padding;
  }
  set Padding(t) {
    this.padding = t;
  }
  // Additional amount of padding to leave around nodes when routing with polylines
  get PolylinePadding() {
    return this.polylinePadding;
  }
  set PolylinePadding(t) {
    this.polylinePadding = t;
  }
  // this is a cone angle to find a relatively close point on the parent boundary
  get RoutingToParentConeAngle() {
    return this.routingToParentConeAngle;
  }
  set RoutingToParentConeAngle(t) {
    this.routingToParentConeAngle = t;
  }
  // if the number of the nodes participating in the routing of the parent edges is less than the threshold
  // then the parent edges are routed avoiding the nodes
  get SimpleSelfLoopsForParentEdgesThreshold() {
    return this.simpleSelfLoopsForParentEdgesThreshold;
  }
  set SimpleSelfLoopsForParentEdgesThreshold(t) {
    this.simpleSelfLoopsForParentEdgesThreshold = t;
  }
  // defines the size of the changed graph that could be routed fast with the standard spline routing when dragging
  get IncrementalRoutingThreshold() {
    return this.incrementalRoutingThreshold;
  }
  set IncrementalRoutingThreshold(t) {
    this.incrementalRoutingThreshold = t;
  }
  // if set to true routes multi edges as ordered bundles, when routing in a spline mode
  // <exception cref="NotImplementedException"></exception>
  get RouteMultiEdgesAsBundles() {
    return this.routeMultiEdgesAsBundles;
  }
  set RouteMultiEdgesAsBundles(t) {
    this.routeMultiEdgesAsBundles = t;
  }
}
class Js {
  constructor() {
    this.edgeRoutingSettings = new Mn(), this.nodeSeparation = 10, this.packingAspectRatio = 1.5;
  }
  static fromJSON(t) {
    const e = new Js();
    return t.nodeSeparation != 10 && (e.nodeSeparation = t.nodeSeparation), t.packingAspectRatio && (e.packingAspectRatio = t.packingAspectRatio), t.edgeRoutingSettings && (e.edgeRoutingSettings = Mn.fromJSON(t.edgeRoutingSettings)), e;
  }
  toJSON() {
    let t = !1;
    const e = {};
    return this.nodeSeparation != 10 && (e.nodeSeparation = this.nodeSeparation, t = !0), this.packingAspectRatio != 1.5 && (e.packingAspectRatio = this.packingAspectRatio, t = !0), (e.edgeRoutingSettings = this.edgeRoutingSettings.toJSON()) && (t = !0), t ? e : void 0;
  }
  get NodeSeparation() {
    return this.nodeSeparation;
  }
  set NodeSeparation(t) {
    this.nodeSeparation = t;
  }
  get PackingAspectRatio() {
    return this.packingAspectRatio;
  }
  set PackingAspectRatio(t) {
    this.packingAspectRatio = t;
  }
}
var Ks;
(function(a) {
  a[a.None = 0] = "None", a[a.Top = 1] = "Top", a[a.Bottom = 2] = "Bottom";
})(Ks || (Ks = {}));
class sn {
  get NodeSeparation() {
    return this.commonSettings.NodeSeparation;
  }
  get edgeRoutingSettings() {
    return this.commonSettings.edgeRoutingSettings;
  }
  set edgeRoutingSettings(t) {
    this.commonSettings.edgeRoutingSettings = t;
  }
  toJSON() {
    const t = {};
    return this.sameRanks && (t.sameRanks = this.sameRanks), this.verticalConstraints && (t.verticalConstraints = this.verticalConstraints), this.horizontalConstraints && (t.horizontalConstraints = this.horizontalConstraints), this.NoGainAdjacentSwapStepsBound != 5 && (t.horizontalConstraints = this.horizontalConstraints), this.NoGainStepsForOrderingMultiplier != 1 && (t.RepetitionCoefficientForOrdering = this.NoGainStepsForOrderingMultiplier), this.AspectRatio && (t.AspectRatio = this.AspectRatio), this.MaxNumberOfPassesInOrdering != 24 && (t.MaxNumberOfPassesInOrdering = this.MaxNumberOfPassesInOrdering), this.BrandesThreshold != 600 && (t.BrandesThreshold = this.BrandesThreshold), this.LabelCornersPreserveCoefficient != 0.1 && (t.LabelCornersPreserveCoefficient = this.LabelCornersPreserveCoefficient), this.MinNodeHeight != 72 * 0.5 / 4 && (t.MinNodeHeight = this.MinNodeHeight), this.MinNodeWidth != 72 * 0.75 / 4 && (t.MinNodeWidth = this.MinNodeWidth), this.SnapToGridByY != Ks.None && (t.SnapToGridByY = this.SnapToGridByY), this.yLayerSep != 30 && (t.yLayerSep = this.yLayerSep), this.transform && (t.transform = this.transform.elements), this.GridSizeByY && (t.GridSizeByY = this.GridSizeByY), this.GridSizeByX && (t.GridSizeByX = this.GridSizeByX), t.commonLayoutSettings = this.commonSettings.toJSON(), t;
  }
  static fromJSON(t) {
    const e = new sn();
    return t.sameRanks && (e.sameRanks = t.sameRanks), t.verticalConstraints && (e.verticalConstraints = t.verticalConstraints), t.horizontalConstraints && (e.horizontalConstraints = t.horizontalConstraints), t.NoGainAdjacentSwapStepsBound && (e.horizontalConstraints = t.horizontalConstraints), t.RepetitionCoefficientForOrdering && (e.NoGainStepsForOrderingMultiplier = t.RepetitionCoefficientForOrdering), t.AspectRatio && (e.AspectRatio = t.AspectRatio), t.MaxNumberOfPassesInOrdering && (e.MaxNumberOfPassesInOrdering = t.MaxNumberOfPassesInOrdering), t.BrandesThreshold && (e.BrandesThreshold = t.BrandesThreshold), t.LabelCornersPreserveCoefficient && (e.LabelCornersPreserveCoefficient = t.LabelCornersPreserveCoefficient), t.MinNodeHeight && (e.MinNodeHeight = t.MinNodeHeight), t.MinNodeWidth && (e.MinNodeWidth = e.MinNodeWidth), t.SnapToGridByY && (e.SnapToGridByY = t.SnapToGridByY), t.yLayerSep && (e.yLayerSep = t.yLayerSep), t.transform && (e.transform = new _t(t.transform[0][0], t.transform[0][1], t.transform[0][2], t.transform[1][0], t.transform[1][1], t.transform[1][2])), t.GridSizeByY && (e.GridSizeByY = t.GridSizeByY), t.GridSizeByX && (e.GridSizeByX = t.GridSizeByX), t.commonLayoutSettings && (e.commonSettings = Js.fromJSON(t.commonLayoutSettings)), e;
  }
  /** the minimum distance between two layer horizontal lines passing througt the node centers */
  get LayerSeparation() {
    return this.yLayerSep;
  }
  set LayerSeparation(t) {
    this.yLayerSep = Math.max(30, t);
  }
  ActualLayerSeparation(t) {
    return t ? this.LayerSeparation / 2 : this.LayerSeparation;
  }
  constructor() {
    this.commonSettings = new Js(), this.verticalConstraints = new Ef(), this.horizontalConstraints = new Af(), this.NoGainAdjacentSwapStepsBound = 5, this.NoGainStepsForOrderingMultiplier = 1, this.AspectRatio = 0, this.MaxNumberOfPassesInOrdering = 24, this.BrandesThreshold = 600, this.LabelCornersPreserveCoefficient = 0.1, this.MinNodeHeight = 72 * 0.5 / 4, this.MinNodeWidth = 72 * 0.75 / 4, this.SnapToGridByY = Ks.None, this.yLayerSep = 30, this.transform = _t.getIdentity(), this.GridSizeByY = 0, this.GridSizeByX = 0, this.commonSettings.edgeRoutingSettings.EdgeRoutingMode = Jt.SugiyamaSplines;
  }
  transformIsRotation(t) {
    const e = _t.rotation(t);
    for (let i = 0; i < 2; i++)
      for (let s = 0; s < 3; s++)
        if (!D(e.elements[i][s], this.transform.elements[i][s]))
          return !1;
    return !0;
  }
  get layerDirection() {
    if (this.transformIsRotation(0))
      return je.TB;
    if (this.transformIsRotation(Math.PI / 2))
      return je.LR;
    if (this.transformIsRotation(-Math.PI / 2))
      return je.RL;
    if (this.transformIsRotation(Math.PI))
      return je.BT;
    throw new Error("unexpected layout direction");
  }
  set layerDirection(t) {
    switch (t) {
      case je.TB:
        this.transform = _t.getIdentity();
        break;
      case je.LR:
        this.transform = _t.rotation(Math.PI / 2);
        break;
      case je.RL:
        this.transform = _t.rotation(-Math.PI / 2);
        break;
      case je.BT:
        this.transform = _t.rotation(Math.PI);
        break;
      default:
        throw new Error("unexpected layout direction");
    }
  }
}
class zh extends ht {
  // Dijkstra algorithm. Computes graph-theoretic distances from a node to
  // all other nodes in a graph with nonnegative edge lengths.
  // The distance between a node and itself is 0; the distance between a pair of
  // nodes for which no connecting path exists is Number.POSITIVE_INFINITY.
  constructor(t, e, i) {
    super(null), this.graph = t, this.source = e, this.length = i;
  }
  // An array of distances from the source node to all shallow nodes.
  // Nodes are indexed when iterating over them.
  get Result() {
    return this.result;
  }
  // Executes the algorithm.
  run() {
    const t = new is((s, n) => s - n), e = /* @__PURE__ */ new Map();
    for (const s of this.graph.shallowNodes) {
      const n = s === this.source ? 0 : Number.POSITIVE_INFINITY;
      t.Enqueue(s, n), e.set(s, n);
    }
    for (; t.count > 0; ) {
      const s = { priority: 0 }, n = t.DequeueAndGetPriority(s);
      e.set(n, s.priority);
      const r = e.get(n);
      for (const o of n.inEdges()) {
        const l = o.source, h = r + this.length(o);
        e.get(l) > h && (e.set(l, h), t.DecreasePriority(l, h));
      }
      for (const o of n.outEdges()) {
        const l = o.target, h = r + this.length(o);
        e.get(l) > h && (e.set(l, h), t.DecreasePriority(l, h));
      }
    }
    this.result = new Array(this.graph.shallowNodeCount);
    let i = 0;
    for (const s of this.graph.shallowNodes) {
      const n = e.get(s);
      n !== void 0 ? this.result[i++] = n : this.result[i++] = Number.POSITIVE_INFINITY;
    }
  }
}
class Pa extends ht {
  // The resulting distances between every pair of nodes in the graph.
  get Result() {
    return this.result;
  }
  set Result(t) {
    this.result = t;
  }
  // Computes distances between every pair of nodes in a graph.
  // Distances are symmetric if the graph is undirected.
  constructor(t, e) {
    super(null), this.graph = t, this.length = e;
  }
  // Executes the algorithm.
  run() {
    this.result = new Array(this.graph.shallowNodeCount);
    let t = 0;
    for (const e of this.graph.shallowNodes) {
      const i = new zh(this.graph, e, this.length);
      i.run(), this.Result[t++] = i.Result;
    }
  }
  // Computes the "stress" of the current layout of the given graph:
  //
  //   stress = sum_{(u,v) in V}  (d(u,v) - D(u,v))^2/(D(u,v)^2)
  //
  // where:
  //   V is the set of nodes
  //   d(u,v) is the euclidean distance between the centers of nodes u and v
  //   D(u,v) is the graph-theoretic path length between u and v - scaled by average edge length.
  //
  // Small stress in graph layout correlated with immediate neighbors to be closer
  // together than nodes that are a few hops apart (i.e. that have path length>1).  More generally
  // the distance between nodes in the drawing should be proportional to the path length between them.
  // The lower the stress of a particular graph layout the better it conforms to this ideal.
  //
  static Stress(t, e) {
    let i = 0;
    if (t.edgeCount === 0)
      return i;
    const s = new Pa(t, e);
    s.run();
    const n = s.Result;
    let r = 0;
    for (const l of t.shallowEdges)
      r += e(l);
    r /= t.edgeCount;
    let o = 0;
    for (const l of t.shallowNodes) {
      let h = 0;
      for (const c of t.shallowNodes) {
        if (o !== h) {
          const d = l.center.sub(c.center).length, f = r * n[o][h], p = f - d;
          i += p * p / (f * f);
        }
        h++;
      }
      o++;
    }
    return i;
  }
}
class Tf extends ht {
  // A square matrix with shortest path distances.
  get Result() {
    return this.result;
  }
  // Computes distances between a selected set of nodes and all nodes.
  // Pivot nodes are selected with maxmin strategy (first at random, later
  // ones to maximize distances to all previously selected ones).
  constructor(t, e, i) {
    super(null), this.graph = t, this.pivotArray = e, this.length = i;
  }
  // Executes the algorithm.
  run() {
    this.result = new Array(this.pivotArray.length);
    const t = Array.from(this.graph.shallowNodes), e = new Array(this.graph.shallowNodeCount).fill(Number.POSITIVE_INFINITY);
    let i = t[0];
    this.pivotArray[0] = 0;
    for (let s = 0; ; s++) {
      const n = new zh(this.graph, i, this.length);
      if (n.run(), this.Result[s] = n.Result, s + 1 < this.pivotArray.length) {
        let r = 0;
        for (let o = 0; o < this.Result[s].length; o++)
          e[o] = Math.min(e[o], this.Result[s][o]), e[o] > e[r] && (r = o);
        i = t[r], this.pivotArray[s + 1] = r;
      } else
        break;
    }
  }
}
class Of {
  // Rotates a 2D configuration clockwise by a given angle
  // The angle is given in degrees
  static Rotate(t, e, i) {
    const s = Math.sin(i * (Math.PI / 180)), n = Math.cos(i * (Math.PI / 180));
    for (let r = 0; r < t.length; r++) {
      const o = n * t[r] + s * e[r];
      e[r] = n * e[r] - s * t[r], t[r] = o;
    }
  }
}
class et {
  // Double-centers a matrix of such a way that the center of gravity is zero.
  // After number-centering, each row and each column sums up to zero.
  static DoubleCenter(t) {
    const e = new Array(t.length).fill(0), i = new Array(t[0].length).fill(0);
    let s = 0;
    for (let n = 0; n < t.length; n++)
      for (let r = 0; r < t[0].length; r++)
        e[n] += t[n][r], i[r] += t[n][r], s += t[n][r];
    for (let n = 0; n < t.length; n++)
      e[n] /= t.length;
    for (let n = 0; n < t[0].length; n++)
      i[n] /= t[0].length;
    s /= t.length, s /= t[0].length;
    for (let n = 0; n < t.length; n++)
      for (let r = 0; r < t[0].length; r++)
        t[n][r] -= e[n] + i[r] - s;
  }
  // Squares all entries of a matrix.
  static SquareEntries(t) {
    for (let e = 0; e < t.length; e++)
      for (let i = 0; i < t[0].length; i++)
        t[e][i] = Math.pow(t[e][i], 2);
  }
  // Multiplies a matrix with a scalar factor.
  static Multiply(t, e) {
    for (let i = 0; i < t.length; i++)
      for (let s = 0; s < t[0].length; s++)
        t[i][s] *= e;
  }
  // Multiply a square matrix and a vector.
  // Note that matrix width and vector length
  // have to be equal, otherwise null is returned.
  static MultiplyX(t, e) {
    if (t[0].length !== e.length)
      return null;
    const i = new Array(e.length).fill(0);
    for (let s = 0; s < t.length; s++)
      for (let n = 0; n < t[0].length; n++)
        i[s] += t[s][n] * e[n];
    return i;
  }
  // Gives the norm of a vector, that is, its length in
  // vector.length dimensional Euclidean space.
  static Norm(t) {
    let e = 0;
    for (let i = 0; i < t.length; i++)
      e += Math.pow(t[i], 2);
    return Math.sqrt(e);
  }
  // Normalizes a vector to unit length (1.0) in
  // vector.length dimensional Euclidean space.
  // If the vector is the 0-vector, nothing is done.
  static Normalize(t) {
    const e = et.Norm(t);
    if (e <= 0)
      return 0;
    for (let i = 0; i < t.length; i++)
      t[i] /= e;
    return e;
  }
  // Gives a random unit Euclidean length vector of a given size.
  static RandomUnitLengthVector(t) {
    const e = new Array(t);
    for (let i = 0; i < t; i++)
      e[i] = Cs();
    return et.Normalize(e), e;
  }
  // Computes the two dominant eigenvectors and eigenvalues of a symmetric
  // square matrix.
  static SpectralDecomposition(t, e) {
    et.SpectralDecompositionIE(t, e, 30, 1e-6);
  }
  // Computes the two dominant eigenvectors and eigenvalues of a symmetric
  // square matrix.
  static SpectralDecompositionIE(t, e, i, s) {
    const n = t[0].length;
    e.u1 = et.RandomUnitLengthVector(n), e.lambda1 = 0, e.u2 = et.RandomUnitLengthVector(n), e.lambda2 = 0;
    let r = 0;
    const o = 1 - s;
    for (let l = 0; l < i && r < o; l++) {
      const h = et.MultiplyX(t, e.u1), c = et.MultiplyX(t, e.u2);
      e.lambda1 = et.Normalize(h), e.lambda2 = et.Normalize(c), et.MakeOrthogonal(c, h), et.Normalize(c), r = Math.min(et.DotProduct(e.u1, h), et.DotProduct(e.u2, c)), e.u1 = h, e.u2 = c;
    }
  }
  // Gives the inner product of two vectors of the same size.
  static DotProduct(t, e) {
    if (t.length !== e.length)
      return 0;
    let i = 0;
    for (let s = 0; s < t.length; s++)
      i += t[s] * e[s];
    return i;
  }
  // Orthogonalizes a vector against another vector, so that
  // their scalar product is 0.
  static MakeOrthogonal(t, e) {
    if (t.length !== e.length)
      return;
    const i = et.DotProduct(t, e) / et.DotProduct(e, e);
    for (let s = 0; s < t.length; s++)
      t[s] -= i * e[s];
  }
  // Classical multidimensional scaling.  Computes two-dimensional coordinates
  // for a given distance matrix by computing the two largest eigenvectors
  // and eigenvalues of a matrix assiciated with the distance matrix (called
  // "fitting inner products").
  static ClassicalScaling(t, e) {
    const i = new Array(t.length);
    for (let s = 0; s < t.length; s++)
      i[s] = t[s].slice();
    et.SquareEntries(i), et.DoubleCenter(i), et.Multiply(i, -0.5), et.SpectralDecomposition(i, e), e.lambda1 = Math.sqrt(Math.abs(e.lambda1)), e.lambda2 = Math.sqrt(Math.abs(e.lambda2));
    for (let s = 0; s < e.u1.length; s++)
      e.u1[s] *= e.lambda1, e.u2[s] *= e.lambda2;
  }
  // Multidimensional scaling.  Computes two-dimensional coordinates
  // for a given distance matrix by fitting the coordinates to these distances
  // iteratively by majorization (called "distance fitting").
  // Only objects that have rows of the distance/weight matrix
  // is subject to iterative relocation.
  static DistanceScalingSubset(t, e, i, s, n) {
    const r = e.length, o = t.length, l = new Array(o);
    for (let c = 0; c < o; c++)
      for (let d = 0; d < r; d++)
        t[c][d] === 0 && (l[c] = d);
    const h = new Array(o).fill(0);
    for (let c = 0; c < o; c++)
      for (let d = 0; d < r; d++)
        l[c] !== d && (h[c] += s[c][d]);
    for (let c = 0; c < n; c++)
      for (let d = 0; d < o; d++) {
        let f = 0, p = 0;
        for (let P = 0; P < r; P++)
          if (d !== P) {
            let y = Math.sqrt(Math.pow(e[l[d]] - e[P], 2) + Math.pow(i[l[d]] - i[P], 2));
            y > 0 && (y = 1 / y), f += s[d][P] * (e[P] + t[d][P] * (e[l[d]] - e[P]) * y), p += s[d][P] * (i[P] + t[d][P] * (i[l[d]] - i[P]) * y);
          }
        e[l[d]] = f / h[d], i[l[d]] = p / h[d];
      }
  }
  // Multidimensional scaling.  Computes two-dimensional coordinates
  // for a given distance matrix by fitting the coordinates to these distances
  // iteratively by majorization (called "distance fitting").
  // (McGee, Kamada-Kawai)
  static DistanceScaling(t, e, i, s, n) {
    const r = e.length, o = new Array(r).fill(0);
    for (let l = 0; l < r; l++)
      for (let h = 0; h < r; h++)
        l !== h && (o[l] += s[l][h]);
    for (let l = 0; l < n; l++)
      for (let h = 0; h < r; h++) {
        let c = 0, d = 0;
        for (let f = 0; f < r; f++)
          if (h !== f) {
            let p = Math.sqrt(Math.pow(e[h] - e[f], 2) + Math.pow(i[h] - i[f], 2));
            p > 0 && (p = 1 / p), c += s[h][f] * (e[f] + t[h][f] * (e[h] - e[f]) * p), d += s[h][f] * (i[f] + t[h][f] * (i[h] - i[f]) * p);
          }
        e[h] = c / o[h], i[h] = d / o[h];
      }
  }
  // Convenience method for generating a weight matrix from a distance matrix.
  // Each output entry is the corresponding input entry powered by a constant
  // exponent.
  static ExponentialWeightMatrix(t, e) {
    const i = new Array(t.length);
    for (let s = 0; s < t.length; s++) {
      i[s] = new Array(t[s].length).fill(0);
      for (let n = 0; n < t[s].length; n++)
        t[s][n] > 0 && (i[s][n] = Math.pow(t[s][n], e));
    }
    return i;
  }
  // Convenience method for all Euclidean distances within two-dimensional
  // positions.
  static EuclideanDistanceMatrix(t, e) {
    const i = new Array(t.length);
    for (let s = 0; s < t.length; s++) {
      i[s] = new Array(t.length);
      for (let n = 0; n < t.length; n++)
        i[s][n] = Math.sqrt(Math.pow(t[s] - t[n], 2) + Math.pow(e[s] - e[n], 2));
    }
    return i;
  }
  // Approximation to classical multidimensional scaling.
  // Computes two-dimensional coordinates
  // for a given rectangular distance matrix.
  static LandmarkClassicalScaling(t, e, i) {
    const s = new Array(t.length);
    for (let o = 0; o < t.length; o++) {
      s[o] = new Array(t.length);
      for (let l = 0; l < t.length; l++)
        s[o][l] = t[o][i[l]];
    }
    et.SquareEntries(s);
    const n = new Array(t.length).fill(0);
    for (let o = 0; o < t.length; o++) {
      for (let l = 0; l < t.length; l++)
        n[o] += s[o][l];
      n[o] /= t.length;
    }
    et.DoubleCenter(s), et.Multiply(s, -0.5);
    const r = {
      u1: new Array(),
      u2: new Array(),
      lambda1: 0,
      lambda2: 0
    };
    et.SpectralDecomposition(s, r), r.lambda1 = Math.sqrt(Math.abs(r.lambda1)), r.lambda2 = Math.sqrt(Math.abs(r.lambda2)), e.x = new Array(t[0].length).fill(0), e.y = new Array(t[0].length).fill(0);
    for (let o = 0; o < e.x.length; o++)
      for (let l = 0; l < s.length; l++) {
        const h = (Math.pow(t[l][o], 2) - n[l]) / 2;
        e.x[o] -= r.u1[l] * h, e.y[o] -= r.u2[l] * h;
      }
  }
}
class xf {
  constructor(t, e) {
    this.constrained = !1, this.Capacity = 1e6, gt.AbovePP(t.point, e.point) === 1 ? (this.upperSite = t, this.lowerSite = e) : (this.lowerSite = t, this.upperSite = e), this.upperSite.AddEdgeToSite(this);
  }
  get CcwTriangle() {
    return this.ccwTriangle;
  }
  set CcwTriangle(t) {
    this.ccwTriangle = t;
  }
  get CwTriangle() {
    return this.cwTriangle;
  }
  set CwTriangle(t) {
    this.cwTriangle = t;
  }
  // returns the trianlge on the edge opposite to the site
  GetOtherTriangle_c(t) {
    return this.cwTriangle.Contains(t) ? this.ccwTriangle : this.cwTriangle;
  }
  IsAdjacent(t) {
    return t === this.upperSite || t === this.lowerSite;
  }
  GetOtherTriangle_T(t) {
    return this.ccwTriangle === t ? this.cwTriangle : this.ccwTriangle;
  }
  // A string that represents the current object.
  toString() {
    return Gt.String.format("({0},{1})", this.upperSite, this.lowerSite);
  }
  OtherSite(t) {
    return this.upperSite === t ? this.lowerSite : this.upperSite;
  }
}
class Cn {
  cleanRemovedEdges() {
    for (const t of this.Edges)
      t.CcwTriangle === null && t.CwTriangle === null && this.Edges.splice(this.Edges.indexOf(t), 1);
  }
  constructor(t) {
    this.Owner = null, this.InEdges = new Array(), this.point = t;
  }
  static mkSO(t, e) {
    const i = new Cn(t);
    return i.Owner = e, i;
  }
  AddEdgeToSite(t) {
    this.Edges == null && (this.Edges = new Array()), this.Edges.push(t);
  }
  // #if TEST_MSAGL && TEST_MSAGL
  //         // Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
  //         // A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
  //         // <filterpriority>2</filterpriority>
  //         public override string ToString()
  //         {
  //             return Point.ToString();
  //         }
  // #endif
  EdgeBetweenUpperSiteAndLowerSite(t) {
    if (this.Edges != null) {
      for (const e of this.Edges)
        if (e.lowerSite === t)
          return e;
    }
    return null;
  }
  AddInEdge(t) {
    this.InEdges.push(t);
  }
  *Triangles() {
    let t;
    if (this.Edges != null && this.Edges.length > 0)
      t = this.Edges[0];
    else if (this.InEdges != null && this.InEdges.length > 0)
      t = this.InEdges[0];
    else
      return;
    let e = t;
    do {
      const i = e.upperSite === this ? e.CcwTriangle : e.CwTriangle;
      if (i == null) {
        e = null;
        break;
      }
      yield i, e = i.Edges.getItem(i.Edges.index(e) + 2);
    } while (e !== t);
    if (e !== t) {
      e = t;
      do {
        const i = e.upperSite === this ? e.CwTriangle : e.CcwTriangle;
        if (i == null)
          break;
        yield i, e = i.Edges.getItem(i.Edges.index(e) + 1);
      } while (!0);
    }
  }
  toString() {
    return this.point.toString();
  }
}
class Os {
  get x() {
    return this.LeftSite.point.x;
  }
  constructor(t, e) {
    this.RightSite = e.upperSite === t ? e.lowerSite : e.upperSite, this.LeftSite = t, this.Edge = e;
  }
  toString() {
    return "(" + this.LeftSite.toString() + ", " + this.Edge.toString() + "," + this.RightSite.toString() + ")";
  }
}
class bl {
  has(t) {
    return t === this.item0 || t === this.item1 || t === this.item2;
  }
  index(t) {
    return t === this.item0 ? 0 : t === this.item1 ? 1 : t === this.item2 ? 2 : -1;
  }
  getItem(t) {
    switch (t) {
      case 0:
      case 3:
      case -3:
        return this.item0;
      case 1:
      case 4:
      case -2:
        return this.item1;
      case 2:
      case 5:
      case -1:
        return this.item2;
      default:
        throw new Error();
    }
  }
  setItem(t, e) {
    switch (t) {
      case 0:
      case 3:
      case -3:
        this.item0 = e;
        break;
      case 1:
      case 4:
      case -2:
        this.item1 = e;
        break;
      case 2:
      case 5:
      case -1:
        this.item2 = e;
        break;
      default:
        throw new Error();
    }
  }
  [Symbol.iterator]() {
    return this.GetEnumerator();
  }
  // Returns an enumerator that iterates through the collection.
  *GetEnumerator() {
    yield this.item0, yield this.item1, yield this.item2;
  }
}
class ee {
  constructor() {
    this.Edges = new bl(), this.Sites = new bl();
  }
  containsPoint(t) {
    return ee.PointLocationForTriangle(t, this) !== F.Outside;
  }
  static PointLocationForTriangle(t, e) {
    let i = !1;
    for (let s = 0; s < 3; s++) {
      const n = u.signedDoubledTriangleArea(t, e.Sites.getItem(s).point, e.Sites.getItem(s + 1).point);
      if (n < -m.distanceEpsilon)
        return F.Outside;
      n < m.distanceEpsilon && (i = !0);
    }
    return i ? F.Boundary : F.Inside;
  }
  /** extend by eps the triangles edges before the test */
  intersectsLine(t, e, i) {
    if (ee.PointLocationForTriangle(t, this) != F.Outside || ee.PointLocationForTriangle(e, this) != F.Outside)
      return !0;
    for (const s of this.Edges)
      if (this.abIntersectsTrianglSide(t, e, s))
        return !0;
    return !1;
  }
  abIntersectsTrianglSide(t, e, i) {
    return Rh(t, e, i.lowerSite.point, i.upperSite.point);
  }
  static mkSSSD(t, e, i, s) {
    const n = u.getTriangleOrientation(t.point, e.point, i.point), r = new ee();
    switch (n) {
      case L.Counterclockwise:
        r.FillCcwTriangle(t, e, i, s);
        break;
      case L.Clockwise:
        r.FillCcwTriangle(t, i, e, s);
        break;
      default:
        throw new Error();
    }
    return r;
  }
  static mkSED(t, e, i) {
    const s = new ee();
    switch (u.getTriangleOrientation(e.upperSite.point, e.lowerSite.point, t.point)) {
      case L.Counterclockwise:
        e.CcwTriangle = s, s.Sites.setItem(0, e.upperSite), s.Sites.setItem(1, e.lowerSite);
        break;
      case L.Clockwise:
        e.CwTriangle = s, s.Sites.setItem(0, e.lowerSite), s.Sites.setItem(1, e.upperSite);
        break;
      default:
        throw new Error();
    }
    return s.Edges.setItem(0, e), s.Sites.setItem(2, t), s.CreateEdge(1, i), s.CreateEdge(2, i), s;
  }
  //
  static mkSSSEE(t, e, i, s, n, r) {
    const o = ee.mkSSSD(t, e, i, r);
    return o.Edges.setItem(0, s), o.Edges.setItem(1, n), o.BindEdgeToTriangle(t, s), o.BindEdgeToTriangle(e, n), o.CreateEdge(2, r), o;
  }
  // in the trianlge, which is always oriented counterclockwise, the edge starts at site
  BindEdgeToTriangle(t, e) {
    t === e.upperSite ? e.CcwTriangle = this : e.CwTriangle = this;
  }
  // here a,b,c comprise a ccw triangle
  FillCcwTriangle(t, e, i, s) {
    this.Sites.setItem(0, t), this.Sites.setItem(1, e), this.Sites.setItem(2, i);
    for (let n = 0; n < 3; n++)
      this.CreateEdge(n, s);
  }
  CreateEdge(t, e) {
    const i = this.Sites.getItem(t), s = this.Sites.getItem(t + 1), n = e(i, s);
    this.Edges.setItem(t, n), this.BindEdgeToTriangle(i, n);
  }
  Contains(t) {
    return this.Sites.has(t);
  }
  OppositeEdge(t) {
    const e = this.Sites.index(t);
    return this.Edges.getItem(e + 1);
  }
  // #if TEST_MSAGL&&TEST_MSAGL
  //         // Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
  //         // A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
  //         // <filterpriority>2</filterpriority>
  //         public override string ToString() {
  //             return String.format("({0},{1},{2}", Sites[0], Sites[1], Sites[2]);
  //         }
  // #endif
  OppositeSite(t) {
    const e = this.Edges.index(t);
    return this.Sites.getItem(e + 2);
  }
  BoundingBox() {
    const t = T.mkPP(this.Sites.getItem(0).point, this.Sites.getItem(1).point);
    return t.add(this.Sites.getItem(2).point), t;
  }
  static mkSSSEED(t, e, i, s, n, r) {
    const o = new ee();
    return o.Sites.setItem(0, t), o.Sites.setItem(1, e), o.Sites.setItem(2, i), o.Edges.setItem(0, s), o.Edges.setItem(1, n), o.BindEdgeToTriangle(t, s), o.BindEdgeToTriangle(e, n), o.CreateEdge(2, r), o;
  }
  toString() {
    return this.Sites.getItem(0).toString() + "," + this.Sites.getItem(1).toString() + "," + this.Sites.getItem(2).toString();
  }
}
class vl {
  constructor(t) {
    this.Edge = t;
  }
}
class Ft extends ht {
  constructor(t, e, i, s) {
    if (super(null), this.front = new we((r, o) => r.x - o.x), this.triangles = /* @__PURE__ */ new Set(), this.listOfSites = t, this.listOfSites.length === 0)
      return;
    this.p_1 = e, this.p_2 = i, this.createEdgeDelegate = s;
    const n = ee.mkSSSD(e, i, this.listOfSites[0], s);
    this.triangles.add(n), this.front.insert(new Os(e, n.Edges.getItem(2))), this.front.insert(new Os(this.listOfSites[0], n.Edges.getItem(1)));
  }
  run() {
    if (this.listOfSites.length !== 0) {
      for (let t = 1; t < this.listOfSites.length; t++)
        this.ProcessSite(this.listOfSites[t]);
      this.FinalizeTriangulation();
    }
  }
  FinalizeTriangulation() {
    this.RemoveP1AndP2Triangles(), this.triangles.size > 0 && this.MakePerimeterConvex();
  }
  MakePerimeterConvex() {
    let t = this.CreateDoubleLinkedListOfPerimeter();
    do {
      const e = this.FindConcaveEdge(t);
      if (e == null)
        return;
      t = this.ShortcutTwoListElements(e);
    } while (!0);
  }
  FindConcaveEdge(t) {
    let e = t, i;
    do {
      if (i = e.Next, u.getTriangleOrientation(e.Start.point, e.End.point, i.End.point) === L.Counterclockwise)
        return e;
      e = i;
    } while (i !== t);
    return null;
  }
  static FindPivot(t) {
    let e = t, i = t;
    do
      i = i.Next, (i.Start.point.x < e.Start.point.x || i.Start.point.x === e.Start.point.x && i.Start.point.y < e.Start.point.y) && (e = i);
    while (i !== t);
    return e;
  }
  FindFirsePerimeterEdge() {
    for (const t of this.triangles)
      for (const e of t.Edges)
        if (e.GetOtherTriangle_T(t) == null)
          return e;
    return null;
  }
  CreateDoubleLinkedListOfPerimeter() {
    const t = this.FindFirsePerimeterEdge();
    let e = t, i = null, s, n = null;
    const r = new Array();
    do
      s = Ft.CreatePerimeterElementFromEdge(e), r.push(v.mkPP(s.Start.point, s.End.point)), e = Ft.FindNextEdgeOnPerimeter(e), n != null ? (s.Prev = n, n.Next = s) : i = s, n = s;
    while (e !== t);
    return i.Prev = s, s.Next = i, i;
  }
  static FindNextEdgeOnPerimeter(t) {
    var e;
    let i = (e = t.CwTriangle) !== null && e !== void 0 ? e : t.CcwTriangle;
    for (t = i.Edges.getItem(i.Edges.index(t) + 2); t.CwTriangle != null && t.CcwTriangle != null; )
      i = t.GetOtherTriangle_T(i), t = i.Edges.getItem(i.Edges.index(t) + 2);
    return t;
  }
  static CreatePerimeterElementFromEdge(t) {
    const e = new vl(t);
    return t.CwTriangle != null ? (e.Start = t.upperSite, e.End = t.lowerSite) : (e.End = t.upperSite, e.Start = t.lowerSite), e;
  }
  RemoveP1AndP2Triangles() {
    const t = /* @__PURE__ */ new Set();
    for (const e of this.triangles)
      (e.Sites.has(this.p_1) || e.Sites.has(this.p_2)) && t.add(e);
    for (const e of t)
      Ft.RemoveTriangleWithEdges(this.triangles, e);
  }
  static RemoveTriangleWithEdges(t, e) {
    t.delete(e);
    for (const i of e.Edges)
      i.CwTriangle === e ? i.CwTriangle = null : i.CcwTriangle = null, i.CwTriangle == null && i.CcwTriangle == null && ko(i.upperSite.Edges, i);
  }
  static RemoveTriangleButLeaveEdges(t, e) {
    t.delete(e);
    for (const i of e.Edges)
      i.CwTriangle === e ? i.CwTriangle = null : i.CcwTriangle = null;
  }
  ProcessSite(t) {
    this.PointEvent(t);
    for (let e = 0; e < t.Edges.length; e++) {
      const i = t.Edges[e];
      i.constrained && this.EdgeEvent(i);
    }
  }
  // #if TEST_MSAGL && TEST_MSAGL
  // void TestThatFrontIsConnected() {
  //     CdtFrontElement p = null;
  //     foreach(var cdtFrontElement of front) {
  //         if (p != null)
  //             Assert.assert(p.RightSite === cdtFrontElement.LeftSite);
  //         p = cdtFrontElement;
  //     }
  // }
  // #endif
  EdgeEvent(t) {
    Ft.EdgeIsProcessed(t) || (this.traversingEdge = t, this.runEdgeInserter());
  }
  static EdgeIsProcessed(t) {
    return t.CwTriangle != null || t.CcwTriangle != null;
  }
  ShowFrontWithSite(t, e = null) {
    const i = new Array();
    if (t.Edges != null)
      for (const s of t.Edges)
        i.push(q.mkDebugCurveTWCI(200, 0.8, s.constrained ? "Pink" : "Brown", v.mkPP(s.upperSite.point, s.lowerSite.point)));
    i.push(q.mkDebugCurveTWCI(200, 1, "Brown", j.mkFullEllipseNNP(0.5, 0.5, t.point)));
    for (const s of this.triangles)
      for (let n = 0; n < 3; n++) {
        const r = s.Edges.getItem(n);
        i.push(q.mkDebugCurveTWCI(r.constrained ? 155 : 100, r.constrained ? 0.8 : 0.4, r.constrained ? "Pink" : "Navy", v.mkPP(r.upperSite.point, r.lowerSite.point)));
      }
    if (e != null)
      for (const s of e)
        i.push(q.mkDebugCurveTWCI(100, 0.5, "Red", s));
    for (const s of this.front)
      i.push(q.mkDebugCurveTWCI(100, 5.5, "Green", v.mkPP(s.Edge.upperSite.point, s.Edge.lowerSite.point)));
  }
  Show(t) {
    Ft.ShowCdt(Array.from(this.triangles.values()), this.front, null, null, [], t);
  }
  static ShowCdt(t, e, i, s, n, r) {
    let o = new Array();
    if (i != null)
      for (const l of i)
        o.push(q.mkDebugCurveTWCI(200, 0.1, "Red", l));
    if (s != null)
      for (const l of s)
        o.push(q.mkDebugCurveTWCI(200, 0.1, "Blue", l));
    if (e != null)
      for (const l of e)
        o.push(q.mkDebugCurveTWCI(200, 0.1, "Green", v.mkPP(l.Edge.upperSite.point, l.Edge.lowerSite.point)));
    for (const l of t)
      for (let h = 0; h < 3; h++) {
        const c = l.Edges.getItem(h);
        o.push(Ft.GetDebugCurveOfCdtEdge(c));
      }
    o = o.concat(n);
  }
  static GetDebugCurveOfCdtEdge(t) {
    return t.CcwTriangle == null || t.CwTriangle == null ? q.mkDebugCurveTWCI(255, 0.5, t.constrained ? "Brown" : "Black", v.mkPP(t.upperSite.point, t.lowerSite.point)) : q.mkDebugCurveTWCI(200, t.constrained ? 0.8 : 0.2, t.constrained ? "Pink" : "Navy", v.mkPP(t.upperSite.point, t.lowerSite.point));
  }
  PointEvent(t) {
    const e = this.ProjectToFront(t), i = { rightSite: null }, s = e.item.x + m.distanceEpsilon < t.point.x ? this.MiddleCase(t, e, i) : this.LeftCase(t, e, i);
    let n = this.InsertSiteIntoFront(s, t, i.rightSite);
    this.TriangulateEmptySpaceToTheRight(n), n = Ft.FindNodeInFrontBySite(this.front, s), this.TriangulateEmptySpaceToTheLeft(n);
  }
  // #if TEST_MSAGL && TEST_MSAGL
  // void TestTriangles() {
  //     var usedSites = new Set<CdtSite>();
  //     foreach(var t of triangles)
  //     usedSites.InsertRange(t.Sites);
  //     foreach(var triangle of triangles) {
  //         TestTriangle(triangle, usedSites);
  //     }
  // }
  // void TestTriangle(CdtTriangle triangle, Set < CdtSite > usedSites) {
  //     var tsites = triangle.Sites;
  //     foreach(var site of usedSites) {
  //         if (!tsites.Contains(site)) {
  //             if (!SeparatedByConstrainedEdge(triangle, site) && InCircle(site, tsites[0], tsites[1], tsites[2])) {
  //                 Array < ICurve > redCurves=new Array<ICurve>();
  //                 redCurves.push(new Ellipse(2, 2, site.point));
  //                 Array < ICurve > blueCurves = new Array<ICurve>();
  //                 blueCurves.push(Circumcircle(tsites[0].point, tsites[1].point, tsites[2].point));
  //                 ShowFront(triangles, front, redCurves, blueCurves);
  //             }
  //         }
  //     }
  // }
  //         static bool SeparatedByConstrainedEdge(CdtTriangle triangle, CdtSite site) {
  //     for (int i = 0; i < 3; i++)
  //     if (SeparatedByEdge(triangle, i, site))
  //         return true;
  //     return false;
  // }
  //         static bool SeparatedByEdge(CdtTriangle triangle, int i, CdtSite site) {
  //     var e = triangle.Edges[i];
  //     var s = triangle.Sites.getItem(i + 2);
  //     var a0 = ApproximateComparer.Sign(Point.SignedDoubledTriangleArea(s.point, e.upperSite.point, e.lowerSite.point));
  //     var a1 = ApproximateComparer.Sign(Point.SignedDoubledTriangleArea(site.point, e.upperSite.point, e.lowerSite.point));
  //     return a0 * a1 <= 0;
  // }
  // #endif
  LeftCase(t, e, i) {
    const s = e.item;
    this.InsertAndLegalizeTriangle(t, s);
    const n = this.front.previous(e), r = n.item.LeftSite;
    return i.rightSite = e.item.RightSite, this.InsertAndLegalizeTriangle(t, n.item), this.front.deleteNodeInternal(n), this.front.remove(s), r;
  }
  MiddleCase(t, e, i) {
    const s = e.item.LeftSite;
    return i.rightSite = e.item.RightSite, this.InsertAndLegalizeTriangle(t, e.item), this.front.deleteNodeInternal(e), s;
  }
  TriangulateEmptySpaceToTheLeft(t) {
    const e = t.item.RightSite;
    let i = this.front.previous(t);
    for (; i != null; ) {
      const s = i.item, n = s.LeftSite, r = s.RightSite;
      if (r.point.sub(e.point).dot(n.point.sub(r.point)) < 0)
        t = this.ShortcutTwoFrontElements(i, t), i = this.front.previous(t);
      else {
        this.TryTriangulateBasinToTheLeft(t);
        break;
      }
    }
  }
  ShortcutTwoListElements(t) {
    var e;
    const i = t.Next;
    let s = ee.mkSSSEE(t.Start, t.End, i.End, t.Edge, i.Edge, this.createEdgeDelegate);
    this.triangles.add(s);
    const n = s.Edges.getItem(2);
    this.LegalizeEdge(t.Start, s.OppositeEdge(t.Start)), s = (e = n.CcwTriangle) !== null && e !== void 0 ? e : n.CwTriangle, this.LegalizeEdge(i.End, s.OppositeEdge(i.End));
    const r = new vl(n);
    return r.Start = t.Start, r.End = i.End, t.Prev.Next = r, r.Prev = t.Prev, r.Next = i.Next, i.Next.Prev = r, r;
  }
  // aNode is to the left of bNode, and they are consecutive
  ShortcutTwoFrontElements(t, e) {
    var i;
    const s = t.item, n = e.item;
    let r = ee.mkSSSEED(s.LeftSite, s.RightSite, n.RightSite, s.Edge, n.Edge, this.createEdgeDelegate);
    this.triangles.add(r), this.front.deleteNodeInternal(t), this.front.remove(n);
    const o = r.Edges.getItem(2);
    return this.LegalizeEdge(s.LeftSite, r.OppositeEdge(s.LeftSite)), r = (i = o.CcwTriangle) !== null && i !== void 0 ? i : o.CwTriangle, this.LegalizeEdge(n.RightSite, r.OppositeEdge(n.RightSite)), this.front.insert(new Os(s.LeftSite, o));
  }
  TryTriangulateBasinToTheLeft(t) {
    if (!Ft.DropsSharpEnoughToTheLeft(t.item))
      return;
    const e = new mt.Stack();
    for (e.push(t.item.LeftSite); ; ) {
      const i = e.pop();
      t = Ft.FindNodeInFrontBySite(this.front, i);
      const s = this.front.previous(t);
      if (s == null)
        return;
      if (u.getTriangleOrientation(s.item.LeftSite.point, t.item.LeftSite.point, t.item.RightSite.point) == L.Counterclockwise)
        e.push(s.item.LeftSite), this.ShortcutTwoFrontElements(s, t);
      else if (t.item.LeftSite.point.y > t.item.RightSite.point.y)
        e.push(s.item.LeftSite);
      else {
        if (s.item.LeftSite.point.y <= s.item.RightSite.point.y)
          return;
        e.push(s.item.LeftSite);
      }
    }
  }
  static DropsSharpEnoughToTheLeft(t) {
    const e = t.Edge;
    if (t.RightSite !== e.upperSite)
      return !1;
    const i = e.lowerSite.point.sub(e.upperSite.point);
    return i.x >= 0.5 * i.y;
  }
  InsertSiteIntoFront(t, e, i) {
    let s = null, n = null;
    for (const r of e.Edges)
      if (n == null && r.lowerSite === t && (n = r), s == null && r.lowerSite === i && (s = r), n != null && s != null)
        break;
    return this.front.insert(new Os(t, n)), this.front.insert(new Os(e, s));
  }
  TriangulateEmptySpaceToTheRight(t) {
    const i = t.item.LeftSite.point;
    let s = this.front.next(t);
    for (; s != null; ) {
      const n = s.item, r = n.LeftSite, o = n.RightSite;
      if (r.point.sub(i).dot(o.point.sub(r.point)) < 0)
        t = this.ShortcutTwoFrontElements(t, s), s = this.front.next(t);
      else {
        this.TryTriangulateBasinToTheRight(t);
        break;
      }
    }
  }
  TryTriangulateBasinToTheRight(t) {
    if (!Ft.DropsSharpEnoughToTheRight(t.item))
      return;
    const e = new mt.Stack();
    for (e.push(t.item.LeftSite); ; ) {
      const i = e.pop();
      t = Ft.FindNodeInFrontBySite(this.front, i);
      const s = this.front.next(t);
      if (s == null)
        return;
      if (u.getTriangleOrientation(t.item.LeftSite.point, t.item.RightSite.point, s.item.RightSite.point) == L.Counterclockwise)
        this.ShortcutTwoFrontElements(t, s), e.push(i);
      else if (t.item.LeftSite.point.y > t.item.RightSite.point.y)
        e.push(t.item.RightSite);
      else {
        if (s.item.LeftSite.point.y >= s.item.RightSite.point.y)
          return;
        e.push(t.item.RightSite);
      }
    }
  }
  static DropsSharpEnoughToTheRight(t) {
    const e = t.Edge;
    if (t.LeftSite !== e.upperSite)
      return !1;
    const i = e.lowerSite.point.sub(e.upperSite.point);
    return i.x <= -0.5 * i.y;
  }
  static FindNodeInFrontBySite(t, e) {
    return t.findLast((i) => i.LeftSite.point.x <= e.point.x);
  }
  InsertAndLegalizeTriangle(t, e) {
    var i;
    if (u.getTriangleOrientation(t.point, e.LeftSite.point, e.RightSite.point) !== L.Collinear) {
      const s = ee.mkSED(t, e.Edge, this.createEdgeDelegate);
      this.triangles.add(s), this.LegalizeEdge(t, s.Edges.getItem(0));
    } else {
      const s = e.Edge;
      ko(s.upperSite.Edges, s);
      let n = (i = s.CcwTriangle) !== null && i !== void 0 ? i : s.CwTriangle;
      const r = n.OppositeSite(s);
      Ft.RemoveTriangleButLeaveEdges(this.triangles, n), n = ee.mkSSSD(e.LeftSite, r, t, this.createEdgeDelegate);
      const o = ee.mkSSSD(e.RightSite, r, t, this.createEdgeDelegate);
      this.triangles.add(n), this.triangles.add(o), this.LegalizeEdge(t, n.OppositeEdge(t)), this.LegalizeEdge(t, o.OppositeEdge(t));
    }
  }
  LegalizeEdge(t, e) {
    e.constrained || e.CcwTriangle == null || e.CwTriangle == null || (e.CcwTriangle.Contains(t) ? this.LegalizeEdgeForOtherCwTriangle(t, e) : this.LegalizeEdgeForOtherCcwTriangle(t, e));
  }
  LegalizeEdgeForOtherCwTriangle(t, e) {
    const i = e.CwTriangle.Edges.index(e);
    if (Cl(t, e.upperSite, e.CwTriangle.Sites.getItem(i + 2), e.lowerSite)) {
      const s = Il(t, e);
      this.LegalizeEdge(t, s.CwTriangle.OppositeEdge(t)), this.LegalizeEdge(t, s.CcwTriangle.OppositeEdge(t));
    }
  }
  LegalizeEdgeForOtherCcwTriangle(t, e) {
    const i = e.CcwTriangle.Edges.index(e);
    if (Cl(t, e.lowerSite, e.CcwTriangle.Sites.getItem(i + 2), e.upperSite)) {
      const s = Il(t, e);
      this.LegalizeEdge(t, s.CwTriangle.OppositeEdge(t)), this.LegalizeEdge(t, s.CcwTriangle.OppositeEdge(t));
    }
  }
  // #if TEST_MSAGL && TEST_MSAGL
  // Array < DebugCurve > ShowIllegalEdge(CdtEdge edge, CdtSite pi, int i) {
  //     Array < DebugCurve > ls = new Array<DebugCurve>();
  //     ls.push(DebugCurve.mkDebugCurveTWCI(new Ellipse(2, 2, pi.point)));
  //     for (int j = 0; j < 3; j++) {
  //         var ee = edge.CcwTriangle.Edges[j];
  //         ls.push(DebugCurve.mkDebugCurveTWCI(j === i ? "red" : "blue", LineSegment.mkPP(ee.upperSite.point, ee.lowerSite.point)));
  //     }
  //     ls.push(DebugCurve.mkDebugCurveTWCI(100, 1, "black", Circumcircle(edge.CcwTriangle.Sites.getItem(0].point, edge.CcwTriangle.Sites[1].point, edge.CcwTriangle.Sites[2).point)));
  //     LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(ls);
  //     return ls;
  // }
  //         static Ellipse Circumcircle(Point a, Point b, Point c) {
  //     var mab = 0.5 * (a + b);
  //     var mbc = 0.5 * (c + b);
  //     Point center;
  //     Point.LineLineIntersection(mab, mab + (b - a).Rotate(Math.PI / 2), mbc, mbc + (b - c).Rotate(Math.PI / 2), out center);
  //     var r = (center - a).Length;
  //     return new Ellipse(r, r, center);
  // }
  // #endif
  ProjectToFront(t) {
    return this.front.findLast((e) => e.x <= t.point.x);
  }
  runEdgeInserter() {
    this.initEdgeInserter(), this.TraceEdgeThroughTriangles(), this.TriangulatePolygon0(this.rightPolygon, this.traversingEdge.upperSite, this.traversingEdge.lowerSite, !0), this.TriangulatePolygon0(this.leftPolygon, this.traversingEdge.upperSite, this.traversingEdge.lowerSite, !1), this.UpdateFront();
  }
  initEdgeInserter() {
    this.rightPolygon = new Array(), this.leftPolygon = new Array(), this.addedTriangles = new Array(), this.piercedEdge = null, this.piercedTriangle = null, this.piercedToTheLeftFrontElemNode = null, this.piercedToTheRightFrontElemNode = null;
  }
  UpdateFront() {
    const t = /* @__PURE__ */ new Set();
    for (const e of this.addedTriangles)
      for (const i of e.Edges)
        if (i.CwTriangle == null || i.CcwTriangle == null) {
          if (i.lowerSite == this.p_2 && i.upperSite == this.p_1)
            continue;
          t.add(i);
        }
    for (const e of t)
      this.AddEdgeToFront(e);
  }
  AddEdgeToFront(t) {
    const e = t.upperSite.point.x < t.lowerSite.point.x ? t.upperSite : t.lowerSite;
    this.front.insert(new Os(e, t));
  }
  TriangulatePolygon0(t, e, i, s) {
    t.length > 0 && this.TriangulatePolygon1(0, t.length - 1, t, e, i, s);
  }
  TriangulatePolygon1(t, e, i, s, n, r) {
    let o = i[t], l = t;
    for (let d = t + 1; d <= e; d++) {
      const f = i[d];
      c(f) && (l = d, o = f);
    }
    const h = ee.mkSSSD(s, n, o, this.createEdgeDelegate);
    this.triangles.add(h), this.addedTriangles.push(h), t < l && this.TriangulatePolygon1(t, l - 1, i, s, o, r), l < e && this.TriangulatePolygon1(l + 1, e, i, o, n, r);
    function c(d) {
      return r ? _o(d, s, o, n) : _o(d, s, n, o);
    }
  }
  TraceEdgeThroughTriangles() {
    this.initEdgeTracer(), this.Traverse();
  }
  Traverse() {
    for (; !this.BIsReached(); )
      this.piercedToTheLeftFrontElemNode != null ? this.ProcessLeftFrontPiercedElement() : this.piercedToTheRightFrontElemNode != null ? this.ProcessRightFrontPiercedElement() : this.ProcessPiercedEdge();
    this.piercedTriangle != null && this.removePiercedTriangle(this.piercedTriangle), this.FindMoreRemovedFromFrontElements();
    for (const t of this.elementsToBeRemovedFromFront)
      this.front.remove(t);
  }
  ProcessLeftFrontPiercedElement() {
    let t = this.piercedToTheLeftFrontElemNode;
    do
      this.elementsToBeRemovedFromFront.push(t.item), this.AddSiteToLeftPolygon(t.item.LeftSite), t = this.front.previous(t);
    while (u.pointToTheLeftOfLine(t.item.LeftSite.point, this.a.point, this.b.point));
    if (this.elementsToBeRemovedFromFront.push(t.item), this.AddSiteToRightPolygon(t.item.LeftSite), t.item.LeftSite === this.b) {
      this.piercedToTheLeftFrontElemNode = t;
      return;
    }
    this.FindPiercedTriangle(t), this.piercedToTheLeftFrontElemNode = null;
  }
  FindPiercedTriangle(t) {
    var e;
    const i = t.item.Edge, s = (e = i.CcwTriangle) !== null && e !== void 0 ? e : i.CwTriangle, n = s.Edges.index(i);
    for (let r = 1; r <= 2; r++) {
      const o = s.Edges.getItem(r + n), l = ji.sign(u.signedDoubledTriangleArea(o.lowerSite.point, this.a.point, this.b.point));
      if (ji.sign(u.signedDoubledTriangleArea(o.upperSite.point, this.a.point, this.b.point)) * l <= 0) {
        this.piercedTriangle = s, this.piercedEdge = o;
        break;
      }
    }
  }
  FindMoreRemovedFromFrontElements() {
    for (const t of this.removedTriangles)
      for (const e of t.Edges)
        if (e.CcwTriangle == null && e.CwTriangle == null) {
          const i = e.upperSite.point.x < e.lowerSite.point.x ? e.upperSite : e.lowerSite, s = Ft.FindNodeInFrontBySite(this.front, i);
          s.item.Edge === e && this.elementsToBeRemovedFromFront.push(s.item);
        }
  }
  ProcessPiercedEdge() {
    this.piercedEdge.CcwTriangle === this.piercedTriangle ? (this.AddSiteToLeftPolygon(this.piercedEdge.lowerSite), this.AddSiteToRightPolygon(this.piercedEdge.upperSite)) : (this.AddSiteToLeftPolygon(this.piercedEdge.upperSite), this.AddSiteToRightPolygon(this.piercedEdge.lowerSite)), this.removePiercedTriangle(this.piercedTriangle), this.PrepareNextStateAfterPiercedEdge();
  }
  PrepareNextStateAfterPiercedEdge() {
    var t, e;
    const i = (t = this.piercedEdge.CwTriangle) !== null && t !== void 0 ? t : this.piercedEdge.CcwTriangle, s = i.Edges.index(this.piercedEdge);
    for (let n = 1; n <= 2; n++) {
      const r = i.Edges.getItem(n + s), o = ji.sign(u.signedDoubledTriangleArea(r.lowerSite.point, this.a.point, this.b.point));
      if (ji.sign(u.signedDoubledTriangleArea(r.upperSite.point, this.a.point, this.b.point)) * o <= 0) {
        if (r.CwTriangle != null && r.CcwTriangle != null) {
          this.piercedTriangle = i, this.piercedEdge = r;
          break;
        }
        this.piercedTriangle = null, this.piercedEdge = null;
        const h = r.upperSite.point.x < r.lowerSite.point.x ? r.upperSite : r.lowerSite, c = Ft.FindNodeInFrontBySite(this.front, h);
        h.point.x < this.a.point.x ? this.piercedToTheLeftFrontElemNode = c : this.piercedToTheRightFrontElemNode = c, this.removePiercedTriangle((e = r.CwTriangle) !== null && e !== void 0 ? e : r.CcwTriangle);
        break;
      }
    }
  }
  removePiercedTriangle(t) {
    this.triangles.delete(t);
    for (const e of t.Edges)
      e.CwTriangle === t ? e.CwTriangle = null : e.CcwTriangle = null, this.removedTriangles.push(t);
  }
  ProcessRightFrontPiercedElement() {
    let t = this.piercedToTheRightFrontElemNode;
    do
      this.elementsToBeRemovedFromFront.push(t.item), this.AddSiteToRightPolygon(t.item.RightSite), t = this.front.next(t);
    while (u.pointToTheRightOfLine(t.item.RightSite.point, this.a.point, this.b.point));
    if (this.elementsToBeRemovedFromFront.push(t.item), this.AddSiteToLeftPolygon(t.item.RightSite), t.item.RightSite === this.b) {
      this.piercedToTheRightFrontElemNode = t;
      return;
    }
    this.FindPiercedTriangle(t), this.piercedToTheRightFrontElemNode = null;
  }
  AddSiteToLeftPolygon(t) {
    this.AddSiteToPolygonWithCheck(t, this.leftPolygon);
  }
  AddSiteToPolygonWithCheck(t, e) {
    t !== this.b && (e.length === 0 || e[e.length - 1] !== t) && e.push(t);
  }
  AddSiteToRightPolygon(t) {
    this.AddSiteToPolygonWithCheck(t, this.rightPolygon);
  }
  BIsReached() {
    var t;
    const e = (t = this.piercedToTheLeftFrontElemNode) !== null && t !== void 0 ? t : this.piercedToTheRightFrontElemNode;
    return e != null ? e.item.Edge.IsAdjacent(this.b) : this.piercedEdge.IsAdjacent(this.b);
  }
  initEdgeTracer() {
    this.elementsToBeRemovedFromFront = [], this.a = this.traversingEdge.upperSite, this.b = this.traversingEdge.lowerSite, this.removedTriangles = [];
    const t = Ft.FindNodeInFrontBySite(this.front, this.a), e = this.front.previous(t);
    if (u.pointToTheLeftOfLine(this.b.point, e.item.LeftSite.point, e.item.RightSite.point))
      this.piercedToTheLeftFrontElemNode = e;
    else if (u.pointToTheRightOfLine(this.b.point, t.item.RightSite.point, t.item.LeftSite.point))
      this.piercedToTheRightFrontElemNode = t;
    else
      for (const i of this.a.Edges) {
        const s = i.CcwTriangle;
        if (s == null || u.pointToTheLeftOfLine(this.b.point, i.lowerSite.point, i.upperSite.point))
          continue;
        const n = s.Edges.index(i), r = s.Sites.getItem(n + 2);
        if (u.pointToTheLeftOfLineOrOnLine(this.b.point, r.point, i.upperSite.point)) {
          this.piercedEdge = s.Edges.getItem(n + 1), this.piercedTriangle = s;
          break;
        }
      }
  }
}
function ko(a, t) {
  if (a.length === 0)
    return;
  const e = a.findIndex((i) => t === i);
  e >= 0 && (e !== a.length - 1 && (a[e] = a[a.length - 1]), a.pop());
}
function Cl(a, t, e, i) {
  return Lf(a, t, e, i) && _o(a, t, e, i);
}
function Lf(a, t, e, i) {
  return u.getTriangleOrientation(t.point, a.point, e.point) === L.Clockwise && u.getTriangleOrientation(e.point, a.point, i.point) === L.Clockwise;
}
function _o(a, t, e, i) {
  const s = t.point.x - a.point.x, n = t.point.y - a.point.y, r = e.point.x - a.point.x, o = e.point.y - a.point.y, l = i.point.x - a.point.x, h = i.point.y - a.point.y, c = s * s + n * n, d = r * r + o * o, f = l * l + h * h;
  return s * (o * f - h * d) - r * (n * f - h * c) + l * (n * d - o * c) > m.tolerance;
}
function Il(a, t) {
  let e, i;
  t.CcwTriangle.Contains(a) ? (e = t.CcwTriangle, i = t.CwTriangle) : (e = t.CwTriangle, i = t.CcwTriangle);
  const s = e.Edges.index(t), n = i.Edges.index(t), r = i.Sites.getItem(n + 2), o = e.Edges.getItem(s + 1), l = i.Edges.getItem(n + 1), h = gt.GetOrCreateEdge(a, r);
  return e.Sites.setItem(s + 1, r), e.Edges.setItem(s, l), e.Edges.setItem(s + 1, h), i.Sites.setItem(n + 1, a), i.Edges.setItem(n, o), i.Edges.setItem(n + 1, h), l.lowerSite === r ? l.CcwTriangle = e : l.CwTriangle = e, o.lowerSite === a ? o.CcwTriangle = i : o.CwTriangle = i, h.upperSite === a ? (h.CcwTriangle = i, h.CwTriangle = e) : (h.CcwTriangle = e, h.CwTriangle = i), ko(t.upperSite.Edges, t), h;
}
class gt extends ht {
  // constructor
  constructor(t, e, i) {
    super(null), this.isolatedSites = [], this.obstacles = [], this.PointsToSites = new ii(), this.simplifyObstacles = !0, this.rectangleNodeOnTriangles = null, this.isolatedSites = t, this.obstacles = e, this.isolatedSegments = i;
  }
  // constructor
  static constructor_(t) {
    const e = new gt(null, null, null);
    return e.isolatedSitesWithObject = t, e;
  }
  FillAllInputSites() {
    if (this.isolatedSitesWithObject != null)
      for (const t of this.isolatedSitesWithObject)
        this.AddSite(t[0], t[1]);
    if (this.isolatedSites != null)
      for (const t of this.isolatedSites)
        this.AddSite(t, null);
    if (this.obstacles != null)
      for (const t of this.obstacles)
        this.AddPolylineToAllInputSites(t);
    if (this.isolatedSegments != null)
      for (const t of this.isolatedSegments)
        this.AddConstrainedEdge(t.A, t.B, null);
    this.AddP1AndP2(), this.allInputSites = Array.from(this.PointsToSites.values());
  }
  AddSite(t, e) {
    let i;
    return (i = this.PointsToSites.get(t)) ? i.Owner = e : (i = Cn.mkSO(t, e), this.PointsToSites.set(t, i)), i;
  }
  AddP1AndP2() {
    const t = T.mkEmpty();
    for (const i of this.PointsToSites.keys())
      t.add(i);
    const e = 10;
    this.P1 = new Cn(t.leftBottom.add(new u(-e, -10))), this.P2 = new Cn(t.rightBottom.add(new u(e, -10)));
  }
  AddPolylineToAllInputSites(t) {
    if (this.simplifyObstacles)
      for (let e = t.startPoint; e != null; ) {
        const i = e.point;
        if (e = e.next, !e)
          break;
        for (; e.next && u.getTriangleOrientation(i, e.point, e.next.point) === L.Collinear; )
          e = e.next;
        this.AddConstrainedEdge(i, e.point, t);
      }
    else
      for (let e = t.startPoint; e.next != null; e = e.next)
        this.AddConstrainedEdge(e.point, e.next.point, t);
    t.closed && this.AddConstrainedEdge(t.endPoint.point, t.startPoint.point, t);
  }
  AddConstrainedEdge(t, e, i) {
    const s = gt.AbovePP(t, e);
    let n, r;
    s > 0 ? (n = this.AddSite(t, i), r = this.AddSite(e, i)) : (n = this.AddSite(e, i), r = this.AddSite(t, i));
    const o = gt.CreateEdgeOnOrderedCouple(n, r);
    o.constrained = !0;
  }
  static GetOrCreateEdge(t, e) {
    if (gt.AboveCC(t, e) === 1) {
      const i = t.EdgeBetweenUpperSiteAndLowerSite(e);
      return i ?? gt.CreateEdgeOnOrderedCouple(t, e);
    } else {
      const i = e.EdgeBetweenUpperSiteAndLowerSite(t);
      return i ?? gt.CreateEdgeOnOrderedCouple(e, t);
    }
  }
  static CreateEdgeOnOrderedCouple(t, e) {
    return new xf(t, e);
  }
  GetTriangles() {
    return this.sweeper.triangles;
  }
  // Executes the actual algorithm.
  run() {
    this.Initialization(), this.SweepAndFinalize();
  }
  SweepAndFinalize() {
    this.sweeper = new Ft(this.allInputSites, this.P1, this.P2, gt.GetOrCreateEdge), this.sweeper.run(), this.cleanRemovedEdges();
  }
  cleanRemovedEdges() {
    for (const t of this.PointsToSites.values())
      t.cleanRemovedEdges();
  }
  Initialization() {
    this.FillAllInputSites(), this.allInputSites.sort(gt.OnComparison);
  }
  static OnComparison(t, e) {
    return gt.AboveCC(t, e);
  }
  // compare first y then -x coordinates
  static AbovePP(t, e) {
    let i = t.y - e.y;
    return i > 0 ? 1 : i < 0 ? -1 : (i = t.x - e.x, i > 0 ? -1 : i < 0 ? 1 : 0);
  }
  // compare first y then -x coordinates
  static AboveCC(t, e) {
    return gt.AbovePP(t.point, e.point);
  }
  RestoreEdgeCapacities() {
    for (const t of this.allInputSites)
      for (const e of t.Edges)
        e.constrained || (e.ResidualCapacity = e.Capacity);
  }
  SetInEdges() {
    for (const t of this.PointsToSites.values())
      for (const e of t.Edges)
        e.lowerSite.AddInEdge(e);
  }
  FindSite(t) {
    return this.PointsToSites.get(t);
  }
  static PointIsInsideOfTriangle(t, e) {
    for (let i = 0; i < 3; i++) {
      const s = e.Sites.getItem(i).point, n = e.Sites.getItem(i + 1).point;
      if (u.signedDoubledTriangleArea(t, s, n) < m.distanceEpsilon * -1)
        return !1;
    }
    return !0;
  }
  getRectangleNodeOnTriangles() {
    return this.rectangleNodeOnTriangles == null && (this.rectangleNodeOnTriangles = Et(Array.from(this.GetTriangles().values()).map((t) => Bt(t, t.BoundingBox())))), this.rectangleNodeOnTriangles;
  }
}
function jh(a) {
  const t = Array.from(a.GetAllLeaves()), e = a.irect, i = e.diagonal / 4, s = e.clone();
  return s.pad(i), Rf(t.concat([s.perimeter()]));
}
function Rf(a) {
  const t = new gt(null, a, null);
  return t.run(), t;
}
class In {
  // constructor
  constructor(t, e) {
    this.start = t, this.end = e;
  }
  add(t) {
    this.add_d(t);
  }
  add_rect(t) {
    const e = t, i = this.clone();
    return i.add_d(e.start), i.add_d(e.end), i;
  }
  clone() {
    return new In(this.start, this.end);
  }
  contains_point(t) {
    return this.contains_d(t);
  }
  contains_rect(t) {
    const e = t;
    return this.contains_d(e.start) && this.contains_d(e.end);
  }
  intersection_rect(t) {
    const e = t;
    return new In(Math.max(this.start, e.start), Math.min(this.end, e.end));
  }
  intersects_rect(t) {
    const e = t;
    return this.intersects(e);
  }
  contains_point_radius(t, e) {
    return this.contains_d(t - e) && this.contains_d(t + e);
  }
  //
  static mkInterval(t, e) {
    const i = new In(t.start, t.end);
    return i.add_d(e.start), i.add_d(e.end), i;
  }
  // expanding the range to hold v
  add_d(t) {
    this.start > t && (this.start = t), this.end < t && (this.end = t);
  }
  get Start() {
    return this.start;
  }
  set Start(t) {
    this.start = t;
  }
  // the length
  get Length() {
    return this.end - this.start;
  }
  // return true if the value is inside the range
  contains_d(t) {
    return this.start <= t && t <= this.end;
  }
  // bringe v into the range
  GetInRange(t) {
    return t < this.start ? this.start : t > this.end ? this.end : t;
  }
  // returns true if and only if two intervals are intersecting
  intersects(t) {
    return t.start > this.end + m.distanceEpsilon ? !1 : !(t.end < this.start - m.distanceEpsilon);
  }
}
class qh {
  get Count() {
    return this.heapSize;
  }
  // the constructor
  // we assume that all integers inserted into the queue will be non-negative and less then n
  constructor(t) {
    this.heapSize = 0, this._priors = new Array(t), this._heap = new Array(t + 1), this._reverse_heap = new Array(t);
  }
  SwapWithParent(t) {
    const e = this._heap[t >> 1];
    this.PutAtI(t >> 1, this._heap[t]), this.PutAtI(t, e);
  }
  Enqueue(t, e) {
    this.heapSize++;
    let i = this.heapSize;
    for (this._priors[t] = e, this.PutAtI(i, t); i > 1 && this._priors[this._heap[i >> 1]] > e; )
      this.SwapWithParent(i), i >>= 1;
  }
  PutAtI(t, e) {
    this._heap[t] = e, this._reverse_heap[e] = t;
  }
  // return the first element of the queue and removes it from the queue
  Dequeue() {
    if (this.heapSize === 0)
      throw new Error();
    const t = this._heap[1];
    if (this.heapSize > 1) {
      this.PutAtI(1, this._heap[this.heapSize]);
      let e = 1;
      for (; ; ) {
        let i = e;
        const s = e << 1;
        s <= this.heapSize && this._priors[this._heap[s]] < this._priors[this._heap[e]] && (i = s);
        const n = s + 1;
        if (n <= this.heapSize && this._priors[this._heap[n]] < this._priors[this._heap[i]] && (i = n), i !== e)
          this.SwapWithParent(i);
        else
          break;
        e = i;
      }
    }
    return this.heapSize--, t;
  }
  IsEmpty() {
    return this.heapSize === 0;
  }
  DecreasePriority(t, e) {
    this._priors[t] = e;
    let i = this._reverse_heap[t];
    for (; i > 1 && this._priors[this._heap[i]] < this._priors[this._heap[i >> 1]]; ) {
      this.SwapWithParent(i);
      i >>= 1;
    }
  }
}
class Nf {
  constructor(t, e, i, s) {
    this._numberOfOverlaps = 0, this._proximityEdges = t, this._nodeSizes = e, this._nodePositions = i, this._forLayers = s, this._q = new qh(e.length * 2);
  }
  Run() {
    return this.InitQueue(), this.FindOverlaps(), this._numberOfOverlaps;
  }
  FindOverlaps() {
    for (; this._q.Count > 0; ) {
      let t = this._q.Dequeue();
      t < this._nodePositions.length ? (this.FindOverlapsWithInterval(t), this.AddIntervalToTree(t)) : (t -= this._nodePositions.length, this.RemoveIntervalFromTree(t));
    }
  }
  RemoveIntervalFromTree(t) {
    this._intervalTree.Remove(this.GetInterval(t), t);
  }
  AddIntervalToTree(t) {
    const e = this.GetInterval(t);
    this._intervalTree == null && (this._intervalTree = mn([])), this._intervalTree.Add(e, t);
  }
  FindOverlapsWithInterval(t) {
    if (this._intervalTree == null)
      return;
    const e = this.GetInterval(t);
    for (const i of this._intervalTree.GetAllIntersecting(e)) {
      const s = qe.GetIdealEdge(t, i, this._nodePositions[t], this._nodePositions[i], this._nodeSizes);
      if (s.overlapFactor <= 1)
        return;
      this._proximityEdges.push(s), this._numberOfOverlaps++;
    }
  }
  GetInterval(t) {
    const e = this._nodeSizes[t].width / 2, i = this._nodePositions[t].x;
    return new In(i - e, i + e);
  }
  InitQueue() {
    for (let t = 0; t < this._nodeSizes.length; t++) {
      const e = this._nodeSizes[t].height / 2, i = this._nodePositions[t].y;
      this._q.Enqueue(t, i - e), this._q.Enqueue(this._nodeSizes.length + t, i + e);
    }
  }
}
class El {
  constructor(t, e, i) {
    this.treeNodes = /* @__PURE__ */ new Set(), this.hedgehog = /* @__PURE__ */ new Map(), this.graph = t, this.weight = e, this.root = i, this.q = new qh(this.graph.nodeCount);
  }
  NodeIsInTree(t) {
    return this.treeNodes.has(t);
  }
  GetTreeEdges() {
    const t = new Array();
    for (this.Init(); t.length < this.graph.nodeCount - 1 && this.q.Count > 0; )
      this.AddEdgeToTree(t);
    return t;
  }
  AddEdgeToTree(t) {
    const e = this.q.Dequeue(), i = this.hedgehog.get(e);
    this.treeNodes.add(e), t.push(i), this.UpdateOutEdgesOfV(e), this.UpdateInEdgesOfV(e);
  }
  UpdateOutEdgesOfV(t) {
    for (const e of this.graph.outEdges[t]) {
      const i = e.target;
      if (this.NodeIsInTree(i))
        continue;
      const s = this.hedgehog.get(i);
      if (s) {
        const n = this.weight(s), r = this.weight(e);
        r < n && (this.q.DecreasePriority(i, r), this.hedgehog.set(i, e));
      } else
        this.q.Enqueue(i, this.weight(e)), this.hedgehog.set(i, e);
    }
  }
  UpdateInEdgesOfV(t) {
    for (const e of this.graph.inEdges[t]) {
      const i = e.source;
      if (this.NodeIsInTree(i))
        continue;
      const s = this.hedgehog.get(i);
      if (s) {
        const n = this.weight(s), r = this.weight(e);
        r < n && (this.q.DecreasePriority(i, r), this.hedgehog.set(i, e));
      } else
        this.q.Enqueue(i, this.weight(e)), this.hedgehog.set(i, e);
    }
  }
  Init() {
    this.treeNodes.add(this.root);
    for (const t of this.graph.outEdges[this.root]) {
      const e = this.weight(t);
      this.q.Enqueue(t.target, e), this.hedgehog.set(t.target, t);
    }
    for (const t of this.graph.inEdges[this.root]) {
      const e = this.weight(t);
      this.q.Enqueue(t.source, e), this.hedgehog.set(t.source, t);
    }
  }
}
class Sa {
  // Computes the minimum spanning tree on a set of edges
  static GetMst(t, e) {
    if (t.length === 0)
      return null;
    const i = t.map((o) => new U(o.source, o.target)), s = new Ki();
    for (let o = 0; o < t.length; o++)
      s.setPair(i[o], t[o]);
    const n = fi(i, e);
    return new El(n, (o) => s.get(o.source, o.target).weight, i[0].source).GetTreeEdges().map((o) => s.get(o.source, o.target));
  }
  // Computes the minimum spanning tree on a DT with given weights.
  static GetMstOnCdt(t, e) {
    const i = Array.from(t.PointsToSites.values()), s = /* @__PURE__ */ new Map();
    for (let l = 0; l < i.length; l++)
      s.set(i[l], l);
    const n = Sa.GetEdges(i, s), r = kh(Array.from(n.keys()));
    return new El(r, (l) => e(n.get(l.source, l.target)), 0).GetTreeEdges().map((l) => n.get(l.source, l.target));
  }
  static GetEdges(t, e) {
    const i = new Ki();
    for (let s = 0; s < t.length; s++) {
      const n = t[s], r = e.get(n);
      for (const o of n.Edges)
        i.set(r, e.get(o.lowerSite), o);
    }
    return i;
  }
}
class ya {
  constructor() {
    this.epsilon = 0.01, this.iterationsMax = 1e3, this.stopOnMaxIterat = !1, this.nodeSeparation = 4, this.randomizationSeed = 1, this.randomizationShift = 0.1;
  }
  // If true, the overlap iteration process stops after maxIterat iterations.
  get StopOnMaxIterat() {
    return this.stopOnMaxIterat;
  }
  set StopOnMaxIterat(t) {
    this.stopOnMaxIterat = t;
  }
  // Epsilon
  get Epsilon() {
    return this.epsilon;
  }
  set Epsilon(t) {
    this.epsilon = t;
  }
  // Number of maxIterat to be made. In each iteration overlap is partly removed.
  get IterationsMax() {
    return this.iterationsMax;
  }
  set IterationsMax(t) {
    this.iterationsMax = t;
  }
  // Minimal distance between nodes.
  get NodeSeparation() {
    return this.nodeSeparation;
  }
  set NodeSeparation(t) {
    this.nodeSeparation = t;
  }
  //
  get RandomizationSeed() {
    return this.randomizationSeed;
  }
  set RandomizationSeed(t) {
    this.randomizationSeed = t;
  }
  //
  get RandomizationShift() {
    return this.randomizationShift;
  }
  set RandomizationShift(t) {
    this.randomizationShift = t;
  }
  // Clones the settings together with the stressmajorization settings
  Clone() {
    const t = new ya();
    return t.Epsilon = this.Epsilon, t.IterationsMax = this.IterationsMax, t.StopOnMaxIterat = this.StopOnMaxIterat, t.NodeSeparation = this.NodeSeparation, t.RandomizationSeed = this.RandomizationSeed, t.RandomizationShift = this.randomizationShift, t;
  }
}
class qe {
  // Settings to be used for the overlap removal, not all of them are used.
  constructor(t, e) {
    this._settings = t, this._nodes = e;
  }
  // Removes the overlap by using the default settings.
  static RemoveOverlaps(t, e) {
    const i = new ya();
    i.RandomizationShift = 1, i.NodeSeparation = e, new qe(i, t).RemoveOverlaps();
  }
  // Removes the overlaps for the given graph.
  RemoveOverlaps() {
    if (this._nodes.length < 3) {
      this.RemoveOverlapsOnTinyGraph();
      return;
    }
    const t = { nodePositions: new Array(), nodeSizes: new Array() };
    for (Bf(this._settings, this._nodes, t, this._settings.RandomizationShift), this.lastRunNumberIterations = 0; this.OneIteration(t.nodePositions, t.nodeSizes, !1); )
      this.lastRunNumberIterations++;
    for (; this.OneIteration(t.nodePositions, t.nodeSizes, !0); )
      this.lastRunNumberIterations++;
    for (let e = 0; e < this._nodes.length; e++)
      this._nodes[e].center = t.nodePositions[e];
  }
  RemoveOverlapsOnTinyGraph() {
    if (this._nodes.length !== 1 && this._nodes.length === 2) {
      const t = this._nodes[0], e = this._nodes[1];
      u.closeDistEps(t.center, e.center) && (e.center = e.center.add(new u(1e-3, 0)));
      const i = this.GetIdealDistanceBetweenTwoNodes(t, e), s = u.middle(t.center, e.center);
      let n = t.center.sub(e.center);
      const r = n.length;
      n = n.mul(0.5 * (i / r)), t.center = s.add(n), e.center = s.sub(n);
    }
  }
  GetIdealDistanceBetweenTwoNodes(t, e) {
    const i = t.center.sub(e.center), s = Math.abs(i.x), n = Math.abs(i.y), r = (t.width + e.width) / 2 + this._settings.NodeSeparation, o = (t.height + e.height) / 2 + this._settings.NodeSeparation;
    let l = Number.POSITIVE_INFINITY, h = Number.POSITIVE_INFINITY;
    return s > m.tolerance && (l = r / s), n > m.tolerance && (h = o / n), Math.min(l, h) * i.length;
  }
  static AvgEdgeLength(t) {
    let e = 0, i = 0;
    for (const s of t)
      for (const n of s.outEdges())
        i += s.center.sub(n.target.center).length, e++;
    return e > 0 ? i / e : 1;
  }
  // Does one iterations in which a miniminum spanning tree is
  // determined on the delaunay triangulation and finally the tree is extended to resolve the overlaps.
  OneIteration(t, e, i) {
    const s = new Array();
    for (let c = 0; c < t.length; c++)
      s.push([t[c], c]);
    const n = gt.constructor_(s);
    n.run();
    const r = /* @__PURE__ */ new Map();
    for (let c = 0; c < t.length; c++)
      r.set(n.PointsToSites.get(t[c]), c);
    let o = 0;
    const l = new Array();
    for (const c of n.PointsToSites.values())
      for (const d of c.Edges) {
        const f = d.upperSite.point, p = d.lowerSite.point, P = r.get(d.upperSite), y = r.get(d.lowerSite), C = qe.GetIdealEdge(P, y, f, p, e);
        l.push(C), C.overlapFactor > 1 && o++;
      }
    if (o === 0 || i) {
      const c = this.FindProximityEdgesWithSweepLine(l, e, t);
      if (o === 0 && c === 0 || o === 0 && !i)
        return !1;
    }
    const h = Sa.GetMst(l, t.length);
    return qe.MoveNodePositions(h, t, h[0].source), !0;
  }
  FindProximityEdgesWithSweepLine(t, e, i) {
    return new Nf(t, e, i, this._overlapForLayers).Run();
  }
  // Returns an edge with: i, j, t(overlapFactor), ideal distance, edge weight.
  static GetIdealEdge(t, e, i, s, n) {
    const r = { overlapFactor: 0 }, o = qe.GetIdealEdgeLength(t, e, i, s, n, r), l = i.sub(s).length, h = T.mkSizeCenter(n[t], i), c = T.mkSizeCenter(n[e], s), d = r.overlapFactor > 1 ? l - o : qe.GetDistanceRects(h, c);
    return {
      source: Math.min(t, e),
      target: Math.max(t, e),
      overlapFactor: r.overlapFactor,
      idealDistance: o,
      weight: d
    };
  }
  // Returns the ideal edge length, such that the overlap is removed.
  static GetIdealEdgeLength(t, e, i, s, n, r) {
    const o = i.sub(s), l = o.length, h = Math.abs(o.x), c = Math.abs(o.y), d = (n[t].width + n[e].width) / 2, f = (n[t].height + n[e].height) / 2;
    if (h >= d || c >= f)
      return r.overlapFactor = 1, o.length;
    let p;
    const P = 1e-10;
    if (h > P)
      c > P ? p = Math.min(d / h, f / c) : p = d / h;
    else if (c > P)
      p = f / c;
    else
      return r.overlapFactor = 2, Math.sqrt(d * d + f * f) / 4;
    return p = Math.max(p, 1.001), r.overlapFactor = p, p * l;
  }
  // Returns the distance between two given rectangles or zero if they intersect.
  static GetDistanceRects(t, e) {
    if (t.intersects(e))
      return 0;
    let i = 0, s = 0;
    return (t.right < e.left || e.right < t.left) && (s = t.left - e.right), t.top < e.bottom ? i = e.bottom - t.top : e.top < t.bottom && (i = t.bottom - e.top), Math.sqrt(s * s + i * i);
  }
  /*
    // Shows the current state of the algorithm for debug purposes.
    ShowAndMoveBoxesRemoveLater(treeEdges: Array<MstEdge>, proximityEdges: Array<MstEdge>, nodeSizes: Size[], nodePos: Point[], rootId: number) {
      let l = new Array<DebugCurve>();
      for (let tuple of proximityEdges) {
        l.Add(new DebugCurve(100, 0.5, "black", new LineSegment(nodePos[tuple.Item1], nodePos[tuple.Item2])));
      }
  
      // just for debug
      let nodeBoxes = new Array(nodeSizes.length);
      for (let i: number = 0; (i < nodePos.length); i++) {
        nodeBoxes[i] = new Rectangle(nodeSizes[i], nodePos[i]);
      }
  
      l.AddRange(nodeBoxes.Select(() => { }, new DebugCurve(100, 0.3, "green", b.Perimeter())));
      if ((treeEdges != null)) {
        l.AddRange(treeEdges.Select(() => { }, new DebugCurve(200, GTreeOverlapRemoval.GetEdgeWidth(e), "red", new LineSegment(nodePos[e.Item1], nodePos[e.Item2]))));
      }
  
      if ((rootId >= 0)) {
        l.Add(new DebugCurve(100, 10, "blue", CurveFactory.CreateOctagon(30, 30, nodePos[rootId])));
      }
  
      LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);
    }
  
    static GetEdgeWidth(edge: MstEdge): number {
      if ((edge.Item3 > 1)) {
        return 6;
      }
  
      return 2;
    }
  */
  // Lets the tree grow according to the ideal distances.
  static MoveNodePositions(t, e, i) {
    const s = e.map((r) => r.clone()), n = /* @__PURE__ */ new Set();
    n.add(i);
    for (let r = 0; r < t.length; r++) {
      const o = t[r];
      n.has(o.source) ? qe.MoveNode(o.source, o.target, s, e, n, o.idealDistance) : qe.MoveNode(o.target, o.source, s, e, n, o.idealDistance);
    }
  }
  static MoveNode(t, e, i, s, n, r) {
    let o = i[e].sub(i[t]);
    o = o.mul(r / o.length + 0.01), s[e] = s[t].add(o), n.add(e);
  }
  //
  GetLastRunIterations() {
    return this.lastRunNumberIterations;
  }
}
function Bf(a, t, e, i) {
  e.nodePositions = t.map((s) => s.center), i && Gf(e.nodePositions, new $r(0, 0), i), e.nodeSizes = t.map((s) => {
    const n = s.boundingBox.size;
    return n.width += a.NodeSeparation, n.height += a.NodeSeparation, n;
  });
}
function Gf(a, t, e) {
  const i = new xt();
  for (let s = 0; s < a.length; s++) {
    let n = a[s];
    if (e || i.has(n))
      do {
        const r = n.x + (2 * t.random() - 1) * e, o = n.y + (2 * t.random() - 1) * e;
        n = new u(r, o);
      } while (i.has(n));
    a[s] = n, i.add(n);
  }
}
class Fn extends ht {
  // Constructs the multidimensional scaling algorithm.
  constructor(t, e, i, s) {
    super(i), this.settings = t, this.graph = e, this.length = s;
  }
  // Executes the algorithm
  run() {
    this.LayoutConnectedGraphWithMds(), this.graph.pumpTheBoxToTheGraphWithMargins();
  }
  // Scales a configuration such that the average edge length in the drawing
  // equals the average of the given edge lengths.
  static ScaleToAverageEdgeLength(t, e, i, s) {
    const n = /* @__PURE__ */ new Map();
    let r = 0;
    for (const h of t.shallowNodes)
      n.set(h, r), r++;
    let o = 0, l = 0;
    for (const h of t.shallowEdges) {
      const c = n.get(h.source), d = n.get(h.target);
      l += Math.sqrt(Math.pow(e[c] - e[d], 2) + Math.pow(i[c] - i[d], 2)), o += s(h);
    }
    if (o > 0 && (l /= o), l > 0)
      for (let h = 0; h < e.length; h++)
        e[h] /= l, i[h] /= l;
  }
  // Layouts a connected graph with Multidimensional Scaling, using
  // shortest-path distances as Euclidean target distances.
  static LayoutGraphWithMds(t, e, i, s) {
    if (i.x = new Array(t.shallowNodeCount), i.y = new Array(t.shallowNodeCount), i.x.length === 0)
      return;
    if (i.x.length === 1) {
      i.x[0] = i.y[0] = 0;
      return;
    }
    const n = Math.min(e.PivotNumber, t.shallowNodeCount), r = e.GetNumberOfIterationsWithMajorization(t.shallowNodeCount), o = e.Exponent, l = new Array(n), h = new Tf(t, l, s);
    h.run();
    const c = h.Result;
    if (et.LandmarkClassicalScaling(c, i, l), Fn.ScaleToAverageEdgeLength(t, i.x, i.y, s), r > 0) {
      const d = new Pa(t, s);
      d.run();
      const f = d.Result, p = et.ExponentialWeightMatrix(f, o);
      et.DistanceScalingSubset(f, i.x, i.y, p, r);
    }
  }
  LayoutConnectedGraphWithMds() {
    const t = { x: [], y: [] };
    Fn.LayoutGraphWithMds(this.graph, this.settings, t, this.length), this.settings.RotationAngle !== 0 && Of.Rotate(t.x, t.y, this.settings.RotationAngle);
    let e = 0;
    for (const i of this.graph.shallowNodes)
      i.boundingBox && (i.center = new u(t.x[e] * this.settings.ScaleX, t.y[e] * this.settings.ScaleY)), e++;
    this.settings.removeOverlaps && qe.RemoveOverlaps(Array.from(this.graph.shallowNodes), this.settings.NodeSeparation), this.graph.pumpTheBoxToTheGraphWithMargins();
  }
  ScaleNodes(t, e) {
    for (const i of t)
      i.center = i.center.mul(e);
  }
  //  static UpdateTree(tree: RectangleNode<Node, Point>) {
  //    if (tree.IsLeaf) {
  //      tree.irect = tree.UserData.BoundingBox
  //    } else {
  //      MdsGraphLayout.UpdateTree(tree.Left)
  //      MdsGraphLayout.UpdateTree(tree.Right)
  //      tree.rectangle = tree.Left.rectangle
  //      tree.rectangle.Add(tree.Right.rectangle)
  //    }
  //  }
  //  static NumberOfHits(
  //    numberOfChecks: number,
  //    random: Random,
  //    tree: RectangleNode<Node, Point>,
  //    maxNumberOfHits: number,
  //  ): number {
  //    //  var l = new Array<Point>();
  //    let numberOfHits = 0
  //    for (let i = 0; i < numberOfChecks; i++) {
  //      const point: Point = MdsGraphLayout.RandomPointFromBox(
  //        random,
  //        <Rectangle>tree.rectangle,
  //      )
  //      //    l.Add(point);
  //      HitTestBehavior.Stop
  //      null
  //      numberOfHits++
  //      if (numberOfHits === maxNumberOfHits) {
  //        return maxNumberOfHits
  //      }
  //    }
  //    // LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(Getdc(tree, l));
  //    return numberOfHits
  //  }
  //  static BuildNodeTree(nodes: IList<Node>): RectangleNode<Node, Point> {
  //    return RectangleNode.CreateRectangleNodeOnListOfNodes(
  //      nodes.Select(() => {}, new RectangleNode<Node, Point>(n, n.BoundingBox)),
  //    )
  //  }
  //  static RandomPointFromBox(random: Random, boundingBox: Rectangle): Point {
  //    const x = random.NextDouble()
  //    const y = random.NextDouble()
  //    const p = new Point(
  //      boundingBox.left + boundingBox.width * x,
  //      boundingBox.bottom + boundingBox.height * y,
  //    )
  //    return p
  //  }
  // Pack the given graph components to the specified aspect ratio
  static PackGraphs(t, e) {
    if (t.length === 0)
      return T.mkEmpty();
    if (t.length === 1)
      return t[0].boundingBox;
    const i = t.map((r) => r.boundingBox), s = new Array();
    for (const r of t)
      s.push({ g: r, lb: r.boundingBox.leftBottom.clone() });
    const n = new Fh(i, e.PackingAspectRatio);
    n.run();
    for (const { g: r, lb: o } of s) {
      const l = r.boundingBox.leftBottom.sub(o);
      r.translate(l);
    }
    return new T({
      left: 0,
      bottom: 0,
      right: n.PackedWidth,
      top: n.PackedHeight
    });
  }
}
class Vn {
  constructor() {
    this.commonSettings = new Js(), this.pivotNumber = 50, this.iterationsWithMajorization = 30, this.scaleX = 100, this.scaleY = 100, this.exponent = -2, this.rotationAngle = 0, this._removeOverlaps = !0, this._callIterationsWithMajorizationThreshold = 2e3, this.adjustScale = !1;
  }
  static fromJSON(t) {
    const e = new Vn();
    return t.pivotNumber && (e.pivotNumber = t.pivotNumber), t.iterationsWithMajorization && (e.iterationsWithMajorization = t.iterationsWithMajorization), t.scaleX && (e.scaleX = t.scaleX), t.scaleY && (e.scaleY = t.scaleY), t.exponent && (e.exponent = t.exponent), t.rotationAngle && (e.rotationAngle = t.rotationAngle), t.removeOverlaps != null && (e._removeOverlaps = t.removeOverlaps), t._callIterationsWithMajorizationThreshold && (e._callIterationsWithMajorizationThreshold = t._callIterationsWithMajorizationThreshold), e;
  }
  toJSON() {
    const t = {};
    return this.pivotNumber != 50 && (t.pivotNumber = this.pivotNumber), this.iterationsWithMajorization != 30 && (t.iterationsWithMajorization = this.iterationsWithMajorization), this.scaleX != 200 && (t.scaleX = this.scaleX), this.scaleY != 200 && (t.scaleY = this.scaleY), this.exponent != -2 && (t.exponent = this.exponent), this.rotationAngle != 0 && (t.rotationAngle = this.rotationAngle), this._removeOverlaps || (t.removeOverlaps = this._removeOverlaps), this._callIterationsWithMajorizationThreshold != 3e3 && (t._callIterationsWithMajorizationThreshold = this._callIterationsWithMajorizationThreshold), t;
  }
  get NodeSeparation() {
    return this.commonSettings.NodeSeparation;
  }
  set NodeSeparation(t) {
    this.commonSettings.NodeSeparation = t;
  }
  get edgeRoutingSettings() {
    return this.commonSettings.edgeRoutingSettings;
  }
  set edgeRoutingSettings(t) {
    this.commonSettings.edgeRoutingSettings = t;
  }
  // remove overlaps between node boundaries
  get removeOverlaps() {
    return this._removeOverlaps;
  }
  set removeOverlaps(t) {
    this._removeOverlaps = t;
  }
  // Number of pivots in Landmark Scaling (between 3 and number of objects).
  get PivotNumber() {
    return this.pivotNumber;
  }
  set PivotNumber(t) {
    this.pivotNumber = t;
  }
  /** Number of iterations in distance scaling: these iterations beautify the layout locally. This heuristic is optional , and the property has to be set to zero for a large graph, because each iteration has O(n*n) time, where n is the number of nodes in the graph */
  get IterationsWithMajorization() {
    return this.iterationsWithMajorization;
  }
  set IterationsWithMajorization(t) {
    this.iterationsWithMajorization = t;
  }
  // X Scaling Factor.
  get ScaleX() {
    return this.scaleX;
  }
  set ScaleX(t) {
    this.scaleX = t;
  }
  // Y Scaling Factor.
  get ScaleY() {
    return this.scaleY;
  }
  set ScaleY(t) {
    this.scaleY = t;
  }
  // Weight matrix exponent.
  get Exponent() {
    return this.exponent;
  }
  set Exponent(t) {
    this.exponent = t;
  }
  // rotation angle
  get RotationAngle() {
    return this.rotationAngle;
  }
  set RotationAngle(t) {
    this.rotationAngle = t % 360;
  }
  // Adjust the scale of the graph if there is not enough whitespace between nodes
  get AdjustScale() {
    return this.adjustScale;
  }
  set AdjustScale(t) {
    this.adjustScale = t;
  }
  GetNumberOfIterationsWithMajorization(t) {
    return t > this.CallIterationsWithMajorizationThreshold ? 0 : this.IterationsWithMajorization;
  }
  get CallIterationsWithMajorizationThreshold() {
    return this._callIterationsWithMajorizationThreshold;
  }
  set CallIterationsWithMajorizationThreshold(t) {
    this._callIterationsWithMajorizationThreshold = t;
  }
}
class Uh extends ht {
  get scaleX() {
    return this.settings.ScaleX;
  }
  set scaleX(t) {
    this.settings.ScaleX = t;
  }
  // scales the final layout by the specified factor on Y
  get scaleY() {
    return this.settings.ScaleY;
  }
  set scaleY(t) {
    this.settings.ScaleY = t;
  }
  // Layout graph by the PivotMds method.  Uses spectral techniques to obtain a layout in
  // O(n^2) time when iterations with majorization are used, otherwise it is more like O(PivotNumber*n).
  constructor(t, e, i, s) {
    super(e), this.graph = t, this.length = i, this.settings = s, this.settings.ScaleX = this.settings.ScaleY = 200;
  }
  // Executes the actual algorithm.
  run() {
    new Fn(this.settings, this.graph, this.cancelToken, this.length).run();
  }
}
function Xh(a, t, e) {
  if (t)
    for (const i of t) {
      if (e && e.canceled)
        return;
      ye.RouteEdge(i);
    }
  else
    for (const i of a.nodesBreadthFirst) {
      if (e && e.canceled)
        return;
      for (const s of i.outEdges())
        s.curve == null && ye.RouteEdge(s);
      for (const s of i.selfEdges())
        s.curve == null && ye.RouteEdge(s);
    }
}
class ye extends ht {
  // Constructs a basic straight geomedge router.
  constructor(t, e) {
    super(null), this.edges = t, this.padding = e;
  }
  // Executes the algorithm.
  run() {
    it.CreatePortsIfNeeded(this.edges);
    for (const t of this.edges)
      ye.RouteEdge(t);
  }
  // populate the geometry including curve and arrowhead positioning for the given geomedge using simple
  // straight line routing style.  Self edges will be drawn as a loop, padding is used to control the
  // size of the loop.
  static RouteEdge(t) {
    const e = t;
    e.sourcePort == null && (e.sourcePort = Zi.mk(() => t.source.boundaryCurve, () => t.source.center)), e.targetPort == null && (e.targetPort = Zi.mk(() => t.target.boundaryCurve, () => t.target.center)), ye.ContainmentLoop(e) || (e.curve = ye.GetEdgeLine(t)), vt.trimSplineAndCalculateArrowheadsII(e, e.sourcePort.Curve, e.targetPort.Curve, t.curve, !1);
  }
  static ContainmentLoop(t) {
    const e = t.sourcePort.Curve, i = t.targetPort.Curve;
    if (e == null || i == null)
      return !1;
    const s = e.boundingBox, n = i.boundingBox, r = s.containsRect(n), o = !r && n.containsRect(s);
    return r || o ? (t.curve = ye.CreateLoop(s, n, o), !0) : !1;
  }
  static CreateLoop(t, e, i) {
    return i ? ye.CreateLoop_(t, e, !1) : ye.CreateLoop_(e, t, !0);
  }
  // creates a loop from sourceBox center to the closest point on the targetBox boundary
  static CreateLoop_(t, e, i) {
    const s = t.center, n = ye.FindClosestPointOnBoxBoundary(t.center, e);
    let r = n.sub(s);
    const l = (Math.abs(r.x) < m.distanceEpsilon ? Math.min(s.y - e.bottom, e.top - s.y) : Math.min(s.x - e.left, e.right - s.x)) / 2, h = 1, c = Math.min(h, l);
    r.length <= m.distanceEpsilon && (r = new u(1, 0));
    const d = r.normalize(), f = d.rotate(Math.PI / 2), p = n.add(d.mul(h)), P = p.add(f.mul(c)), y = n.add(f.mul(c)), C = s.add(f.mul(c));
    return (i ? Tt.mkFromPoints([C, y, P, p, n, s]) : Tt.mkFromPoints([s, n, p, P, y, C])).createCurve();
  }
  static FindClosestPointOnBoxBoundary(t, e) {
    const i = t.x - e.left < e.right - t.x ? e.left : e.right, s = t.y - e.bottom < e.top - t.y ? e.bottom : e.top;
    return Math.abs(i - t.x) < Math.abs(s - t.y) ? new u(i, t.y) : new u(t.x, s);
  }
  // Returns a line segment for the given geomedge.
  static GetEdgeLine(t) {
    let e, i;
    t.sourcePort == null ? (e = t.source.center, i = t.source.boundaryCurve) : (e = t.sourcePort.Location, i = t.sourcePort.Curve);
    let s, n;
    t.targetPort == null ? (s = t.target.center, n = t.target.boundaryCurve) : (s = t.targetPort.Location, n = t.targetPort.Curve);
    let r = v.mkPP(e, s), o = g.getAllIntersections(i, r, !1);
    if (o.length > 0) {
      let l = r.trim(o[0].par1, 1);
      l instanceof v && (r = l, o = g.getAllIntersections(n, r, !1), o.length > 0 && (l = r.trim(0, o[0].par1), l instanceof v && (r = l)));
    }
    return r;
  }
  // creates an geomedge curve based only on the source and target geometry
  static CreateSimpleEdgeCurveWithUnderlyingPolyline(t) {
    const e = t.sourcePort ? t.sourcePort.Location : t.source.center, i = t.targetPort ? t.targetPort.Location : t.target.center;
    if (t.source === t.target) {
      const s = 2 / (3 * t.source.boundaryCurve.boundingBox.width), n = t.source.boundingBox.height / 4;
      t.smoothedPolyline = ye.CreateUnderlyingPolylineForSelfEdge(e, s, n), t.curve = t.smoothedPolyline.createCurve();
    } else
      t.smoothedPolyline = Tt.mkFromPoints([e, i]), t.curve = t.smoothedPolyline.createCurve();
    vt.trimSplineAndCalculateArrowheadsII(t, t.source.boundaryCurve, t.target.boundaryCurve, t.curve, !1);
  }
  static CreateUnderlyingPolylineForSelfEdge(t, e, i) {
    const s = t.add(new u(0, i)), n = t.add(new u(e, i)), r = t.add(new u(e, i * -1)), o = t.add(new u(0, i * -1));
    let l = St.mkSiteP(t);
    const h = new Tt(l);
    return l = St.mkSiteSP(l, s), l = St.mkSiteSP(l, n), l = St.mkSiteSP(l, r), l = St.mkSiteSP(l, o), St.mkSiteSP(l, t), h;
  }
  static SetStraightLineEdgesWithUnderlyingPolylines(t) {
    it.CreatePortsIfNeeded(Array.from(t.deepEdges));
    for (const e of t.deepEdges)
      ye.CreateSimpleEdgeCurveWithUnderlyingPolyline(e);
  }
}
var os;
(function(a) {
  a[a.OverlapsOtherLabels = 0] = "OverlapsOtherLabels", a[a.OverlapsNodes = 1] = "OverlapsNodes", a[a.OverlapsEdges = 2] = "OverlapsEdges", a[a.OverlapsNothing = Number.MAX_VALUE] = "OverlapsNothing";
})(os || (os = {}));
var re;
(function(a) {
  a[a.Any = 0] = "Any", a[a.Port = 1] = "Port", a[a.Starboard = 2] = "Starboard", a[a.Top = 3] = "Top", a[a.Bottom = 4] = "Bottom", a[a.Left = 5] = "Left", a[a.Right = 6] = "Right";
})(re || (re = {}));
class Mf {
}
class Ff {
  constructor() {
    this.points = [], this.coveredLength = 0;
  }
  AddFirst(t) {
    if (this.points.length !== 0) {
      const e = this.points[0];
      this.coveredLength = this.coveredLength + t.Center.sub(e.Center).length;
    }
    return this.points.unshift(t), this.coveredLength;
  }
  AddLast(t) {
    if (this.points.length !== 0) {
      const e = this.points[this.points.length - 1];
      this.coveredLength = this.coveredLength + t.Center.sub(e.Center).length;
    }
    return this.points.push(t), this.coveredLength;
  }
}
var Fs;
(function(a) {
  a[a.AlongCurve = 0] = "AlongCurve", a[a.Horizontal = 1] = "Horizontal";
})(Fs || (Fs = {}));
class wl {
  constructor(t) {
    this.location = t, this.boundingBox = T.rectangleOnPoint(t);
  }
}
class cn {
  constructor(t, e) {
    this.data = e, this.boundingBox = t;
  }
}
class Vf {
  constructor(t) {
    this.innerPoints = [], this.outerPoints = [], this.placementSide = re.Any, this.placementOffset = 0.5, this.edgePoints = t, this.placementSide;
  }
}
class z extends ht {
  //     The granularity with which to break up a curve into sub points.
  get CollisionGranularity() {
    return this.granularity;
  }
  set CollisionGranularity(t) {
    this.granularity = t;
  }
  //     Constructs an edge label placer that places all labels in the graph.
  static constructorG(t) {
    return new z(Array.from(t.nodesBreadthFirst), Array.from(t.deepEdges).filter((e) => e.label));
  }
  //     Constructs an edge label placer that places the given labels in the graph.
  static constructorGA(t, e) {
    return new z(Array.from(t.nodesBreadthFirst), e.filter((i) => i.label));
  }
  //     Constructs a edge label placer that will only avoid overlaps with the given nodes and edges.
  constructor(t, e) {
    super(null), this.placementStrategy = [Fs.Horizontal, Fs.AlongCurve], this.obstacleMaps = [], this.edgeInfos = /* @__PURE__ */ new Map(), this.granularity = z.MinGranularity, this.ScaleCollisionGranularity = !0, this.granularity = this.ScaleCollisionGranularity ? this.interpolateGranularity(e.length) : z.MinGranularity, this.InitializeObstacles(t, e), this.edges = e;
  }
  interpolateGranularity(t) {
    if (t <= z.LowerEdgeBound)
      return z.MaxGranularity;
    if (t >= z.UpperEdgeBound)
      return z.MinGranularity;
    const e = (z.UpperEdgeBound - z.LowerEdgeBound) / (t - z.LowerEdgeBound);
    return Math.ceil(z.MinGranularity + e);
  }
  InitializeObstacles(t, e) {
    const i = this.GetEdgeObstacles(e);
    this.obstacleMaps[1] = mn(t.map((s) => [s.boundingBox, new cn(s.boundingBox, s)])), this.obstacleMaps[2] = mn(i.map((s) => [s.boundingBox, new cn(s.boundingBox, s)]));
  }
  static CurvePoints(t, e) {
    const i = [], s = t.end.sub(t.start).lengthSquared / (e * e);
    return z.SubdivideCurveSegment(i, t, s, t.parStart, t.parEnd), i.sort(z.compareByArgument), i;
  }
  static compareByArgument(t, e) {
    return t[0] < e[0] ? -1 : t[0] > e[0] ? 1 : 0;
  }
  static SubdivideCurveSegment(t, e, i, s, n) {
    if (t.length > 64)
      return;
    const r = e.value(s), o = e.value(n);
    if (r.sub(o).lengthSquared > i) {
      const l = (s + n) / 2;
      z.SubdivideCurveSegment(t, e, i, s, l), z.SubdivideCurveSegment(t, e, i, l, n);
    } else
      t.push([s, r]);
  }
  //Places the given labels at their default positions.  Only avoids overlaps with the edge and source/target node that the label is connected to.
  static PlaceLabelsAtDefaultPositions(t, e) {
    for (const i of e)
      i.label && new z([i.source, i.target], [i]).run();
  }
  GetEdgeObstacles(t) {
    const e = [];
    for (const i of t) {
      if (i.curve == null)
        continue;
      const s = z.CurvePoints(i.curve, this.CollisionGranularity);
      this.edgeInfos.set(i, new Vf(s));
      for (const n of s)
        e.push(new wl(n[1]));
    }
    return e;
  }
  /**       Adds the label to the label obstacle map.*/
  AddLabelObstacle(t) {
    this.labelObstacleMap == null ? (this.labelObstacleMap = mn([[t.boundingBox, t]]), this.obstacleMaps[0] = this.labelObstacleMap) : this.labelObstacleMap.Add(t.boundingBox, t);
  }
  //     Places the given labels.
  run() {
    this.edges.sort((t, e) => this.edgeInfos.get(t).edgePoints.length - this.edgeInfos.get(e).edgePoints.length);
    for (const t of this.edges)
      this.PlaceLabel(t);
  }
  //     Places the given label in an available location.
  PlaceLabel(t) {
    let e = !1;
    for (const i of this.placementStrategy) {
      switch (i) {
        case Fs.AlongCurve:
          e = this.PlaceEdgeLabelOnCurve(t.label);
          break;
        case Fs.Horizontal:
          e = this.PlaceEdgeLabelHorizontally(t);
          break;
        default:
          throw new Error("unexpected case");
      }
      if (e)
        break;
    }
    e ? this.CalculateCenterLabelInfoCenter(t.label) : this.PlaceLabelAtFirstPosition(t.label);
  }
  getLabelInfo(t) {
    const e = t.parent;
    return this.edgeInfos.get(e);
  }
  //     Places the label at the first position requested.  Ignores all overlaps.
  PlaceLabelAtFirstPosition(t) {
    const e = t.parent, i = e.curve, s = this.edgeInfos.get(e).edgePoints, n = this.StartIndex(t, s.map((f) => f[1])), r = s[n][1];
    let o = i.derivative(s[n][0]);
    o.length < m.distanceEpsilon && (o = new u(1, 1)), o = o.normalize();
    const l = new Ti(t.width, t.height), h = this.getLabelInfo(t), c = z.GetPossibleSides(h.placementSide, o)[0], d = z.GetLabelBounds(r, o, l, c);
    this.SetLabelBounds(this.getLabelInfo(t), d);
  }
  StartIndex(t, e) {
    const i = this.getLabelInfo(t);
    return Math.min(e.length - 1, Math.max(0, Math.floor(e.length * i.placementOffset)));
  }
  CalculateCenterLabelInfoCenter(t) {
    const e = this.getLabelInfo(t);
    let i = new u(0, 0);
    for (const s of e.innerPoints)
      i = i.add(s);
    for (const s of e.outerPoints)
      i = i.add(s);
    t.positionCenter(i.div(e.innerPoints.length + e.outerPoints.length));
  }
  PlaceEdgeLabelHorizontally(t) {
    const e = t.label, s = this.getLabelInfo(e).edgePoints, n = new Ti(e.width, e.height);
    let r = -1, o = T.mkEmpty();
    const l = t.curve;
    for (const h of z.ExpandingSearch(this.StartIndex(e, s.map((c) => c[1])), 0, s.length)) {
      const c = s[h];
      let d = l.derivative(c[0]);
      if (!D(d.lengthSquared, 0)) {
        d = d.normalize();
        for (const f of z.GetPossibleSides(this.getLabelInfo(e).placementSide, d)) {
          const p = z.GetLabelBounds(c[1], d, n, f), P = this.ConflictIndexRL(p, e);
          if (P > r && (r = P, o = p, r === Number.MAX_VALUE))
            break;
        }
        if (r === Number.MAX_VALUE)
          break;
      }
    }
    if (r >= 0) {
      this.SetLabelBounds(this.getLabelInfo(e), o);
      const h = new cn(o, null);
      this.AddLabelObstacle(h);
      const c = this.getLabelInfo(e);
      return r === 0 ? c.placementResult = os.OverlapsOtherLabels : r === 1 ? c.placementResult = os.OverlapsNodes : r === 2 ? c.placementResult = os.OverlapsEdges : c.placementResult = os.OverlapsNothing, !0;
    }
    return !1;
  }
  //     Gets the label placement bounds for the given location, side, and label size.
  // The point along a curve that the label should be placed near.
  // The derivative of the curve at the point position.
  // The width and height of the label.
  // The side (1 or -1) of the line to place the label on.
  // <returns>The label's desired position.</returns>
  static GetLabelBounds(t, e, i, s) {
    const n = e.rotate(Math.PI / 2).mul(s), r = t.add(n), o = 1;
    let l = n.x > 0 ? r.x : r.x - i.width, h = n.y > 0 ? r.y : r.y - i.height;
    if (Math.abs(n.x) < 0.75) {
      const c = Math.acos(Math.abs(n.y) / o), d = o / Math.sin(c), f = o / Math.cos(c);
      l += (n.x > 0 ? -1 : 1) * Math.min(d, i.width / 2), h += (n.y > 0 ? 1 : -1) * f;
    } else if (Math.abs(n.y) < 0.75) {
      const c = Math.acos(Math.abs(n.x) / o), d = o / Math.sin(c), f = o / Math.cos(c);
      l += (n.x > 0 ? 1 : -1) * f, h += (n.y > 0 ? -1 : 1) * Math.min(d, i.height / 2);
    }
    return T.mkLeftBottomSize(l, h, i);
  }
  //     Sets the label's position to be the given bounds.
  SetLabelBounds(t, e) {
    t.innerPoints = [e.leftTop, e.rightTop], t.outerPoints = [e.leftBottom, e.rightBottom];
  }
  //     Gets the possible sides for the given label and the given derivative point.
  // <returns>An enumeration of the possible sides (-1 or 1).</returns>
  static GetPossibleSides(t, e) {
    switch (e.length === 0 && (t = re.Any), t) {
      case re.Port:
        return [-1];
      case re.Starboard:
        return [1];
      case re.Top:
        return D(e.x, 0) ? z.GetPossibleSides(re.Left, e) : [1];
      case re.Bottom:
        return D(e.x, 0) ? z.GetPossibleSides(re.Right, e) : [e.x < 0 ? -1 : 1];
      case re.Left:
        return D(e.y, 0) ? z.GetPossibleSides(re.Top, e) : [e.y < 0 ? -1 : 1];
      case re.Right:
        return D(e.y, 0) ? z.GetPossibleSides(re.Bottom, e) : [e.y < 0 ? 1 : -1];
      default:
        return [-1, 1];
    }
  }
  static *ExpandingSearch(t, e, i) {
    let s = t + 1, n = s;
    for (; n > e; )
      yield --n;
    for (; s < i; )
      yield s++;
  }
  static PointSetLength(t) {
    let e = 0, i = null;
    for (const s of t)
      i != null && (e += i.sub(s.Center).length), i = s.Center;
    return e;
  }
  PlaceEdgeLabelOnCurve(t) {
    const e = t.parent, i = this.getLabelInfo(t);
    i.innerPoints = null;
    const s = i.edgePoints, n = 3, r = t.height / 2, o = new Ti(r, r), l = t.width;
    for (const h of z.ExpandingSearch(this.StartIndex(t, s), 0, s.length)) {
      const c = this.GetSidesAndEdgeCurve(t, e, s, h);
      for (const d of c) {
        const f = new Ff(), p = { coveredLength: 0 };
        if (this.ProcessExpandingSearchOnSide(h, s, e.curve, d, r, n, o, p, f, l), p.coveredLength >= l)
          return this.CaseOfCoveredLengthGreaterThanLabelLength(t, f, p.coveredLength, l, o), !0;
      }
    }
    return !1;
  }
  CaseOfCoveredLengthGreaterThanLabelLength(t, e, i, s, n) {
    const r = new Array(), o = new Array(), l = Array.from(e.points), h = i - s;
    if (h > 0) {
      let d = l[l.length - 1], f = l[l.length - 2], p = d.Center.sub(f.Center), P = p.length;
      h > P && (d = l[0], f = l[1], p = d.Center.sub(f.Center), P = p.length);
      const y = p.mul((P - h) / P);
      d.Center = f.Center.add(y), d.Inner = f.Inner.add(y), d.Outer = f.Outer.add(y);
    }
    this.GoOverOrderedPointsAndAddLabelObstacels(l, r, o, n);
    const c = this.getLabelInfo(t);
    c.innerPoints = r, c.outerPoints = o;
  }
  GoOverOrderedPointsAndAddLabelObstacels(t, e, i, s) {
    for (const n of t) {
      const r = n.Center;
      e.push(n.Inner), i.push(n.Outer);
      const o = new cn(T.mkSizeCenter(new Ti(s.width * 2, s.height * 2), r), null);
      this.AddLabelObstacle(o);
    }
  }
  ProcessExpandingSearchOnSide(t, e, i, s, n, r, o, l, h, c) {
    for (const d of z.ExpandingSearch(t, 0, e.length)) {
      const [f, p] = e[d], P = i.derivative(f);
      if (D(P.lengthSquared, 0))
        continue;
      const y = P.rotate(Math.PI / 2).normalize().mul(s), C = p.add(y.mul(n + r));
      if (this.Conflict(C, n, o))
        break;
      {
        const w = new Mf();
        if (w.Center = C, w.Inner = p.add(y.mul(r)), w.Outer = p.add(y.mul(2 * n + r)), l.coveredLength = d <= t ? h.AddFirst(w) : h.AddLast(w), l.coveredLength >= c)
          break;
      }
    }
  }
  GetSidesAndEdgeCurve(t, e, i, s) {
    const n = e.curve.derivative(i[s][0]);
    return z.GetPossibleSides(this.getLabelInfo(t).placementSide, n);
  }
  //     Determines if the query point intersects with any of the obstacles.
  // <returns>True if the query point itnersects with any of the obstacles.</returns>
  Conflict(t, e, i) {
    return this.ConflictIndex(t, e, i) !== Number.MAX_VALUE;
  }
  //    Determines the index of the first obstacle map that the rectangle intersects.
  //    Clusters that are parents/grandparents of the label's source/target nodes are not considered intersection.
  // <returns>The index of the first obstacle map that the rectangle intersects. int.MaxValue if there is no intersection.</returns>
  ConflictIndexRL(t, e) {
    const i = e.parent, s = i.source, n = i.target;
    for (let r = 0; r < this.obstacleMaps.length; r++)
      if (this.obstacleMaps[r] != null) {
        for (const o of this.obstacleMaps[r].GetAllIntersecting(t))
          if (!(r === os.OverlapsNodes && o instanceof cn && o.data instanceof Nt && (s.node.isDescendantOf(o.data.graph) || n.node.isDescendantOf(o.data))))
            return r;
      }
    return Number.MAX_VALUE;
  }
  /**   Determines the index of the first obstacle map that the point intersects.
    Returns the index of the first obstacle map that the point intersects. int.MaxValue if there is no intersection.*/
  ConflictIndex(t, e, i) {
    const s = T.creatRectangleWithSize(new Ti(i.width * 2, i.height * 2), t), n = e * e;
    for (let r = 0; r < this.obstacleMaps.length; r++)
      if (this.obstacleMaps[r] != null) {
        for (let o = 0; o < this.obstacleMaps.length; o++)
          if (this.obstacleMaps[o] != null)
            for (const l of this.obstacleMaps[o].GetAllIntersecting(s))
              if (l instanceof wl) {
                if (t.sub(l.location).lengthSquared < n)
                  return o;
              } else
                return o;
        return Number.MAX_VALUE;
      }
  }
}
z.MinGranularity = 5;
z.MaxGranularity = 50;
z.LowerEdgeBound = 500;
z.UpperEdgeBound = 3e3;
class bi extends Lh {
  clone() {
    throw new Error("Method not implemented.");
  }
  rebind(t) {
    this.entity = t, this.bind(_e.AlgorithmDataIndex);
  }
  constructor(t, e = null) {
    super(t, _e.AlgorithmDataIndex), this.data = e;
  }
  static getAlgData(t) {
    return t.getAttr(_e.AlgorithmDataIndex);
  }
}
function Wo(a) {
  const t = bi.getAlgData(a.node);
  return t == null ? null : t.data;
}
class Df {
  //  local cache of node center (which in the MSAGL node has to be computed from the bounding box)
  get Center() {
    return this.center;
  }
  set Center(t) {
    this.geomNode.center = t, this.center = t;
  }
  //  When mNode's bounds change we need to update our local
  //  previous and current center to MSAGL node center
  //  and update width and height
  ResetBounds() {
    this.previousCenter = this.geomNode.center, this.center = this.geomNode.center, this.Width = this.geomNode.width, this.Height = this.geomNode.height;
  }
  constructor(t, e) {
    this.force = new u(0, 0), this.stayWeight = 1, this.index = t, this.geomNode = e, this.ResetBounds();
  }
  //  Update the current X or Y coordinate of the node center from the result of a solve
  ToString() {
    return "FINode(" + (this.index + ("):" + this.geomNode));
  }
}
class kf {
  constructor(t) {
    this._length = 1, this.mEdge = t, this.sourceFiNode = Wo(this.mEdge.source), this.targetFiNode = Wo(this.mEdge.target);
  }
  get source() {
    return this.sourceFiNode.index;
  }
  get target() {
    return this.targetFiNode.index;
  }
  get length() {
    return this._length;
  }
  set length(t) {
    this._length = t;
  }
  vector() {
    return this.sourceFiNode.geomNode.center.sub(this.targetFiNode.geomNode.center);
  }
}
class Ut {
  /**   disc centre*/
  get Center() {
    return this.c;
  }
  set Center(t) {
    this.c = t;
  }
  /**   Radius of disc */
  get Radius() {
    return this.r;
  }
  set Radius(t) {
    this.r = t, this.r2 = t * t;
  }
  //  squared distance from the centre of this disc to point
  //  <returns></returns>
  Distance2(t) {
    const e = this.c.y - t.y, i = this.c.x - t.x;
    return i * i + e * e;
  }
  //  Test if point is contained in this disc
  //  <returns></returns>
  Contains(t) {
    return this.Distance2(t) - 1e-7 <= this.r2;
  }
  //  test if all specified points (apart from the except list) are contained in this disc
  //  <returns>true if all points are contained in the disc</returns>
  ContainsPN(t, e) {
    for (let i = 0; i < t.length; i++)
      if (e.findIndex((s) => s == i) == -1 && !this.Contains(t[i]))
        return !1;
    return !0;
  }
  //  create a zero radius disc centred at center
  static constructorP(t) {
    const e = new Ut();
    return e.c = t, e.r = 0, e.r2 = 0, e;
  }
  //  find the point mid-way between two points
  static midPoint(t, e) {
    return new u((e.x + t.x) / 2, (e.y + t.y) / 2);
  }
  //  Create the smallest possible disc with the specified points on the boundary
  static constructorPP(t, e) {
    const i = new Ut();
    return i.c = Ut.midPoint(t, e), i.r2 = i.Distance2(t), i.r = Math.sqrt(i.r2), lt.assert(i.OnBoundary(t)), lt.assert(i.OnBoundary(e)), i;
  }
  //  test if a point lies on (within a small delta of) the boundary of this disc
  //  <returns></returns>
  OnBoundary(t) {
    const e = this.Distance2(t);
    return Math.abs(e - this.r2) / (e + this.r2) < 1e-5;
  }
  //  computes the centre of the disc with the 3 specified points on the boundary
  //  <returns></returns>
  static centre(t, e, i) {
    lt.assert(e.x != t.x), lt.assert(i.x != e.x);
    const s = (e.y - t.y) / (e.x - t.x), n = (i.y - e.y) / (i.x - e.x);
    lt.assert(n != s);
    let r;
    const o = (s * n * (t.y - i.y) + n * (t.x + e.x) - s * (e.x + i.x)) / (2 * (n - s));
    return Math.abs(s) > Math.abs(n) ? r = (t.y + e.y) / 2 - (o - (t.x + e.x) / 2) / s : r = (e.y + i.y) / 2 - (o - (e.x + i.x) / 2) / n, new u(o, r);
  }
  //  if the area of the triangle formed by the 3 points is 0 then the points are collinear
  //  <returns></returns>
  static Collinear(t, e, i) {
    return t.x * (e.y - i.y) + (e.x * (i.y - t.y) + i.x * (t.y - e.y)) == 0;
  }
  //  Create a disc with the specified points on the boundary
  static constructorPPP(t, e, i) {
    Ut.count++;
    const s = new Ut();
    if (Ut.Collinear(t, e, i)) {
      const n = new u(Math.min(t.x, Math.min(e.x, i.x)), Math.min(t.y, Math.max(e.y, i.y))), r = new u(Math.max(t.x, Math.max(e.x, i.x)), Math.max(t.y, Math.max(e.y, i.y)));
      s.c = Ut.midPoint(n, r), s.r2 = s.Distance2(r), s.r = Math.sqrt(s.r2);
    } else {
      const n = e.x - t.x, r = i.x - e.x, o = i.x - t.x;
      n != 0 ? r != 0 ? s.c = Ut.centre(t, e, i) : (lt.assert(o != 0), s.c = Ut.centre(e, t, i)) : (lt.assert(r != 0), s.c = Ut.centre(e, i, t)), s.r2 = s.Distance2(t), s.r = Math.sqrt(s.r2), lt.assert(s.OnBoundary(t)), lt.assert(s.OnBoundary(e)), lt.assert(s.OnBoundary(i));
    }
    return s;
  }
}
Ut.count = 0;
function _f(a) {
  const t = a.slice();
  return Wf(t), Ho(t, a.length, [], 0);
}
function Wf(a) {
  let t, e, i;
  for (i = a.length - 1; i > 0; i--)
    t = Xs(i + 1), e = a[i], a[i] = a[t], a[t] = e;
  return a;
}
function Ho(a, t, e, i) {
  let s = null;
  return i === 3 ? s = Hf(e[0], e[1], e[2]) : t === 1 && i === 0 ? s = { x: a[0].x, y: a[0].y, r: 0 } : t === 0 && i === 2 ? s = Al(e[0], e[1]) : t === 1 && i === 1 ? s = Al(e[0], a[0]) : (s = Ho(a, t - 1, e, i), zf(a[t - 1], s) || (e[i++] = a[t - 1], s = Ho(a, t - 1, e, i))), s;
}
function Hf(a, t, e) {
  const i = a.x, s = a.y, n = t.x, r = t.y, o = e.x, l = e.y, h = n - i, c = r - s, d = o - i, f = l - s, p = h * (n + i) * 0.5 + c * (r + s) * 0.5, P = d * (o + i) * 0.5 + f * (l + s) * 0.5, y = h * f - c * d, C = (f * p - c * P) / y, w = (-d * p + h * P) / y;
  return { x: C, y: w, r: Math.sqrt((i - C) * (i - C) + (s - w) * (s - w)) };
}
function Al(a, t) {
  const e = a.x, i = a.y, s = t.x, n = t.y, r = 0.5 * (e + s), o = 0.5 * (i + n);
  return { x: r, y: o, r: Math.sqrt((e - r) * (e - r) + (i - o) * (i - o)) };
}
function zf(a, t) {
  return (t.x - a.x) * (t.x - a.x) + (t.y - a.y) * (t.y - a.y) <= t.r * t.r;
}
class jf {
  /**  linear-time computation using the move-to-front heuristic by Welzl */
  static LinearComputation(t) {
    const e = _f(t), i = new Ut();
    return i.Center = new u(e.x, e.y), i.Radius = e.r, i;
  }
  //  Computing the minimum enclosing disc the naive way for testing purposes.
  static SlowComputation(t) {
    const e = t.length;
    let i = null, s = null;
    for (let n = 0; n < e; n++)
      for (let r = 0; r < e; r++) {
        if (n != r) {
          const o = Ut.constructorPP(t[n], t[r]);
          o.ContainsPN(t, [n, r]) && (i == null || i.Radius > o.Radius) && (i = o, s = [n, r]);
        }
        for (let o = 0; o < e; o++)
          if (o != n && o != r && !Ut.Collinear(t[n], t[r], t[o])) {
            const l = Ut.constructorPPP(t[n], t[r], t[o]);
            l.ContainsPN(t, [n, r, o]) && (i == null || i.Radius > l.Radius) && (i = l, s = [n, r, o]);
          }
      }
    return lt.assert(s != null), i;
  }
}
class Re {
  static constructorNPA(t, e, i) {
    const s = new Re();
    s.p = t, s.z0 = new dt(e.x, e.y), s.a = new Array(t);
    for (let n = 0; n < t; n++)
      s.a[n] = s.compute(n, i);
    return s;
  }
  static constructorPMM(t, e, i) {
    const s = new Re();
    lt.assert(e.p == i.p), s.p = e.p, s.z0 = new dt(t.x, t.y);
    const n = i.shift(s.z0), r = e.shift(s.z0);
    s.a = new Array(s.p);
    for (let o = 0; o < s.p; o++)
      s.a[o] = bo(r[o], n[o]);
    return s;
  }
  static factorial(t) {
    let e = 1;
    for (let i = 2; i <= t; i++)
      e *= i;
    return e;
  }
  static binomial(t, e) {
    return Re.factorial(t) / (Re.factorial(e) * Re.factorial(t - e));
  }
  sum(t, e) {
    let i = dt.constructorN(0);
    for (let s = 1; s <= t; s++) {
      const n = dt.constructorN(Re.binomial(t - 1, s - 1));
      i = bo(i, Ui(this.a[s], Ui(dt.Pow(e, t - s), n)));
    }
    return i;
  }
  shift(t) {
    const e = new Array(this.p), i = e[0] = this.a[0], s = un(this.z0, t);
    for (let n = 1; n < this.p; n++) {
      const r = dt.constructorN(n);
      e[n] = bo(Ui(Uf(i), vo(dt.Pow(s, n), r)), this.sum(n, s));
    }
    return e;
  }
  //  Compute kth multipole coefficient of a set of points ps around a centre z0
  compute(t, e) {
    const i = e.length;
    let s = dt.constructorN(0);
    if (t == 0)
      s.re = i;
    else {
      for (let n = 0; n < i; n++) {
        const r = e[n], o = new dt(r.x, r.y);
        s = un(s, dt.Pow(un(o, this.z0), t));
      }
      s.divideBy(t);
    }
    return s;
  }
  //  Compute approximate force at point v due to potential energy moments
  ApproximateForce(t) {
    const e = new dt(t.x, t.y), i = un(e, this.z0);
    let s = vo(this.a[0], i), n = i, r = 0;
    for (; s = un(s, vo(qf(this.a[r], r), n)), r++, r != this.p; )
      n = Ui(n, i);
    return new u(s.re, -s.im);
  }
  //  Force on point u due to point v.
  //  If v and u at the same position it returns a small vector to separate them
  static Force(t, e) {
    const i = e.sub(t), s = i.lengthSquared;
    return s < 0.1 ? s != 0 ? i.div(0.1) : new u(1, 0) : i.div(s);
  }
}
class dt {
  constructor(t, e) {
    this.re = t, this.im = e;
  }
  static constructorN(t) {
    return new dt(t, 0);
  }
  divideBy(t) {
    this.re /= t, this.im /= t;
  }
  static Pow(t, e) {
    switch (lt.assert(e >= 0), e) {
      case 0:
        return dt.constructorN(1);
      case 1:
        return t;
      case 2:
        return Ui(t, t);
      case 3:
        return Ui(t, Ui(t, t));
      default:
        return Ui(dt.Pow(t, e / 2), dt.Pow(t, e / 2 + e % 2));
    }
  }
}
function bo(a, t) {
  return new dt(a.re + t.re, a.im + t.im);
}
function Ui(a, t) {
  return new dt(a.re * t.re - a.im * t.im, a.re * t.im + t.re * a.im);
}
function qf(a, t) {
  return new dt(a.re * t, a.im * t);
}
function un(a, t) {
  return new dt(a.re - t.re, a.im - t.im);
}
function Uf(a) {
  return new dt(-a.re, -a.im);
}
function vo(a, t) {
  const e = t.re * t.re + t.im * t.im;
  if (e == 0)
    return dt.constructorN(0);
  const i = a.re * t.re + a.im * t.im, s = a.im * t.re - a.re * t.im;
  return new dt(i / e, s / e);
}
var Le;
(function(a) {
  a[a.Horizontal = 0] = "Horizontal", a[a.Vertical = 1] = "Vertical";
})(Le || (Le = {}));
class Qh {
  intersects(t) {
    return t.med.Center.sub(this.med.Center).length < t.med.Radius + this.med.Radius;
  }
}
class Xf extends Qh {
  constructor(t, e, i) {
    super(), this.med = t, this.parent = e.parent, this.parent != null && (this.parent.leftChild == e ? this.parent.leftChild = this : this.parent.rightChild = this), this.leftChild = e, this.rightChild = i, e.parent = this, i.parent = this;
  }
  computeMultipoleCoefficients(t) {
    this.leftChild.computeMultipoleCoefficients(t), this.rightChild.computeMultipoleCoefficients(t), this.multipoleCoefficients = Re.constructorPMM(this.med.Center, this.leftChild.multipoleCoefficients, this.rightChild.multipoleCoefficients);
  }
}
class Dr extends Qh {
  constructor(t) {
    super(), this.particles = t, this.ComputeMinimumEnclosingDisc();
  }
  computeMultipoleCoefficients(t) {
    this.multipoleCoefficients = Re.constructorNPA(t, this.med.Center, this.ps);
  }
  ComputeMinimumEnclosingDisc() {
    const t = this.Size();
    this.ps = new Array(t);
    for (let e = 0; e < t; e++)
      this.ps[e] = this.particles[0][e].point;
    return this.med = jf.LinearComputation(this.ps);
  }
  Min(t) {
    return this.particles[t][0].pos(t);
  }
  Size() {
    return this.particles[0].length;
  }
  Max(t) {
    return this.particles[t][this.Size() - 1].pos(t);
  }
  Dimension(t) {
    return this.Max(t) - this.Min(t);
  }
  Split(t) {
    const e = this.Dimension(Le.Horizontal) > this.Dimension(Le.Vertical) ? Le.Horizontal : Le.Vertical, i = e == Le.Horizontal ? Le.Vertical : Le.Horizontal, s = this.Size(), n = s >> 1, r = s - n, o = [new Array(n), new Array(n)], l = [new Array(r), new Array(r)];
    let h = 0, c = 0;
    for (let f = 0; f < s; f++) {
      const p = this.particles[e][f];
      f < n ? (o[e][f] = p, p.splitLeft = !0) : (l[e][f - n] = p, p.splitLeft = !1);
    }
    for (let f = 0; f < s; f++) {
      const p = this.particles[i][f];
      p.splitLeft ? o[i][c++] = p : l[i][h++] = p;
    }
    const d = this.med;
    return this.particles = o, this.ComputeMinimumEnclosingDisc(), t.rightSibling = new Dr(l), new Xf(d, this, t.rightSibling);
  }
  ComputeForces() {
    for (const t of this.particles[0])
      for (const e of this.particles[0])
        t != e && (t.force = t.force.add(Re.Force(t.point, e.point)));
  }
}
class Qf {
  pos(t) {
    return t == Le.Horizontal ? this.point.x : this.point.y;
  }
  //  Create particle at point
  constructor(t) {
    this.point = t, this.force = new u(0, 0);
  }
}
class Yf {
  particlesBy(t) {
    return this.particles.map((e) => e).sort((e, i) => e.pos(t) - i.pos(t));
  }
  //  Create a KDTree over the specified particles, with the leaf partitions each containing bucketSize particles.
  constructor(t, e) {
    this.particles = t;
    const i = new Array();
    i.push(this.particlesBy(Le.Horizontal)), i.push(this.particlesBy(Le.Vertical)), this.leaves = new Array();
    let s = new Dr(i);
    this.leaves.push(s);
    const n = { rightSibling: null };
    this.root = s.Split(n), this.leaves.push(n.rightSibling);
    const r = new Jf(e);
    for (r.EnqueueLL(s, n.rightSibling); r.length > 0; )
      s = r.dequeue(), s.Split(n), this.leaves.push(n.rightSibling), r.EnqueueLL(s, n.rightSibling);
  }
  //  Compute forces between particles using multipole approximations.
  ComputeForces(t) {
    this.root.computeMultipoleCoefficients(t);
    for (const e of this.leaves) {
      e.ComputeForces();
      const i = new Array();
      for (i.push(this.root); i.length > 0; ) {
        const s = i.pop();
        if (e.intersects(s))
          if (s instanceof Dr)
            for (const n of e.particles[0])
              for (const r of s.particles[0])
                n != r && (n.force = n.force.add(Re.Force(n.point, r.point)));
          else {
            const n = s;
            i.push(n.leftChild), i.push(n.rightChild);
          }
        else
          for (const n of e.particles[0])
            n.force = n.force.sub(s.multipoleCoefficients.ApproximateForce(n.point));
      }
    }
  }
}
class Jf extends We.Queue {
  constructor(t) {
    super(), this.B = t;
  }
  EnqueueLL(t, e) {
    t.Size() > this.B && this.enqueue(t), e.Size() > this.B && this.enqueue(e);
  }
}
class Dn extends ht {
  //  Create the graph data structures.
  constructor(t, e, i) {
    if (super(null), this.clustersInfo = /* @__PURE__ */ new Map(), this.clusterEdges = new Array(), this.graph = t, this.settings = e, this.initFiNodesEdges(), this.edges = Array.from(this.graph.shallowEdges).map((s) => bi.getAlgData(s.edge).data), this.nodes = Array.from(this.graph.shallowNodes).map((s) => bi.getAlgData(s.node).data), this.components = new Array(), this.settings.InterComponentForces)
      this.components.push(this.nodes);
    else {
      this.basicGraph = fi(this.edges, this.nodes.length);
      for (const s of Qs(this.basicGraph)) {
        const n = new Array(s.length);
        let r = 0;
        for (const o of s)
          n[r++] = this.nodes[o];
        this.components.push(n);
      }
    }
    this.computeWeight(t), this.setCurrentConstraintLevel(i);
  }
  initFiNodesEdges() {
    let t = 0;
    for (const e of this.graph.shallowNodes) {
      const i = new Df(t++, e);
      new bi(e.node, i);
    }
    for (const e of this.graph.shallowEdges) {
      const i = new kf(e);
      new bi(e.edge, i);
    }
  }
  //  Controls which constraints are applied of CalculateLayout.  Setter enforces feasibility at that level.
  getCurrentConstraintLevel() {
    return this.currentConstraintLevel;
  }
  setCurrentConstraintLevel(t) {
    this.currentConstraintLevel = t, this.settings.Unconverge();
  }
  //  Add constraint to constraints lists.  Warning, no check that dictionary alread holds a list for the level.
  //  Make sure you call AddConstraintLevel first (perf).
  //  Check for constraint level of dictionary, if it doesn't exist add the list at that level.
  ResetNodePositions() {
    for (const t of this.nodes)
      t.ResetBounds();
  }
  AddRepulsiveForce(t, e) {
    t.force = e.mul(10 * this.settings.RepulsiveForceConstant);
  }
  AddLogSpringForces(t, e, i) {
    const s = e.length, n = 7e-4 * this.settings.AttractiveForceConstant * s * Math.log((s + 0.1) / (i + 0.1));
    t.sourceFiNode.force = t.sourceFiNode.force.add(e.mul(n)), t.targetFiNode.force = t.targetFiNode.force.sub(e.mul(n));
  }
  AddSquaredSpringForces(t, e, i) {
    const s = e.length, n = i * i + 0.1, r = this.settings.AttractiveForceConstant * (s - i) / n;
    t.sourceFiNode.force = t.sourceFiNode.force.add(e.mul(r)), t.targetFiNode.force = t.targetFiNode.force.sub(e.mul(r));
  }
  AddSpringForces(t) {
    let e;
    if (this.settings.RespectEdgePorts) {
      let i = t.sourceFiNode.Center, s = t.targetFiNode.Center;
      const n = t.mEdge.sourcePort;
      n instanceof Te && (i = n.Location);
      const r = t.mEdge.targetPort;
      r instanceof Te && (s = r.Location), e = i.sub(s);
    } else
      e = t.vector();
    this.settings.LogScaleEdgeForces ? this.AddLogSpringForces(t, e, t.length) : this.AddSquaredSpringForces(t, e, t.length);
  }
  static AddGravityForce(t, e, i) {
    i != null && (i.force = i.force.sub(t.sub(i.Center).mul(e * 1e-4)));
  }
  ComputeRepulsiveForces(t) {
    const e = t.length;
    if (e > 16 && this.settings.ApproximateRepulsion) {
      const i = new Array(t.length), s = 2 * (Math.PI / e);
      let n = 0;
      for (let o = 0; o < e; o++)
        i[o] = new Qf(t[o].Center.add(new u(Math.cos(n), Math.sin(n)).mul(1e-5))), n += s;
      new Yf(i, 8).ComputeForces(5);
      for (let o = 0; o < t.length; o++)
        this.AddRepulsiveForce(t[o], i[o].force);
    } else
      for (const i of t) {
        let s = new u(0, 0);
        for (const n of t)
          i != n && (s = s.add(Re.Force(i.Center, n.Center)));
        this.AddRepulsiveForce(i, s);
      }
  }
  SetBarycenter(t) {
    const e = this.clustersInfo.get(t);
    if (e != null)
      return e.barycenter;
    let i = new u(0, 0);
    if (t.shallowNodeCount || Kf(t)) {
      const s = this.clustersInfo.get(t);
      if ((s == null || s.weight == null) && this.computeWeight(t), s.weight != null) {
        for (const n of t.shallowNodes)
          n instanceof Yt ? i = i.add(n.center) : i = i.add(this.SetBarycenter(n).mul(this.clustersInfo.get(n).weight));
        this.clustersInfo.get(t).barycenter = i = i.div(s.weight);
      }
    } else
      this.clustersInfo.get(t).barycenter = i;
    return i;
  }
  computeWeight(t) {
    let e = 0;
    for (const s of t.shallowNodes)
      s.entity instanceof di ? e += this.computeWeight(s) : e++;
    let i = this.clustersInfo.get(t);
    return i == null && this.clustersInfo.set(t, i = { barycenter: new u(0, 0) }), i.weight = e, e;
  }
  AddClusterForces(t) {
    if (t != null) {
      this.SetBarycenter(t);
      for (const e of this.clusterEdges) {
        const i = $.getGeom(e.source), s = $.getGeom(e.target), n = bi.getAlgData(e.source).data, r = bi.getAlgData(e.target).data, o = i.hasOwnProperty("shallowNodes"), l = o ? this.clustersInfo.get(i).barycenter : i.center, h = s.hasOwnProperty("shallowNodes"), c = h ? this.clustersInfo.get(s).barycenter : s.center;
        let d = l.sub(c);
        const f = d.length, p = 1e-8 * (this.settings.AttractiveInterClusterForceConstant * (f * Math.log(f + 0.1)));
        if (d = d.mul(p), o) {
          const P = i;
          for (const y of P.shallowNodes) {
            const C = bi.getAlgData(y.node).data;
            C.force = C.force.add(d);
          }
        } else
          n.force = n.force.add(d);
        if (h) {
          const P = s;
          for (const y of P.shallowNodes) {
            const C = bi.getAlgData(y.node).data;
            C.force = C.force.sub(d);
          }
        } else
          r.force = r.force.sub(d);
      }
      for (const e of t.subgraphsDepthFirst) {
        const i = this.clustersInfo.get(e).barycenter;
        for (const s of e.shallowNodes)
          Dn.AddGravityForce(i, this.settings.ClusterGravity, Wo(s));
      }
    }
  }
  //  Aggregate all the forces affecting each node
  ComputeForces() {
    if (this.components != null)
      for (const t of this.components)
        this.ComputeRepulsiveForces(t);
    else
      this.ComputeRepulsiveForces(this.nodes);
    this.edges.forEach((t) => this.AddSpringForces(t));
    for (const t of this.components) {
      let e = new u(0, 0);
      for (let s = 0; s < t.length; s++)
        e = e.add(t[s].Center);
      e = e.div(t.length);
      let i = Number.NEGATIVE_INFINITY;
      for (let s = 0; s < t.length; s++) {
        const n = t[s];
        Dn.AddGravityForce(e, this.settings.GravityConstant, n), n.force.length > i && (i = n.force.length);
      }
      if (i > 100)
        for (let s = 0; s < t.length; s++)
          t[s].force = t[s].force.mul(100 / i);
    }
    this.AddClusterForces(this.graph);
  }
  //  Checks if solvers need to be applied, i.e. if there are user constraints or
  //  generated constraints (such as non-overlap) that need satisfying
  //  Force directed layout is basically an iterative approach to solving a bunch of differential equations.
  //  Different integration schemes are possible for applying the forces iteratively.  Euler is the simplest:
  //   v_(i+1) = v_i + a dt
  //   x_(i+1) = x_i + v_(i+1) dt
  //
  //  Verlet is much more stable (and not really much more complicated):
  //   x_(i+1) = x_i + (x_i - x_(i-1)) + a dt dt
  VerletIntegration() {
    const t = this.energy;
    this.energy = this.ComputeDescentDirection(1), this.UpdateStepSize(t);
    let e = 0;
    for (let i = 0; i < this.nodes.length; i++) {
      const s = this.nodes[i];
      e += s.Center.sub(s.previousCenter).lengthSquared;
    }
    return e;
  }
  ComputeDescentDirection(t) {
    this.ResetForceVectors(), this.settings.ApplyForces && this.ComputeForces();
    let e = 0;
    for (const i of this.nodes) {
      e = e + i.force.lengthSquared;
      let s = i.Center.sub(i.previousCenter).mul(this.settings.Friction);
      const n = i.force.mul(-this.stepSize * t);
      i.previousCenter = i.Center, lt.assert(!Number.isNaN(n.x), "!double.IsNaN(a.X)"), lt.assert(!Number.isNaN(n.y), "!double.IsNaN(a.Y)"), lt.assert(Number.isFinite(n.x), "!double.IsInfinity(a.X)"), lt.assert(Number.isFinite(n.y), "!double.IsInfinity(a.Y)"), s = s.add(n), s = s.div(i.stayWeight), i.Center = i.Center.add(s);
    }
    return e;
  }
  ResetForceVectors() {
    for (const t of this.nodes)
      t.force = new u(0, 0);
  }
  //  Adapt StepSize based on change of energy.
  //  Five sequential improvements of energy mean we increase the stepsize.
  //  Any increase of energy means we reduce the stepsize.
  UpdateStepSize(t) {
    this.energy < t ? ++this.progress >= 3 && (this.progress = 0, this.stepSize /= this.settings.Decay) : (this.progress = 0, this.stepSize *= this.settings.Decay);
  }
  RungeKuttaIntegration() {
    const t = new Array(this.nodes.length), e = new Array(this.nodes.length), i = new Array(this.nodes.length), s = new Array(this.nodes.length), n = new Array(this.nodes.length), r = this.energy;
    for (let l = 0; l < this.nodes.length; l++)
      this.nodes[l].previousCenter = this.nodes[l].Center, t[l] = this.nodes[l].Center;
    const o = 3;
    this.ComputeDescentDirection(o);
    for (let l = 0; l < this.nodes.length; l++)
      e[l] = this.nodes[l].Center.sub(this.nodes[l].previousCenter), this.nodes[l].Center = t[l].add(e[l].mul(0.5));
    this.ComputeDescentDirection(o);
    for (let l = 0; l < this.nodes.length; l++)
      i[l] = this.nodes[l].Center.sub(this.nodes[l].previousCenter), this.nodes[l].previousCenter = t[l], this.nodes[l].Center = t[l].add(i[l].mul(0.5));
    this.ComputeDescentDirection(o);
    for (let l = 0; l < this.nodes.length; l++)
      s[l] = this.nodes[l].Center.sub(this.nodes[l].previousCenter), this.nodes[l].previousCenter = t[l], this.nodes[l].Center = t[l].add(s[l]);
    this.energy = this.ComputeDescentDirection(o);
    for (let l = 0; l < this.nodes.length; l++) {
      n[l] = this.nodes[l].Center.sub(this.nodes[l].previousCenter), this.nodes[l].previousCenter = t[l];
      const h = e[l].add(i[l].mul(2).add(s[l].mul(2)).add(n[l])).div(6);
      this.nodes[l].Center = t[l].add(h);
    }
    return this.UpdateStepSize(r), this.nodes.reduce((l, h) => h.Center.sub(h.previousCenter).lengthSquared + l, 0);
  }
  //  Apply a small number of iterations of the layout.
  //  The idea of incremental layout is that settings.minorIterations should be a small number (e.g. 3) and
  //  CalculateLayout should be invoked of a loop, e.g.:
  //
  //  while(settings.RemainingIterations > 0) {
  //     fastIncrementalLayout.CalculateLayout();
  //     InvokeYourProcedureToRedrawTheGraphOrHandleInteractionEtc();
  //  }
  //
  //  In the verletIntegration step above, the RemainingIterations is used to control damping.
  run() {
    this.settings.Converged = !1, this.settings.EdgeRoutesUpToDate = !1, this.settings.Iterations++ == 0 && (this.stepSize = this.settings.InitialStepSize, this.energy = Number.MAX_VALUE, this.progress = 0);
    for (let t = 0; t < this.settings.MinorIterations; t++) {
      if ((this.settings.RungeKuttaIntegration ? this.RungeKuttaIntegration() : this.VerletIntegration()) < this.settings.DisplacementThreshold || this.settings.Iterations > this.settings.MaxIterations) {
        this.settings.Converged = !0;
        break;
      }
      this.ProgressStep();
    }
  }
}
function Kf(a) {
  for (const t of a.Clusters)
    return !0;
  return !1;
}
class Qi {
  get edgeRoutingSettings() {
    return this.commonSettings.edgeRoutingSettings;
  }
  set edgeRoutingSettings(t) {
    this.commonSettings.edgeRoutingSettings = t;
  }
  get PackingAspectRatio() {
    return this.commonSettings.PackingAspectRatio;
  }
  set PackingAspectRatio(t) {
    this.commonSettings.PackingAspectRatio = t;
  }
  get NodeSeparation() {
    return this.commonSettings.NodeSeparation;
  }
  set NodeSeparation(t) {
    this.commonSettings.NodeSeparation = t;
  }
  //  Stop after maxIterations completed
  get MaxIterations() {
    return this.maxIterations;
  }
  set MaxIterations(t) {
    this.maxIterations = t;
  }
  //  Number of iterations in inner loop.
  get MinorIterations() {
    return this.minorIterations;
  }
  set MinorIterations(t) {
    this.minorIterations = t;
  }
  //  Number of iterations completed
  get Iterations() {
    return this.iterations;
  }
  set Iterations(t) {
    this.iterations = t;
  }
  //  number of times to project over all constraints at each layout iteration
  get ProjectionIterations() {
    return this.projectionIterations;
  }
  set ProjectionIterations(t) {
    this.projectionIterations = t;
  }
  //  Rather than computing the exact repulsive force between all pairs of nodes (which would take O(n^2) time for n nodes)
  //  use a fast inexact technique (that takes O(n log n) time)
  get ApproximateRepulsion() {
    return this.approximateRepulsion;
  }
  set ApproximateRepulsion(t) {
    this.approximateRepulsion = t;
  }
  //  StepSize taken at each iteration (a coefficient of the force on each node) adapts depending on change in
  //  potential energy at each step.  With this scheme changing the InitialStepSize doesn't have much effect
  //  because if it is too large or too small it will be quickly updated by the algorithm anyway.
  get InitialStepSize() {
    return this.initialStepSize;
  }
  set InitialStepSize(t) {
    if (t <= 0 || t > 2)
      throw new Error("ForceScalar should be greater than 0 and less than 2 (if we let you set it to 0 nothing would happen, greater than 2 would most likely be very unstable!)");
    this.initialStepSize = t;
  }
  //  FrictionalDecay isn't really friction so much as a scaling of velocity to improve convergence.  0.8 seems to work well.
  get Decay() {
    return this.decay;
  }
  set Decay(t) {
    if (t < 0.1 || t > 1)
      throw new Error("Setting decay too small gives no progress.  1==no decay, 0.1==minimum allowed value");
    this.decay = t;
  }
  //  Friction isn't really friction so much as a scaling of velocity to improve convergence.  0.8 seems to work well.
  get Friction() {
    return this.friction;
  }
  set Friction(t) {
    if (t < 0 || t > 1)
      throw new Error("Setting friction less than 0 or greater than 1 would just be strange.  1==no friction, 0==no conservation of velocity");
    this.friction = t;
  }
  //  strength of repulsive force between each pair of nodes.  A setting of 1.0 should work OK.
  get RepulsiveForceConstant() {
    return this.repulsiveForceConstant;
  }
  set RepulsiveForceConstant(t) {
    this.repulsiveForceConstant = t;
  }
  //  strength of attractive force between pairs of nodes joined by an edge.  A setting of 1.0 should work OK.
  get AttractiveForceConstant() {
    return this.attractiveForceConstant;
  }
  set AttractiveForceConstant(t) {
    this.attractiveForceConstant = t;
  }
  //  gravity is a constant force applied to all nodes attracting them to the Origin
  //  and keeping disconnected components from flying apart.  A setting of 1.0 should work OK.
  get GravityConstant() {
    return this.gravity;
  }
  set GravityConstant(t) {
    this.gravity = t;
  }
  //  If the following is false forces will not be considered between each component and each component will have its own gravity origin.
  get InterComponentForces() {
    return this.interComponentForces;
  }
  set InterComponentForces(t) {
    this.interComponentForces = t;
  }
  //  If the following is false forces will not be applied, but constraints will still be satisfied.
  get ApplyForces() {
    return this.applyForces;
  }
  set ApplyForces(t) {
    this.applyForces = t;
  }
  constructor() {
    this.commonSettings = new Js(), this.maxIterations = 100, this.clusterMargin = 10, this.minorIterations = 3, this.projectionIterations = 5, this.approximateRepulsion = !0, this.RungeKuttaIntegration = !1, this.initialStepSize = 1.4, this.decay = 0.9, this.friction = 0.8, this.repulsiveForceConstant = 1, this.attractiveForceConstant = 1, this.gravity = 1, this.interComponentForces = !0, this.applyForces = !0, this.AvoidOverlaps = !0, this.approximateRouting = !0, this.logScaleEdgeForces = !0, this.displacementThreshold = 0.1, this.maxConstraintLevel = 2, this.minConstraintLevel = 0, this.attractiveInterClusterForceConstant = 1, this.clusterGravity = 1, this.commonSettings.NodeSeparation *= 2;
  }
  //  restart layout, use e.g. after a mouse drag or non-structural change to the graph
  ResetLayout() {
    this.Unconverge(), this.algorithm != null && this.algorithm.ResetNodePositions();
  }
  /**   reset iterations and convergence status*/
  Unconverge() {
    this.iterations = 0, this.converged = !1;
  }
  InitializeLayoutGN(t, e) {
    this.InitializeLayout(t, e);
  }
  //  Initialize the layout algorithm
  InitializeLayout(t, e) {
    this.algorithm = new Dn(t, this, e), this.ResetLayout();
  }
  //
  Uninitialize() {
    this.algorithm = null;
  }
  //
  get IsInitialized() {
    return this.algorithm != null;
  }
  //
  IncrementalRunG(t) {
    this.IncrementalRunGF(t);
  }
  SetupIncrementalRun(t) {
    this.IsInitialized ? this.IsDone && this.ResetLayout() : this.InitializeLayout(t, this.MaxConstraintLevel);
  }
  //  Run the FastIncrementalLayout instance incrementally
  IncrementalRunGF(t) {
    this.SetupIncrementalRun(t), this.algorithm.run();
  }
  //
  IncrementalRun(t, e) {
    t?.throwIfCanceled(), this.SetupIncrementalRun(e), this.algorithm.cancelToken = t, this.algorithm.run();
  }
  Clone() {
    return Qi.ctorClone(this);
  }
  //  If RouteEdges is true then the following is checked to see whether to do optimal shortest path routing
  //  or use a sparse visibility graph spanner to do approximate---but much faster---shortest path routing
  get ApproximateRouting() {
    return this.approximateRouting;
  }
  set ApproximateRouting(t) {
    this.approximateRouting = t;
  }
  //  If true then attractive forces across edges are computed as:
  //  AttractiveForceConstant * actualLength * Math.Log((actualLength + epsilon) / (idealLength + epsilon))
  //  where epsilon is a small positive constant to avoid divide by zero or taking the log of zero.
  //  Note that LogScaleEdges can lead to ghost forces in highly constrained scenarios.
  //  If false then a the edge force is based on (actualLength - idealLength)^2, which works better with
  //  lots of constraints.
  get LogScaleEdgeForces() {
    return this.logScaleEdgeForces;
  }
  set LogScaleEdgeForces(t) {
    this.logScaleEdgeForces = t;
  }
  //  If the amount of total squared displacement after a particular iteration falls below DisplacementThreshold then Converged is set to true.
  //  Make DisplacementThreshold larger if you want layout to finish sooner - but not necessarily make as much progress towards a good layout.
  get DisplacementThreshold() {
    return this.displacementThreshold;
  }
  set DisplacementThreshold(t) {
    this.displacementThreshold = t;
  }
  //  Set to true if displacement from the last iteration was less than DisplacementThreshold.
  //  The caller should invoke FastIncrementalLayout.CalculateLayout() in a loop, e.g.:
  //
  //   while(!settings.Converged)
  //   {
  //     layout.CalculateLayout();
  //     redrawGraphOrHandleInteractionOrWhatever();
  //   }
  //
  //  RemainingIterations affects damping.
  get Converged() {
    return this.converged;
  }
  set Converged(t) {
    this.converged = t;
  }
  //  Return iterations as a percentage of MaxIterations.  Useful for reporting progress, e.g. in a progress bar.
  get PercentDone() {
    return this.Converged ? 100 : 100 * this.iterations / this.MaxIterations;
  }
  //  Not quite the same as Converged:
  get IsDone() {
    return this.Converged || this.iterations >= this.MaxIterations;
  }
  //  Returns an estimate of the cost function calculated in the most recent iteration.
  //  It's a float because FastIncrementalLayout.Energy is a volatile float so it
  //  can be safely read from other threads
  get Energy() {
    return this.algorithm != null ? this.algorithm.energy : 0;
  }
  //
  get MaxConstraintLevel() {
    return this.maxConstraintLevel;
  }
  set MaxConstraintLevel(t) {
    this.maxConstraintLevel != t && (this.maxConstraintLevel = t, this.IsInitialized && this.Uninitialize());
  }
  //
  get MinConstraintLevel() {
    return this.minConstraintLevel;
  }
  set MinConstraintLevel(t) {
    this.minConstraintLevel = t;
  }
  //  Constraint level ranges from Min to MaxConstraintLevel.
  //  0 = no constraints
  //  1 = only structural constraints
  //  2 = all constraints including non-overlap constraints
  //
  //  A typical run of FastIncrementalLayout will apply it at each constraint level, starting at 0 to
  //  obtain an untangled unconstrained layout, then 1 to introduce structural constraints and finally 2 to beautify.
  //  Running only at level 2 will most likely leave the graph stuck in a tangled local minimum.
  getCurrentConstraintLevel() {
    return this.algorithm == null ? 0 : this.algorithm.getCurrentConstraintLevel();
  }
  setCurrentConstraintLevel(t) {
    this.algorithm.setCurrentConstraintLevel(t);
  }
  //  Attractive strength of edges connected to clusters
  get AttractiveInterClusterForceConstant() {
    return this.attractiveInterClusterForceConstant;
  }
  set AttractiveInterClusterForceConstant(t) {
    this.attractiveInterClusterForceConstant = t;
  }
  //  Shallow copy the settings
  static ctorClone(t) {
    const e = new Qi();
    return e.maxIterations = t.maxIterations, e.minorIterations = t.minorIterations, e.projectionIterations = t.projectionIterations, e.approximateRepulsion = t.approximateRepulsion, e.initialStepSize = t.initialStepSize, e.RungeKuttaIntegration = t.RungeKuttaIntegration, e.decay = t.decay, e.friction = t.friction, e.repulsiveForceConstant = t.repulsiveForceConstant, e.attractiveForceConstant = t.attractiveForceConstant, e.gravity = t.gravity, e.interComponentForces = t.interComponentForces, e.applyForces = t.applyForces, e.AvoidOverlaps = t.AvoidOverlaps, e.RespectEdgePorts = t.RespectEdgePorts, e.RouteEdges = t.RouteEdges, e.approximateRouting = t.approximateRouting, e.logScaleEdgeForces = t.logScaleEdgeForces, e.displacementThreshold = t.displacementThreshold, e.minConstraintLevel = t.minConstraintLevel, e.maxConstraintLevel = t.maxConstraintLevel, e.attractiveInterClusterForceConstant = t.attractiveInterClusterForceConstant, e.clusterGravity = t.clusterGravity, e.PackingAspectRatio = t.PackingAspectRatio, e.NodeSeparation = t.NodeSeparation, e.clusterMargin = t.clusterMargin, e;
  }
  //  Controls how tightly members of clusters are pulled together
  get ClusterGravity() {
    return this.clusterGravity;
  }
  set ClusterGravity(t) {
    this.clusterGravity = t;
  }
  //      creates the settings that seems working
  //  <returns></returns>
  static CreateFastIncrementalLayoutSettings() {
    const t = new Qi();
    return t.ApplyForces = !1, t.ApproximateRepulsion = !0, t.ApproximateRouting = !0, t.AttractiveForceConstant = 1, t.AttractiveInterClusterForceConstant = 1, t.AvoidOverlaps = !0, t.ClusterGravity = 1, t.Decay = 0.9, t.DisplacementThreshold = 5e-8, t.Friction = 0.8, t.GravityConstant = 1, t.InitialStepSize = 2, t.InterComponentForces = !1, t.Iterations = 0, t.LogScaleEdgeForces = !1, t.MaxConstraintLevel = 2, t.MaxIterations = 20, t.MinConstraintLevel = 0, t.MinorIterations = 1, t.ProjectionIterations = 5, t.RepulsiveForceConstant = 2, t.RespectEdgePorts = !1, t.RouteEdges = !1, t.RungeKuttaIntegration = !0, t.NodeSeparation = 20, t;
  }
}
class Zf {
  constructor(t) {
    this.topNodes = t;
  }
  get nodesBreadthFirst() {
    return this.nodesBreadthFirst_();
  }
  *nodesBreadthFirst_() {
    for (const t of this.topNodes)
      if (yield Yt.getGeom(t), t instanceof di)
        for (const e of t.nodesBreadthFirst)
          yield Yt.getGeom(e);
  }
  get Clusters() {
    return this.clusters();
  }
  *clusters() {
    for (const t of this.topNodes)
      t instanceof di && (yield Nt.getGeom(t));
  }
  get subgraphsDepthFirst() {
    return this.subgraphsDepthFirst_();
  }
  *subgraphsDepthFirst_() {
    for (const t of this.topNodes)
      if (t instanceof di) {
        const e = Nt.getGeom(t);
        yield* e.subgraphsDepthFirst, yield e;
      }
  }
  get shallowEdges() {
    return this.edges_();
  }
  *edges_() {
    for (const t of this.topNodes) {
      for (const e of t.outEdges)
        yield Kt.getGeom(e);
      for (const e of t.selfEdges)
        yield Kt.getGeom(e);
    }
  }
  get shallowNodes() {
    return this.shallowNodes_();
  }
  *shallowNodes_() {
    for (const t of this.topNodes)
      yield Yt.getGeom(t);
  }
  pumpTheBoxToTheGraphWithMargins() {
    const t = { b: T.mkEmpty() };
    return ra(this, t), this.boundingBox = t.b;
  }
  get shallowNodeCount() {
    return this.topNodes.length;
  }
  translate(t) {
    this.boundingBox && (this.boundingBox.center = this.boundingBox.center.add(t));
    for (const e of this.topNodes)
      Yt.getGeom(e).translate(t);
  }
}
class Tl {
  //  Linearly interpolates a result between the minResult and the maxResult based on the location of the value between the lowerThreshold and the upperThreshold.
  //  <returns>The linearly interpolated result.  Between minResult and maxResult, inclusive.</returns>
  static LinearInterpolation(t, e, i, s, n) {
    if (t < e)
      return s;
    if (t > i)
      return n;
    const r = (t - e) / (i - e);
    return s + r * (n - s);
  }
  //  Negatively linearly interpolates a result between the minResult and the maxResult based on the location of the value between the lowerThreshold and the upperThreshold.
  //  <returns>The linearly interpolated result.  Between minResult and maxResult, inclusive.</returns>
  static NegativeLinearInterpolation(t, e, i, s, n) {
    if (t < e)
      return n;
    if (t > i)
      return s;
    const r = (t - e) / (i - e);
    return s + (1 - r) * (n - s);
  }
}
class $f extends ht {
  //  Static layout of graph by gradually adding constraints.
  //  Uses PivotMds to find initial layout.
  //  Breaks the graph into connected components (nodes of the same cluster are considered
  //  connected whether or not there is an edge between them), then lays out each component
  //  individually.  Finally, a simple packing is applied.
  //  ratio as close as possible to the PackingAspectRatio property (not currently used).
  constructor(t, e) {
    super(null), this.SingleComponent = !1, this.graph = t, this.settings = Qi.ctorClone(e), this.settings.ApplyForces = !0, this.settings.InterComponentForces = !0, this.settings.RungeKuttaIntegration = !1, this.settings.RespectEdgePorts = !1;
  }
  //  The actual layout process
  run() {
    if (this.SingleComponent)
      this.componentCount = 1, this.LayoutComponent(this.graph);
    else {
      const t = Array.from(this.graph.graph.getClusteredConnectedComponents()).map((e) => new Zf(e));
      this.componentCount = t.length;
      for (const e of t)
        this.LayoutComponent(e);
      this.graph.boundingBox = Fn.PackGraphs(t, this.settings.commonSettings);
    }
  }
  LayoutComponent(t) {
    if (t.shallowNodeCount > 1) {
      if (this.settings.MaxIterations = Tl.NegativeLinearInterpolation(t.shallowNodeCount, 50, 500, 5, 10), this.settings.MinorIterations = Tl.NegativeLinearInterpolation(t.shallowNodeCount, 50, 500, 3, 20), this.settings.MinConstraintLevel == 0) {
        const i = new Vn();
        i.removeOverlaps = !1, i.IterationsWithMajorization = 0, new Uh(t, null, () => 1, new Vn()).run();
      }
      const e = new Dn(t, this.settings, this.settings.MinConstraintLevel);
      for (const i of this.GetConstraintLevels(t)) {
        if (i > this.settings.MaxConstraintLevel)
          break;
        i > this.settings.MinConstraintLevel && e.setCurrentConstraintLevel(i);
        do
          e.run();
        while (!this.settings.IsDone);
      }
      this.settings.AvoidOverlaps && qe.RemoveOverlaps(Array.from(this.graph.shallowNodes), this.settings.NodeSeparation);
    }
    t.pumpTheBoxToTheGraphWithMargins(), t.uniformMargins = this.settings.NodeSeparation, t.translate(t.boundingBox.leftBottom.mul(-1));
  }
  /** returns 0, 1 or 2:
   *   Get the distinct ConstraintLevels that need to be applied to layout.
    Used by InitialLayout.
   Will only include ConstraintLevel == 2 if AvoidOverlaps is on and there are fewer than 2000 nodes
   */
  GetConstraintLevels(t) {
    const e = /* @__PURE__ */ new Set();
    return e.add(0), this.settings.AvoidOverlaps && t.shallowNodeCount < 2e3 && e.add(2), e;
  }
}
function Yh(a) {
  a.layoutSettings || (a.layoutSettings = Jh(a));
}
function tg(a) {
  let t = a.parent;
  for (; t; ) {
    if (t.layoutSettings)
      return t.layoutSettings;
    t = t.parent;
  }
  return null;
}
function Jh(a) {
  const t = tg(a);
  if (t)
    return t;
  if (a.graph.shallowNodeCount > 2e3 || a.graph.deepEdgesCount > 4e3)
    return new Qi();
  let i = !1;
  for (const s of a.deepEdges)
    if (s.sourceArrowhead != null || s.targetArrowhead != null) {
      i = !0;
      break;
    }
  return i ? new sn() : new Qi();
}
function eg(a, t, e = () => 1) {
  if (Yh(a), a.layoutSettings instanceof sn)
    new nc(a, a.layoutSettings, t).run();
  else if (a.layoutSettings instanceof Vn)
    new Uh(a, t, e, a.layoutSettings).run();
  else if (a.layoutSettings instanceof Qi) {
    const i = new $f(a, a.layoutSettings);
    i.SingleComponent = !0, i.run();
  } else
    throw new Error("not implemented");
}
function ig(a, t = null) {
  Yh(a), $h(a, t, eg, Zh, Fd), ag(a);
}
function Kh(a) {
  do {
    if (a.layoutSettings && a.layoutSettings.commonSettings.edgeRoutingSettings)
      return a.layoutSettings.commonSettings.edgeRoutingSettings;
    const e = a.graph.parent;
    if (e)
      a = $.getGeom(e);
    else
      break;
  } while (!0);
  const t = new Mn();
  return t.EdgeRoutingMode = Jt.Spline, t;
}
function Zh(a, t, e) {
  const i = Kh(a);
  i.EdgeRoutingMode === Jt.Rectilinear ? rg(a, t) : i.EdgeRoutingMode === Jt.Spline || i.EdgeRoutingMode === Jt.SplineBundling ? Ig(a, t, e) : i.EdgeRoutingMode === Jt.StraightLine ? Xh(a, t, e) : i.EdgeRoutingMode !== Jt.None && new it(a, t).run(), tc(a, t);
}
function $h(a, t, e, i, s, n = 1, r = () => 1) {
  if (a.graph.isEmpty())
    return;
  a.shallowNodes.next(), a.parent == null && (to(n), og(a));
  const o = f();
  d(a);
  const l = sg(a.graph), h = ng(a);
  if (p(), l.forEach((P) => {
    P[0].edge.remove(), P[1].add();
  }), h.forEach((P) => {
    for (const y of P.graph.shallowNodes)
      y.parent = a.graph;
  }), o.forEach((P) => P.add()), a.graph.parent == null) {
    const P = c(a);
    i(a, P, t), tc(a, P), a.pumpTheBoxToTheGraphWithMargins();
  }
  function c(P) {
    const y = [];
    for (const C of P.nodesBreadthFirst) {
      for (const w of C.outEdges())
        w.curve == null && y.push(w);
      for (const w of C.selfEdges())
        w.curve == null && y.push(w);
    }
    return y;
  }
  function d(P) {
    for (const y of P.shallowNodes)
      y instanceof Nt && $h(y, t, e, i, s);
  }
  function f() {
    const P = /* @__PURE__ */ new Set(), y = a.graph;
    if (y.parent == null)
      return P;
    for (const C of y.shallowNodes) {
      for (const w of C.outEdges) {
        const N = y.liftNode(w.target);
        (N == null || N === C) && P.add(w);
      }
      for (const w of C.inEdges) {
        const N = y.liftNode(w.source);
        (N == null || N === C) && P.add(w);
      }
    }
    for (const C of P)
      C.remove();
    return P;
  }
  function p() {
    if (h.length === 1)
      e(a, t, r);
    else {
      for (const P of h)
        e(P, t, r), P.boundingBox = P.pumpTheBoxToTheGraphWithMargins();
      s(a, h);
    }
  }
}
function sg(a) {
  const t = new Array();
  for (const e of a.nodesBreadthFirst) {
    const i = a.liftNode(e);
    if (i != null)
      for (const s of e.outEdges.values()) {
        const n = s.target, r = a.liftNode(n);
        if (r == null || i === e && r === n || i === r)
          continue;
        s.remove();
        const o = new Mh(i, r), l = new Kt(o);
        t.push([l, s]);
      }
  }
  return t;
}
function ng(a) {
  var t;
  const e = a.graph, i = xd(e), s = [];
  let n = 0;
  for (const r of i) {
    const o = new di(e.id + n++);
    o.parent = e;
    const l = new Nt(o);
    l.layoutSettings = (t = a.layoutSettings) !== null && t !== void 0 ? t : Jh(a);
    for (const h of r)
      h.parent = o, o.addNode(h);
    s.push(l);
  }
  return s;
}
function rg(a, t, e, i = 1, s = 3, n = 3) {
  const r = bt.constructorGNAN(a, t, i, s);
  r.edgeSeparatian = n, r.run();
}
function tc(a, t) {
  if (t.length === 0)
    return;
  z.constructorGA(a, t).run();
}
function og(a) {
  for (const t of a.deepEdges)
    t.label && (t.label.isPositioned = !1);
}
function ag(a) {
  const t = a.boundingBox.leftBottom;
  if (t.x < 0 || t.y < 0) {
    const e = new u(-t.x, -t.y);
    a.translate(e);
  }
}
class ba {
  static constructorStatic(t, e) {
    const i = new ba();
    i.edges = t, i.nodeBoundaries = e, i.boundingBox = T.mkEmpty();
    for (const s of i.nodeBoundaries)
      i.boundingBox = i.boundingBox.addRec(s.boundingBox);
    return i;
  }
  AddGraph(t) {
    this.edges = this.edges.concat(t.edges), this.nodeBoundaries = js(this.nodeBoundaries, t.nodeBoundaries), this.boundingBox.addRec(t.boundingBox);
  }
  AddNodeBoundary(t) {
    this.nodeBoundaries.add(t), this.boundingBox.addRec(t.boundingBox);
  }
}
var zo;
(function(a) {
  a[a.Success = 0] = "Success", a[a.Overlaps = 1] = "Overlaps", a[a.EdgeSeparationIsTooLarge = 2] = "EdgeSeparationIsTooLarge";
})(zo || (zo = {}));
class ur {
  get CurrentPiercedEdge() {
    return this.currentPiercedEdge;
  }
  get CurrentTriangle() {
    return this.currentTriangle;
  }
  constructor(t, e, i) {
    this.currentTriangle = t, this.start = e, this.end = i;
  }
  /**This method finds the first edge of the current triangle that
     * is pierced by a segment (start,end). It assumes that the start
     * point is inside or on the boundary of the current triangle,
     *  and the end point is outside.
     * The function works by computing the sign of each vertex
     *  of the current triangle with respect to the segment.
     *  The sign is zero if the vertex is on the segment,
     * positive if it is to the right of the segment  (when looking from the start point to the end point),
     * and negative if it is to the left.
     * The function then checks if there are two consecutive
     * vertices with different signs. If so, it means that the edge between them is pierced by the segment. The function returns that edge as the result.
  
  The function also sets the positiveSign and negativeSign fields to store the signs of the vertices on either side of the pierced edge. This is useful for finding the next triangle in the path of the segment. */
  FindFirstPiercedEdge() {
    const t = this.GetHyperplaneSign(this.currentTriangle.Sites.item0), e = this.GetHyperplaneSign(this.currentTriangle.Sites.item1);
    if (t !== e && u.getTriangleOrientation(this.end, this.currentTriangle.Sites.item0.point, this.currentTriangle.Sites.item1.point) == L.Clockwise)
      return this.positiveSign = t, this.negativeSign = e, this.currentTriangle.Edges.item0;
    const i = this.GetHyperplaneSign(this.currentTriangle.Sites.item2);
    return e !== i && u.getTriangleOrientation(this.end, this.currentTriangle.Sites.item1.point, this.currentTriangle.Sites.item2.point) == L.Clockwise ? (this.positiveSign = e, this.negativeSign = i, this.currentTriangle.Edges.item1) : (this.positiveSign = i, this.negativeSign = t, this.currentTriangle.Edges.item2);
  }
  FindNextPierced() {
    if (this.currentTriangle = this.currentPiercedEdge.GetOtherTriangle_T(this.currentTriangle), this.currentTriangle == null) {
      this.currentPiercedEdge = null;
      return;
    }
    const t = this.currentTriangle.Edges.index(this.currentPiercedEdge);
    let e;
    const i = this.currentTriangle.Sites.getItem(t + 2), s = this.GetHyperplaneSign(i);
    this.negativeSign === 0 ? s === -1 || s === 0 ? (this.negativeSign = s, e = t + 1) : e = t + 2 : this.positiveSign === 0 ? s === 1 || s === 0 ? (this.positiveSign = s, e = t + 2) : e = t + 1 : s !== this.positiveSign ? (this.negativeSign = s, e = t + 1) : (this.positiveSign = s, e = t + 2), this.currentPiercedEdge = u.signedDoubledTriangleArea(this.end, this.currentTriangle.Sites.getItem(e).point, this.currentTriangle.Sites.getItem(e + 1).point) < -m.distanceEpsilon ? this.currentTriangle.Edges.getItem(e) : null;
  }
  //        void ShowDebug(Array<CdtTriangle> cdtTriangles, CdtEdge cdtEdge, CdtTriangle cdtTriangle) {
  //            var l = new Array<DebugCurve> { new DebugCurve(10,"red",new LineSegment(start,end)) };
  //            if(cdtEdge!=null)
  //                l.Add(new DebugCurve(100,3,"navy", new LineSegment(cdtEdge.upperSite.point,cdtEdge.lowerSite.point)));
  //            AddTriangleToListOfDebugCurves(l,cdtTriangle,100,2,"brown");
  //            LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);
  //
  //        }
  //        static void AddTriangleToListOfDebugCurves(Array<DebugCurve> debugCurves,CdtTriangle triangle,byte transparency,double width,string color) {
  //            foreach(var cdtEdge of triangle.Edges) {
  //                debugCurves.Add(new DebugCurve(transparency,width,color,new LineSegment(cdtEdge.upperSite.point,cdtEdge.lowerSite.point)));
  //            }
  //        }
  GetHyperplaneSign(t) {
    const e = u.signedDoubledTriangleArea(this.start, t.point, this.end);
    return e > m.distanceEpsilon ? 1 : e < -m.distanceEpsilon ? -1 : 0;
  }
  MoveNext() {
    return this.currentPiercedEdge == null ? this.currentPiercedEdge = this.FindFirstPiercedEdge() : this.FindNextPierced(), this.currentPiercedEdge != null;
  }
}
class va {
  EdgeIsLegal_(t, e, i, s) {
    if (gt.PointIsInsideOfTriangle(e, i))
      return !0;
    const n = new ur(i, t, e);
    for (; n.MoveNext(); ) {
      const r = n.CurrentPiercedEdge;
      if (r.constrained) {
        const o = r.lowerSite.Owner;
        if (!s.has(o))
          return !1;
      }
    }
    return !0;
  }
  constructor(t, e) {
    this.ComputeForcesForBundles = !1, this.metroGraphData = t, this.bundlingSettings = e;
  }
  /**   returns false iff an edge overlap an obstacle,
  otherwise it calulates distances to the closest obstacles */
  BundleAvoidsObstacles(t, e, i, s, n, r) {
    r.closestDist = new Array();
    const o = this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(t, e), l = this.FindCloseObstaclesForBundle(e.cdtTriangle, s, i, o, n);
    if (l == null)
      return !1;
    for (const h of l) {
      const c = h[1];
      r.closestDist.push(c);
    }
    return !0;
  }
  // returns null iff the edge overlap an obstacle
  FindCloseObstaclesForBundle(t, e, i, s, n) {
    const r = /* @__PURE__ */ new Map(), o = [];
    if (!this.ThreadLineSegmentThroughTriangles(t, e, i, s, o))
      return null;
    if (!this.ComputeForcesForBundles && !this.bundlingSettings.HighestQuality)
      return r;
    const l = /* @__PURE__ */ new Set();
    for (const h of o)
      for (const c of h.Sites) {
        if (l.has(c))
          continue;
        l.add(c);
        const d = c.Owner;
        if (s.has(d))
          continue;
        const f = va.FindPolylinePoint(d, c.point), p = v.minDistBetweenLineSegments(f.point, f.nextOnPolyline.point, e, i), P = p.dist, y = p.parab, C = p.parcd, w = v.minDistBetweenLineSegments(f.point, f.prevOnPolyline.point, e, i), N = w.dist, I = w.parab, x = w.parcd;
        let V, M, X;
        if (P < N) {
          if (X = P, X > n)
            continue;
          V = f.point.add(f.nextOnPolyline.point.sub(f.point).mul(y)), M = e.add(i.sub(e).mul(C));
        } else {
          if (X = N, X > n)
            continue;
          V = f.point.add(f.prevOnPolyline.point.sub(f.point).mul(I)), M = e.add(i.sub(e).mul(x));
        }
        r.get(d) || r.set(d, [V, M]);
      }
    return r;
  }
  /**   returns false iff the edge overlap an obstacle*/
  ThreadLineSegmentThroughTriangles(t, e, i, s, n) {
    if (gt.PointIsInsideOfTriangle(i, t))
      return n.push(t), !0;
    const r = new ur(t, e, i);
    for (n.push(t); r.MoveNext(); ) {
      n.push(r.CurrentTriangle);
      const o = r.CurrentPiercedEdge;
      if (o.constrained) {
        const l = o.lowerSite.Owner;
        if (!s.has(l))
          return !1;
      }
    }
    return r.CurrentTriangle != null && n.push(r.CurrentTriangle), !0;
  }
  static PointLocationInsideTriangle(t, e) {
    let i = !1;
    for (let s = 0; s < 3; s++) {
      const n = u.signedDoubledTriangleArea(t, e.Sites.getItem(s).point, e.Sites.getItem(s + 1).point);
      if (n < m.distanceEpsilon * -1)
        return F.Outside;
      n < m.distanceEpsilon && (i = !0);
    }
    return i ? F.Boundary : F.Inside;
  }
  static FindPolylinePoint(t, e) {
    for (const i of t.polylinePoints())
      if (i.point.equal(e))
        return i;
    throw new Error("polyline point " + e + " not found");
  }
  // checks if an edge intersects obstacles
  // otherwise it calulates distances to the closest obstacles
  EdgeIsLegal(t, e, i, s) {
    const n = [], r = this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(t, e);
    return this.ThreadLineSegmentThroughTriangles(t.cdtTriangle, i, s, r, n);
  }
  // checks if an edge intersects obstacles
  // otherwise it calulates distances to the closest obstacles
  EdgeIsLegalSSPPS(t, e, i) {
    const s = t.Position, n = t.cdtTriangle, r = e.Position;
    if (gt.PointIsInsideOfTriangle(r, n))
      return !0;
    const o = new ur(n, s, r);
    for (; o.MoveNext(); ) {
      const l = o.CurrentPiercedEdge;
      if (l.constrained) {
        const h = l.lowerSite.Owner;
        if (!i.has(h))
          return !1;
      }
    }
    return !0;
  }
}
class Ue {
  constructor(t, e, i, s) {
    this.metroGraphData = t, this.obstaclesToIgnoreLambda = s, this.bundlingSettings = e, this.obstacleTree = i;
  }
  ObstaclesToIgnoreForBundle(t, e) {
    return t != null && e != null ? js(this.obstaclesToIgnoreLambda(t), this.obstaclesToIgnoreLambda(e)) : t == null && e == null ? /* @__PURE__ */ new Set() : t != null ? this.obstaclesToIgnoreLambda(t) : this.obstaclesToIgnoreLambda(e);
  }
  HubAvoidsObstaclesSPNBA(t, e, i, s) {
    const n = { minimalDistance: i };
    return Ue.IntersectCircleWithTree(this.obstacleTree, e, i, this.obstaclesToIgnoreLambda(t), s.touchedObstacles, n);
  }
  HubAvoidsObstaclesPNS__(t, e, i) {
    const s = { touchedObstacles: Array() }, n = { minimalDistance: 0 };
    return this.HubAvoidsObstaclesPNSTT(t, e, i, s, n);
  }
  GetMinimalDistanceToObstacles(t, e, i) {
    const s = new Array(), n = { minimalDistance: i };
    return Ue.IntersectCircleWithTree(this.obstacleTree, e, i, this.obstaclesToIgnoreLambda(t), s, n) ? n.minimalDistance : 0;
  }
  HubAvoidsObstaclesPNSTT(t, e, i, s, n) {
    return s.touchedObstacles = new Array(), n.minimalDistance = e, Ue.IntersectCircleWithTree(this.obstacleTree, t, e, i, s.touchedObstacles, n);
  }
  // Computes the intersection between the hub and obstacles
  // Returns false iff the center is inside of an obstacle, which is not ignored
  static IntersectCircleWithTree(t, e, i, s, n, r) {
    if (!t.irect.contains_point_radius(e, i))
      return !0;
    if (t.UserData == null) {
      let o = Ue.IntersectCircleWithTree(t.Left, e, i, s, n, r);
      if (!o || (o = Ue.IntersectCircleWithTree(t.Right, e, i, s, n, r), !o))
        return !1;
    } else {
      const o = t.UserData;
      if (s.has(o))
        return !0;
      if (g.PointRelativeToCurveLocation(e, o) !== F.Outside)
        return Ue.containingPoly = o, !1;
      const h = o.value(o.closestParameter(e)), c = h.sub(e).length;
      c <= i && n.push([o, h]), r.minimalDistance = Math.min(c, r.minimalDistance);
    }
    return !0;
  }
  static Create4gon(t, e, i, s) {
    let n = e.sub(t).normalize();
    return n = new u(n.y, n.x * -1), B.mkFromPoints([
      t.add(n.mul(i / 2)),
      t.sub(n.mul(i / 2)),
      e.sub(n.mul(s / 2)),
      e.add(n.mul(s / 2))
    ]);
  }
}
class lg {
  constructor(t, e, i, s) {
    this.Width = e, this.Polyline = t, this.sourceAndTargetLoosePolylines = i, this.Index = s;
  }
  UpdateLengths() {
    let t = 0;
    for (let e = this.Polyline.startPoint; e.next != null; e = e.next)
      t += e.next.point.sub(e.point).length;
    this.Length = t, this.IdealLength = this.Polyline.end.sub(this.Polyline.start).length;
  }
}
class hg {
  constructor(t, e, i) {
    this.metroline = t, this.station = e, this.polyPoint = i;
  }
  get Metroline() {
    return this.metroline;
  }
  get PolyPoint() {
    return this.polyPoint;
  }
}
class cg {
  constructor(t, e, i) {
    this.Radius = 0, this.BundleBases = /* @__PURE__ */ new Map(), this.MetroNodeInfos = new Array(), this._cachedIdealRadius = 0, this.SerialNumber = t, this.IsReal = e, this.Position = i;
  }
  debStop() {
    return (
      //(this.SerialNumber === 1 && this.Position.sub(new Point(706.0327200902565, 203.36018761064003)).length < 0.01) ||
      this.SerialNumber === 28 && this.Position.sub(new u(841.2662778763244, 303.3817005853006)).length < 1e-3
    );
  }
  get Position() {
    return this._Position;
  }
  set Position(t) {
    this._Position = t;
  }
  getELP() {
    return this.EnterableLoosePolylines;
  }
  setELP(t) {
    this.EnterableLoosePolylines = t;
  }
  addEL(t) {
    this.EnterableLoosePolylines.add(t);
  }
  get cachedIdealRadius() {
    return this._cachedIdealRadius;
  }
  set cachedIdealRadius(t) {
    this._cachedIdealRadius = t;
  }
  AddEnterableLoosePolyline(t) {
    this.EnterableLoosePolylines == null && (this.EnterableLoosePolylines = /* @__PURE__ */ new Set()), this.EnterableLoosePolylines.add(t);
  }
  AddEnterableTightPolyline(t) {
    this.EnterableTightPolylines == null && (this.EnterableTightPolylines = /* @__PURE__ */ new Set()), this.EnterableTightPolylines.add(t);
  }
}
class ug {
  constructor() {
    this.Width = 0, this.Metrolines = new Array(), this.cachedBundleCost = 0;
  }
  get Count() {
    return this.Metrolines.length;
  }
}
class Qt {
  constructor(t, e) {
    this.metroGraphData = t, this.bundlingSettings = e;
  }
  // calculate node radii with fixed hubs
  CreateNodeRadii() {
    for (const t of this.metroGraphData.VirtualStations())
      t.Radius = 0, t.cachedIdealRadius = Qt.CalculateIdealHubRadiusWithNeighborsMBS(this.metroGraphData, this.bundlingSettings, t);
    this.GrowHubs(!1), this.GrowHubs(!0);
    for (const t of this.metroGraphData.VirtualStations())
      t.Radius = Math.max(t.Radius, this.bundlingSettings.MinHubRadius);
  }
  // Grow hubs
  GrowHubs(t) {
    const e = new is(yt);
    for (const s of this.metroGraphData.VirtualStations())
      e.Enqueue(s, -this.CalculatePotential(s, t));
    let i = !1;
    for (; !e.IsEmpty(); ) {
      const s = { priority: 0 }, n = e.DequeueAndGetPriority(s);
      if (s.priority >= 0)
        break;
      this.TryGrowHub(n, t) && (e.Enqueue(n, -this.CalculatePotential(n, t)), i = !0);
    }
    return i;
  }
  TryGrowHub(t, e) {
    const i = this.CalculateAllowedHubRadius(t);
    if (t.Radius >= i)
      return !1;
    const s = e ? Qt.CalculateIdealHubRadiusWithAdjacentEdges(this.bundlingSettings, t) : t.cachedIdealRadius;
    if (t.Radius >= s)
      return !1;
    let r = 0.05 * (s - t.Radius);
    r < 1 && (r = 1);
    const o = Math.min(t.Radius + r, i);
    return o <= t.Radius ? !1 : (t.Radius = o, !0);
  }
  CalculatePotential(t, e) {
    const i = e ? Qt.CalculateIdealHubRadiusWithAdjacentEdges(this.bundlingSettings, t) : t.cachedIdealRadius;
    return i <= t.Radius ? 0 : (i - t.Radius) / i;
  }
  // Returns the maximal possible radius of the node
  CalculateAllowedHubRadius(t) {
    let e = this.bundlingSettings.MaxHubRadius;
    for (const s of t.Neighbors) {
      const n = s.Position.sub(t.Position).length;
      e = Math.min(e, n / 1.05 - s.Radius);
    }
    const i = this.metroGraphData.tightIntersections.GetMinimalDistanceToObstacles(t, t.Position, e);
    return i < e && (e = i - 1e-3), Math.max(e, 0.1);
  }
  // Returns the ideal radius of the hub
  static CalculateIdealHubRadius(t, e, i) {
    let s = 1;
    for (const n of i.Neighbors) {
      const o = t.GetWidthSSN(n, i, e.EdgeSeparation) / 2 + e.EdgeSeparation;
      s = Math.max(s, o);
    }
    return s = Math.min(s, 2 * e.MaxHubRadius), s;
  }
  // Returns the ideal radius of the hub
  static CalculateIdealHubRadiusWithNeighborsMBS(t, e, i) {
    return Qt.CalculateIdealHubRadiusWithNeighborsMBNP(t, e, i, i.Position);
  }
  // Returns the ideal radius of the hub
  static CalculateIdealHubRadiusWithNeighborsMBNP(t, e, i, s) {
    let n = Qt.CalculateIdealHubRadius(t, e, i);
    if (i.Neighbors.length > 1) {
      const r = i.Neighbors;
      for (let o = 0; o < r.length; o++) {
        const l = r[o], h = r[(o + 1) % r.length];
        n = Math.max(n, Qt.GetMinRadiusForTwoAdjacentBundles(n, i, s, l, h, t, e));
      }
    }
    return n = Math.min(n, 2 * e.MaxHubRadius), n;
  }
  // Returns the ideal radius of the hub
  static CalculateIdealHubRadiusWithAdjacentEdges(t, e) {
    let i = t.MaxHubRadius;
    for (const s of e.Neighbors)
      i = Math.min(i, e.Position.sub(s.Position).length / 2);
    return i;
  }
  static GetMinRadiusForTwoAdjacentBundles(t, e, i, s, n, r, o) {
    const l = r.GetWidthSSN(e, s, o.EdgeSeparation), h = r.GetWidthSSN(e, n, o.EdgeSeparation);
    return Qt.GetMinRadiusForTwoAdjacentBundlesNPPPNNB(t, i, s.Position, n.Position, l, h, o);
  }
  // Radius we need to draw to separate adjacent bundles ab and ac
  static GetMinRadiusForTwoAdjacentBundlesNPPPNNB(t, e, i, s, n, r, o) {
    if (n < m.distanceEpsilon || r < m.distanceEpsilon)
      return t;
    let l = u.anglePCP(i, e, s);
    if (l = Math.min(l, Math.PI * 2 - l), l < m.distanceEpsilon)
      return 2 * o.MaxHubRadius;
    if (l >= Math.PI / 2)
      return t * 1.05;
    const h = Math.sin(l), c = Math.cos(l), d = n / (4 * h), f = r / (4 * h);
    let p = 2 * Math.sqrt(d * d + (f * f + 2 * (d * (f * c))));
    return p = Math.min(p, 2 * o.MaxHubRadius), p = Math.max(p, t), p;
  }
}
class so {
  constructor(t, e, i, s) {
    this.metroGraphData = t, this.bundlingSettings = e, this.costCalculator = i, this.cdt = s;
  }
  InitializeCostCache() {
    for (const t of this.metroGraphData.VirtualStations())
      t.cachedIdealRadius = Qt.CalculateIdealHubRadiusWithNeighborsMBS(this.metroGraphData, this.bundlingSettings, t), t.cachedRadiusCost = this.costCalculator.RadiusCost(t, t.Position), t.cachedBundleCost = 0;
    for (const t of this.metroGraphData.VirtualEdges()) {
      const e = t[0], i = t[1], s = this.metroGraphData.GetIjInfo(e, i);
      s.cachedBundleCost = this.costCalculator.BundleCost(e, i, e.Position), e.cachedBundleCost += s.cachedBundleCost, i.cachedBundleCost += s.cachedBundleCost;
    }
  }
  UpdateCostCache(t) {
    const e = this.cdt.getRectangleNodeOnTriangles();
    t.cdtTriangle = e.FirstHitNodeWithPredicate(t.Position, so.testPointInside).UserData, t.cachedIdealRadius = Qt.CalculateIdealHubRadiusWithNeighborsMBS(this.metroGraphData, this.bundlingSettings, t), t.cachedRadiusCost = this.costCalculator.RadiusCost(t, t.Position), t.cachedBundleCost = 0;
    for (const i of t.Neighbors) {
      i.IsReal || (i.cachedIdealRadius = Qt.CalculateIdealHubRadiusWithNeighborsMBS(this.metroGraphData, this.bundlingSettings, i), i.cachedRadiusCost = this.costCalculator.RadiusCost(i, i.Position));
      const s = this.metroGraphData.GetIjInfo(t, i);
      i.cachedBundleCost -= s.cachedBundleCost, s.cachedBundleCost = this.costCalculator.BundleCost(t, i, t.Position), t.cachedBundleCost += s.cachedBundleCost, i.cachedBundleCost += s.cachedBundleCost;
    }
  }
  static testPointInside(t, e) {
    return gt.PointIsInsideOfTriangle(t, e) ? at.Stop : at.Continue;
  }
}
class ec {
  constructor() {
    this.mainMap = /* @__PURE__ */ new Map();
  }
  get isEmpty() {
    return this.mainMap.size === 0 || this.everyMapIsEmpty();
  }
  everyMapIsEmpty() {
    for (const t of this.mainMap.values())
      if (t.size)
        return !1;
    return !0;
  }
  get(t, e) {
    const i = this.mainMap.get(t);
    if (i)
      return i.get(e);
  }
  has(t, e) {
    const i = this.mainMap.get(t);
    return i ? i.has(e) : !1;
  }
  set(t, e, i) {
    let s = this.mainMap.get(t);
    s || (s = /* @__PURE__ */ new Map(), this.mainMap.set(t, s)), s.set(e, i);
  }
  *[Symbol.iterator]() {
    for (const [t, e] of this.mainMap)
      for (const [i, s] of e)
        yield [t, i, s];
  }
  *keys() {
    for (const [t, e] of this.mainMap)
      for (const [i] of e)
        yield [t, i];
  }
}
class dg {
  constructor(t, e, i, s, n, r, o, l) {
    this.cachedEnterableLooseForEnd = new ii(), this.bundlingSettings = s, this.regularEdges = t, n != null ? this.cdt = n : this.cdt = jh(e), this.EdgeLooseEnterable = r, this.EdgeTightEnterable = o, this.LoosePolylineOfPort = l, this.looseIntersections = new Ue(this, s, e, (h) => h.getELP()), this.tightIntersections = new Ue(this, s, i, (h) => h.EnterableTightPolylines), this.cdtIntersections = new va(this, s), this.Initialize(!1);
  }
  get Ink() {
    return this.ink;
  }
  get Edges() {
    return this.regularEdges;
  }
  VirtualStations() {
    return Array.from(this.Stations).filter((t) => !t.IsReal);
  }
  get Metrolines() {
    return this.metrolines;
  }
  get LooseTree() {
    return this.looseIntersections.obstacleTree;
  }
  get TightTree() {
    return this.tightIntersections.obstacleTree;
  }
  *VirtualEdges() {
    for (const t of this.edgeInfoDictionary.keys())
      yield t;
  }
  // number of real edges passing the edge uv
  RealEdgeCount(t, e) {
    const i = t.SerialNumber < e.SerialNumber ? [t, e] : [e, t], s = this.edgeInfoDictionary.get(i[0], i[1]);
    return s ? s.Count : 0;
  }
  // real edges passing the node
  MetroNodeInfosOfNode(t) {
    return t.MetroNodeInfos;
  }
  // real edges passing the edge uv
  GetIjInfo(t, e) {
    const i = t.SerialNumber < e.SerialNumber ? [t, e] : [e, t];
    return this.edgeInfoDictionary.get(i[0], i[1]);
  }
  // Move node to the specified position
  MoveNode(t, e) {
    const i = t.Position;
    this.PointToStations.deleteP(i), this.PointToStations.set(e, t), t.Position = e;
    for (const s of this.MetroNodeInfosOfNode(t))
      s.PolyPoint.point = e;
    for (const s of this.MetroNodeInfosOfNode(t)) {
      const n = s.Metroline, r = s.PolyPoint.prev.point, o = s.PolyPoint.next.point;
      n.Length += o.sub(e).length + r.sub(e).length - o.sub(i).length - r.sub(i).length;
    }
    for (const s of t.Neighbors)
      this.ink += e.sub(s.Position).length - i.sub(s.Position).length;
    this.SortNeighbors(t);
    for (const s of t.Neighbors)
      this.SortNeighbors(s);
  }
  GetWidthSSN(t, e, i) {
    const s = t.SerialNumber < e.SerialNumber ? [t, e] : [e, t], n = this.edgeInfoDictionary.get(s[0], s[1]);
    return n ? n.Width + (n.Count - 1) * i : 0;
  }
  GetWidthAN(t, e) {
    let i = 0;
    for (const n of t)
      i += n.Width;
    const s = t.length;
    return i += s > 0 ? (s - 1) * e : 0, i;
  }
  // Initialize data
  Initialize(t) {
    this.SimplifyRegularEdges(), this.InitializeStationData(), this.InitializeEdgeData(), this.InitializeVirtualGraph(), this.InitializeEdgeNodeInfo(t), this.InitializeCdtInfo();
  }
  // remove self-cycles
  SimplifyRegularEdges() {
    for (const t of this.regularEdges)
      this.SimplifyRegularEdge(t);
  }
  // change the polyline by removing cycles
  SimplifyRegularEdge(t) {
    const e = t.curve, i = new mt.Stack(), s = new xt();
    for (let n = e.endPoint; n != null; n = n.prev) {
      const r = n.point;
      if (s.has(n.point)) {
        let o = n.next;
        do {
          const l = i.top;
          if (!l.equal(r))
            s.delete(l), i.pop(), o = o.next;
          else
            break;
        } while (!0);
        o.prev = n.prev, o.prev.next = o;
      } else
        i.push(r), s.add(r);
    }
  }
  InitializeStationData() {
    this.Stations = [], this.PointToStations = new ii();
    for (const t of this.regularEdges) {
      const e = t.curve;
      this.ProcessPolylinePoints(e);
    }
  }
  ProcessPolylinePoints(t) {
    let e = t.startPoint;
    for (this.RegisterStation(e, !0), e = e.next; e !== t.endPoint; e = e.next)
      this.RegisterStation(e, !1);
    this.RegisterStation(e, !0);
  }
  RegisterStation(t, e) {
    if (!this.PointToStations.has(t.point)) {
      const i = new cg(this.Stations.length, e, t.point);
      this.PointToStations.set(t.point, i), this.Stations.push(i);
    }
  }
  InitializeEdgeData() {
    this.metrolines = new Array();
    for (let t = 0; t < this.regularEdges.length; t++) {
      const e = this.regularEdges[t];
      this.InitEdgeData(e, t);
    }
  }
  InitEdgeData(t, e) {
    const i = new lg(t.curve, this.bundlingSettings.ActualEdgeWidth(t), this.EdgeSourceAndTargetFunc(t), e);
    this.metrolines.push(i), this.PointToStations.get(i.Polyline.start).BoundaryCurve = t.sourcePort.Curve, this.PointToStations.get(i.Polyline.end).BoundaryCurve = t.targetPort.Curve;
  }
  EdgeSourceAndTargetFunc(t) {
    return () => [this.LoosePolylineOfPort(t.sourcePort), this.LoosePolylineOfPort(t.targetPort)];
  }
  /**   Initialize graph comprised of stations and their neighbors */
  InitializeVirtualGraph() {
    const t = /* @__PURE__ */ new Map();
    for (const e of this.metrolines) {
      let i = this.PointToStations.get(e.Polyline.start), s;
      for (let n = e.Polyline.startPoint; n.next != null; n = n.next, i = s)
        s = this.PointToStations.get(n.next.point), Or(t, i, s), Or(t, s, i);
    }
    for (const e of this.Stations)
      e.Neighbors = Array.from(t.get(e));
  }
  GetUnorderedIjInfo(t, e) {
    return t.SerialNumber < e.SerialNumber ? this.GetCreateOrderedIjInfo(t, e) : this.GetCreateOrderedIjInfo(e, t);
  }
  static closedeb(t, e) {
    return t.Position.sub(new u(360.561, 428.416)).length < 0.1 && e.Position.sub(new u(414.281, 440.732)).length < 0.1;
  }
  GetCreateOrderedIjInfo(t, e) {
    let i = this.edgeInfoDictionary.get(t, e);
    return i || (i = new ug(), this.edgeInfoDictionary.set(t, e, i), i);
  }
  InitializeEdgeNodeInfo(t) {
    this.edgeInfoDictionary = new ec(), this.InitAllMetroNodeInfos(t), this.SortAllNeighbors(), this.InitEdgeIjInfos(), this.ink = 0;
    for (const e of this.VirtualEdges())
      this.ink += e[0].Position.sub(e[1].Position).length;
  }
  InitAllMetroNodeInfos(t) {
    for (let e = 0; e < this.metrolines.length; e++) {
      const i = this.metrolines[e];
      this.InitMetroNodeInfos(i), this.InitNodeEnterableLoosePolylines(i, this.regularEdges[e]), t && this.InitNodeEnterableTightPolylines(i, this.regularEdges[e]), i.UpdateLengths();
    }
  }
  InitMetroNodeInfos(t) {
    for (let e = t.Polyline.startPoint; e != null; e = e.next) {
      const i = this.PointToStations.get(e.point);
      i.MetroNodeInfos.push(new hg(t, i, e));
    }
  }
  InitNodeEnterableLoosePolylines(t, e) {
    const i = this.EdgeLooseEnterable != null ? this.EdgeLooseEnterable.get(e) : /* @__PURE__ */ new Set();
    for (let s = t.Polyline.startPoint.next; s != null && s.next != null; s = s.next) {
      const n = this.PointToStations.get(s.point);
      n.getELP() != null ? n.setELP(Hi(n.getELP(), i)) : n.setELP(new Set(i));
    }
    this.AddLooseEnterableForMetrolineStartEndPoints(t);
  }
  AddLooseEnterableForMetrolineStartEndPoints(t) {
    this.AddLooseEnterableForEnd(t.Polyline.start), this.AddLooseEnterableForEnd(t.Polyline.end);
  }
  AddTightEnterableForMetrolineStartEndPoints(t) {
    this.AddTightEnterableForEnd(t.Polyline.start), this.AddTightEnterableForEnd(t.Polyline.end);
  }
  AddLooseEnterableForEnd(t) {
    const e = this.PointToStations.get(t);
    if (this.cachedEnterableLooseForEnd.has(t))
      e.setELP(this.cachedEnterableLooseForEnd.get(t));
    else {
      for (const i of this.LooseTree.AllHitItems_(t))
        g.PointRelativeToCurveLocation(t, i) === F.Inside && e.AddEnterableLoosePolyline(i);
      this.cachedEnterableLooseForEnd.set(t, e.getELP());
    }
  }
  AddTightEnterableForEnd(t) {
    const e = this.PointToStations.get(t);
    for (const i of this.TightTree.AllHitItems_(t))
      g.PointRelativeToCurveLocation(t, i) === F.Inside && e.AddEnterableTightPolyline(i);
  }
  InitNodeEnterableTightPolylines(t, e) {
    const i = this.EdgeTightEnterable != null ? this.EdgeTightEnterable.get(e) : /* @__PURE__ */ new Set();
    for (let s = t.Polyline.startPoint.next; s != null && s.next != null; s = s.next) {
      const n = this.PointToStations.get(s.point), r = n.EnterableTightPolylines;
      r != null ? n.EnterableTightPolylines = Hi(r, i) : n.EnterableTightPolylines = new Set(i);
    }
    this.AddTightEnterableForMetrolineStartEndPoints(t);
  }
  SortAllNeighbors() {
    for (const t of this.Stations)
      this.SortNeighbors(t);
  }
  SortNeighbors(t) {
    if (t.Neighbors.length <= 2)
      return;
    const e = t.Neighbors[0].Position, i = t.Position;
    t.Neighbors.sort((s, n) => cs(e.sub(i), s.Position.sub(i), n.Position.sub(i)));
  }
  InitEdgeIjInfos() {
    for (const t of this.metrolines) {
      const e = t.Polyline;
      let i = this.PointToStations.get(e.start), s;
      for (let n = t.Polyline.startPoint; n.next != null; n = n.next, i = s) {
        s = this.PointToStations.get(n.next.point);
        const r = this.GetUnorderedIjInfo(i, s);
        r.Width += t.Width, r.Metrolines.push(t);
      }
    }
  }
  InitializeCdtInfo() {
    const t = this.cdt.getRectangleNodeOnTriangles();
    for (const e of this.Stations)
      e.cdtTriangle = t.FirstHitNodeWithPredicate(e.Position, so.testPointInside).UserData;
  }
  PointIsAcceptableForEdge(t, e) {
    if (this.LoosePolylineOfPort == null)
      return !0;
    const i = t.sourceAndTargetLoosePolylines();
    return g.PointRelativeToCurveLocation(e, i[0]) === F.Outside && g.PointRelativeToCurveLocation(e, i[1]) === F.Outside;
  }
}
function cs(a, t, e) {
  const i = u.crossProduct(a, e), s = a.dot(e), n = u.crossProduct(a, t), r = a.dot(t);
  return D(n, 0) && dr(r, 0) ? D(i, 0) && dr(s, 0) ? 0 : 1 : D(i, 0) && dr(s, 0) ? -1 : D(n, 0) || D(i, 0) || n * i > 0 ? Er(u.crossProduct(e, t), 0) : -Er(Math.sign(n), 0);
}
function dr(a, t) {
  return Er(a, t) >= 0;
}
class ft {
  constructor(t, e) {
    this.metroGraphData = t, this.bundlingSettings = e;
  }
  // Error of ink
  static InkError(t, e, i) {
    return (t - e) * i.InkImportance;
  }
  // Error of path lengths
  static PathLengthsError(t, e, i, s) {
    return (t - e) * (s.PathLengthImportance / i);
  }
  // Error of hubs
  static RError(t, e, i) {
    return t <= e ? 0 : i.HubRepulsionImportance * ((1 - e / t) * (t - e));
  }
  // Error of bundles
  static BundleError(t, e, i) {
    return t <= e ? 0 : i.BundleRepulsionImportance * ((1 - e / t) * (t - e));
  }
  // Cost of the whole graph
  static Cost(t, e) {
    let i = e.InkImportance * t.Ink;
    for (const s of t.Metrolines)
      i += e.PathLengthImportance * s.Length / s.IdealLength;
    return i += this.CostOfForces(t), i;
  }
  // Cost of the whole graph (hubs and bundles)
  static CostOfForces(t) {
    let e = 0;
    for (const i of t.VirtualStations())
      e = e + i.cachedRadiusCost;
    for (const i of t.VirtualEdges()) {
      const s = i[0], n = i[1];
      e += t.GetIjInfo(s, n).cachedBundleCost;
    }
    return e;
  }
  // Gain of ink
  InkGain(t, e) {
    const i = this.metroGraphData.Ink;
    let s = this.metroGraphData.Ink;
    for (const n of t.Neighbors) {
      const r = n.Position;
      s -= r.sub(t.Position).length, s += r.sub(e).length;
    }
    return ft.InkError(i, s, this.bundlingSettings);
  }
  // Gain of path lengths
  PathLengthsGain(t, e) {
    let i = 0;
    for (const s of this.metroGraphData.MetroNodeInfosOfNode(t)) {
      const n = s.Metroline.Length, r = s.PolyPoint.prev.point, o = s.PolyPoint.next.point, l = s.Metroline.Length + o.sub(e).length + r.sub(e).length - o.sub(t.Position).length - r.sub(t.Position).length;
      i += ft.PathLengthsError(n, l, s.Metroline.IdealLength, this.bundlingSettings);
    }
    return i;
  }
  // Gain of radii
  RadiusGain(t, e) {
    let i = 0;
    return i = i + t.cachedRadiusCost, i = i - this.RadiusCost(t, e), i;
  }
  RadiusCost(t, e) {
    let i;
    u.closeDistEps(t.Position, e) ? i = t.cachedIdealRadius : i = Qt.CalculateIdealHubRadiusWithNeighborsMBNP(this.metroGraphData, this.bundlingSettings, t, e);
    const s = { touchedObstacles: [] };
    if (!this.metroGraphData.looseIntersections.HubAvoidsObstaclesSPNBA(t, e, i, s))
      return ft.Inf;
    let n = 0;
    for (const r of s.touchedObstacles) {
      const o = r[1].sub(e).length;
      n += ft.RError(i, o, this.bundlingSettings);
    }
    return n;
  }
  // Gain of bundles
  // if a newPosition is not valid (e.g. intersect obstacles) the result is -inf
  BundleGain(t, e) {
    let i = t.cachedBundleCost;
    for (const s of t.Neighbors) {
      const n = this.BundleCost(t, s, e);
      if (dr(n, ft.Inf))
        return -ft.Inf;
      i -= n;
    }
    return i;
  }
  BundleCost(t, e, i) {
    const s = this.metroGraphData.GetWidthSSN(t, e, this.bundlingSettings.EdgeSeparation), n = { closestDist: [] };
    if (!this.metroGraphData.cdtIntersections.BundleAvoidsObstacles(t, e, i, e.Position, s, n))
      return ft.Inf;
    let r = 0;
    for (const o of n.closestDist) {
      const l = o[0].sub(o[1]).length;
      r += ft.BundleError(s / 2, l, this.bundlingSettings);
    }
    return r;
  }
}
ft.Inf = 1e9;
class fg {
  get Polylines() {
    return Array.from(this.polylineToEdgeGeom.keys());
  }
  constructor(t) {
    this.polylineToEdgeGeom = /* @__PURE__ */ new Map(), this.pathsThroughPoints = new ii(), this.interestingPoints = new xt(), this.metroGraphData = t;
  }
  Run() {
    this.Init(), this.SwitchFlips();
  }
  Init() {
    for (const t of this.metroGraphData.Edges)
      this.polylineToEdgeGeom.set(t.curve, t);
    for (const t of this.Polylines)
      this.RegisterPolylinePointInPathsThrough(t.polylinePoints());
  }
  RegisterPolylinePointInPathsThrough(t) {
    for (const e of t)
      this.RegisterPolylinePointInPathsThroughP(e);
  }
  RegisterPolylinePointInPathsThroughP(t) {
    gg(this.pathsThroughPoints, t.point, t);
  }
  UnregisterPolylinePointsInPathsThrough(t) {
    for (const e of t)
      this.UnregisterPolylinePointInPathsThrough(e);
  }
  UnregisterPolylinePointInPathsThrough(t) {
    pg(this.pathsThroughPoints, t.point, t);
  }
  SwitchFlips() {
    const t = new Set(this.Polylines), e = new We.Queue();
    for (const i of this.Polylines)
      e.enqueue(i);
    for (; e.length > 0; ) {
      const i = e.dequeue();
      t.delete(i);
      const s = this.ProcessPolyline(i);
      s != null && (t.has(i) || (t.add(i), e.enqueue(i)), t.has(s) || (t.add(s), e.enqueue(s)));
    }
  }
  ProcessPolyline(t) {
    const e = /* @__PURE__ */ new Map();
    for (let i = t.startPoint.next; i != null; i = i.next) {
      this.FillDepartedPolylinePoints(i, e);
      for (const s of this.pathsThroughPoints.get(i.point)) {
        const n = e.get(s.polyline);
        if (n) {
          if (this.ProcessFlip(i, n))
            return s.polyline;
          e.delete(s.polyline);
        }
      }
    }
    return null;
  }
  FillDepartedPolylinePoints(t, e) {
    const i = t.prev.point;
    for (const s of this.pathsThroughPoints.get(i))
      this.IsNeighborOnTheSamePolyline(s, t) || e.has(s.polyline) || e.set(s.polyline, s);
  }
  ProcessFlip(t, e) {
    const i = t.polyline, s = e.polyline, n = t.point, r = e.point, o = this.polylineToEdgeGeom.get(i), l = this.polylineToEdgeGeom.get(s);
    if (o.lineWidth !== l.lineWidth || this.metroGraphData.EdgeLooseEnterable == null || !Tr(this.metroGraphData.EdgeLooseEnterable.get(o), this.metroGraphData.EdgeLooseEnterable.get(l)))
      return !1;
    let h = this.FindPointsOnPolyline(i, n, r);
    const c = h[0], d = h[1], f = h[2];
    h = this.FindPointsOnPolyline(s, n, r);
    const p = h[0], P = h[1], y = h[2], C = this.FindRelationOnFirstPoint(c, p, f, y), w = this.FindRelationOnLastPoint(d, P, f, y);
    return C !== 2 && w !== 2 || C === 1 || w === 1 ? !1 : (this.UnregisterPolylinePointsInPathsThrough(i.polylinePoints()), this.UnregisterPolylinePointsInPathsThrough(s.polylinePoints()), this.Swap(c, p, d, P, f, y), this.RegisterPolylinePointInPathsThrough(i.polylinePoints()), this.RegisterPolylinePointInPathsThrough(s.polylinePoints()), this.RegisterInterestingPoint(c.point), this.RegisterInterestingPoint(d.point), this.numberOfReducedCrossings++, !0);
  }
  FindPointsOnPolyline(t, e, i) {
    let s, n;
    for (let r = t.startPoint; r != null; r = r.next)
      if (s == null)
        if (r.point.equal(e)) {
          if (n != null)
            return [r, n, !1];
          s = r;
        } else
          n == null && r.point.equal(i) && (n = r);
      else if (r.point.equal(i))
        return [s, r, !0];
  }
  PolylinePointsAreInForwardOrder(t, e) {
    for (let i = t; i != null; i = i.next)
      if (i === e)
        return !0;
    return !1;
  }
  Next(t, e) {
    return e ? t.next : t.prev;
  }
  Prev(t, e) {
    return e ? t.prev : t.next;
  }
  FindRelationOnFirstPoint(t, e, i, s) {
    const n = t, r = e;
    for (; ; ) {
      const o = this.Prev(t, i), l = this.Prev(e, s);
      if (o == null || l == null)
        return 0;
      if (!o.point.equal(l.point))
        break;
      t = o, e = l;
    }
    return this.PolylinesIntersect(n, r, t, e, i, s);
  }
  FindRelationOnLastPoint(t, e, i, s) {
    const n = t, r = e;
    for (; ; ) {
      const o = this.Next(t, i), l = this.Next(e, s);
      if (o == null || l == null)
        return 0;
      if (!o.point.equal(l.point))
        break;
      t = o, e = l;
    }
    for (; this.Next(t, i).point.equal(this.Prev(e, s).point); )
      t = this.Next(t, i), e = this.Prev(e, s);
    return this.PolylinesIntersect(t, e, n, r, i, s);
  }
  PolylinesIntersect(t, e, i, s, n, r) {
    const o = this.Prev(t, n), l = this.Next(t, n), h = this.Next(i, n), c = this.Prev(i, n), d = this.Next(e, r), f = this.Prev(s, r);
    if (t.point.equal(i.point)) {
      const p = t.point, P = cs(c.point.sub(p), f.point.sub(p), l.point.sub(p)), y = cs(c.point.sub(p), d.point.sub(p), l.point.sub(p));
      return P === y ? 1 : 2;
    } else {
      const p = cs(o.point.sub(t.point), l.point.sub(t.point), d.point.sub(t.point)), P = cs(h.point.sub(i.point), f.point.sub(i.point), c.point.sub(i.point));
      return p === P ? 1 : 2;
    }
  }
  Swap(t, e, i, s, n, r) {
    const o = this.GetRangeOnPolyline(this.Next(t, n), i, n), l = this.GetRangeOnPolyline(this.Next(e, r), s, r);
    this.ChangePolylineSegment(t, i, n, l), this.ChangePolylineSegment(e, s, r, o), kn.RemoveSelfCyclesFromPolyline(t.polyline), kn.RemoveSelfCyclesFromPolyline(e.polyline);
  }
  ChangePolylineSegment(t, e, i, s) {
    let n = t;
    for (const r of s) {
      const o = ei.mkFromPoint(r.point);
      o.polyline = n.polyline, i ? (o.prev = n, n.next = o) : (o.next = n, n.prev = o), n = o;
    }
    i ? (n.next = e, e.prev = n) : (n.prev = e, e.next = n);
  }
  GetRangeOnPolyline(t, e, i) {
    const s = new Array();
    for (let n = t; n !== e; n = this.Next(n, i))
      s.push(n);
    return s;
  }
  IsNeighborOnTheSamePolyline(t, e) {
    return t.prev != null && t.prev.point.equal(e.point) || t.next != null && t.next.point.equal(e.point);
  }
  RegisterInterestingPoint(t) {
    this.interestingPoints.has(t) || this.interestingPoints.add(t);
  }
  GetChangedHubs() {
    return this.interestingPoints;
  }
  NumberOfReducedCrossings() {
    return this.numberOfReducedCrossings;
  }
  PolylineIsOK(t) {
    const e = new xt();
    for (let i = t.startPoint; i != null; i = i.next) {
      if (i === t.startPoint) {
        if (i.prev != null)
          return !1;
      } else if (i.prev.next !== i)
        return !1;
      if (i === t.endPoint) {
        if (i.next != null)
          return !1;
      } else if (i.next.prev !== i)
        return !1;
      if (e.has(i.point))
        return !1;
      e.add(i.point);
    }
    return !(t.startPoint.prev != null || t.endPoint.next != null);
  }
}
function gg(a, t, e) {
  let i = a.get(t);
  i || (i = /* @__PURE__ */ new Set(), a.set(t, i)), i.add(e);
}
function pg(a, t, e) {
  const i = a.get(t);
  i && (i.delete(e), i.size === 0 && a.deleteP(t));
}
class kn {
  constructor(t, e) {
    this.foundCrossings = new xt(), this.crossingsThatShouldBecomeHubs = new xt(), this.metroGraphData = t, this.polylineAcceptsPoint = e;
  }
  *Vertices() {
    for (const t of this.Polylines)
      for (const e of t.polylinePoints())
        yield e;
  }
  get Polylines() {
    return this.metroGraphData.Edges.map((t) => t.curve);
  }
  Edges() {
    const t = new Rn();
    for (const e of this.Vertices())
      e.next && t.set(new ie(e.point, e.next.point), 0);
    return Array.from(t.keys());
  }
  run() {
    if (this.metroGraphData.Edges.length === 0)
      return !1;
    const t = new Rn(), e = new Lr(null);
    for (const o of this.Vertices()) {
      const l = T.mkOnPoints([o.point]);
      l.pad(m.intersectionEpsilon), e.Add(l, o.point);
    }
    const i = Ar(this.Edges(), (o) => T.mkPP(o.first, o.second));
    Xt(i, i, (o, l) => this.IntersectTwoEdges.bind(o, l, t, e)), this.SortInsertedPoints(t);
    const s = this.InsertPointsIntoPolylines(t), n = this.FixPaths(), r = this.RemoveUnimportantCrossings();
    return n || s || r;
  }
  FixPaths() {
    let t = !1;
    return this.RemoveSelfCycles() && (t = !0), this.ReduceEdgeCrossings() && (t = !0), t;
  }
  SortInsertedPoints(t) {
    for (const e of t)
      this.SortInsideSegment(e[0], e[1]);
  }
  SortInsideSegment(t, e) {
    e.sort((i, s) => yt(Z(i, t.first), Z(s, t.first)));
  }
  InsertPointsIntoPolylines(t) {
    let e = !1;
    for (const i of this.metroGraphData.Metrolines)
      return this.InsertPointsIntoPolyline(i, t) && (e = !0), e;
  }
  InsertPointsIntoPolyline(t, e) {
    let i = !1;
    for (let s = t.Polyline.startPoint; s.next != null; s = s.next)
      this.InsertPointsOnPolypoint(s, e, t) && (i = !0);
    return i;
  }
  InsertPointsOnPolypoint(t, e, i) {
    const s = new ie(t.point, t.next.point), n = t.point !== s.first, r = e.get(s);
    if (!r)
      return !1;
    const o = t.next, l = t.polyline;
    if (n)
      for (let h = r.length - 1; h >= 0; h--) {
        if (this.polylineAcceptsPoint != null && !this.polylineAcceptsPoint(i, r[h]))
          continue;
        const c = ei.mkFromPoint(r[h]);
        c.prev = t, c.polyline = l, t.next = c, t = c;
      }
    else
      for (let h = 0; h < r.length; h++) {
        if (this.polylineAcceptsPoint != null && !this.polylineAcceptsPoint(i, r[h]))
          continue;
        const c = ei.mkFromPoint(r[h]);
        c.prev = t, c.polyline = l, t.next = c, t = c;
      }
    return t.next = o, o.prev = t, !0;
  }
  RemoveSelfCycles() {
    let t = !1;
    for (const e of this.Polylines)
      kn.RemoveSelfCyclesFromPolyline(e) && (t = !0);
    return t;
  }
  // returns removed points
  static RemoveSelfCyclesFromPolyline(t) {
    let e = !1;
    const i = new ii();
    for (let s = t.startPoint; s != null; s = s.next) {
      const n = s.point, r = i.get(n);
      if (r) {
        for (let o = r.next; o !== s.next; o = o.next)
          i.deleteP(o.point);
        r.next = s.next, s.next.prev = r, e = !0;
      } else
        i.set(s.point, s);
    }
    return e;
  }
  // bool CollapseCycles() {
  //    var cycleCollapser = new FlipCollapser(metroGraphData, bundlingSettings, cdt);
  //    cycleCollapser.Run();
  //    crossingsThatShouldBecomeHubs.InsertRange(cycleCollapser.GetChangedCrossing());
  //    //TimeMeasurer.DebugOutput("#crossingsThatShouldBecomeHubs = " + crossingsThatShouldBecomeHubs.Count);
  //    return false;
  // }
  ReduceEdgeCrossings() {
    const t = new fg(this.metroGraphData);
    t.Run();
    for (const e of t.GetChangedHubs())
      this.crossingsThatShouldBecomeHubs.add(e);
    return t.NumberOfReducedCrossings() > 0;
  }
  RemoveUnimportantCrossings() {
    let t = !1;
    this.pointsToDelete = Id(this.foundCrossings, this.crossingsThatShouldBecomeHubs);
    for (const e of this.Polylines)
      this.RemoveUnimportantCrossingsFromPolyline(e) && (t = !0);
    return t;
  }
  RemoveUnimportantCrossingsFromPolyline(t) {
    let e = !1;
    for (let i = t.startPoint.next; i != null && i.next != null; i = i.next)
      if (this.pointsToDelete.has(i.point) && u.getTriangleOrientation(i.prev.point, i.point, i.next.point) === L.Collinear) {
        const s = i.prev, n = i.next;
        s.next = n, n.prev = s, i = s, e = !0;
      }
    return e;
  }
  IntersectTwoEdges(t, e, i, s) {
    const n = v.IntersectPPPP(t.first, t.second, e.first, e.second);
    if (n) {
      const r = this.FindExistingVertexOrCreateNew(s, n);
      (this.AddVertexToSplittingList(t, i, r) || this.AddVertexToSplittingList(e, i, r)) && this.foundCrossings.add(r);
    }
  }
  FindExistingVertexOrCreateNew(t, e) {
    const i = t.RootNode.FirstHitNode(e);
    if (i != null)
      return i.UserData;
    const s = T.mkOnPoints([e]);
    return s.pad(m.intersectionEpsilon), t.Add(s, e), e;
  }
  AddVertexToSplittingList(t, e, i) {
    if (!g.closeIntersectionPoints(i, t.first) && !g.closeIntersectionPoints(i, t.second)) {
      let s = e.get(t);
      if (s || (s = new Array(), e.set(t, s)), !s.find((n) => n.equal(i)))
        return s.push(i), !0;
    }
    return !1;
  }
}
class Ol {
  isCorrectlyOrienected() {
    return u.getTriangleOrientation(this.Curve.boundingBox.center, this.Curve.value(this.parEnd), this.Curve.value(this.parStart)) !== L.Counterclockwise;
  }
  get Count() {
    return this.points.length;
  }
  constructor(t, e, i, s) {
    this.BelongsToRealNode = s, this.Curve = e, this.Position = i, this.points = new Array(t), this.tangents = new Array(t), this.OrientedHubSegments = new Array(t);
  }
  get CurveCenter() {
    return this.Curve.boundingBox.center;
  }
  get OppositeBase() {
    return this.OutgoingBundleInfo != null ? this.OutgoingBundleInfo.TargetBase : this.IncomingBundleInfo.SourceBase;
  }
  get length() {
    return this.points.length;
  }
  get Points() {
    return this.points;
  }
  get Tangents() {
    return this.tangents;
  }
  get InitialMidParameter() {
    return this.initialMidParameter;
  }
  set InitialMidParameter(t) {
    this.initialMidParameter = t, this.InitialMidPoint = this.Curve.value(t);
  }
  /**
   * corresponds to the left point of the base: if looking from the center of
   * this.Curve.boundingBox.center
   */
  get ParStart() {
    return this.parStart;
  }
  set ParStart(t) {
    this.parStart = t, this.StartPoint = this.Curve.value(this.parStart);
  }
  /**
   * corresponds to the right point of the base: if looking from the center of
   * this.Curve.boundingBox.center */
  get ParEnd() {
    return this.parEnd;
  }
  set ParEnd(t) {
    this.parEnd = t, this.EndPoint = this.Curve.value(this.parEnd);
  }
  get ParMid() {
    return (this.parStart + this.parEnd) / 2;
  }
  get MidPoint() {
    return u.middle(this.StartPoint, this.EndPoint);
  }
  get Span() {
    return this.SpanBetweenTwoParameters(this.parStart, this.parEnd);
  }
  SpanBetweenTwoParameters(t, e) {
    return t <= e ? e - t : e - t + Vi(this.Curve);
  }
  RotateLeftPoint(t, e) {
    return t === 0 ? this.EndPoint : this.RotatePoint(t, this.parEnd, e);
  }
  RotateRigthPoint(t, e) {
    return t === 0 ? this.StartPoint : this.RotatePoint(t, this.parStart, e);
  }
  RotatePoint(t, e, i) {
    const s = Vi(this.Curve) * i;
    return e += t * s, e = this.AdjustParam(e), this.Curve.value(e);
  }
  AdjustParam(t) {
    return t > this.Curve.parEnd ? t = this.Curve.parStart + (t - this.Curve.parEnd) : t < this.Curve.parStart && (t = this.Curve.parEnd - (this.Curve.parStart - t)), t;
  }
  RotateBy(t, e, i) {
    const s = Vi(this.Curve) * i;
    t !== 0 && (this.ParStart = this.AdjustParam(this.ParStart + t * s)), e !== 0 && (this.ParEnd = this.AdjustParam(this.ParEnd + e * s));
  }
  RelativeOrderOfBasesIsPreserved(t, e, i) {
    const s = Vi(this.Curve) * i, n = this.parStart + t * s, r = this.parStart < this.parEnd ? this.parEnd + e * s : this.parEnd + Vi(this.Curve) + e * s;
    if (n > r || this.SpanBetweenTwoParameters(n, r) > Vi(this.Curve) / 2)
      return !1;
    if (this.Prev == null || this.SpanBetweenTwoParameters(this.Prev.ParMid, this.ParMid) > s && this.SpanBetweenTwoParameters(this.ParMid, this.Next.ParMid) > s)
      return !0;
    const o = this.RotateLeftPoint(e, i), l = this.RotateRigthPoint(t, i), h = u.middle(o, l), c = this.MidPoint;
    return !(u.getTriangleOrientation(this.CurveCenter, this.Prev.MidPoint, c) != u.getTriangleOrientation(this.CurveCenter, this.Prev.MidPoint, h) || u.getTriangleOrientation(this.CurveCenter, this.Next.MidPoint, c) != u.getTriangleOrientation(this.CurveCenter, this.Next.MidPoint, h));
  }
}
class ki {
  constructor(t, e, i, s) {
    this.SourceBase = t, this.TargetBase = e, this.obstaclesToIgnore = i, this.HalfWidthArray = s, this.TotalRequiredWidth = this.HalfWidthArray.reduce((r, o) => r + o, 0) * 2, this.longEnoughSideLength = t.Curve.boundingBox.addRec(e.Curve.boundingBox).diagonal;
    const n = Math.max(t.Curve.boundingBox.diagonal, e.Curve.boundingBox.diagonal);
    if (this.TotalRequiredWidth > n) {
      const r = this.TotalRequiredWidth / n;
      for (let o = 0; o < this.HalfWidthArray.length; o++)
        this.HalfWidthArray[o] /= r;
      this.TotalRequiredWidth /= r;
    }
  }
  SetParamsFeasiblySymmetrically(t) {
    this.CalculateTightObstaclesForBundle(t, this.obstaclesToIgnore), this.SetEndParamsSymmetrically();
  }
  CalculateTightObstaclesForBundle(t, e) {
    const i = this.SourceBase.Curve.boundingBox.diagonal / 2, s = this.TargetBase.Curve.boundingBox.diagonal / 2, n = Ue.Create4gon(this.SourceBase.Position, this.TargetBase.Position, i * 2, s * 2);
    this.tightObstaclesInTheBoundingBox = Array.from(t.AllHitItems(n.boundingBox, (r) => !e.has(r) && g.ClosedCurveInteriorsIntersect(n, r)));
  }
  SetEndParamsSymmetrically() {
    const t = this.TargetBase.Position, e = this.SourceBase.Position, i = t.sub(e).normalize(), s = i.rotate90Ccw(), n = u.middle(t, e), r = i.mul(this.longEnoughSideLength), o = n.add(r), l = n.sub(r);
    if (this.SetRLParamsIfWidthIsFeasible(s.mul(this.TotalRequiredWidth / 2), o, l)) {
      this.SetInitialMidParams();
      return;
    }
    let h = this.TotalRequiredWidth, c = 0, d = h / 2;
    for (; h - c > ki.FeasibleWidthEpsilon; )
      this.SetRLParamsIfWidthIsFeasible(s.mul(d / 2), o, l) ? c = d : h = d, d = 0.5 * (h + c);
    d <= ki.FeasibleWidthEpsilon && (this.SetRLParamsIfWidthIsFeasible_(s.mul(ki.FeasibleWidthEpsilon), new u(0, 0), o, l) || this.SetRLParamsIfWidthIsFeasible_(new u(0, 0), s.mul(-ki.FeasibleWidthEpsilon), o, l)) && (d = 2 * ki.FeasibleWidthEpsilon), this.SourceBase.InitialMidParameter = this.SourceBase.AdjustParam(this.SourceBase.ParStart + this.SourceBase.Span / 2), this.TargetBase.InitialMidParameter = this.TargetBase.AdjustParam(this.TargetBase.ParStart + this.TargetBase.Span / 2);
  }
  mkNameFromLRST() {
    return "./tmp/leftRight" + this.SourceBase.Position.toString() + "_" + this.TargetBase.Position.toString() + ".svg";
  }
  SetRLParamsIfWidthIsFeasible(t, e, i) {
    return this.SetRLParamsIfWidthIsFeasible_(t, t.neg(), e, i);
  }
  SetRLParamsIfWidthIsFeasible_(t, e, i, s) {
    const n = { par: 0 }, r = { par: 0 }, o = { par: 0 }, l = { par: 0 };
    let h = this.TrimSegWithBoundaryCurves(v.mkPP(i.add(t), s.add(t)), r, o);
    return h == null || this.tightObstaclesInTheBoundingBox.find((d) => g.intersectionOne(h, d, !1) != null) || (h = this.TrimSegWithBoundaryCurves(v.mkPP(i.add(e), s.add(e)), l, n), h == null) || this.tightObstaclesInTheBoundingBox.find((d) => g.intersectionOne(h, d, !1) != null) ? !1 : (this.SourceBase.IsParent ? (this.SourceBase.ParStart = r.par, this.SourceBase.ParEnd = l.par) : (this.SourceBase.ParStart = l.par, this.SourceBase.ParEnd = r.par), this.TargetBase.IsParent ? (this.TargetBase.ParStart = n.par, this.TargetBase.ParEnd = o.par) : (this.TargetBase.ParStart = o.par, this.TargetBase.ParEnd = n.par), !0);
  }
  SetInitialMidParams() {
    const t = { par: 0 }, e = { par: 0 };
    this.TrimSegWithBoundaryCurves(v.mkPP(this.TargetBase.CurveCenter, this.TargetBase.CurveCenter), e, t) != null ? (this.SourceBase.InitialMidParameter = e.par, this.TargetBase.InitialMidParameter = t.par) : (this.SourceBase.InitialMidParameter = this.SourceBase.AdjustParam(this.SourceBase.ParStart + this.SourceBase.Span / 2), this.TargetBase.InitialMidParameter = this.TargetBase.AdjustParam(this.TargetBase.ParStart + this.TargetBase.Span / 2));
  }
  mkNameFromST() {
    return "./tmp/mparam" + this.SourceBase.Position.toString() + "_" + this.TargetBase.Position.toString() + ".svg";
  }
  TrimSegWithBoundaryCurves(t, e, i) {
    let s = g.getAllIntersections(t, this.SourceBase.Curve, !0);
    if (s.length === 0)
      return i.par = 0, e.par = 0, null;
    let n;
    if (s.length === 1 ? n = s[0] : this.SourceBase.IsParent ? n = s[0].par0 < s[1].par0 ? s[1] : s[0] : n = s[0].par0 < s[1].par0 ? s[0] : s[1], s = g.getAllIntersections(t, this.TargetBase.Curve, !0), s.length === 0)
      return i.par = 0, e.par = 0, null;
    let r;
    return s.length === 1 ? r = s[0] : this.TargetBase.IsParent ? r = s[0].par0 > s[1].par0 ? s[1] : s[0] : r = s[0].par0 > s[1].par0 ? s[0] : s[1], e.par = n.par1, i.par = r.par1, v.mkPP(n.x, r.x);
  }
  RotateBy(t, e, i, s, n) {
    const r = t !== 0 || e !== 0, o = i !== 0 || s !== 0;
    r && this.SourceBase.RotateBy(t, e, n), o && this.TargetBase.RotateBy(i, s, n), this.UpdateSourceAndTargetBases(r, o);
  }
  UpdateSourceAndTargetBases(t, e) {
    t && this.UpdatePointsOnBundleBase(this.SourceBase), e && this.UpdatePointsOnBundleBase(this.TargetBase), this.UpdateTangentsOnBases();
  }
  UpdateTangentsOnBases() {
    const t = this.TargetBase.length;
    for (let e = 0; e < t; e++) {
      let i = this.TargetBase.Points[e].sub(this.SourceBase.Points[t - 1 - e]);
      const s = i.length;
      s >= m.tolerance && (i = i.div(s), this.TargetBase.Tangents[e] = i, this.SourceBase.Tangents[t - 1 - e] = i.neg());
    }
  }
  UpdatePointsOnBundleBase(t) {
    const e = t.length, i = t.Points, s = v.mkPP(t.EndPoint, t.StartPoint), n = 1 / this.TotalRequiredWidth;
    let r = this.HalfWidthArray[0];
    i[0] = s.value(r * n);
    for (let o = 1; o < e; o++)
      r += this.HalfWidthArray[o - 1] + this.HalfWidthArray[o], i[o] = s.value(r * n);
  }
  RotationIsLegal(t, e, i, s, n) {
    if (!this.SourceBase.IsParent && !this.TargetBase.IsParent) {
      if (e !== 0 || i !== 0) {
        const r = this.SourceBase.RotateLeftPoint(e, n), o = this.TargetBase.RotateRigthPoint(i, n);
        if (!this.LineIsLegal(r, o))
          return !1;
      }
      if (t !== 0 || s !== 0) {
        const r = this.SourceBase.RotateRigthPoint(t, n), o = this.TargetBase.RotateLeftPoint(s, n);
        if (!this.LineIsLegal(r, o))
          return !1;
      }
    } else {
      if (e !== 0 || s !== 0) {
        const r = this.SourceBase.RotateLeftPoint(e, n), o = this.TargetBase.RotateLeftPoint(s, n);
        if (!this.LineIsLegal(r, o))
          return !1;
      }
      if (t !== 0 || i !== 0) {
        const r = this.SourceBase.RotateRigthPoint(t, n), o = this.TargetBase.RotateRigthPoint(i, n);
        if (!this.LineIsLegal(r, o))
          return !1;
      }
    }
    return !((t !== 0 || e !== 0) && !this.SourceBase.RelativeOrderOfBasesIsPreserved(t, e, n) || (i !== 0 || s !== 0) && !this.TargetBase.RelativeOrderOfBasesIsPreserved(i, s, n));
  }
  LineIsLegal(t, e) {
    return this.tightObstaclesInTheBoundingBox.find((i) => g.intersectionOne(v.mkPP(t, e), i, !1) != null) == null;
  }
}
ki.FeasibleWidthEpsilon = 0.1;
class xl {
  get Segment() {
    return this.segment;
  }
  set Segment(t) {
    this.segment = t;
  }
  constructor(t, e, i, s) {
    this.Segment = t, this.Reversed = e, this.Index = i, this.BundleBase = s;
  }
  value(t) {
    return this.Reversed ? this.Segment.value(this.Segment.parEnd - t) : this.Segment.value(t);
  }
}
class H {
  constructor(t, e, i) {
    this.fixedBundles = /* @__PURE__ */ new Set(), this.stepsWithProgress = 0, this.metroOrdering = t, this.metroGraphData = e, this.bundlingSettings = i;
  }
  Run() {
    this.AllocateBundleBases(), this.SetBasesRightLeftParamsToTheMiddles(), this.bundlingSettings.KeepOverlaps ? (this.UpdateSourceAndTargetBases(), this.CreateOrientedSegs()) : (this.SetRightLeftParamsFeasiblySymmetrically(), this.AdjustStartEndParamsToAvoidBaseOverlaps(), this.UpdateSourceAndTargetBases(), this.CreateOrientedSegs(), this.bundlingSettings.RotateBundles && this.RotateBundlesToDiminishCost(), this.AdjustStartEndParamsToAvoidBaseOverlaps(), this.UpdateSourceAndTargetBases());
  }
  AllocateBundleBases() {
    this.externalBases = /* @__PURE__ */ new Map(), this.internalBases = /* @__PURE__ */ new Map(), this.Bundles = new Array();
    for (const t of this.metroGraphData.Stations)
      t.BoundaryCurve == null && (t.BoundaryCurve = j.mkCircle(t.Radius, t.Position));
    for (const t of this.metroGraphData.Stations)
      for (const e of t.Neighbors)
        if (t.SerialNumber < e.SerialNumber) {
          const i = new Ol(this.metroGraphData.RealEdgeCount(t, e), t.BoundaryCurve, t.Position, t.IsReal);
          t.BundleBases.set(e, i);
          const s = new Ol(this.metroGraphData.RealEdgeCount(t, e), e.BoundaryCurve, e.Position, e.IsReal);
          e.BundleBases.set(t, s), g.PointRelativeToCurveLocation(e.Position, t.BoundaryCurve) !== F.Outside ? (i.IsParent = !0, Ts(this.internalBases, t, i), Ts(this.externalBases, e, s)) : g.PointRelativeToCurveLocation(t.Position, e.BoundaryCurve) !== F.Outside ? (s.IsParent = !0, Ts(this.externalBases, t, i), Ts(this.internalBases, e, s)) : (Ts(this.externalBases, t, i), Ts(this.externalBases, e, s));
          const n = this.metroGraphData.tightIntersections.ObstaclesToIgnoreForBundle(t, e), r = new ki(i, s, n, Array.from(this.metroOrdering.GetOrder(t, e)).map((o) => o.Width / 2));
          i.OutgoingBundleInfo = s.IncomingBundleInfo = r, this.Bundles.push(r);
        }
    this.SetBundleBaseNeighbors();
  }
  SetBundleBaseNeighbors() {
    for (const t of this.externalBases.keys()) {
      const e = this.externalBases.get(t);
      this.SortBundlesCounterClockwise(e), this.SetLeftRightBases(e);
    }
    for (const t of this.internalBases.keys()) {
      const e = this.internalBases.get(t);
      this.SortBundlesCounterClockwise(e), this.SetLeftRightBases(e);
    }
  }
  SortBundlesCounterClockwise(t) {
    if (t.length > 2) {
      const e = t[0].OppositeBase.Position, i = t[0].CurveCenter;
      t.sort((s, n) => cs(e.sub(i), s.OppositeBase.Position.sub(i), n.OppositeBase.Position.sub(i)));
    }
  }
  SetLeftRightBases(t) {
    const e = t.length;
    if (!(e <= 1))
      for (let i = 0; i < e; i++)
        t[i].Prev = t[(i - 1 + e) % e], t[i].Next = t[(i + 1) % e];
  }
  CreateOrientedSegs() {
    for (const t of this.metroGraphData.Metrolines)
      this.CreateOrientedSegsOnLine(t);
  }
  CreateOrientedSegsOnLine(t) {
    for (let e = t.Polyline.startPoint.next; e.next != null; e = e.next)
      this.CreateOrientedSegsOnLineVertex(t, e);
  }
  CreateOrientedSegsOnLineVertex(t, e) {
    const i = this.metroGraphData.PointToStations.get(e.prev.point), s = this.metroGraphData.PointToStations.get(e.point), n = this.metroGraphData.PointToStations.get(e.next.point), r = s.BundleBases.get(i), o = s.BundleBases.get(n), l = this.metroOrdering.GetLineIndexInOrder(i, s, t), h = this.metroOrdering.GetLineIndexInOrder(n, s, t), c = r.OrientedHubSegments[l] = new xl(null, !1, l, r), d = o.OrientedHubSegments[h] = new xl(null, !0, h, o);
    d.Other = c, c.Other = d;
  }
  UpdateSourceAndTargetBases() {
    for (const t of this.Bundles)
      t.UpdateSourceAndTargetBases(!0, !0);
  }
  SetBasesRightLeftParamsToTheMiddles() {
    for (const t of this.Bundles) {
      const e = t.SourceBase, i = t.TargetBase;
      e.ParEnd = e.ParStart = this.GetBaseMiddleParamInDirection(e, e.Position, i.Position), i.ParEnd = i.ParStart = this.GetBaseMiddleParamInDirection(i, i.Position, e.Position);
    }
  }
  GetBaseMiddleParamInDirection(t, e, i) {
    const s = t.Curve;
    if (s instanceof j) {
      const o = s;
      if (o.isArc())
        return u.angle(o.aAxis, i.sub(e));
    }
    const r = g.getAllIntersections(s, v.mkPP(e, i), !0);
    for (const o of r) {
      const l = o.x;
      if (l.sub(e).dot(l.sub(i)) <= 0)
        return o.par0;
    }
    throw new Error();
  }
  SetRightLeftParamsFeasiblySymmetrically() {
    for (const t of this.Bundles)
      t.SetParamsFeasiblySymmetrically(this.metroGraphData.TightTree);
  }
  AdjustStartEndParamsToAvoidBaseOverlaps() {
    for (const t of this.externalBases.values())
      this.AdjustCurrentBundleWidthsOnCurve(t);
    for (const t of this.internalBases.values())
      this.AdjustCurrentBundleWidthsOnCurve(t);
  }
  AdjustCurrentBundleWidthsOnCurve(t) {
    const e = t.length;
    if (!(e <= 1))
      for (let i = 0; i < e; i++) {
        const s = t[i], n = s.Next;
        this.ShrinkBasesToMakeTwoConsecutiveNeighborsHappy(s, n);
      }
  }
  ShrinkBasesToMakeTwoConsecutiveNeighborsHappy(t, e) {
    const i = mg(t, e);
    if (i == null || D(i.start, i.end))
      return;
    const s = i.rbaseMiddle, n = i.lbaseMiddle;
    if (s < n) {
      const h = t;
      t = e, e = h;
    }
    const r = t.Span, o = e.Span, l = (i.end * r + i.start * o) / (o + r);
    t.ParStart = t.AdjustParam(l + m.distanceEpsilon), e.ParEnd = e.AdjustParam(l - m.distanceEpsilon);
  }
  // find a cut point for 2 segments
  RegularCut(t, e, i, s, n, r) {
    let o = (n * s + r * t) / (n + r);
    const l = Math.min(e, s), h = Math.max(t, i);
    return o < h && (o = h), o > l && (o = l), o;
  }
  RotateBundlesToDiminishCost() {
    let t = H.MaxParameterChange;
    const e = { cost: this.Cost() };
    let i = 0;
    for (; i++ < H.MaxIterations; ) {
      const s = e.cost;
      if (this.RotateBundlesToDiminishCostOneIteration(t, e), t = this.UpdateParameterChange(t, s, e.cost), t < H.MinParameterChange)
        break;
    }
  }
  UpdateParameterChange(t, e, i) {
    return i + 1 < e ? (this.stepsWithProgress++, this.stepsWithProgress >= 5 && (this.stepsWithProgress = 0, this.fixedBundles.clear())) : (this.stepsWithProgress = 0, t *= 0.8, this.fixedBundles.clear()), t;
  }
  RotateBundlesToDiminishCostOneIteration(t, e) {
    let i = !1;
    for (const s of this.Bundles)
      this.fixedBundles.has(s) || (this.OptimizeBundle(s, t, e) ? i = !0 : this.fixedBundles.add(s));
    return i;
  }
  OptimizeBundle(t, e, i) {
    const s = this.CostBi(t);
    if (s < H.CostThreshold)
      return !1;
    let n = 0, r = -1, o = -1;
    for (let l = 0; l < H.Deltas.length - 1; l++) {
      let h = this.DeltaWithChangedAngles(H.Deltas[l][0], H.Deltas[l][1], 0, 0, t, s, e);
      h > H.CostDeltaThreshold && h > n && (o = l, r = H.Deltas.length - 1, n = h), h = this.DeltaWithChangedAngles(0, 0, H.Deltas[l][0], H.Deltas[l][1], t, s, e), h > H.CostDeltaThreshold && h > n && (o = H.Deltas.length - 1, r = l, n = h);
    }
    return n < H.CostDeltaThreshold ? !1 : (i.cost -= n, t.RotateBy(H.Deltas[o][0], H.Deltas[o][1], H.Deltas[r][0], H.Deltas[r][1], e), !0);
  }
  DeltaWithChangedAngles(t, e, i, s, n, r, o) {
    if (!n.RotationIsLegal(t, e, i, s, o))
      return 0;
    n.RotateBy(t, e, i, s, o);
    const l = this.CostBN(n, r);
    return n.RotateBy(t * -1, e * -1, i * -1, s * -1, o), r - l;
  }
  CostBi(t) {
    return H.SeparationCoeff * this.SeparationCost(t) + (H.SqueezeCoeff * this.SqueezeCost(t) + (H.AssymetryCoeff * this.AssymetryCost(t) + H.CenterCoeff * this.CenterCostBi(t)));
  }
  // this is an accelerated version of the above function (calculate cost partly)
  CostBN(t, e) {
    let i = 0;
    return i = i + H.CenterCoeff * this.CenterCostBi(t), i > e || (i = i + H.SeparationCoeff * this.SeparationCost(t), i > e) || (i = i + H.SqueezeCoeff * this.SqueezeCost(t), i > e) || (i = i + H.AssymetryCoeff * this.AssymetryCost(t)), i;
  }
  SqueezeCost(t) {
    const i = t.TargetBase.MidPoint.sub(t.SourceBase.MidPoint).normalize().rotate90Ccw(), s = Math.abs(t.SourceBase.StartPoint.sub(t.SourceBase.EndPoint).dot(i)), n = Math.abs(t.TargetBase.StartPoint.sub(t.TargetBase.EndPoint).dot(i)), r = Math.abs(t.TotalRequiredWidth - s) / t.TotalRequiredWidth, o = Math.abs(t.TotalRequiredWidth - n) / t.TotalRequiredWidth, l = Math.abs(s - n) / t.TotalRequiredWidth;
    return Math.exp(r * 10) - 1 + (Math.exp(o * 10) - 1) + l;
  }
  CenterCostBi(t) {
    return !t.SourceBase.BelongsToRealNode && !t.TargetBase.BelongsToRealNode ? 0 : this.CenterCostBb(t.SourceBase) + this.CenterCostBb(t.TargetBase);
  }
  CenterCostBb(t) {
    if (!t.BelongsToRealNode)
      return 0;
    const e = t.ParMid, i = Math.min(t.InitialMidParameter, e), s = Math.max(t.InitialMidParameter, e), n = Math.min(s - i, i + (Vi(t.Curve) - s));
    return t.CurveCenter.equal(t.Position) || t.IsParent ? 25 * (n * n) : 500 * (n * n);
  }
  AssymetryCost(t) {
    return this.GetAssymetryCostForBase(t.SourceBase) + this.GetAssymetryCostForBase(t.TargetBase);
  }
  GetAssymetryCostForBase(t) {
    if (t.BelongsToRealNode)
      return 0;
    const e = t.OppositeBase.BelongsToRealNode ? 200 : 500;
    let i = 0;
    for (const s of t.OrientedHubSegments) {
      const n = s.Index, r = s.Other.Index, o = t.Points[n], l = t.Tangents[n], h = s.Other.BundleBase, c = h.Points[r], d = h.Tangents[r], f = t.Count + h.Count;
      i += this.GetAssymetryCostOnData(o, l, c, d, e) / f;
    }
    return i;
  }
  GetAssymetryCostOnData(t, e, i, s, n) {
    const r = t.sub(i);
    if (r.length < m.distanceEpsilon)
      return 0;
    const l = e.add(s).dot(r), h = u.crossProduct(r, e), c = u.crossProduct(r, s), d = h - c, f = l * l + d * d, p = h * h + c * c;
    return 10 * f + n * p;
  }
  SeparationCost(t) {
    return this.SeparationCostForBundleBase(t.SourceBase) + this.SeparationCostForBundleBase(t.TargetBase);
  }
  SeparationCostForBundleBase(t) {
    return t.Prev == null ? 0 : this.SeparationCostForAdjacentBundleBases(t, t.Prev) + this.SeparationCostForAdjacentBundleBases(t, t.Next);
  }
  SeparationCostForAdjacentBundleBases(t, e) {
    const i = t.Curve, s = this.IntervalsOverlapLength(t.ParStart, t.ParEnd, e.ParStart, e.ParEnd, i), n = Math.min(t.Span, e.Span);
    return Math.exp(s / (n * 10)) - 1;
  }
  // returns the length of the overlapped interval of parameter space
  IntervalsOverlapLength(t, e, i, s, n) {
    const r = n.parStart, o = n.parEnd;
    return t < e ? i < s ? this.IntersectRegularIntervals(t, e, i, s) : this.IntersectRegularIntervals(t, e, i, o) + this.IntersectRegularIntervals(t, e, r, s) : i < s ? this.IntersectRegularIntervals(t, o, i, s) + this.IntersectRegularIntervals(r, e, i, s) : this.IntersectRegularIntervals(t, o, i, o) + this.IntersectRegularIntervals(r, e, r, s);
  }
  IntersectRegularIntervals(t, e, i, s) {
    const n = Math.max(t, i), r = Math.min(e, s);
    return n < r ? r - n : 0;
  }
  Cost() {
    let t = 0;
    for (const e of this.Bundles) {
      const i = H.SeparationCoeff * this.SeparationCost(e), s = H.AssymetryCoeff * this.AssymetryCost(e), n = H.SqueezeCoeff * this.SqueezeCost(e), r = H.CenterCoeff * this.CenterCostBi(e);
      t += (i + s) / 2 + n + r;
    }
    return t;
  }
}
H.Deltas = [
  [1, -1],
  // [0, 1],
  //[-1, 1],
  // [1, 0],
  // [-1, 0],
  //[1, -1],
  // [0, -1],
  [1, -1]
  //rotating the left point cw, the right ccw
];
H.SeparationCoeff = 1;
H.SqueezeCoeff = 1;
H.CenterCoeff = 10;
H.AssymetryCoeff = 1;
H.MaxIterations = 200;
H.MaxParameterChange = 8 / 360;
H.MinParameterChange = 0.1 / 360;
H.CostThreshold = 1e-5;
H.CostDeltaThreshold = 0.01;
function mg(a, t) {
  const e = Vi(a.Curve);
  let i = a.ParEnd, s = a.ParStart < a.ParEnd ? a.ParStart : a.ParStart - e, n = t.ParEnd, r = t.ParStart < t.ParEnd ? t.ParStart : t.ParStart - e;
  i > n ? i - r > e && (r += e, n += e) : n - s > e && (s += e, i += e);
  const o = Math.min(i, n), l = Math.max(s, r);
  return l <= o ? { start: l, end: o, rbaseMiddle: (s + i) / 2, lbaseMiddle: (r + n) / 2 } : null;
}
class Pg {
  constructor() {
    this.Metrolines = new Array();
  }
  Add(t) {
    this.Metrolines.push(t);
  }
}
class kr {
  // Initialize bundle graph and build the ordering
  constructor(t) {
    this.Metrolines = t, this.BuildOrder();
  }
  *GetOrder(t, e) {
    const i = new ie(t.Position, e.Position), s = this.bundles.get(i).Metrolines;
    if (t.Position === i.first)
      for (let n = 0; n < s.length; n++)
        yield s[n];
    else
      for (let n = s.length - 1; n >= 0; n--)
        yield s[n];
  }
  /**   Get the index of line on the edge (u->v) and node u */
  GetLineIndexInOrder(t, e, i) {
    const s = new ie(t.Position, e.Position), n = t.Position !== s.first, r = this.bundles.get(s).LineIndexInOrder;
    return n ? r.size - 1 - r.get(i) : r.get(i);
  }
  /**   Do the main job */
  BuildOrder() {
    this.bundles = new Rn();
    for (const t of this.Metrolines)
      for (let e = t.Polyline.startPoint; e.next != null; e = e.next) {
        const i = new ie(e.point, e.next.point);
        let s = this.bundles.get(i);
        s || this.bundles.set(i, s = new Pg()), s.Add(t);
      }
    for (const t of this.bundles)
      this.BuildOrderPP(t[0], t[1]);
  }
  /**   Build an order for edge (u->v) */
  BuildOrderPP(t, e) {
    if (!e.orderFixed) {
      e.Metrolines.sort((i, s) => this.CompareLines(i, s, t.first, t.second)), e.orderFixed = !0, e.LineIndexInOrder = /* @__PURE__ */ new Map();
      for (let i = 0; i < e.Metrolines.length; i++)
        e.LineIndexInOrder.set(e.Metrolines[i], i);
    }
  }
  /**   Compare two lines on station u with respect to edge (u->v) */
  CompareLines(t, e, i, s) {
    const n = { polyPoint: null, next: null, prev: null };
    this.FindStationOnLine(i, s, t, n);
    const r = n.polyPoint, o = n.next, l = n.prev;
    this.FindStationOnLine(i, s, e, n);
    const h = n.polyPoint, c = n.next, d = n.prev;
    let f = r, p = h, P, y;
    for (; (y = l(f)) != null && (P = d(p)) != null && y.point.equal(P.point); ) {
      const C = new ie(y.point, f.point);
      if (this.bundles.get(C).orderFixed)
        return this.CompareOnFixedOrder(C, t, e, !y.point.equal(C.first));
      f = y, p = P;
    }
    if (y != null && P != null) {
      const C = f.point;
      return -kr.IsLeft(o(f).point.sub(C), y.point.sub(C), P.point.sub(C));
    }
    for (f = r, p = h; (y = o(f)) != null && (P = c(p)) != null && y.point.equal(P.point); ) {
      const C = new ie(y.point, f.point);
      if (this.bundles.get(C).orderFixed)
        return this.CompareOnFixedOrder(C, t, e, !f.point.equal(C.first));
      f = y, p = P;
    }
    if (y != null && P != null) {
      const C = f.point;
      return kr.IsLeft(l(f).point.sub(C), y.point.sub(C), P.point.sub(C));
    }
    return yt(t.Index, e.Index);
  }
  CompareOnFixedOrder(t, e, i, s) {
    const n = this.bundles.get(t).LineIndexInOrder;
    return (s ? -1 : 1) * yt(n.get(e), n.get(i));
  }
  /** Fills Next and Prev functions according to the direction of the metroline */
  // todo?  Reimplement it in more efficient way!!! (cache indexes)
  FindStationOnLine(t, e, i, s) {
    for (let n = i.Polyline.startPoint; n.next != null; n = n.next) {
      if (n.point.equal(t) && n.next.point.equal(e)) {
        s.next = (r) => r.next, s.prev = (r) => r.prev, s.polyPoint = n;
        return;
      }
      if (n.point.equal(e) && n.next.point.equal(t)) {
        s.next = (r) => r.prev, s.prev = (r) => r.next, s.polyPoint = n.next;
        return;
      }
    }
    throw new Error();
  }
  /**  computes orientation of three vectors with a common source
     (compare the polar angles of v1 and v2 with respect to v0),
      return -1 if the orientation is v0 v1 v2,
               1 if the orientation is v0 v2 v1,
               0  if v1 and v2 are collinear and codirectinal, TODO: seems fishy */
  static IsLeft(t, e, i) {
    return cs(t, e, i);
  }
}
class Y extends ht {
  // Constructor
  constructor(t, e) {
    super(null), this.metroGraphData = t, this.bundlingSettings = e;
  }
  run() {
    this.CreateMetroOrdering(), this.InitRadii(), this.FinalizePaths();
  }
  InitRadii() {
    new Qt(this.metroGraphData, this.bundlingSettings).CreateNodeRadii();
  }
  // bundle-map ordering
  CreateMetroOrdering() {
    this.metroOrdering = new kr(this.metroGraphData.Metrolines);
  }
  FinalizePaths() {
    this.CreateBundleBases(), this.CreateSegmentsInsideHubs(), this.CreateCurves();
  }
  CreateBundleBases() {
    new H(this.metroOrdering, this.metroGraphData, this.bundlingSettings).Run();
  }
  CreateCurves() {
    for (let t = 0; t < this.metroGraphData.Metrolines.length; t++)
      this.CreateCurveLine(this.metroGraphData.Metrolines[t], this.metroGraphData.Edges[t]);
  }
  CreateCurveLine(t, e) {
    const i = new g();
    let n = Y.FindCurveStart(this.metroGraphData, this.metroOrdering, t);
    const r = Y.HubSegsOfLine(this.metroGraphData, this.metroOrdering, t);
    for (const o of r)
      o != null && (i.addSegment(v.mkPP(n, o.start)), i.addSegment(o), n = o.end);
    i.addSegment(v.mkPP(n, Y.FindCurveEnd(this.metroGraphData, this.metroOrdering, t))), e.curve = i;
  }
  static FindCurveStart(t, e, i) {
    const s = t.PointToStations.get(i.Polyline.startPoint.point), n = t.PointToStations.get(i.Polyline.startPoint.next.point), r = s.BundleBases.get(n), o = r.IsParent ? e.GetLineIndexInOrder(s, n, i) : e.GetLineIndexInOrder(n, s, i);
    return r.Points[o];
  }
  static FindCurveEnd(t, e, i) {
    const s = t.PointToStations.get(i.Polyline.endPoint.prev.point), n = t.PointToStations.get(i.Polyline.endPoint.point), r = n.BundleBases.get(s), o = r.IsParent ? e.GetLineIndexInOrder(n, s, i) : e.GetLineIndexInOrder(s, n, i);
    return r.Points[o];
  }
  static *HubSegsOfLine(t, e, i) {
    for (let s = i.Polyline.startPoint.next; s.next != null; s = s.next)
      yield Y.SegOnLineVertex(t, e, i, s);
  }
  static SegOnLineVertex(t, e, i, s) {
    const n = t.PointToStations.get(s.prev.point), r = t.PointToStations.get(s.point), o = r.BundleBases.get(n), l = e.GetLineIndexInOrder(n, r, i);
    if (o.OrientedHubSegments[l] == null || o.OrientedHubSegments[l].Segment == null) {
      const h = t.PointToStations.get(s.next.point), c = r.BundleBases.get(h), d = e.GetLineIndexInOrder(h, r, i);
      return v.mkPP(o.Points[l], c.Points[d]);
    }
    return o.OrientedHubSegments[l].Segment;
  }
  CreateSegmentsInsideHubs() {
    for (const t of this.metroGraphData.Metrolines)
      this.CreateOrientedSegsOnLine(t);
    this.bundlingSettings.UseCubicBezierSegmentsInsideOfHubs && this.FanBezierSegs();
  }
  CreateOrientedSegsOnLine(t) {
    for (let e = t.Polyline.startPoint.next; e.next != null; e = e.next)
      this.CreateICurveForOrientedSeg(t, e);
  }
  CreateICurveForOrientedSeg(t, e) {
    const i = this.metroGraphData.PointToStations.get(e.prev.point), s = this.metroGraphData.PointToStations.get(e.point), n = this.metroGraphData.PointToStations.get(e.next.point), r = s.BundleBases.get(i), o = s.BundleBases.get(n), l = this.metroOrdering.GetLineIndexInOrder(i, s, t), h = this.metroOrdering.GetLineIndexInOrder(n, s, t), c = this.bundlingSettings.UseCubicBezierSegmentsInsideOfHubs ? Y.StandardBezier(r.Points[l], r.Tangents[l], o.Points[h], o.Tangents[h]) : Y.BiArc(r.Points[l], r.Tangents[l], o.Points[h], o.Tangents[h]);
    r.OrientedHubSegments[l].Segment = c, o.OrientedHubSegments[h].Segment = c;
  }
  static ShowHubs(t, e, i, s, n = []) {
    let r = Y.GetAllDebugCurves(e, t);
    i != null && r.push(q.mkDebugCurveTWCI(255, 1, "red", pt.mkDiamond(5, 25, i.Position))), r = r.concat(n);
  }
  static GetAllDebugCurves(t, e) {
    return Y.GraphNodes(e).concat(Y.VertexDebugCurves(t, e)).concat(Y.DebugEdges(e));
  }
  static DebugEdges(t) {
    return t.Edges.map((e) => q.mkDebugCurveTWCI(40, 0.1, "gray", e.curve));
  }
  static VertexDebugCurves(t, e) {
    return Y.DebugCircles(e).concat(Y.DebugHubBases(e)).concat(Y.DebugSegs(e)).concat(Y.BetweenHubs(t, e));
  }
  static BetweenHubs(t, e) {
    const i = [];
    for (const s of e.Metrolines) {
      const n = Y.GetInterestingSegs(e, t, s), r = Y.GetMonotoneColor(s.Polyline.start, s.Polyline.end, n);
      for (const o of n)
        i.push(q.mkDebugCurveTWCI(100, s.Width, r, v.mkPP(o[0], o[1])));
    }
    return i;
  }
  static GetInterestingSegs(t, e, i) {
    const s = new Array();
    if (t.Stations.length === 0 || t.Stations[0].BundleBases == null || t.Stations[0].BundleBases.size === 0)
      return [];
    let n = Y.FindCurveStart(t, e, i);
    const r = Y.HubSegsOfLine(t, e, i);
    for (const o of r)
      o != null && (s.push([n, o.start]), n = o.end);
    return s.push([n, Y.FindCurveEnd(t, e, i)]), s;
  }
  static GetMonotoneColor(t, e, i) {
    return "green";
  }
  static DebugHubBases(t) {
    const e = new Array();
    for (const i of t.Stations)
      for (const s of i.BundleBases.values())
        e.push(q.mkDebugCurveTWCI(100, 1, "red", v.mkPP(s.EndPoint, s.StartPoint)));
    return e;
  }
  static DebugCircles(t) {
    return t.Stations.map((e) => q.mkDebugCurveTWCI(100, 0.1, "blue", pt.mkCircle(e.Radius, e.Position)));
  }
  static DebugSegs(t) {
    const e = new Array();
    for (const i of t.VirtualStations())
      for (const s of i.BundleBases.values())
        for (const n of s.OrientedHubSegments)
          if (n != null)
            if (n.Segment == null) {
              const r = n.Other.BundleBase, o = n.Index, l = n.Other.Index;
              e.push(v.mkPP(s.Points[o], r.Points[l]));
            } else
              e.push(n.Segment);
    return e.map((i) => q.mkDebugCurveTWCI(100, 0.01, "green", i));
  }
  static GraphNodes(t) {
    return t.Edges.map((i) => i.sourcePort.Curve).concat(t.Edges.map((i) => i.targetPort.Curve)).map((i) => q.mkDebugCurveTWCI(40, 1, "black", i));
  }
  static BiArc(t, e, i, s) {
    const n = t.sub(i);
    if (n.length < m.distanceEpsilon)
      return null;
    const r = n.dot(e.sub(s)), o = -e.dot(s);
    if (e.dot(i.sub(t)) <= 0 && e.dot(s) <= 0)
      return Y.StandardBezier(t, e, i, s);
    const l = 2 * (o - 1), h = 2 * r, c = n.dot(n);
    let d;
    if (Math.abs(l) < m.distanceEpsilon)
      if (Math.abs(h) > m.distanceEpsilon)
        d = -c / h;
      else
        return null;
    else {
      let N = h * h - 4 * l * c;
      N < 0 && (N = 0), N = Math.sqrt(N), d = (-h + N) / (2 * l), d < 0 && (d = (-h - N) / (2 * l));
    }
    const f = t.add(e.mul(d)), p = i.add(s.mul(d)), P = u.middle(f, p), y = u.getTriangleOrientation(t, f, P), C = u.getTriangleOrientation(P, p, i);
    if (y !== C)
      return Y.StandardBezier(t, e, i, s);
    const w = new g();
    return w.addSegs([Y.ArcOn(t, f, P), Y.ArcOn(P, p, i)]), w;
  }
  // returns the arc that a,b,c touches
  static ArcOn(t, e, i) {
    const s = { center: null };
    if (Math.abs(u.signedDoubledTriangleArea(t, e, i)) < 1e-4 || !Y.FindArcCenter(t, e, i, s))
      return v.mkPP(t, i);
    const n = s.center, r = Z(t, n);
    if (Z(t, e) / r < 1e-4)
      return v.mkPP(t, i);
    const l = t.sub(n);
    let h = Math.atan2(l.y, l.x);
    const c = i.sub(n);
    let d = Math.atan2(c.y, c.x), f = d - h;
    if (f < 0 && (f += 2 * Math.PI, d += 2 * Math.PI), f <= Math.PI)
      return new j(h, d, new u(r, 0), new u(0, r), n);
    for (d > 2 * Math.PI && (d -= 2 * Math.PI), h = Math.PI - h, d = Math.PI - d, h < 0 && (h += 2 * Math.PI); d < h; )
      d += 2 * Math.PI;
    return f = d - h, new j(h, d, new u(-r, 0), new u(0, r), n);
  }
  static FindArcCenter(t, e, i, s) {
    const n = e.sub(t).rotate90Cw(), r = e.sub(i).rotate90Cw();
    return s.center = u.lineLineIntersection(t, t.add(n), i, i.add(r)), s.center != null;
  }
  static StandardBezier(t, e, i, s) {
    const n = Z(t, i) / 4;
    return st.mkBezier([t, t.add(e.mul(n)), i.add(s.mul(n)), i]);
  }
  FanBezierSegs() {
    let t = !0;
    const e = 5;
    let i = 0;
    for (; t && i++ < e; ) {
      t = !1;
      for (const s of this.metroGraphData.Stations)
        for (const n of s.BundleBases.values())
          t || (t = this.FanEdgesOfHubSegment(n));
    }
  }
  FanEdgesOfHubSegment(t) {
    let e = !1;
    for (let i = 0; i < t.Count - 1; i++)
      e || (e = this.FanCouple(t, i, t.CurveCenter, t.Curve.boundingBox.diagonal / 2));
    return e;
  }
  // fans the couple i,i+1
  FanCouple(t, e, i, s) {
    const n = t.OrientedHubSegments[e], r = t.OrientedHubSegments[e + 1];
    if (n == null || Rh(n.Segment.start, n.Segment.end, r.Segment.start, r.Segment.end) || u.getTriangleOrientation(n.value(0), n.value(0.5), n.value(1)) != u.getTriangleOrientation(r.value(0), r.value(0.5), r.value(1)))
      return !1;
    const l = this.BaseLength(n), h = this.BaseLength(r);
    return Math.abs(l - h) < m.intersectionEpsilon ? !1 : l > h ? this.AdjustLongerSeg(n, r, i, s) : this.AdjustLongerSeg(r, n, i, s);
  }
  AdjustLongerSeg(t, e, i, s) {
    const n = t.value(0).sub(e.value(0)), r = t.value(1).sub(e.value(1)), o = Math.min(n.length, r.length), l = e.value(0.5), h = Math.max(n.length, r.length);
    return this.NicelyAligned(t.Segment, n, r, l, o, h) === 0 ? !1 : this.FitLonger(t, n, r, l, o, h, i, s);
  }
  FitLonger(t, e, i, s, n, r, o, l) {
    let h = t.Segment;
    const c = h.start, d = h.end;
    let f = 0;
    const p = 10;
    let P = h.start.mul(1 - Y.SqueezeBound).add(h.B(1).mul(Y.SqueezeBound)), y = h.end.mul(1 - Y.SqueezeBound).add(h.B(2).mul(Y.SqueezeBound)), C = h.B(1).mul(2).sub(h.start), w = h.B(2).mul(2).sub(h.end);
    const N = { highP: C };
    this.PullControlPointToTheCircle(h.start, N, o, l), C = N.highP;
    let I = this.NicelyAligned(h, e, i, s, n, r);
    do {
      if (I === -1) {
        const x = u.middle(h.B(1), P), V = u.middle(h.B(2), y);
        C = h.B(1), w = h.B(2), h = new st(c, x, V, d);
      } else {
        const x = u.middle(h.B(1), C), V = (h.B(2), w);
        P = h.B(1), y = h.B(2), h = new st(c, x, V, d);
      }
      if ((I = this.NicelyAligned(h, e, i, s, n, r)) === 0)
        return t.Segment = h, t.Other.Segment = h, !0;
      if (f++ > p)
        return !1;
    } while (!0);
  }
  PullControlPointToTheCircle(t, e, i, s) {
    const n = u.ProjectionToLine(t, e.highP, i), r = Math.sqrt(s * s - n.sub(i).lengthSquared), o = e.highP.sub(n), l = o.length;
    l > r && (e.highP = n.add(o.mul(r / l)));
  }
  //
  NicelyAligned(t, e, i, s, n, r) {
    const l = t.value(0.5).sub(s), h = l.length;
    return e.dot(l) < 0 || i.dot(l) < 0 || h < n - 1e-3 ? 1 : h > r + 1e-3 ? -1 : 0;
  }
  BaseLength(t) {
    return t.value(0).sub(t.value(1)).lengthSquared;
  }
}
Y.SqueezeBound = 0.2;
class At {
  // fix routing by simulated annealing algorithm
  static FixRouting(t, e) {
    return this.FixRoutingMBP(t, e, null);
  }
  static FixRoutingMBP(t, e, i) {
    return new At(t, e).FixRoutingP(i);
  }
  constructor(t, e) {
    this.stepsWithProgress = 0, this.metroGraphData = t, this.bundlingSettings = e, this.costCalculator = new ft(this.metroGraphData, this.bundlingSettings), this.cache = new so(this.metroGraphData, this.bundlingSettings, this.costCalculator, this.metroGraphData.cdt);
  }
  // Use constraint edge routing to reduce ink
  FixRoutingP(t) {
    this.stationsForOptimizations = this.GetStationsForOptimizations(t), this.cache.InitializeCostCache();
    let e = At.MaxStep, i = Number.POSITIVE_INFINITY, s = this.metroGraphData.VirtualStations().map((r) => r.Position), n = 0;
    for (; n++ < At.MaxIterations; ) {
      const r = this.TryMoveStations();
      if (n <= 1 && !r)
        return !1;
      if (!r)
        break;
      const o = i;
      i = ft.Cost(this.metroGraphData, this.bundlingSettings), e = this.UpdateMaxStep(e, o, i);
      const l = s;
      if (s = this.metroGraphData.VirtualStations().map((h) => h.Position), e < At.MinStep || this.Converged(e, l, s))
        break;
    }
    return !0;
  }
  static stationsArePositionedCorrectly(t) {
    for (const e of t.VirtualEdges())
      if (!this.edgeIsPositionedCorrectly(e, t))
        return !1;
    return !0;
  }
  static edgeIsPositionedCorrectly(t, e) {
    const i = t[0], s = t[1], n = e.looseIntersections.ObstaclesToIgnoreForBundle(i, s), r = v.mkPP(i.Position, s.Position), o = Array.from(e.looseIntersections.obstacleTree.GetNodeItemsIntersectingRectangle(r.boundingBox)).filter((l) => !n.has(l)).filter((l) => g.CurvesIntersect(r, l));
    return o.length > 0 ? (Y.ShowHubs(e, null, null, "./tmp/badcross.svg", [
      q.mkDebugCurveTWCI(200, 1, "Brown", r),
      q.mkDebugCurveTWCI(200, 1, "Red", pt.mkCircle(2, i.Position)),
      q.mkDebugCurveTWCI(200, 1, "Blue", pt.mkCircle(5, s.Position)),
      q.mkDebugCurveTWCI(100, 1, "Blue", pt.mkCircle(5, s.Position))
    ].concat(o.map((l) => q.mkDebugCurveTWCI(100, 1, "Pink", l)))), !1) : !0;
  }
  GetStationsForOptimizations(t) {
    if (t == null)
      return new Set(this.metroGraphData.VirtualStations());
    {
      const e = /* @__PURE__ */ new Set();
      for (const i of t) {
        const s = this.metroGraphData.PointToStations.get(i);
        s && !s.IsReal && e.add(s);
      }
      return e;
    }
  }
  // stop SA if relative changes are small
  Converged(t, e, i) {
    let s = 0, n = 0;
    for (let o = 0; o < e.length; o++)
      n += e[o].sub(i[o]).lengthSquared, s += e[o].lengthSquared;
    return Math.sqrt(n / s) < At.MinRelativeChange;
  }
  UpdateMaxStep(t, e, i) {
    return i + 1 < e ? (this.stepsWithProgress++, this.stepsWithProgress >= 5 && (this.stepsWithProgress = 0, t = Math.min(At.MaxStep, t / 0.8))) : (this.stepsWithProgress = 0, t *= 0.8), t;
  }
  TryMoveStations() {
    let t = !1;
    const e = /* @__PURE__ */ new Set();
    for (const i of this.stationsForOptimizations)
      if (this.TryMoveStation(i)) {
        t = !0, e.add(i);
        for (const s of i.Neighbors)
          s.IsReal || e.add(s);
      }
    return this.stationsForOptimizations = e, t;
  }
  /**
      Move node to decrease the cost of the drawing
     Returns true iff position has changed
  */
  TryMoveStation(t) {
    let e = this.BuildDirection(t);
    if (e.length === 0)
      return !1;
    let i = this.BuildStepLength(t, e);
    if (i < At.MinStep && (e = Sg(), i = this.BuildStepLength(t, e), i < At.MinStep))
      return !1;
    const s = e.mul(i), n = t.Position.add(s);
    return this.metroGraphData.PointToStations.has(n) || !this.moveIsLegalForAdjacentBundles(t, n) ? !1 : (this.metroGraphData.MoveNode(t, n), this.cache.UpdateCostCache(t), !0);
  }
  /** checking the node position and neigborhood bundles */
  moveIsLegalForAdjacentBundles(t, e) {
    for (const i of this.metroGraphData.looseIntersections.obstacleTree.AllHitItems(T.mkOnPoints([e]), (s) => g.PointRelativeToCurveLocation(e, s) !== F.Outside))
      if (t.getELP().has(i) === !1)
        return !1;
    for (const i of t.Neighbors) {
      const s = this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(i, t);
      if (!this.metroGraphData.cdtIntersections.EdgeIsLegal_(i.Position, e, i.cdtTriangle, s))
        return !1;
    }
    return !0;
  }
  // Calculate the direction to improve the ink function
  BuildDirection(t) {
    const e = this.BuildForceForInk(t), i = this.BuildForceForPathLengths(t), s = this.BuildForceForRadius(t), n = this.BuildForceForBundle(t), r = e.add(i.add(s.add(n)));
    return r.length < 0.1 ? new u(0, 0) : r.normalize();
  }
  BuildStepLength(t, e) {
    let i = At.MinStep, s = this.CostGain(t, t.Position.add(e.mul(i)));
    if (s < 0.01)
      return 0;
    for (; 2 * i <= At.MaxStep; ) {
      const n = this.CostGain(t, t.Position.add(e.mul(i * 2)));
      if (n <= s)
        break;
      i *= 2, s = n;
    }
    return i;
  }
  // Computes cost delta when moving the node
  // the cost will be negative if a new position overlaps obstacles
  CostGain(t, e) {
    const s = this.costCalculator.RadiusGain(t, e);
    if (s < -12345678)
      return -12345678;
    const n = this.costCalculator.BundleGain(t, e);
    if (n < -12345678)
      return -12345678;
    const r = this.costCalculator.InkGain(t, e), o = this.costCalculator.PathLengthsGain(t, e);
    return s + r + o + n;
  }
  // force to decrease ink
  BuildForceForInk(t) {
    let e = new u(0, 0);
    for (const s of t.Neighbors) {
      const n = s.Position.sub(t.Position);
      e = e.add(n.normalize());
    }
    return e.mul(this.bundlingSettings.InkImportance);
  }
  // direction to decrease path lengths
  BuildForceForPathLengths(t) {
    let e = new u(0, 0);
    for (const s of this.metroGraphData.MetroNodeInfosOfNode(t)) {
      const n = s.Metroline, r = s.PolyPoint.next.point, o = s.PolyPoint.prev.point, l = r.sub(t.Position), h = o.sub(t.Position);
      e = e.add(l.div(l.length * n.IdealLength)), e = e.add(h.div(h.length * n.IdealLength));
    }
    return e.mul(this.bundlingSettings.PathLengthImportance);
  }
  // direction to increase radii
  BuildForceForRadius(t) {
    let e = new u(0, 0);
    const i = t.cachedIdealRadius, s = { touchedObstacles: [] };
    if (!this.metroGraphData.looseIntersections.HubAvoidsObstaclesSPNBA(t, t.Position, i, s))
      throw Y.ShowHubs(this.metroGraphData, null, t, "./tmp/hubs.svg", [
        q.mkDebugCurveTWCI(255, 1, "Brown", Ue.containingPoly),
        q.mkDebugCurveTWCI(100, 1, "Blue", pt.mkCircle(i, t.Position))
      ]), new Error();
    for (const o of s.touchedObstacles) {
      const h = 2 * (1 - o[1].sub(t.Position).length / i), c = t.Position.sub(o[1]).normalize();
      e = e.add(c.mul(h));
    }
    return e.mul(this.bundlingSettings.HubRepulsionImportance);
  }
  /** calculates the direction to push a bundle away from obstacle*/
  BuildForceForBundle(t) {
    let e = new u(0, 0);
    for (const s of t.Neighbors) {
      const n = this.metroGraphData.GetWidthSSN(t, s, this.bundlingSettings.EdgeSeparation), r = { closestDist: [] };
      this.metroGraphData.cdtIntersections.BundleAvoidsObstacles(t, s, t.Position, s.Position, n / 2, r);
      for (const o of r.closestDist) {
        const h = 2 * (1 - o[0].sub(o[1]).length / (n / 2)), c = o[0].sub(o[1]).normalize().neg();
        e = e.add(c.mul(h));
      }
    }
    return e.mul(this.bundlingSettings.BundleRepulsionImportance);
  }
}
At.MaxIterations = 100;
At.MaxStep = 50;
At.MinStep = 1;
At.MinRelativeChange = 5e-4;
function Sg() {
  return new u(1 + 2 * Cs(), 1 + 2 * Cs());
}
class as {
  constructor(t, e) {
    this.metroGraphData = t, this.bundlingSettings = e;
  }
  /**  apply a number of heuristics to improve current routing */
  static FixRouting(t, e) {
    const i = new as(t, e);
    i.GlueConflictingStations(), i.UnglueEdgesFromBundleToSaveInk(!0);
    let s = 0;
    const n = 10;
    for (; ++s < n; ) {
      let r = i.GlueConflictingStations();
      if (r || (r = i.RelaxConstrainedEdges()), r || (r = s <= 3 && i.UnglueEdgesFromBundleToSaveInk(!1)), r || (r = i.GlueCollinearNeighbors(s)), r || (r = s === 3 && i.RemoveDoublePathCrossings()), !r)
        break;
    }
    for (t.cdtIntersections.ComputeForcesForBundles = !0, i.RemoveDoublePathCrossings(), i.UnglueEdgesFromBundleToSaveInk(!0); i.GlueConflictingStations(); )
      ;
    t.Initialize(!0);
  }
  /** unite the nodes that are close to each other */
  GlueConflictingStations() {
    const t = this.GetCirclesHierarchy();
    if (t == null)
      return !1;
    const e = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Set();
    if (Xt(t, t, (n, r) => this.TryToGlueStations(n, r, e, i)), e.size === 0)
      return !1;
    for (let n = 0; n < this.metroGraphData.Edges.length; n++)
      this.RegenerateEdge(e, n);
    const s = new xt();
    for (const n of i) {
      s.add(n.Position);
      for (const r of n.Neighbors)
        r.IsReal || s.add(r.Position);
    }
    return this.metroGraphData.Initialize(!1), At.FixRoutingMBP(this.metroGraphData, this.bundlingSettings, s), !0;
  }
  GetCirclesHierarchy() {
    for (const i of this.metroGraphData.VirtualStations())
      i.Radius = this.GetCurrentHubRadius(i);
    const t = this.metroGraphData.VirtualStations().map(e);
    return Et(t);
    function e(i) {
      const s = i.Position, n = Math.max(i.Radius, 5), r = new u(n, n), o = T.mkPP(s.add(r), s.sub(r));
      return Bt(i, o);
    }
  }
  GetCurrentHubRadius(t) {
    if (t.IsReal)
      return t.BoundaryCurve.boundingBox.diagonal / 2;
    {
      const e = t.cachedIdealRadius;
      let i = this.metroGraphData.looseIntersections.GetMinimalDistanceToObstacles(t, t.Position, e);
      for (const s of t.Neighbors)
        i = Math.min(i, t.Position.sub(s.Position).length);
      return i;
    }
  }
  TryToGlueStations(t, e, i, s) {
    if (!Tr(t.getELP(), e.getELP()))
      return !1;
    const n = t.Position.sub(e.Position).length, r = Math.max(t.Radius, 5), o = Math.max(e.Radius, 5);
    n >= r + o || this.TryGlueOrdered(t, e, s, i) || this.TryGlueOrdered(e, t, s, i);
  }
  TryGlueOrdered(t, e, i, s) {
    return !s.has(t) && !i.has(t) && this.StationGluingIsAllowed(t, e, s) ? (this.Map(t, e, i, s), !0) : !1;
  }
  Map(t, e, i, s) {
    s.set(t, e), i.add(e);
  }
  /**  trying to glue i to j */
  StationGluingIsAllowed(t, e, i) {
    for (const n of t.Neighbors) {
      const r = as.Glued(n, i), o = this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(r, t);
      if (!this.metroGraphData.cdtIntersections.EdgeIsLegalSSPPS(r, e, o))
        return !1;
    }
    return !(this.ComputeCostDeltaAfterStationGluing(t, e, i) < 0);
  }
  ComputeCostDeltaAfterStationGluing(t, e, i) {
    const s = t.Position.sub(e.Position).length;
    if (t.Radius >= s || e.Radius >= s)
      return 1;
    let n = 0;
    const r = this.metroGraphData.Ink;
    let o = this.metroGraphData.Ink - e.Position.sub(t.Position).length;
    for (const l of t.Neighbors) {
      const h = as.Glued(l, i);
      o -= h.Position.sub(t.Position).length, o += this.metroGraphData.RealEdgeCount(h, e) === 0 ? h.Position.sub(e.Position).length : 0;
    }
    n += ft.InkError(r, o, this.bundlingSettings);
    for (const l of this.metroGraphData.MetroNodeInfosOfNode(t)) {
      const h = l.Metroline.Length;
      let c = l.Metroline.Length;
      const d = l.PolyPoint, f = d.prev, p = d.next;
      c -= f.point.sub(t.Position).length + p.point.sub(t.Position).length, c += f.point.sub(e.Position).length + p.point.sub(e.Position).length, n += ft.PathLengthsError(h, c, l.Metroline.IdealLength, this.bundlingSettings);
    }
    return n;
  }
  RegenerateEdge(t, e) {
    const i = this.metroGraphData.Metrolines[e].Polyline;
    for (const r of i)
      if (!this.metroGraphData.PointToStations.has(r))
        return;
    let s = !1;
    for (const r of i)
      if (t.has(this.metroGraphData.PointToStations.get(r))) {
        s = !0;
        break;
      }
    if (!s)
      return;
    const n = Array.from(i).map((r) => this.metroGraphData.PointToStations.get(r));
    this.metroGraphData.Edges[e].curve = B.mkFromPoints(as.GluedPolyline(n, t));
  }
  static GluedPolyline(t, e) {
    let i;
    const s = new mt.Stack();
    s.push(t[0]);
    const n = /* @__PURE__ */ new Set();
    for (i = 1; i < t.length - 1; i++) {
      const r = as.Glued(t[i], e);
      if (n.has(r)) {
        for (; s.top !== r; )
          n.delete(s.pop());
        continue;
      }
      u.closeDistEps(r.Position, s.top.Position) || (n.add(r), s.push(r));
    }
    return s.push(t[i]), Array.from(s).reverse().map((r) => r.Position);
  }
  static Glued(t, e) {
    var i;
    return (i = e.get(t)) !== null && i !== void 0 ? i : t;
  }
  // Unbundle unnecessary edges:
  //  instead of one bundle (a->bcd) we get two bundles (a->b,a->cd) with smaller ink
  UnglueEdgesFromBundleToSaveInk(t) {
    const e = new Rn();
    this.ink = this.metroGraphData.Ink, this.polylineLength = /* @__PURE__ */ new Map();
    for (const n of this.metroGraphData.Metrolines) {
      this.polylineLength.set(n, n.Length);
      for (let r = n.Polyline.startPoint; r.next != null; r = r.next) {
        const o = new ie(r.point, r.next.point);
        Gh(e, o, n);
      }
    }
    const i = new xt();
    let s = !1;
    for (const n of this.metroGraphData.Metrolines) {
      const r = Hi(this.metroGraphData.PointToStations.get(n.Polyline.start).getELP(), this.metroGraphData.PointToStations.get(n.Polyline.end).getELP());
      this.TrySeparateOnPolyline(n, e, i, r) && (s = !0);
    }
    return s && this.metroGraphData.Initialize(!1), (t || s) && At.FixRoutingMBP(this.metroGraphData, this.bundlingSettings, t ? null : i), s;
  }
  TrySeparateOnPolyline(t, e, i, s) {
    let n = !1, r = !0;
    for (; r; ) {
      r = !1;
      for (let o = t.Polyline.startPoint; o.next != null && o.next.next != null; o = o.next)
        this.TryShortcutPolypoint(o, e, i, s) && (r = !0);
      r && (n = !0);
    }
    return n;
  }
  TryShortcutPolypoint(t, e, i, s) {
    return this.SeparationShortcutAllowed(t, e, s) ? (i.add(t.point), i.add(t.next.point), i.add(t.next.next.point), this.RemoveShortcuttedPolypoint(t, e), !0) : !1;
  }
  // allowed iff line (a,c) is legal and inkgain > 0
  SeparationShortcutAllowed(t, e, i) {
    const s = t.point, n = t.next.point, r = t.next.next.point, o = this.metroGraphData.PointToStations.get(s), l = this.metroGraphData.PointToStations.get(n), h = this.metroGraphData.PointToStations.get(r), c = js(o.getELP(), h.getELP()), d = Ed([i, l.getELP(), c]);
    return !(!this.metroGraphData.cdtIntersections.EdgeIsLegalSSPPS(o, h, d) || this.GetInkgain(t, e, s, n, r) < 0);
  }
  GetInkgain(t, e, i, s, n) {
    const [r, o, l] = this.FindPolylines(t, e);
    let h = 0;
    const c = this.ink;
    let d = this.ink;
    const f = i.sub(s).length, p = s.sub(n).length, P = i.sub(n).length;
    r.size === l.size && (d -= f), o.size === l.size && (d -= p);
    const y = e.get(new ie(i, n));
    (!y || y.size === 0) && (d += P), h += ft.InkError(c, d, this.bundlingSettings);
    for (const V of l) {
      const M = this.polylineLength.get(V), X = M - (f + p - P);
      h += ft.PathLengthsError(M, X, V.IdealLength, this.bundlingSettings);
    }
    let C = this.GetCurrentHubRadius(this.metroGraphData.PointToStations.get(i));
    const w = this.metroGraphData.GetWidthAN(Array.from(l), this.bundlingSettings.EdgeSeparation), N = this.metroGraphData.GetWidthAN(Array.from(zs(r, l)), this.bundlingSettings.EdgeSeparation);
    let I = Qt.GetMinRadiusForTwoAdjacentBundlesNPPPNNB(C, i, n, s, w, N, this.bundlingSettings);
    I > C && (h -= ft.RError(I, C, this.bundlingSettings)), C = this.GetCurrentHubRadius(this.metroGraphData.PointToStations.get(n));
    const x = this.metroGraphData.GetWidthAN(Array.from(zs(o, l)), this.bundlingSettings.EdgeSeparation);
    return I = Qt.GetMinRadiusForTwoAdjacentBundlesNPPPNNB(C, n, s, i, x, w, this.bundlingSettings), I > C && (h -= ft.RError(I, C, this.bundlingSettings)), h;
  }
  RemoveShortcuttedPolypoint(t, e) {
    const i = t.point, s = t.next.point, n = t.next.next.point, [r, o, l] = this.FindPolylines(t, e), h = Z(i, s), c = Z(s, n), d = Z(i, n);
    r.size === l.size && (this.ink -= h), o.size === l.size && (this.ink -= c);
    const f = e.get(new ie(i, n));
    (!f || f.size === 0) && (this.ink += d);
    for (const p of l) {
      const P = this.polylineLength.get(p);
      this.polylineLength.set(p, P - (h + c - d));
    }
    for (const p of l) {
      const P = Array.from(p.Polyline.polylinePoints()).find((y) => y.point.equal(s));
      this.RemovePolypoint(P), Qa(e, [i, s], p), Qa(e, [s, n], p), wd(e, [i, n], p);
    }
  }
  FindPolylines(t, e) {
    const i = t.point, s = t.next.point, n = t.next.next.point, r = e.getPP(i, s), o = e.getPP(s, n), l = Hi(r, o);
    return [r, o, l];
  }
  RemovePolypoint(t) {
    const e = t.prev, i = t.next;
    e.next = i, i.prev = e;
  }
  /**   Fix the situation where a station has two neighbors that are almost in the same directions */
  GlueCollinearNeighbors(t) {
    const e = new xt();
    let i = !1;
    for (const s of this.metroGraphData.Stations)
      this.GlueCollinearNeighborsSPN(s, e, t) && (i = !0);
    return i && (this.metroGraphData.Initialize(!1), At.FixRoutingMBP(this.metroGraphData, this.bundlingSettings, e)), i;
  }
  GlueCollinearNeighborsSPN(t, e, i) {
    if (t.Neighbors.length <= 1)
      return !1;
    const s = new ec(), n = t.Neighbors;
    for (let r = 0; r < n.length; r++)
      this.TryToGlueEdges(t, n[r], n[(r + 1) % n.length], s, i);
    if (s.isEmpty)
      return !1;
    for (const r of s)
      this.GlueEdge(r), e.add(r[0].Position), e.add(r[1].Position), e.add(r[2]);
    return !0;
  }
  TryToGlueEdges(t, e, i, s, n) {
    if (u.anglePCP(e.Position, t.Position, i.Position) < this.bundlingSettings.AngleThreshold) {
      const o = Z(e.Position, t.Position), l = Z(i.Position, t.Position), h = Math.min(o, l) / Math.max(o, l);
      if (h < 0.05)
        return;
      if (o < l) {
        if (this.EdgeGluingIsAllowedSSS(t, e, i)) {
          this.AddEdgeToGlue(t, i, e, e.Position, s);
          return;
        }
      } else if (this.EdgeGluingIsAllowedSSS(t, i, e)) {
        this.AddEdgeToGlue(t, e, i, i.Position, s);
        return;
      }
      if (n < 5 && h > 0.5) {
        const c = this.ConstructGluingPoint(t, e, i);
        this.EdgeGluingIsAllowedSSSP(t, e, i, c) && this.AddEdgeToGlue(t, i, e, c, s);
      }
    }
  }
  ConstructGluingPoint(t, e, i) {
    const s = Math.min(Z(e.Position, t.Position), Z(i.Position, t.Position) / 2), n = e.Position.sub(t.Position).normalize().add(i.Position.sub(t.Position).normalize());
    return t.Position.add(n.mul(s / 2));
  }
  EdgeGluingIsAllowedSSS(t, e, i) {
    if (e.IsReal || i.IsReal || !Tr(e.getELP(), i.getELP()) || !this.metroGraphData.cdtIntersections.EdgeIsLegal(e, i, e.Position, i.Position))
      return !1;
    const s = this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(t, i);
    return !(tt.IntersectionsOfLineAndRectangleNodeOverPolylineLR(v.mkPP(t.Position, e.Position), this.metroGraphData.LooseTree).find((l) => !s.has(l.seg1)) || tt.IntersectionsOfLineAndRectangleNodeOverPolylineLR(v.mkPP(e.Position, i.Position), this.metroGraphData.LooseTree).find((l) => !s.has(l.seg1)) || this.ComputeCostDeltaAfterEdgeGluing(t, e, i, e.Position) < 0);
  }
  EdgeGluingIsAllowedSSSP(t, e, i, s) {
    return !(!this.metroGraphData.looseIntersections.HubAvoidsObstaclesPNS__(s, 0, Hi(e.getELP(), i.getELP())) || !this.metroGraphData.cdtIntersections.EdgeIsLegal(t, null, t.Position, s) || !this.metroGraphData.cdtIntersections.EdgeIsLegal(e, null, e.Position, s) || !this.metroGraphData.cdtIntersections.EdgeIsLegal(i, null, i.Position, s) || this.ComputeCostDeltaAfterEdgeGluing(t, e, i, s) < 0);
  }
  ComputeCostDeltaAfterEdgeGluing(t, e, i, s) {
    let n = 0;
    const r = this.metroGraphData.Ink, o = this.metroGraphData.Ink - Z(t.Position, i.Position) - Z(t.Position, e.Position) + Z(t.Position, s) + Z(s, e.Position) + Z(s, i.Position);
    n += ft.InkError(r, o, this.bundlingSettings);
    for (const d of this.metroGraphData.GetIjInfo(t, i).Metrolines) {
      const f = d.Length, p = d.Length - Z(t.Position, i.Position) + Z(t.Position, s) + Z(s, i.Position);
      n += ft.PathLengthsError(f, p, d.IdealLength, this.bundlingSettings);
    }
    for (const d of this.metroGraphData.GetIjInfo(t, e).Metrolines) {
      const f = d.Length, p = d.Length - Z(t.Position, e.Position) + Z(t.Position, s) + Z(s, e.Position);
      n += ft.PathLengthsError(f, p, d.IdealLength, this.bundlingSettings);
    }
    const l = t.cachedIdealRadius, h = this.GetCurrentHubRadius(t), c = Qt.GetMinRadiusForTwoAdjacentBundles(h, t, t.Position, e, i, this.metroGraphData, this.bundlingSettings);
    return c > h && (n += ft.RError(c, h, this.bundlingSettings)), l > Z(t.Position, s) && !t.IsReal && (n -= ft.RError(l, Z(t.Position, s), this.bundlingSettings)), n;
  }
  AddEdgeToGlue(t, e, i, s, n) {
    n.has(i, t) || n.has(e, t) || n.has(t, i) || n.has(t, e) || (n.set(t, i, s), n.set(t, e, s));
  }
  GlueEdge(t) {
    const e = t[0], i = t[1], s = t[2];
    for (const n of e.MetroNodeInfos.map((r) => r.PolyPoint))
      n.next != null && n.next.point.equal(i.Position) ? this.SplitPolylinePoint(n, s) : n.prev != null && n.prev.point.equal(i.Position) && this.SplitPolylinePoint(n.prev, s);
  }
  SplitPolylinePoint(t, e) {
    if (t.point === e || t.next.point === e)
      return;
    const i = ei.mkFromPoint(e);
    i.polyline = t.polyline, i.next = t.next, i.prev = t, i.next.prev = i, i.prev.next = i;
  }
  // split each edge that is too much constrained by the obstacles
  RelaxConstrainedEdges() {
    const t = new xt();
    let e = !1;
    for (const i of this.metroGraphData.VirtualEdges())
      this.RelaxConstrainedEdge(i[0], i[1], t) && (e = !0);
    return e && (this.metroGraphData.Initialize(!1), At.FixRoutingMBP(this.metroGraphData, this.bundlingSettings, t)), e;
  }
  RelaxConstrainedEdge(t, e, i) {
    const s = this.metroGraphData.GetWidthSSN(t, e, this.bundlingSettings.EdgeSeparation), n = { closestDist: new Array() };
    this.metroGraphData.cdtIntersections.BundleAvoidsObstacles(t, e, t.Position, e.Position, 0.99 * s / 2, n);
    const r = n.closestDist;
    if (r.length > 0) {
      let o = -1, l;
      for (const h of r) {
        const c = Math.min(Z(t.Position, h[1]), Z(e.Position, h[1])), d = Z(t.Position, e.Position);
        if (c / d < 0.1)
          continue;
        const p = Z(h[0], h[1]);
        (o === -1 || p < o) && (o = p, l = h[1]);
      }
      if (o === -1 || !this.metroGraphData.looseIntersections.HubAvoidsObstaclesPNS__(l, 0, Hi(t.getELP(), e.getELP())))
        return !1;
      i.add(l), i.add(t.Position), i.add(e.Position);
      for (const h of this.metroGraphData.GetIjInfo(t, e).Metrolines) {
        let c = null;
        for (const d of h.Polyline.polylinePoints())
          if (d.point.equal(t.Position)) {
            c = d;
            break;
          }
        c.next != null && c.next.point.equal(e.Position) ? this.SplitPolylinePoint(c, l) : this.SplitPolylinePoint(c.prev, l);
      }
      return !0;
    }
    return !1;
  }
  // switch flips
  RemoveDoublePathCrossings() {
    const t = new kn(this.metroGraphData, this.metroGraphData.PointIsAcceptableForEdge.bind(this)).run();
    return t && (this.metroGraphData.Initialize(!1), At.FixRouting(this.metroGraphData, this.bundlingSettings)), t;
  }
}
class _r {
  constructor(t, e, i) {
    this.upperBound = Number.POSITIVE_INFINITY, this._visGraph = i, i.ClearPrevEdgesTable();
    for (const s of i.Vertices())
      s.Distance = Number.POSITIVE_INFINITY;
    this.sources = t, this.targets = new Set(e);
  }
  // Returns  a  path
  GetPath() {
    const t = new is();
    for (const e of this.sources)
      e.Distance = 0, t.Enqueue(e, 0);
    for (; !t.IsEmpty() && (this._current = t.Dequeue(), !this.targets.has(this._current)); ) {
      for (const e of this._current.OutEdges)
        this.PassableOutEdge(e) && this.ProcessNeighbor(t, e, e.Target);
      for (const e of this._current.InEdges.filter(this.PassableInEdge.bind))
        this.ProcessNeighbor(t, e, e.Source);
    }
    return this._visGraph.PreviosVertex(this._current) == null ? null : this.CalculatePath();
  }
  PassableOutEdge(t) {
    return this.targets.has(t.Target) || !_r.IsForbidden(t);
  }
  PassableInEdge(t) {
    return this.targets.has(t.Source) || !_r.IsForbidden(t);
  }
  static IsForbidden(t) {
    return (t.IsPassable != null && !t.IsPassable() || t) instanceof pi;
  }
  ProcessNeighbor(t, e, i) {
    const s = e.Length, n = this._current.Distance + s;
    n >= this.upperBound || (this.targets.has(i) && (this.upperBound = n, this.closestTarget = i), this._visGraph.PreviosVertex(i) == null ? (i.Distance = n, this._visGraph.SetPreviousEdge(i, e), t.Enqueue(i, n)) : n < i.Distance && (i.Distance = n, this._visGraph.SetPreviousEdge(i, e), t.DecreasePriority(i, n)));
  }
  CalculatePath() {
    if (this.closestTarget == null)
      return null;
    const t = new Array();
    let e = this.closestTarget;
    do
      t.push(e), e = this._visGraph.PreviosVertex(e);
    while (e.Distance > 0);
    return t.push(e), t.reverse();
  }
}
class En extends ht {
  constructor(t, e, i, s, n, r, o, l, h, c) {
    super(null), this.bundlingSettings = s, this.bundlingSettings.edgeWidthShrinkCoeff = 1, this.edgesToRoute = t, this.regularEdges = t.filter((d) => d.source !== d.target), this.VisibilityGraph = i, this.shortestPathRouter = e, this.LoosePadding = n, this.LooseHierarchy = o, this.TightHierarchy = r, this.EdgeLooseEnterable = l, this.EdgeTightEnterable = h, this.loosePolylineOfPort = c, to(0);
  }
  ThereAreOverlaps(t) {
    return xe(t, t, g.CurvesIntersect);
  }
  // edge routing with Ordered Bundles:
  // 1. route edges with bundling
  // 2. nudge bundles and hubs
  // 3. order paths
  run() {
    if (this.ThereAreOverlaps(this.TightHierarchy)) {
      this.Status = zo.Overlaps;
      return;
    }
    this.FixLocationsForHookAnywherePorts(this.edgesToRoute), this.RoutePathsWithSteinerDijkstra(), this.FixChildParentEdges(), this.bundlingSettings.StopAfterShortestPaths || this.OrderOptimizeNudgeEtc(), this.RouteSelfEdges(), this.FixArrowheads();
  }
  OrderOptimizeNudgeEtc() {
    const t = new dg(this.regularEdges, this.LooseHierarchy, this.TightHierarchy, this.bundlingSettings, this.shortestPathRouter.cdt, this.EdgeLooseEnterable, this.EdgeTightEnterable, this.loosePolylineOfPort);
    as.FixRouting(t, this.bundlingSettings), new Y(t, this.bundlingSettings).run();
  }
  // set endpoint of the edge from child to parent (cluster) to the boundary of the parent
  // TODO: is there a better solution?
  FixChildParentEdges() {
    for (const t of this.regularEdges) {
      const e = t.sourcePort, i = t.targetPort;
      if (e.Curve.boundingBox.containsRect(i.Curve.boundingBox)) {
        const s = g.intersectionOne(e.Curve, v.mkPP(t.curve.start, t.curve.end), !1), n = t.curve;
        n.startPoint.point = s.x;
      }
      if (i.Curve.boundingBox.containsRect(e.Curve.boundingBox)) {
        const s = g.intersectionOne(i.Curve, v.mkPP(t.curve.start, t.curve.end), !0), n = t.curve;
        n.endPoint.point = s.x;
      }
    }
  }
  // ReSharper disable UnusedMember.Local
  // ShowGraphLocal() {
  //  //  ReSharper restore UnusedMember.Local
  //  const l = new List<ICurve>()
  //  l.Clear()
  //  for (const e in this.geometryGraph.edges) {
  //    l.Add(new Ellipse(2, 2, e.Curve.Start))
  //    l.Add(CurveFactory.CreateDiamond(5, 5, e.Curve.End))
  //    l.Add(e.Curve)
  //  }
  //  SplineRouter.ShowVisGraph(this.VisibilityGraph, this.LooseHierarchy.GetAllLeaves(), null, l)
  // }
  FixLocationsForHookAnywherePorts(t) {
    for (const e of t) {
      let i = e.sourcePort instanceof $t;
      if (i) {
        const s = e.sourcePort;
        s.SetLocation(this.FigureOutHookLocation(s.LoosePolyline, e.targetPort, e));
      } else if (i = e.targetPort instanceof $t, i) {
        const s = e.targetPort;
        s.SetLocation(this.FigureOutHookLocation(s.LoosePolyline, e.sourcePort, e));
      }
    }
  }
  FigureOutHookLocation(t, e, i) {
    return e instanceof Ve ? this.FigureOutHookLocationForClusterOtherPort(t, e, i) : this.FigureOutHookLocationForSimpleOtherPort(t, e, i);
  }
  FigureOutHookLocationForClusterOtherPort(t, e, i) {
    const s = this.shortestPathRouter.MakeTransparentShapesOfEdgeGeometry(i), r = new _r(Array.from(e.LoosePolyline).map(this.VisibilityGraph.FindVertex.bind), Array.from(t).map(this.VisibilityGraph.FindVertex.bind), this.VisibilityGraph).GetPath();
    for (const o of s)
      o.IsTransparent = !1;
    return r[r.length - 1].point;
  }
  FigureOutHookLocationForSimpleOtherPort(t, e, i) {
    const s = e.Location, n = this.shortestPathRouter.MakeTransparentShapesOfEdgeGeometry(i), o = new Ln(this.VisibilityGraph.FindVertex(s), Array.from(t).map((l) => this.VisibilityGraph.FindVertex(l)), this.VisibilityGraph).GetPath();
    for (const l of n)
      l.IsTransparent = !1;
    return o[o.length - 1].point;
  }
  RoutePathsWithSteinerDijkstra() {
    this.shortestPathRouter.VisibilityGraph = this.VisibilityGraph, this.shortestPathRouter.BundlingSettings = this.bundlingSettings, this.shortestPathRouter.geomEdges = this.regularEdges, this.shortestPathRouter.ObstacleHierarchy = this.LooseHierarchy, this.shortestPathRouter.RouteEdges(), this.shortestPathRouter.cdt != null && this.AdjustEdgeSeparation();
  }
  // calculates maximum possible edge separation for the computed routing
  //   if it is greater than bundlingSettings.EdgeSeparation, then proceed
  //   if it is smaller, then either
  //     stop edge bundling, or
  //     reduce edge separation, or
  //     move obstacles to get more free space
  AdjustEdgeSeparation() {
    const t = /* @__PURE__ */ new Map();
    this.shortestPathRouter.FillCrossedCdtEdges(t);
    const e = this.GetPathsOnCdtEdge(t);
    this.bundlingSettings.edgeWidthShrinkCoeff = this.CalculateEdgeWidthShrinkCoeff(e);
  }
  //  //  reducing edge separation
  //  //  TimeMeasurer.DebugOutput("reducing edge separation to " + es);
  //  this.bundlingSettings.EdgeSeparation = es
  //  this.shortestPathRouter.RouteEdges()
  //  return true
  // }
  GetPathsOnCdtEdge(t) {
    const e = /* @__PURE__ */ new Map();
    for (const i of t.keys())
      for (const s of t.get(i))
        Or(e, s, i);
    return e;
  }
  CalculateEdgeWidthShrinkCoeff(t) {
    let e = 0, i = this.bundlingSettings.edgeWidthShrinkCoeff;
    if (this.EdgeSeparationIsOkMN(t, i))
      return i;
    let s = !1;
    for (; !s || Math.abs(i - e) > 0.01; ) {
      const n = (e + i) / 2;
      this.EdgeSeparationIsOkMN(t, n) ? (e = n, s = !0) : i = n;
    }
    return e;
  }
  EdgeSeparationIsOkMN(t, e) {
    for (const i of t.keys())
      if (!this.EdgeSeparationIsOk(i, t.get(i), e))
        return !1;
    return !0;
  }
  EdgeSeparationIsOk(t, e, i) {
    return Array.from(e).map((n) => this.bundlingSettings.ActualEdgeWidth(n, i)).reduce((n, r) => n + r, 0) <= t.Capacity;
  }
  RouteSelfEdges() {
    for (const t of this.edgesToRoute)
      if (t.source === t.target) {
        const e = { smoothedPolyline: null };
        t.curve = Kt.RouteSelfEdge(t.source.boundaryCurve, this.LoosePadding * 2, e);
      }
  }
  FixArrowheads() {
    for (const t of this.edgesToRoute)
      vt.trimSplineAndCalculateArrowheadsII(t, t.source.boundaryCurve, t.target.boundaryCurve, t.curve, !1);
  }
}
En.SuperLoosePaddingCoefficient = 1.1;
class yg {
  constructor(t, e, i) {
    this.numberOfPassedPaths = 0, this.VisibilityEdge = t, this.Source = e, this.Target = i;
  }
  get TargetPoint() {
    return this.Target.Point;
  }
  get SourcePoint() {
    return this.Source.Point;
  }
  get IsOccupied() {
    return this.numberOfPassedPaths > 0;
  }
  get IsPassable() {
    return this.Target.IsTargetOfRouting || this.Source.IsSourceOfRouting || this.VisibilityEdge.IsPassable == null || this.VisibilityEdge.IsPassable();
  }
  AddOccupiedEdge() {
    this.numberOfPassedPaths++;
  }
  RemoveOccupiedEdge() {
    this.numberOfPassedPaths--;
  }
}
class bg {
  get Prev() {
    return this.PrevEdge == null ? null : this.PrevEdge.Source === this ? this.PrevEdge.Target : this.PrevEdge.Source;
  }
  constructor(t) {
    this.InBoneEdges = new Array(), this.OutBoneEdges = new Array(), this.VisibilityVertex = t;
  }
  get Point() {
    return this.VisibilityVertex.point;
  }
  get Cost() {
    return this.IsSourceOfRouting ? this.cost : this.Prev == null ? Number.POSITIVE_INFINITY : this.cost;
  }
  set Cost(t) {
    this.cost = t;
  }
  SetPreviousToNull() {
    this.PrevEdge = null;
  }
}
class _i {
  constructor(t, e, i) {
    this.EdgesToRoutes = /* @__PURE__ */ new Map(), this.EdgesToRouteSources = /* @__PURE__ */ new Map(), this.MakeTransparentShapesOfEdgeGeometry = t, this.cdt = e, this.Gates = i;
  }
  CreateGraphElements() {
    for (const t of this.vertexArray) {
      const e = t.VisibilityVertex;
      for (const i of e.InEdges) {
        const s = new yg(i, this.VisibilityVerticesToSdVerts.get(i.Source), this.VisibilityVerticesToSdVerts.get(i.Target)), n = this.VisibilityVerticesToSdVerts.get(i.Source);
        t.InBoneEdges.push(s), n.OutBoneEdges.push(s);
      }
    }
  }
  CreateRoutingGraph() {
    this.vertexArray = [], this.VisibilityVerticesToSdVerts = /* @__PURE__ */ new Map();
    for (const t of this.VisibilityGraph.Vertices()) {
      const e = new bg(t);
      this.vertexArray.push(e), this.VisibilityVerticesToSdVerts.set(t, e);
    }
    this.CreateGraphElements();
  }
  // routing of the edges minimizing (ink+path length+capacity penalty)
  RouteEdges() {
    this.Initialize(), this.RestoreCapacities();
    for (const t of this.geomEdges)
      this.EdgesToRoutes.set(t, this.RouteEdge(t));
    this.RerouteEdges();
    for (const t of this.geomEdges)
      this.SetEdgeGeometryCurve(t);
  }
  SetEdgeGeometryCurve(t) {
    const e = new B();
    let i = this.EdgesToRouteSources.get(t);
    e.addPoint(i.Point);
    for (const r of this.EdgesToRoutes.get(t))
      r.SourcePoint.equal(i.Point) ? (e.addPoint(r.TargetPoint), i = r.Target) : (e.addPoint(r.SourcePoint), i = r.Source);
    t.curve = e, t.sourcePort instanceof Ve && _i.ExtendPolylineStartToClusterBoundary(e, t.sourcePort.Curve), t.targetPort instanceof Ve && _i.ExtendPolylineEndToClusterBoundary(e, t.targetPort.Curve);
  }
  static ExtendPolylineEndToClusterBoundary(t, e) {
    const i = e.closestParameter(t.end);
    t.addPoint(e.value(i));
  }
  static ExtendPolylineStartToClusterBoundary(t, e) {
    const i = e.closestParameter(t.start);
    t.PrependPoint(e.value(i));
  }
  RerouteEdges() {
    this.RestoreCapacities();
    for (const t of this.geomEdges) {
      const e = this.RerouteEdge(t);
      this.EdgesToRoutes.set(t, e);
    }
  }
  RestoreCapacities() {
    this.cdt != null && this.cdt.RestoreEdgeCapacities();
  }
  // Reroute edge
  RerouteEdge(t) {
    const e = this.EdgesToRoutes.get(t);
    for (const i of e)
      i.RemoveOccupiedEdge();
    return this.RouteEdge(t);
  }
  RouteEdge(t) {
    this.CurrentEdgeGeometry = t;
    for (let s = 0; s < this.vertexArray.length; s++) {
      const n = this.vertexArray[s];
      n.SetPreviousToNull(), n.IsTargetOfRouting = n.IsSourceOfRouting = !1;
    }
    const e = this.MakeTransparentShapesOfEdgeGeometry(t), i = this.RouteEdgeWithGroups();
    for (const s of e)
      s.IsTransparent = !1;
    return i;
  }
  RouteEdgeWithGroups() {
    for (let t = 0; t < 2; t++) {
      this.SetLengthCoefficient(), this.Queue = new is(), this.sourceLoosePoly = this.SetPortVerticesAndObstacles(this.CurrentEdgeGeometry.sourcePort, !0), this.targetLoosePoly = this.SetPortVerticesAndObstacles(this.CurrentEdgeGeometry.targetPort, !1);
      const e = this.RouteOnKnownSourceTargetVertices(this.CurrentEdgeGeometry.targetPort.Location.sub(this.CurrentEdgeGeometry.sourcePort.Location).normalize(), t === 0);
      if (e != null)
        return e;
      for (let i = 0; i < this.vertexArray.length; i++)
        this.vertexArray[i].SetPreviousToNull();
    }
    throw new Error();
  }
  RouteOnKnownSourceTargetVertices(t, e) {
    for (this.LowestCostToTarget = Number.POSITIVE_INFINITY, this.ClosestTargetVertex = null; this.Queue.count > 0; ) {
      const i = { priority: 0 }, s = this.Queue.DequeueAndGetPriority(i);
      if (!(i.priority >= this.LowestCostToTarget)) {
        for (let n = 0; n < s.OutBoneEdges.length; n++) {
          const r = s.OutBoneEdges[n];
          r.IsPassable && this.ProcessOutcomingBoneEdge(s, r, t, e);
        }
        for (let n = 0; n < s.InBoneEdges.length; n++) {
          const r = s.InBoneEdges[n];
          r.IsPassable && this.ProcessIncomingBoneEdge(s, r, t, e);
        }
      }
    }
    return this.GetPathAndUpdateRelatedCosts();
  }
  ProcessOutcomingBoneEdge(t, e, i, s) {
    s && i.dot(e.TargetPoint.sub(e.SourcePoint)) < 0 || this.ProcessBoneEdge(t, e.Target, e);
  }
  ProcessIncomingBoneEdge(t, e, i, s) {
    s && i.dot(e.SourcePoint.sub(e.TargetPoint)) < 0 || this.ProcessBoneEdge(t, e.Source, e);
  }
  ProcessBoneEdge(t, e, i) {
    const s = this.GetEdgeAdditionalCost(i, t.Cost);
    if (!(e.Cost <= s))
      if (e.Cost = s, e.PrevEdge = i, this.Queue.ContainsElement(e))
        this.Queue.DecreasePriority(e, s);
      else {
        if (e.IsTargetOfRouting) {
          let n = 0;
          this.CurrentEdgeGeometry.targetPort instanceof Ve && (n = this.LengthCoefficient * e.Point.sub(this.CurrentEdgeGeometry.targetPort.Location).length), s + n < this.LowestCostToTarget && (this.LowestCostToTarget = s + n, this.ClosestTargetVertex = e);
          return;
        }
        this.Enqueue(e);
      }
  }
  GetPathAndUpdateRelatedCosts() {
    let t = this.ClosestTargetVertex;
    if (t == null)
      return null;
    const e = new Array();
    for (; t.PrevEdge != null; )
      e.push(t.PrevEdge), this.RegisterPathInBoneEdge(t.PrevEdge), t = t.Prev;
    return this.EdgesToRouteSources.set(this.CurrentEdgeGeometry, t), e.reverse(), e;
  }
  RegisterPathInBoneEdge(t) {
    t.AddOccupiedEdge(), this.cdt != null && this.BundlingSettings.CapacityOverflowCoefficient !== 0 && this.UpdateResidualCostsOfCrossedCdtEdges(t);
  }
  UpdateResidualCostsOfCrossedCdtEdges(t) {
    for (const e of t.CrossedCdtEdges)
      this.AdjacentToSourceOrTarget(e) || (e.ResidualCapacity === e.Capacity ? e.ResidualCapacity -= this.BundlingSettings.edgeWidthShrinkCoeff * this.CurrentEdgeGeometry.lineWidth : e.ResidualCapacity -= this.BundlingSettings.ActualEdgeWidth(this.CurrentEdgeGeometry));
  }
  H(t) {
    return t.Cost + this.LengthCoefficient * t.Point.sub(this.CurrentEdgeGeometry.targetPort.Location).length;
  }
  GetEdgeAdditionalCost(t, e) {
    const i = t.TargetPoint.sub(t.SourcePoint).length;
    return this.LengthCoefficient * i + e + (t.IsOccupied ? 0 : this.BundlingSettings.InkImportance * i) + this.CapacityOverflowCost(t);
  }
  CapacityOverflowCost(t) {
    if (this.cdt == null || this.BundlingSettings.CapacityOverflowCoefficient === 0)
      return 0;
    let e = 0;
    for (const i of this.CrossedCdtEdgesOfBoneEdge(t))
      e += this.CostOfCrossingCdtEdgeLocal(this.capacityOverlowPenaltyMultiplier, this.BundlingSettings, this.CurrentEdgeGeometry, i);
    return e;
  }
  CrossedCdtEdgesOfBoneEdge(t) {
    return t.CrossedCdtEdges != null ? Array.from(t.CrossedCdtEdges) : Array.from(t.CrossedCdtEdges = this.ThreadBoneEdgeThroughCdt(t));
  }
  ThreadBoneEdgeThroughCdt(t) {
    const e = t.SourcePoint, i = t.Source.Triangle, s = /* @__PURE__ */ new Set(), n = t.TargetPoint;
    if (gt.PointIsInsideOfTriangle(n, i))
      return s;
    const r = new ur(i, e, n);
    for (; r.MoveNext(); ) {
      const o = r.CurrentPiercedEdge;
      this.Gates.has(o) && s.add(o);
    }
    return s;
  }
  // TODO: method incorrect since id doesn't check AdjacentToSourceOrTarget condition
  static CostOfCrossingCdtEdge(t, e, i, s) {
    let n = i.lineWidth * e.edgeWidthShrinkCoeff;
    s.Capacity !== s.ResidualCapacity && (n += e.EdgeSeparation * e.edgeWidthShrinkCoeff);
    const r = s.ResidualCapacity - n;
    return r >= 0 ? 0 : -r * t;
  }
  CostOfCrossingCdtEdgeLocal(t, e, i, s) {
    return this.AdjacentToSourceOrTarget(s) ? 0 : _i.CostOfCrossingCdtEdge(t, e, i, s);
  }
  AdjacentToSourceOrTarget(t) {
    return t.upperSite.Owner === this.sourceLoosePoly || t.lowerSite.Owner === this.sourceLoosePoly || t.upperSite.Owner === this.targetLoosePoly || t.lowerSite.Owner === this.targetLoosePoly;
  }
  SetLengthCoefficient() {
    const t = this.GetIdealDistanceBetweenSourceAndTarget(this.CurrentEdgeGeometry);
    this.LengthCoefficient = this.BundlingSettings.PathLengthImportance / t;
  }
  GetIdealDistanceBetweenSourceAndTarget(t) {
    return t.sourcePort.Location.sub(t.targetPort.Location).length;
  }
  SetPortVerticesAndObstacles(t, e) {
    let i;
    if (t instanceof Ve) {
      i = t.LoosePolyline;
      for (const n of i) {
        let r = 0;
        e && (r = this.LengthCoefficient * n.sub(this.CurrentEdgeGeometry.sourcePort.Location).length), this.AddAndEnqueueVertexToEnds(n, e, r);
      }
    } else if (t instanceof $t) {
      i = t.LoosePolyline;
      for (const n of i)
        this.AddAndEnqueueVertexToEnds(n, e, 0);
    } else {
      this.AddAndEnqueueVertexToEnds(t.Location, e, 0);
      const s = Array.from(this.ObstacleHierarchy.GetNodeItemsIntersectingRectangle(t.Curve.boundingBox));
      let n = s[0].boundingBox.diagonal;
      i = s[0];
      for (let r = 1; r < s.length; r++) {
        const o = s[r], l = o.boundingBox.diagonal;
        l < n && (n = l, i = o);
      }
    }
    return i;
  }
  Enqueue(t) {
    this.Queue.Enqueue(t, this.H(t));
  }
  AddAndEnqueueVertexToEnds(t, e, i) {
    const s = this.FindVertex(t), n = this.VisibilityVerticesToSdVerts.get(s);
    e ? (n.IsSourceOfRouting = !0, n.Cost = i, this.Enqueue(n)) : n.IsTargetOfRouting = !0;
  }
  FindVertex(t) {
    return this.VisibilityGraph.FindVertex(t);
  }
  Initialize() {
    this.CreateRoutingGraph(), this.cdt != null && (this.capacityOverlowPenaltyMultiplier = _i.CapacityOverflowPenaltyMultiplier(this.BundlingSettings), this.SetVertexTriangles(), this.CalculateCapacitiesOfTrianglulation());
  }
  CalculateCapacitiesOfTrianglulation() {
    for (const t of this.Gates)
      _i.CalculateCdtEdgeCapacityForEdge(t);
  }
  static CalculateCdtEdgeCapacityForEdge(t) {
    if (t.constrained || t.CwTriangle == null || t.CcwTriangle == null)
      return;
    const e = t.upperSite.Owner, i = t.lowerSite.Owner;
    if (e !== i) {
      const s = ue.DistancePoint(new ue(e), t.lowerSite.point), n = ue.DistancePoint(new ue(i), t.upperSite.point);
      t.Capacity = (s + n) / 2;
    }
  }
  SetVertexTriangles() {
    const t = Et(Array.from(this.cdt.GetTriangles()).map((i) => Bt(i, i.BoundingBox()))), e = Et(this.vertexArray.map((i) => Bt(i, T.mkOnPoints([i.Point]))));
    ae(t, e, (i, s) => this.TryToAssigenTriangleToVertex(i, s));
  }
  TryToAssigenTriangleToVertex(t, e) {
    e.Triangle == null && gt.PointIsInsideOfTriangle(e.Point, t) && (e.Triangle = t);
  }
  static CapacityOverflowPenaltyMultiplier(t) {
    return t.CapacityOverflowCoefficient * (t.PathLengthImportance + t.InkImportance);
  }
  // compute cdt edges crossed by paths
  FillCrossedCdtEdges(t) {
    for (const e of this.geomEdges) {
      this.sourceLoosePoly = this.SetPortVerticesAndObstacles(e.sourcePort, !0), this.targetLoosePoly = this.SetPortVerticesAndObstacles(e.targetPort, !1);
      for (const i of this.EdgesToRoutes.get(e))
        for (const s of this.CrossedCdtEdgesOfBoneEdge(i))
          this.AdjacentToSourceOrTarget(s) || Or(t, e, s);
    }
  }
}
class Wr {
  constructor(t, e, i, s, n) {
    this.multiEdges = t, this.interactiveEdgeRouter = e, this.bundlingSettings = s, this.bundlingSettings.edgeWidthShrinkCoeff = 1, this.transparentShapeSetter = n, this.nodeTree = Ar(i, (r) => r.boundingBox);
  }
  run() {
    for (const t of this.GetIndependantPreGraphs())
      new En(t.edges, new _i(this.transparentShapeSetter, null, null), this.interactiveEdgeRouter.VisibilityGraph, this.bundlingSettings, this.interactiveEdgeRouter.LoosePadding, this.interactiveEdgeRouter.TightHierarchy, this.interactiveEdgeRouter.LooseHierarchy, null, null, null).run();
  }
  GetPortCurve(t) {
    return this.nodeTree.FirstHitNodeWithPredicate(t.Location, (i, s) => g.PointRelativeToCurveLocation(i, s) !== F.Outside ? at.Stop : at.Continue).UserData;
  }
  // creates a set of pregraphs suitable for bundle routing
  GetIndependantPreGraphs() {
    const t = this.CreateInitialPregraphs();
    do {
      const e = t.length, i = { preGraphs: t };
      if (this.UniteConnectedPreGraphs(i), e <= t.length)
        break;
    } while (!0);
    return t;
  }
  UniteConnectedPreGraphs(t) {
    const e = Wr.GetIntersectionGraphOfPreGraphs(t.preGraphs);
    if (e == null)
      return;
    const i = Qs(e), s = new Array();
    for (const n of i) {
      let r = null;
      for (const o of n)
        r == null ? (r = t.preGraphs[o], s.push(r)) : r.AddGraph(t.preGraphs[o]);
    }
    t.preGraphs = s;
    for (const n of t.preGraphs)
      this.AddIntersectingNodes(n);
  }
  AddIntersectingNodes(t) {
    const e = t.boundingBox;
    for (const i of this.nodeTree.GetNodeItemsIntersectingRectangle(e))
      t.AddNodeBoundary(i);
  }
  static GetIntersectionGraphOfPreGraphs(t) {
    const e = Wr.EnumeratePairsOfIntersectedPreGraphs(t);
    return e.length ? fi(e, t.length) : null;
  }
  static EnumeratePairsOfIntersectedPreGraphs(t) {
    const e = Array.from(Array(t.length).keys()), i = Ar(e, (n) => t[n].boundingBox), s = new Array();
    return Xt(i, i, (n, r) => s.push(new U(n, r))), s;
  }
  CreateInitialPregraphs() {
    return this.multiEdges.map((t) => this.CreatePregraphFromSetOfEdgeGeometries(t));
  }
  CreatePregraphFromSetOfEdgeGeometries(t) {
    const e = /* @__PURE__ */ new Set(), i = t[0], s = this.GetPortCurve(i.sourcePort), n = s.boundingBox;
    e.add(s), e.add(i.targetPort.Curve), n.addRec(i.targetPort.Curve.boundingBox);
    const r = this.nodeTree.GetNodeItemsIntersectingRectangle(n);
    for (const o of r)
      e.add(o);
    return ba.constructorStatic(t, e);
  }
}
class vg {
  constructor() {
    this.triangles = /* @__PURE__ */ new Set();
  }
  setCdt(t) {
    this.cdt = t, this.cdt.SetInEdges();
    const e = /* @__PURE__ */ new Set();
    for (const i of t.GetTriangles())
      for (const s of i.Sites)
        s.Owner != null && e.add(s.Owner);
  }
  outsideOfObstacles(t) {
    var e;
    if (t == null)
      return !1;
    const i = (e = t.Sites.item0.Owner) !== null && e !== void 0 ? e : t.Sites.item1.Owner;
    return i === this.sourcePoly || i === this.targetPoly || !Cg(t);
  }
  /** following "https://page.mi.fu-berlin.de/mulzer/notes/alggeo/polySP.pdf" */
  run(t) {
    if (this.triangles.clear(), this.poly = t, this.d = [], t.count <= 2 || this.cdt == null)
      return;
    this.sourcePoly = this.findPoly(t.start), this.targetPoly = this.findPoly(t.end), this.findChannelTriangles();
    let e = this.getPerimeterEdges();
    e = this.fillTheCollapedSites(e);
    const i = new gt([], [], Array.from(e).map((n) => ({ A: n.lowerSite.point, B: n.upperSite.point })));
    i.run();
    const s = this.getSleeve(this.findSourceTriangle(i));
    if (s == null) {
      console.log("failed to create sleeve");
      return;
    }
    if (s.length == 0) {
      this.poly = B.mkFromPoints([t.start, t.end]);
      return;
    }
    this.initDiagonals(s), this.refineFunnel();
  }
  /**A function that returns an array of all crossed triangles
   * by a line segment from start to end
   * assuming the initial triangle contains the start point*/
  getAllCrossedTriangles(t, e, i) {
    const s = [], n = [];
    let r = null;
    for (n.push(t); n.length > 0; ) {
      const o = n.pop();
      if (r == null && o.containsPoint(i) && (r = o), o.intersectsLine(e, i, 0)) {
        s.push(o);
        for (const l of o.Edges) {
          const h = l.GetOtherTriangle_T(o);
          h && !s.includes(h) && !n.includes(h) && n.push(h);
        }
      }
    }
    return { triangles: s, containsEnd: r };
  }
  findChannelTriangles() {
    let e = this.cdt.FindSite(this.poly.start).Triangles().next().value;
    this.triangles.clear();
    for (let i = this.poly.startPoint; i.next != null; i = i.next) {
      const s = this.getAllCrossedTriangles(e, i.point, i.next.point);
      e = s.containsEnd;
      for (const n of s.triangles)
        this.outsideOfObstacles(n) && this.triangles.add(n);
    }
  }
  findPoly(t) {
    var e;
    const i = this.cdt.FindSite(t);
    for (const s of i.Edges)
      return (e = s.lowerSite.Owner) !== null && e !== void 0 ? e : s.upperSite.Owner;
  }
  /** Because of the floating point operations we might miss some triangles and get a polygon collapsing to a point somewhere inside of the polyline.
   * This point will correspond to a site adjacent to more than two edges from 'perimeter'.
   * We add to the polygon all the 'legal' triangles adjacent to this cite.
   */
  fillTheCollapedSites(t) {
    const e = /* @__PURE__ */ new Map();
    for (const n of t)
      s(n.lowerSite, n), s(n.upperSite, n);
    const i = [];
    for (const [n, r] of e)
      r.length > 2 && i.push(n);
    if (i.length == 0)
      return t;
    for (const n of i)
      for (const r of n.Triangles())
        this.outsideOfObstacles(r) && this.triangles.add(r);
    return this.getPerimeterEdges();
    function s(n, r) {
      let o = e.get(n);
      o == null && e.set(n, o = []), o.push(r);
    }
  }
  findSourceTriangle(t) {
    let e;
    for (const i of t.GetTriangles())
      if (i.containsPoint(this.poly.start)) {
        e = i;
        break;
      }
    return e;
  }
  // debugDraw(triangles: Tr[], perimEdges: Set<Ed>, poly: Polyline, originalPoly: Polyline, strangeObs: ICurve[] = [], ls: ICurve = null) {
  //   const dc = []
  //   if (ls) {
  //     dc.push(DebugCurve.mkDebugCurveTWCI(255, 5, 'PapayaWhip', ls))
  //   }
  //   const box = this.poly.boundingBox.clone()
  //   box.addRec(this.sourcePoly.boundingBox)
  //   box.addRec(this.targetPoly.boundingBox)
  //   for (const t of triangles) {
  //     // if (t.BoundingBox().intersects(box) == false) continue
  //     for (const e of t.Edges) {
  //       dc.push(
  //         DebugCurve.mkDebugCurveTWCI(
  //           e.constrained ? 150 : 100,
  //           e.constrained ? 1.5 : 1,
  //           e.constrained ? 'DarkSeaGreen' : 'Cyan',
  //           LineSegment.mkPP(e.upperSite.point, e.lowerSite.point),
  //         ),
  //       )
  //     }
  //   }
  //   if (perimEdges) {
  //     for (const e of perimEdges) {
  //       dc.push(DebugCurve.mkDebugCurveTWCI(200, 2.5, 'Blue', LineSegment.mkPP(e.lowerSite.point, e.upperSite.point)))
  //     }
  //   }
  //   if (poly) dc.push(DebugCurve.mkDebugCurveTWCI(200, 1, 'Green', poly))
  //   for (const strangeOb of strangeObs) {
  //     dc.push(DebugCurve.mkDebugCurveTWCI(200, 3, 'Pink', strangeOb))
  //   }
  //   if (originalPoly) dc.push(DebugCurve.mkDebugCurveTWCI(200, 1, 'Brown', originalPoly))
  //   dc.push(DebugCurve.mkDebugCurveTWCI(200, 0.5, 'Violet', this.sourcePoly))
  //   dc.push(DebugCurve.mkDebugCurveTWCI(200, 0.5, 'Magenta', this.targetPoly))
  //   writeDebugCurves('./tmp/poly' + ++drawCount + '.svg', dc)
  // }
  refineFunnel() {
    const t = [];
    let e = this.poly.start;
    const i = { point: e }, s = { point: e };
    let n = { point: this.d[0].left, prev: i }, r = { point: this.d[0].right, prev: s };
    i.next = n, s.next = r;
    let o;
    for (let I = 1; I < this.d.length; I++)
      h(I, this.d);
    this.d.push({ right: this.poly.end, left: n.point }), h(this.d.length - 1, this.d);
    const l = B.mkFromPoints(t);
    for (let I = s; I != null; I = I.next)
      l.addPoint(I.point);
    this.poly = l;
    function h(I, x) {
      if (x[I - 1].left !== x[I].left) {
        o = x[I].left;
        let M = n;
        for (; !(C(M) || f(M)); M = M.prev)
          ;
        C(M) ? P() : N(M);
      } else {
        o = x[I].right;
        let M = r;
        for (; !(C(M) || p(M)); M = M.prev)
          ;
        C(M) ? y() : w(M);
      }
    }
    function c(I) {
      return I.next == null ? !0 : u.pointToTheLeftOfLineOrOnLine(o, I.point, I.next.point);
    }
    function d(I) {
      return I.next == null ? !0 : u.pointToTheRightOfLineOrOnLine(o, I.point, I.next.point);
    }
    function f(I) {
      return u.pointToTheLeftOfLine(o, I.prev.point, I.point);
    }
    function p(I) {
      return u.pointToTheRightOfLine(o, I.prev.point, I.point);
    }
    function P() {
      let I = s;
      for (; !c(I); )
        I = I.next;
      if (!C(I)) {
        let x = s;
        for (; !x.point.equal(I.point); x = x.next)
          t.push(x.point);
        s.point = x.point, s.next = x.next, e = x.point, r.point.equal(s.point) && (r.prev = r.next = null);
      }
      i.point = e, n.point = o, n.prev = i, i.next = n;
    }
    function y() {
      let I = i;
      for (; !d(I); )
        I = I.next;
      if (!C(I)) {
        let x = i;
        for (; !x.point.equal(I.point); x = x.next)
          t.push(x.point);
        i.point = x.point, i.next = x.next, e = x.point, n.point.equal(i.point) && (n.prev = i.next = null);
      }
      s.point = e, r.point = o, r.prev = s, s.next = r;
    }
    function C(I) {
      return I.point == e;
    }
    function w(I) {
      I != r ? (r.point = o, r.prev = I, I.next = r) : (r = { point: o, prev: I }, I.next = r);
    }
    function N(I) {
      I != n ? (n.point = o, n.prev = I, I.next = n) : (n = { point: o, prev: I }, I.next = n);
    }
  }
  initDiagonals(t) {
    for (const e of t) {
      const i = e.edge, s = e.source.OppositeSite(i);
      u.getTriangleOrientation(s.point, i.lowerSite.point, i.upperSite.point) == L.Counterclockwise ? this.d.push({ left: i.upperSite.point, right: i.lowerSite.point }) : this.d.push({ right: i.upperSite.point, left: i.lowerSite.point });
    }
  }
  getSleeve(t) {
    const e = new We.Queue();
    e.enqueue(t);
    const i = /* @__PURE__ */ new Map();
    for (i.set(t, void 0); e.length > 0; ) {
      const s = e.dequeue(), n = i.get(s);
      if (s.containsPoint(this.poly.end))
        return this.recoverPath(t, i, s);
      for (const r of s.Edges) {
        if (r.constrained || n !== void 0 && r === n)
          continue;
        const o = r.GetOtherTriangle_T(s);
        o != null && (i.has(o) || (i.set(o, r), e.enqueue(o)));
      }
    }
  }
  recoverPath(t, e, i) {
    const s = [];
    for (let n = i; n != t && n !== t; ) {
      const r = e.get(n);
      n = r.GetOtherTriangle_T(n), s.push({ source: n, edge: r });
    }
    return s.reverse();
  }
  getPerimeterEdges() {
    const t = /* @__PURE__ */ new Set();
    for (const e of this.triangles)
      for (const i of e.Edges)
        this.triangles.has(i.GetOtherTriangle_T(e)) || t.add(i);
    return t;
  }
}
function Cg(a) {
  return a.Sites.item0.Owner == null || a.Sites.item1.Owner == null || a.Sites.item2.Owner == null ? !0 : a.Sites.item0.Owner == a.Sites.item1.Owner && a.Sites.item0.Owner == a.Sites.item2.Owner;
}
class it extends ht {
  get ContinueOnOverlaps() {
    return this.continueOnOverlaps;
  }
  set ContinueOnOverlaps(t) {
    this.continueOnOverlaps = t;
  }
  get LoosePadding() {
    return this.loosePadding;
  }
  set LoosePadding(t) {
    this.loosePadding = t;
  }
  get MultiEdgesSeparation() {
    return this.multiEdgesSeparation;
  }
  set MultiEdgesSeparation(t) {
    this.multiEdgesSeparation = t;
  }
  static mk2(t, e) {
    return it.mk5(t, e.Padding, e.PolylinePadding, e.ConeAngle, e.bundlingSettings);
  }
  static mk4(t, e, i, s) {
    return new it(t, Array.from(t.deepEdges), e, i, s, null);
  }
  // Creates a spline group router for the given graph
  static mk5(t, e, i, s, n) {
    return new it(t, Array.from(t.deepEdges), e, i, s, n);
  }
  // Creates a spline group router for a given GeomGraph.
  constructor(t, e, i = 1, s = 2, n = 30 * (Math.PI / 180), r = null, o = null) {
    super(o), this.continueOnOverlaps = !0, this.shapesToTightLooseCouples = /* @__PURE__ */ new Map(), this.multiEdgesSeparation = 0.5, this.routeMultiEdgesAsBundles = !0, this.UsePolylineEndShortcutting = !0, this.UseInnerPolylingShortcutting = !0, this.AllowedShootingStraightLines = !0, this._overlapsDetected = !1, this.edges = e, this.BundlingSettings = r, this.geomGraph = t, this.LoosePadding = s, this.tightPadding = i, this.coneAngle = n, this.routeMultiEdgesAsBundles = e.length < 1e3 && t.deepNodeCount < 1e3;
  }
  static mk6(t, e, i, s, n, r) {
    const o = it.mk4(t, e, i, s), l = ze.GetShapes(n, r);
    return o.Initialize(l, s), o;
  }
  Initialize(t, e) {
    this.rootShapes = t.filter((i) => i.Parents == null || i.Parents.length === 0), this.coneAngle = e, this.coneAngle === 0 && (this.coneAngle = Math.PI / 6);
  }
  // Executes the algorithm.
  run() {
    if (this.edges.length == 0 || this.geomGraph.isEmpty())
      return;
    console.time("SplineRouter");
    const t = le.GetShapes(this.geomGraph, this.edges);
    this.BundlingSettings == null && this.geomGraph.layoutSettings && this.geomGraph.layoutSettings.commonSettings.edgeRoutingSettings && this.geomGraph.layoutSettings.commonSettings.edgeRoutingSettings.bundlingSettings && (this.BundlingSettings = this.geomGraph.layoutSettings.commonSettings.edgeRoutingSettings.bundlingSettings), this.Initialize(t, this.coneAngle), this.GetOrCreateRoot(), this.RouteOnRoot(), this.RemoveRoot(), console.timeEnd("SplineRouter");
  }
  /** Uses the existing routes and optimizing them only to avoid 'activeNodes'.   */
  rerouteOnSubsetOfNodes(t) {
    this.RouteMultiEdgesAsBundles = !1, this.edges = Array.from(this.geomGraph.deepEdges).filter((i) => hr(i.edge, t));
    const e = le.GetShapes(this.geomGraph, this.edges);
    this.rootShapes = e.filter((i) => i.Parents == null || i.Parents.length === 0), this.GetOrCreateRoot(), this.CalculateShapeToBoundaries(this.root), this.calcLooseShapesToNodes(), this.CalculatePortsToShapes(), this.rerouteOnActiveNodes(t), this.RemoveRoot();
  }
  calcLooseShapesToNodes() {
    if (this.loosePolylinesToNodes = /* @__PURE__ */ new Map(), !this.OverlapsDetected) {
      for (const [i, s] of this.shapesToTightLooseCouples)
        this.loosePolylinesToNodes.set(s.LooseShape.BoundaryCurve, /* @__PURE__ */ new Set([i.node.node]));
      return;
    }
    const t = Ar(this.geomGraph.nodesBreadthFirst, (i) => i.boundingBox), e = this.GetLooseHierarchy();
    ae(e, t, (i, s) => {
      if (g.CurveIsInsideOther(s.boundaryCurve, i)) {
        let n = this.loosePolylinesToNodes.get(i);
        for (const r of s.getAncestors())
          if (!(r instanceof Nt && r.parent == null) && r.boundaryCurve != null && g.CurveIsInsideOther(r.boundaryCurve, i))
            return;
        n == null && this.loosePolylinesToNodes.set(i, n = /* @__PURE__ */ new Set()), n.add(s.node);
      }
    });
  }
  RouteOnRoot() {
    to(0), this.CalculatePortsToShapes(), this.CalculatePortsToEnterableShapes(), this.CalculateShapeToBoundaries(this.root), !(this.OverlapsDetected && !this.ContinueOnOverlaps) && (this.BindLooseShapes(), this.SetLoosePolylinesForAnywherePorts(), this.CalculateVisibilityGraph(), this.RouteOnVisGraph());
  }
  CalculatePortsToEnterableShapes() {
    this.portsToEnterableShapes = /* @__PURE__ */ new Map();
    for (const [t, e] of this.portsToShapes) {
      const i = /* @__PURE__ */ new Set();
      it.EdgesAttachedToPortAvoidTheNode(t) || i.add(e), this.portsToEnterableShapes.set(t, i);
    }
    for (const t of this.rootShapes)
      for (const e of t.Descendants())
        for (const i of e.Ports) {
          const s = this.portsToEnterableShapes.get(i);
          an(s, Array.from(e.Ancestors()).filter((n) => n.BoundaryCurve != null));
        }
  }
  static EdgesAttachedToPortAvoidTheNode(t) {
    return t instanceof Oe || t instanceof Ve;
  }
  SetLoosePolylinesForAnywherePorts() {
    for (const [t, e] of this.shapesToTightLooseCouples)
      for (const i of t.Ports) {
        if (i instanceof $t) {
          const n = i;
          n.LoosePolyline = e.LooseShape.BoundaryCurve;
        }
        if (i instanceof Ve) {
          const n = i;
          n.LoosePolyline = e.LooseShape.BoundaryCurve;
        }
      }
  }
  BindLooseShapes() {
    this.looseRoot = new qs();
    for (const t of this.root.Children) {
      const e = this.shapesToTightLooseCouples.get(t).LooseShape;
      this.BindLooseShapesUnderShape(t), this.looseRoot.AddChild(e);
    }
  }
  BindLooseShapesUnderShape(t) {
    const e = this.shapesToTightLooseCouples.get(t).LooseShape;
    for (const i of t.Children) {
      const s = this.shapesToTightLooseCouples.get(i).LooseShape;
      e.AddChild(s), this.BindLooseShapesUnderShape(i);
    }
  }
  CalculateShapeToBoundaries(t) {
    if (this.ProgressStep(), t.Children.length === 0)
      return;
    for (const i of t.Children)
      this.CalculateShapeToBoundaries(i);
    const e = Number.POSITIVE_INFINITY;
    this.obstacleCalculator = new da(t, this.tightPadding, Math.min(this.AdjustedLoosePadding, e), this.shapesToTightLooseCouples), this.obstacleCalculator.Calculate(0.01), this.OverlapsDetected || (this.OverlapsDetected = this.obstacleCalculator.OverlapsDetected);
  }
  get OverlapsDetected() {
    return this._overlapsDetected;
  }
  set OverlapsDetected(t) {
    this._overlapsDetected = t;
  }
  get AdjustedLoosePadding() {
    return this.BundlingSettings == null ? this.LoosePadding : this.LoosePadding * En.SuperLoosePaddingCoefficient;
  }
  GroupEdgesByPassport() {
    const t = new Array();
    for (const e of this.edges) {
      const i = this.EdgePassport(e);
      let s = t.find((n) => Tr(n.passport, i));
      s || (s = { passport: i, edges: [] }, t.push(s)), s.edges.push(e);
    }
    return t;
  }
  RouteOnVisGraph() {
    if (this.ancestorSets = it.GetAncestorSetsMap(Array.from(this.root.Descendants())), this.BundlingSettings == null) {
      const t = this.GroupEdgesByPassport();
      for (let e = 0; e < t.length; e++) {
        const i = t[e], s = i.passport, n = this.GetObstaclesFromPassport(s), r = this.CreateInteractiveEdgeRouter(Array.from(n));
        this.RouteEdgesWithTheSamePassport(i, r, n);
      }
    } else
      this.RouteBundles();
  }
  rerouteOnActiveNodes(t) {
    if (this.ancestorSets = it.GetAncestorSetsMap(Array.from(this.root.Descendants())), this.BundlingSettings == null)
      for (const e of this.GroupEdgesByPassport()) {
        const i = e.passport, s = this.GetObstaclesFromPassport(i), n = /* @__PURE__ */ new Set();
        for (const o of s) {
          const l = this.LooseShapeOfOriginalShape(o);
          for (const h of this.loosePolylinesToNodes.get(l.BoundaryCurve))
            t.has(h) && n.add(o);
        }
        const r = this.CreateInteractiveEdgeRouter(Array.from(n));
        this.rerouteEdgesWithTheSamePassportActiveNodes(e, r, n, t);
      }
    else
      this.RouteBundles();
  }
  getDebugCurvesFromEdgesAndCdt(t) {
    const e = Array.from(this.geomGraph.deepEdges).map((i) => i.curve).filter((i) => i != null).filter((i) => i.count > 5).map((i) => q.mkDebugCurveTWCI(200, 1, "Red", i));
    for (const i of t.PointsToSites.values())
      for (const s of i.Edges)
        e.push(q.mkDebugCurveTWCI(200, 0.5, s.constrained ? "Blue" : "Green", v.mkPP(s.lowerSite.point, s.upperSite.point)));
    return e;
  }
  RouteEdgesWithTheSamePassport(t, e, i) {
    const s = {
      regularEdges: [],
      multiEdges: []
    };
    try {
      const n = this.getCdtFromPassport(i);
      e.pathOptimizer.setCdt(n);
    } catch {
      e.pathOptimizer.setCdt(null);
    }
    if (this.RouteMultiEdgesAsBundles) {
      if (this.SplitOnRegularAndMultiedges(t.edges, s), s.regularEdges.length > 0)
        for (let n = 0; n < s.regularEdges.length; n++)
          this.routeEdge(e, s.regularEdges[n]);
      s.multiEdges != null && (this.ScaleDownLooseHierarchy(e, i), this.RouteMultiEdges(s.multiEdges, e, t.passport));
    } else
      for (let n = 0; n < t.edges.length; n++)
        this.routeEdge(e, t.edges[n]);
  }
  /** edgeToPolys maps edges to their original polyline routes */
  rerouteEdgesWithTheSamePassportActiveNodes(t, e, i, s) {
    const n = {
      regularEdges: [],
      multiEdges: []
    };
    try {
      const r = this.getCdtFromPassport(i);
      e.pathOptimizer.setCdt(r);
    } catch (r) {
      console.log(r), e.pathOptimizer.setCdt(null);
    }
    if (this.RouteMultiEdgesAsBundles) {
      if (this.SplitOnRegularAndMultiedges(t.edges, n), n.regularEdges.length > 0)
        for (let r = 0; r < n.regularEdges.length; r++) {
          const o = n.regularEdges[r];
          lt.assert(hr(o.edge, s)), this.rerouteEdge(e, o);
        }
      n.multiEdges != null && (this.ScaleDownLooseHierarchy(e, i), this.RouteMultiEdges(n.multiEdges, e, t.passport));
    } else
      for (let r = 0; r < t.edges.length; r++) {
        const o = t.edges[r];
        hr(o.edge, s) && this.rerouteEdge(e, o);
      }
  }
  /** poly gives the polyline to reroute */
  rerouteEdge(t, e) {
    try {
      t.rerouteEdge(e), vt.trimSplineAndCalculateArrowheadsII(e, e.sourcePort.Curve, e.targetPort.Curve, e.curve, !1);
    } catch {
      console.log("failed");
    }
  }
  getCdtFromPassport(t) {
    const e = /* @__PURE__ */ new Set(), i = [], s = T.mkEmpty();
    for (const o of t) {
      const l = this.LoosePolyOfOriginalShape(o);
      if (l != null) {
        e.add(l);
        for (const h of o.Ports)
          i.push(h.Location);
        s.addRecSelf(l.boundingBox);
      }
    }
    s.pad(Math.max(s.diagonal / 4, 100));
    const n = Array.from(e);
    n.push(s.perimeter());
    const r = new gt(i, n, []);
    return r.run(), r;
  }
  // if set to true routes multi edges as ordered bundles
  get RouteMultiEdgesAsBundles() {
    return this.routeMultiEdgesAsBundles;
  }
  set RouteMultiEdgesAsBundles(t) {
    this.routeMultiEdgesAsBundles = t;
  }
  routeEdge(t, e) {
    const i = this.makeTransparentShapesOfEdgeAndGetTheShapes(e);
    this.ProgressStep(), this.RouteEdgeInternal(e, t), it.SetTransparency(i, !1);
  }
  ScaleDownLooseHierarchy(t, e) {
    const i = new Array();
    for (const s of e) {
      const n = this.shapesToTightLooseCouples.get(s);
      i.push(G.LoosePolylineWithFewCorners(
        n.TightPolyline,
        n.Distance / 1.1,
        // 1.1 is BundleRouter.SuperLoosePaddingCoefficient,
        0
      ));
    }
    t.LooseHierarchy = it.CreateLooseObstacleHierarachy(i), t.ClearActivePolygons(), t.AddActivePolygons(i.map((s) => new ue(s)));
  }
  RouteMultiEdges(t, e, i) {
    const s = [];
    for (const o of i)
      for (const l of o.Children)
        s.push(l.BoundaryCurve);
    const n = new Dt();
    n.InkImportance = 1e-5, n.EdgeSeparation = this.MultiEdgesSeparation, new Wr(t, e, s, n, (o) => this.makeTransparentShapesOfEdgeAndGetTheShapes(o)).run();
  }
  SplitOnRegularAndMultiedges(t, e) {
    const i = new Rn();
    for (const s of t)
      it.IsEdgeToParent(s) ? e.regularEdges.push(s) : it.RegisterInPortLocationsToEdges(s, i);
    e.multiEdges = null;
    for (const s of i.values())
      s.length === 1 || this.OverlapsDetected ? Di(e.regularEdges, s) : (e.multiEdges == null && (e.multiEdges = new Array()), e.multiEdges.push(s));
  }
  static RegisterInPortLocationsToEdges(t, e) {
    let i;
    const s = new ie(t.sourcePort.Location, t.targetPort.Location);
    i = e.get(s), i || (i = new Array(), e.set(s, i)), i.push(t);
  }
  static IsEdgeToParent(t) {
    return t.sourcePort instanceof $t || t.targetPort instanceof $t;
  }
  CreateInteractiveEdgeRouter(t) {
    const e = new Set(t.map((s) => this.shapesToTightLooseCouples.get(s).LooseShape.BoundaryCurve)), i = new tt(this.cancelToken);
    return i.pathOptimizer = new vg(), i.ObstacleCalculator = new G(t.map((s) => s.BoundaryCurve), this.tightPadding, this.loosePadding, !1), i.VisibilityGraph = this.visGraph, i.TightHierarchy = this.CreateTightObstacleHierarachy(t), i.LooseHierarchy = it.CreateLooseObstacleHierarachy(Array.from(e)), i.UseSpanner = !0, i.LookForRoundedVertices = !0, i.TightPadding = this.tightPadding, i.LoosePadding = this.LoosePadding, i.UseEdgeLengthMultiplier = this.UseEdgeLengthMultiplier, i.UsePolylineEndShortcutting = this.UsePolylineEndShortcutting, i.UseInnerPolylingShortcutting = this.UseInnerPolylingShortcutting, i.AllowedShootingStraightLines = this.AllowedShootingStraightLines, i.AddActivePolygons(Array.from(e).map((s) => new ue(s))), i;
  }
  GetObstaclesFromPassport(t) {
    if (t.size === 0)
      return new Set(this.root.Children);
    const e = this.GetCommonAncestorsAbovePassport(t), i = this.GetAllAncestors(t), s = /* @__PURE__ */ new Set();
    for (const o of t)
      for (const l of o.Children)
        i.has(l) || s.add(l);
    const n = js(new Set(t), s), r = new We.Queue();
    for (const o of t)
      e.has(o) || r.enqueue(o);
    for (; r.length > 0; ) {
      const o = r.dequeue();
      for (const l of o.Parents) {
        for (const h of l.Children)
          i.has(h) || s.add(h);
        !e.has(l) && !n.has(l) && (r.enqueue(l), n.add(l));
      }
    }
    return s;
  }
  GetAllAncestors(t) {
    if (t.size === 0)
      return /* @__PURE__ */ new Set();
    let e = new Set(t);
    for (const i of t)
      e = js(e, this.ancestorSets.get(i));
    return e;
  }
  GetCommonAncestorsAbovePassport(t) {
    if (t.size === 0)
      return /* @__PURE__ */ new Set();
    const e = Array.from(t);
    let i = this.ancestorSets.get(e[0]);
    for (let s = 1; s < e.length; s++) {
      const n = e[s];
      i = Hi(i, this.ancestorSets.get(n));
    }
    return i;
  }
  RouteBundles() {
    this.ScaleLooseShapesDown(), this.CalculateEdgeEnterablePolylines();
    const t = this.GetLooseHierarchy(), e = jh(t), i = new _i((n) => this.makeTransparentShapesOfEdgeAndGetTheShapes(n), e, this.FindCdtGates(e));
    new En(this.edges, i, this.visGraph, this.BundlingSettings, this.LoosePadding, this.GetTightHierarchy(), t, this.enterableLoose, this.enterableTight, (n) => this.LoosePolyOfOriginalShape(this.portsToShapes.get(n))).run();
  }
  CreateTheMapToParentLooseShapes(t, e) {
    for (const i of t.Children) {
      const n = this.shapesToTightLooseCouples.get(i).LooseShape.BoundaryCurve;
      e.set(n, t), this.CreateTheMapToParentLooseShapes(i, e);
    }
  }
  FindCdtGates(t) {
    const e = /* @__PURE__ */ new Map();
    this.CreateTheMapToParentLooseShapes(this.root, e);
    const i = /* @__PURE__ */ new Set();
    for (const s of t.PointsToSites.values())
      for (const n of s.Edges) {
        if (n.CwTriangle == null && n.CcwTriangle == null)
          continue;
        const r = s.Owner, o = n.lowerSite.Owner;
        if (r === o)
          continue;
        const l = e.get(r);
        if (l) {
          const h = e.get(o);
          l === h && i.add(n);
        }
      }
    return i;
  }
  CalculateEdgeEnterablePolylines() {
    this.enterableLoose = /* @__PURE__ */ new Map(), this.enterableTight = /* @__PURE__ */ new Map();
    for (const t of this.edges) {
      const e = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set();
      this.GetEdgeEnterablePolylines(t, e, i), this.enterableLoose.set(t, e), this.enterableTight.set(t, i);
    }
  }
  GetEdgeEnterablePolylines(t, e, i) {
    const s = this.portsToShapes.get(t.sourcePort), n = this.portsToShapes.get(t.targetPort);
    s !== this.root && this.GetEnterablesForShape(s, e, i), n !== this.root && this.GetEnterablesForShape(n, e, i);
  }
  GetEnterablesForShape(t, e, i) {
    for (const s of this.ancestorSets.get(t)) {
      const n = this.LoosePolyOfOriginalShape(s);
      n && e.add(n);
      const r = this.TightPolyOfOriginalShape(s);
      r && i.add(r);
    }
  }
  GetTightHierarchy() {
    return Et(Array.from(this.shapesToTightLooseCouples.values()).map((t) => Bt(t.TightPolyline, t.TightPolyline.boundingBox)));
  }
  GetLooseHierarchy() {
    const t = /* @__PURE__ */ new Set();
    for (const e of this.shapesToTightLooseCouples.values())
      t.add(e.LooseShape.BoundaryCurve);
    return Et(Array.from(t).map((e) => Bt(e, e.boundingBox)));
  }
  ScaleLooseShapesDown() {
    for (const [, t] of this.shapesToTightLooseCouples)
      t.LooseShape.BoundaryCurve = G.LoosePolylineWithFewCorners(t.TightPolyline, t.Distance / En.SuperLoosePaddingCoefficient, 0);
  }
  /**
   * The set of shapes where the edge source and target ports shapes are citizens: the shapes who's interior the edge can cross
   *   In the simple case it is the union of the target port shape parents and the sourceport shape parents.
   *   When one end shape contains another, the passport is the set consisting of the end shape and all other shape parents.
   */
  EdgePassport(t) {
    const e = /* @__PURE__ */ new Set(), i = this.portsToShapes.get(t.sourcePort), s = this.portsToShapes.get(t.targetPort);
    return this.IsAncestor(i, s) ? (an(e, s.Parents), e.add(i), e) : this.IsAncestor(s, i) ? (an(e, i.Parents), e.add(s), e) : (i !== this.looseRoot && an(e, i.Parents), s !== this.looseRoot && an(e, s.Parents), e);
  }
  *AllPorts() {
    for (const t of this.edges)
      yield t.sourcePort, yield t.targetPort;
  }
  CalculatePortsToShapes() {
    this.portsToShapes = /* @__PURE__ */ new Map();
    for (const t of this.root.Descendants())
      for (const e of t.Ports)
        this.portsToShapes.set(e, t);
    for (const t of this.AllPorts())
      this.portsToShapes.has(t) || (this.root.Ports.add(t), this.portsToShapes.set(t, this.root));
  }
  RouteEdgeInternal(t, e) {
    const i = new Array();
    t.sourcePort instanceof $t || Di(i, this.AddVisibilityEdgesFromPort(t.sourcePort)), t.targetPort instanceof $t || Di(i, this.AddVisibilityEdgesFromPort(t.targetPort));
    const s = { smoothedPolyline: null };
    if (u.closeDistEps(t.sourcePort.Location, t.targetPort.Location) ? t.curve = Kt.RouteSelfEdge(t.sourcePort.Curve, Math.max(this.LoosePadding * 2, t.GetMaxArrowheadLength()), s) : t.curve = e.RouteSplineFromPortToPortWhenTheWholeGraphIsReady(t.sourcePort, t.targetPort, !0, s), t.smoothedPolyline = null, t.curve == null)
      throw new Error();
    for (const n of i)
      wt.RemoveEdge(n);
    vt.trimSplineAndCalculateArrowheadsII(t, t.sourcePort.Curve, t.targetPort.Curve, t.curve, !1);
  }
  *AddVisibilityEdgesFromPort(t) {
    let e, i;
    if (t instanceof Oe || !(e = this.portsToShapes.get(t)) || !(i = this.shapesToTightLooseCouples.get(e)))
      return;
    const s = i.LooseShape;
    for (const n of s.BoundaryCurve)
      this.visGraph.FindEdgePP(t.Location, n) == null && (yield this.visGraph.AddEdgePP(t.Location, n));
  }
  makeTransparentShapesOfEdgeAndGetTheShapes(t) {
    const e = this.portsToShapes.get(t.sourcePort), i = this.portsToShapes.get(t.targetPort), s = new Array();
    for (const n of this.GetTransparentShapes(t.sourcePort, t.targetPort, e, i))
      n != null && s.push(this.LooseShapeOfOriginalShape(n));
    for (const n of this.portsToEnterableShapes.get(t.sourcePort))
      s.push(this.LooseShapeOfOriginalShape(n));
    for (const n of this.portsToEnterableShapes.get(t.targetPort))
      s.push(this.LooseShapeOfOriginalShape(n));
    return it.SetTransparency(s, !0), s;
  }
  LooseShapeOfOriginalShape(t) {
    return t === this.root ? this.looseRoot : this.shapesToTightLooseCouples.get(t).LooseShape;
  }
  LoosePolyOfOriginalShape(t) {
    return this.LooseShapeOfOriginalShape(t).BoundaryCurve;
  }
  TightPolyOfOriginalShape(t) {
    return t === this.root ? null : this.shapesToTightLooseCouples.get(t).TightPolyline;
  }
  //    static GetEdgeColor(e: VisibilityEdge, sourcePort: Port, targetPort: Port): string {
  //  if (((sourcePort == null )
  //    || (targetPort == null ))) {
  //    return "green";
  //  }
  //  if ((closeDistEps(e.SourcePoint, sourcePort.Location)
  //    || (closeDistEps(e.SourcePoint, targetPort.Location)
  //      || (closeDistEps(e.TargetPoint, sourcePort.Location) || closeDistEps(e.TargetPoint, targetPort.Location))))) {
  //    return "lightgreen";
  //  }
  //  return "green";
  //  // TODO: Warning!!!, inline IF is not supported ?
  //  ((e.IsPassable == null )
  //    || e.IsPassable());
  //  "red";
  // }
  *GetTransparentShapes(t, e, i, s) {
    for (const n of this.ancestorSets.get(i))
      yield n;
    for (const n of this.ancestorSets.get(s))
      yield n;
    it.EdgesAttachedToPortAvoidTheNode(t) || (yield i), it.EdgesAttachedToPortAvoidTheNode(e) || (yield s);
  }
  static SetTransparency(t, e) {
    for (const i of t)
      i.IsTransparent = e;
  }
  IsAncestor(t, e) {
    let i;
    return e != null && (i = this.ancestorSets.get(e)) != null && i.has(t);
  }
  static CreateLooseObstacleHierarachy(t) {
    return Et(t.map((e) => Bt(e, e.boundingBox)));
  }
  CreateTightObstacleHierarachy(t) {
    const e = t.map((i) => this.shapesToTightLooseCouples.get(i).TightPolyline);
    return Et(e.map((i) => Bt(i, i.boundingBox)));
  }
  CalculateVisibilityGraph() {
    const t = this.LineSweeperPorts != null ? xt.mk(this.LineSweeperPorts) : new xt();
    this.ProcessHookAnyWherePorts(t), this.portRTree = mn(Array.from(t.values()).map((e) => [T.rectangleOnPoint(e), e])), this.visGraph = new wt(), this.FillVisibilityGraphUnderShape(this.root);
  }
  ProcessHookAnyWherePorts(t) {
    for (const e of this.edges)
      e.sourcePort instanceof $t || e.sourcePort instanceof Ve || t.add(e.sourcePort.Location), e.targetPort instanceof $t || e.targetPort instanceof Ve || t.add(e.targetPort.Location);
  }
  // this function might change the shape's loose polylines by inserting new points
  FillVisibilityGraphUnderShape(t) {
    const e = t.Children;
    for (let c = 0; c < e.length; c++) {
      const d = e[c];
      this.FillVisibilityGraphUnderShape(d);
    }
    const i = this.shapesToTightLooseCouples.get(t), s = i ? i.LooseShape.BoundaryCurve : null, n = i ? i.LooseShape : this.looseRoot, r = new Set(n.Children.map((c) => c.BoundaryCurve)), o = this.RemoveInsidePortsAndSplitBoundaryIfNeeded(s);
    let l = new wt(), h = Us.mk([], l, this.coneAngle, o, s);
    h.run(), l = new wt(), h = Us.mk(Array.from(r), l, this.coneAngle, o, s), h.run(), this.ProgressStep();
    for (const c of l.Edges)
      this.TryToCreateNewEdgeAndSetIsPassable(c, n);
    this.AddBoundaryEdgesToVisGraph(s);
  }
  // #if TEST_MSAGL
  //     static internal void ShowVisGraph(VisibilityGraph tmpVisGraph, Iterable<Polyline> obstacles, Iterable<ICurve> greenCurves, Iterable<ICurve> redCurves) {
  //       var l = new Array<DebugCurve>(tmpVisGraph.Edges.Select(e => new DebugCurve(100, 1,
  //           e.IsPassable != null && e.IsPassable() ? "green" : "black"
  //           , new LineSegment(e.SourcePoint, e.TargetPoint))));
  //       if (obstacles != null)
  //         l.AddRange(obstacles.Select(p => new DebugCurve(100, 1, "brown", p)));
  //       if (greenCurves != null)
  //         l.AddRange(greenCurves.Select(p => new DebugCurve(100, 10, "navy", p)));
  //       if (redCurves != null)
  //         l.AddRange(redCurves.Select(p => new DebugCurve(100, 10, "red", p)));
  //       LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);
  //     }
  // #endif
  TryToCreateNewEdgeAndSetIsPassable(t, e) {
    let i = this.visGraph.FindEdgePP(t.SourcePoint, t.TargetPoint);
    i == null && (i = this.visGraph.AddEdgePP(t.SourcePoint, t.TargetPoint), e != null && (i.IsPassable = () => e.IsTransparent));
  }
  AddBoundaryEdgesToVisGraph(t) {
    if (t == null)
      return;
    let e;
    for (let i = t.startPoint; e = i.nextOnPolyline, this.visGraph.AddEdgePP(i.point, e.point), e !== t.startPoint; i = e)
      ;
  }
  /** this run will split the polyline enough to route later from the inner ports */
  RemoveInsidePortsAndSplitBoundaryIfNeeded(t) {
    const e = new xt();
    if (t == null) {
      for (const n of this.portRTree.GetAllLeaves())
        e.add(n);
      return this.portRTree.clear(), e;
    }
    const i = t.boundingBox, s = this.portRTree.GetAllIntersecting(i);
    for (const n of s)
      switch (g.PointRelativeToCurveLocation(n, t)) {
        case F.Inside:
          e.add(n), this.portRTree.Remove(T.rectangleOnPoint(n), n);
          break;
        case F.Boundary:
          this.portRTree.Remove(T.rectangleOnPoint(n), n);
          const r = it.FindPointOnPolylineToInsertAfter(t, n);
          if (r != null)
            qt.InsertPointIntoPolylineAfter(t, r, n);
          else
            throw new Error();
          break;
      }
    return e;
  }
  static FindPointOnPolylineToInsertAfter(t, e) {
    for (let i = t.startPoint; ; ) {
      const s = i.nextOnPolyline;
      if (u.closeDistEps(e, i.point) || u.closeDistEps(e, s.point))
        return null;
      const n = u.distToLineSegment(e, i.point, s.point).dist;
      if (D(n, 0))
        return i;
      if (i = s, i === t.startPoint)
        throw new Error();
    }
  }
  // creates a root; a shape with BoundaryCurve set to null
  GetOrCreateRoot() {
    if (this.rootShapes.length === 1) {
      const t = this.rootShapes[0];
      if (t.BoundaryCurve == null) {
        this.root = t;
        return;
      }
    }
    this.rootWasCreated = !0, this.root = new qs(null);
    for (const t of this.rootShapes)
      this.root.AddChild(t);
  }
  RemoveRoot() {
    if (this.rootWasCreated) {
      for (const t of this.rootShapes)
        t.RemoveParent(this.root);
      this.root = null, this.rootWasCreated = !1;
    }
  }
  // #if TEST_MSAGL
  //     // ReSharper disable UnusedMember.Local
  //     static void Show(
  //         Iterable<GeomEdge> edgeGeometries, Iterable<Shape> listOfShapes) {
  //       // ReSharper restore UnusedMember.Local
  //       var r = new Random(1);
  //       LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(
  //           listOfShapes.Select(s => s.BoundaryCurve).Select(
  //               c => new DebugCurve(50, 1, DebugCurve.Colors[r.Next(DebugCurve.Colors.Length - 1)], c)).Concat(
  //                   edgeGeometries.Select(e => new DebugCurve(100, 1, "red", e.Curve))));
  //     }
  // #endif
  static GetAncestorSetsMap(t) {
    const e = /* @__PURE__ */ new Map();
    for (const i of t.filter((s) => !e.has(s)))
      e.set(i, it.GetAncestorSet(i, e));
    return e;
  }
  static GetAncestorSet(t, e) {
    const i = new Set(t.Parents);
    for (const s of t.Parents) {
      let n = e.get(s);
      n || e.set(s, n = it.GetAncestorSet(s, e));
      for (const r of n)
        i.add(r);
    }
    return i;
  }
  static CreatePortsIfNeeded(t) {
    for (const e of t) {
      if (e.sourcePort == null) {
        const i = e;
        new Zi(() => i.source.boundaryCurve, () => i.source.center, new u(0, 0));
      }
      if (e.targetPort == null) {
        const i = e;
        new Zi(() => i.target.boundaryCurve, () => i.target.center, new u(0, 0));
      }
    }
  }
}
function Ig(a, t, e) {
  const i = Kh(a);
  new it(a, t, i.Padding, i.PolylinePadding, i.coneAngle, i.bundlingSettings, e).run();
}
class xp {
  /** retrieves the data for a single tile(x-y-z) */
  getTileData(t, e, i) {
    const s = this.levels[i];
    return s ? s.get(t, e) : null;
  }
  /** retrieves all the tiles of z-th level */
  *getTilesOfLevel(t) {
    const e = this.levels[t];
    if (e != null)
      for (const [i, s] of e.keyValues())
        yield { x: i.x, y: i.y, data: s };
  }
  /** geomGraph  - the graph to work with.
   * The topLevelTileRect serves as the only tile of the top level.
   */
  constructor(t, e) {
    this.numberOfNodesOnLevel = [], this.nodeScales = [], this.tileCapacity = 5e3, this.levels = [], this.nodeIndexInSortedNodes = /* @__PURE__ */ new Map(), this.geomGraph = t, this.topLevelTileRect = e, this.tileSizes = [], this.tileSizes.push(e.size);
  }
  getMinTileSize() {
    let t = 0, e = 0, i = 0;
    for (const s of this.geomGraph.nodesBreadthFirst)
      s instanceof Nt || (i == 0 ? (t = s.width, e = s.height) : (t = (i * t + s.width) / (i + 1), e = (i * e + s.height) / (i + 1)), i++);
    return new Ti(t * 10, e * 10);
  }
  fillTheLowestLayer() {
    const t = new Ki(), e = new tr(this.topLevelTileRect), i = e.arrowheads, s = e.labels;
    for (const r of this.geomGraph.graph.deepEdges)
      n(r);
    e.nodes = Array.from(this.geomGraph.nodesBreadthFirst), t.set(0, 0, e), this.levels.push(t);
    function n(r) {
      const o = Kt.getGeom(r), l = Kt.getGeom(r).curve;
      if (l instanceof g)
        for (const h of l.segs)
          e.addElement({ edge: r, curve: h, startPar: h.parStart, endPar: h.parEnd });
      else
        e.addElement({ edge: r, curve: l, startPar: l.parStart, endPar: l.parEnd });
      o.sourceArrowhead && i.push({ edge: o.edge, tip: o.sourceArrowhead.tipPosition, base: o.curve.start }), o.targetArrowhead && i.push({ edge: o.edge, tip: o.targetArrowhead.tipPosition, base: o.curve.end }), o.label && s.push(o.label);
    }
  }
  /**
   * Creates tilings for levels from 0 to z, including the level z.
   * The method does not necesserely creates all levels until z, but can exit earlier
   *  if all tiles either has size smaller or equal than this.minTileSize or have at most this.tileCapacityMin elements.
   * Returns the number of created levels.
   */
  buildUpToLevel(t) {
    if (this.fillTheLowestLayer(), this.minTileSize = this.getMinTileSize(), this.pageRank = Ld(this.geomGraph.graph, 0.85), !this.needToSubdivide())
      return 1;
    for (let i = 1; i <= t && !this.subdivideLevel(i); i++)
      ;
    this.sortedNodes = Array.from(this.pageRank.keys()).sort(this.compareByPagerank.bind(this));
    for (let i = 0; i < this.sortedNodes.length; i++)
      this.nodeIndexInSortedNodes.set(this.sortedNodes[i], i);
    for (let i = 0; i < this.levels.length - 1; i++)
      this.numberOfNodesOnLevel.push(this.filterOutEntities(this.levels[i], i));
    this.numberOfNodesOnLevel.push(this.sortedNodes.length);
    const e = new it(this.geomGraph, []);
    for (let i = this.levels.length - 2; i >= 0; i--) {
      const s = this.setOfNodesOnTheLevel(i);
      e.rerouteOnSubsetOfNodes(s), this.regenerateCurveClipsUpToLevel(i, s);
    }
    return this.calculateNodeRank(), this.levels.length;
  }
  // private makeSomeNodesVizible() {
  //   for (let levelIndex = 0; levelIndex < this.levels.length - 1; levelIndex++) {
  //     this.calculateNodeAdditionalScales(levelIndex)
  //   }
  // }
  // calculateNodeAdditionalScalesOnLevelZero() {
  //   const tree = new RTree()
  //   // we always get at least one intersection with the whole graph record
  //   tree.batchInsert([
  //     {
  //       x: this.geomGraph.left,
  //       y: this.geomGraph.bottom,
  //       width: this.geomGraph.width,
  //       height: this.geomGraph.height,
  //       data: {node: this.geomGraph.graph, nodeBB: this.geomGraph.boundingBox},
  //     },
  //   ]) // to init with the whole
  //   const scales = new Map<Node, number>()
  //   this.nodeScales.push(scales)
  //   // with this scale the node will be rendered at level[this.level.length -1]
  //   let scale = Math.pow(2, this.levels.length - 1)
  //   for (let j = 0; j < this.numberOfNodesOnLevel[0]; j++) {
  //     const n = this.sortedNodes[j]
  //     scale = this.findMaxScaleToNotIntersectTree(n, tree, scale)
  //     if (scale < 1.1) break // getting almost no enlargement
  //     scales.set(n, scale)
  //   }
  // }
  // findMaxScaleToNotIntersectTree(n: Node, tree: RTree, maxScale: number): number {
  //   const geomNode = GeomNode.getGeom(n)
  //   let nodeBB = geomNode.boundingBox
  //   // make sure that we are not rendering the node outside of  the the graph bounding box
  //   maxScale = Math.min(this.keepInsideGraphBoundingBox(nodeBB), maxScale)
  //   const ret = this.intersectWithTreeAndGetScale(tree, nodeBB, maxScale)
  //   // use the resulting bounding box and insert it to the tree
  //   nodeBB = geomNode.boundingBox.clone()
  //   nodeBB.scaleAroundCenter(ret)
  //   tree.insert({x: nodeBB.left, y: nodeBB.bottom, width: nodeBB.width, height: nodeBB.height, data: {node: n, nodeBB: nodeBB}})
  //   return ret
  // }
  /** returns the maximal scale keeping nodeBB inside of the graph bounding box */
  keepInsideGraphBoundingBox(t) {
    const e = this.geomGraph.boundingBox, i = t.width / 2, s = t.height / 2;
    return Math.min(
      // left stays inside
      (t.center.x - e.left) / i,
      // top stays inside
      (e.top - t.center.y) / s,
      // right stays inside
      (e.right - t.center.x) / i,
      //bottom stays inside
      (t.center.y - e.bottom) / s
    );
  }
  // intersectWithTreeAndGetScale(tree: RTree, nodeBB: Rectangle, maxScale: number): number {
  //   const xx = tree.search({x: nodeBB.left, y: nodeBB.bottom, width: nodeBB.width, height: nodeBB.height}) as {
  //     node: Node
  //     nodeBB: Rectangle
  //   }[]
  //   if (xx.length == 1) return maxScale // there is always one intersection with the whole graph
  //   let scale = maxScale
  //   for (const x of xx) {
  //     if (x.node == this.geomGraph.graph) continue
  //     scale = this.diminishScaleToAvoidTree(x.node, x.nodeBB, nodeBB)
  //     if (scale == 1) return scale // no separation
  //   }
  //   return scale
  // }
  diminishScaleToAvoidTree(t, e, i) {
    lt.assert(e.intersects(i));
    let s;
    const n = i.center.x, r = i.center.y, o = i.height / 2, l = i.width / 2;
    if (n < e.left)
      s = (e.left - n) / o;
    else if (n > e.right)
      s = (n - e.right) / o;
    else
      return 1;
    let h;
    if (r < e.bottom)
      h = (e.bottom - r) / l;
    else if (r > e.top)
      h = (r - e.top) / l;
    else
      return s;
    return Math.min(s, h);
  }
  // calculateNodeAdditionalScales(levelIndex: number) {
  //   const tree = new RTree()
  //   // we always get at least one intersection with the whole graph record
  //   tree.batchInsert([
  //     {
  //       x: this.geomGraph.left,
  //       y: this.geomGraph.bottom,
  //       width: this.geomGraph.width,
  //       height: this.geomGraph.height,
  //       data: {node: this.geomGraph.graph, nodeBB: this.geomGraph.boundingBox},
  //     },
  //   ]) // to init with the whole graph bounding box
  //   const scales = new Map<Node, number>()
  //   this.nodeScales.push(scales)
  //   let scale = Math.pow(2, this.levels.length - 1 - levelIndex)
  //   for (let j = 0; j < this.numberOfNodesOnLevel[levelIndex]; j++) {
  //     const n = this.sortedNodes[j]
  //     scale = this.findMaxScaleToNotIntersectTree(n, tree, scale)
  //     if (scale <= 1) break
  //     scales.set(n, scale)
  //   }
  // }
  // findMaxScale(n: Node, levelIndex: number, tree: RTree, maxScale: number): number {
  //   const geomNode = GeomNode.getGeom(n)
  //   let boundingBox = geomNode.boundingBox.clone()
  //   boundingBox.scaleAroundCenter(maxScale)
  //   let ret = maxScale
  //   while (ret > 1 && treeIntersectsRect(tree, boundingBox)) {
  //     ret /= 2
  //     if (ret < 1) ret = 1
  //   }
  //   boundingBox = geomNode.boundingBox.clone()
  //   boundingBox.scaleAroundCenter(ret)
  //   tree.insert({x: boundingBox.left, y: boundingBox.bottom, width: boundingBox.width, height: boundingBox.height})
  //   return ret
  // }
  needToSubdivide() {
    let t = !1;
    for (const e of this.levels[0].values())
      if (e.entityCount > this.tileCapacity) {
        t = !0;
        break;
      }
    return t;
  }
  setOfNodesOnTheLevel(t) {
    const e = /* @__PURE__ */ new Set();
    for (const i of this.levels[t].values())
      for (const s of i.nodes)
        e.add(s.node);
    return e;
  }
  // checkLevel(i: number) {
  //   const [edgeMap, nodeSet] = this.getEntityDataFromLevel(i)
  //   for (const [e, entDataArray] of edgeMap) {
  //     this.checkEntityDataArray(e, entDataArray, nodeSet)
  //   }
  // }
  // checkEntityDataArray(e: Entity, entDataArray: EntityDataInTile[], nodeSet: Set<Node>) {
  //   if (e instanceof Edge) {
  //     if (!nodeSet.has(e.source)) {
  //       Assert.assert(false)
  //     }
  //     if (!nodeSet.has(e.target)) {
  //       Assert.assert(false)
  //     }
  //     let connectedToSource = false
  //     let connectedToTarget = false
  //     const ge = GeomEdge.getGeom(e)
  //     const sb = ge.source.boundingBox
  //     const tb = ge.target.boundingBox
  //     for (const cc of entDataArray) {
  //       if ('curve' in cc.data) {
  //         Assert.assert(cc.data.edge === e)
  //         const curve = cc.data.curve
  //         if (sb.contains(curve.start)) connectedToSource = true
  //         if (tb.contains(curve.end)) connectedToTarget = true
  //       }
  //     }
  //     Assert.assert(connectedToSource && connectedToTarget)
  //   }
  // }
  regenerateCurveClipsUpToLevel(t, e) {
    this.clearCurveClipsInLevelsUpTo(t);
    for (const i of this.levels[0].values())
      this.regenerateCurveClipsUnderTileUpToLevel(i, t, e);
  }
  clearCurveClipsInLevelsUpTo(t) {
    for (let e = 0; e <= t; e++)
      for (const i of this.levels[e].values())
        i.initCurveClips();
  }
  regenerateCurveClipsUnderTileUpToLevel(t, e, i) {
    t.arrowheads = [], t.initCurveClips();
    for (const s of this.geomGraph.deepEdges)
      if (hr(s.edge, i)) {
        if (s.curve instanceof g)
          for (const n of s.curve.segs)
            t.addElement({ edge: s.edge, curve: n, startPar: n.parStart, endPar: n.parEnd });
        else
          t.addElement({ edge: s.edge, curve: s.curve, startPar: s.curve.parStart, endPar: s.curve.parEnd });
        s.sourceArrowhead && t.arrowheads.push({ edge: s.edge, tip: s.sourceArrowhead.tipPosition, base: s.curve.start }), s.targetArrowhead && t.arrowheads.push({ edge: s.edge, tip: s.targetArrowhead.tipPosition, base: s.curve.end });
      }
    for (let s = 1; s <= e; s++)
      this.regenerateCurveClipsWhenPreviosLayerIsDone(s), this.removeEmptyTiles(s);
  }
  removeEmptyTiles(t) {
    const e = this.levels[t], i = [];
    for (const [s, n] of e.keyValues())
      n.isEmpty() && i.push(s);
    for (const s of i)
      e.delete(s.x, s.y);
  }
  regenerateCurveClipsWhenPreviosLayerIsDone(t) {
    for (const [e, i] of this.levels[t - 1].keyValues())
      this.subdivideTile(
        e,
        t,
        i,
        /** for regenerate */
        !0
      );
  }
  // regenerateUnderOneTile(key: IntPair, upperTile: Tile, z: number) {
  //   const subTilesRects = createSubTileRects()
  //   const clipsPerRect = this.regenerateCurveClipsUnderTile(upperTile, subTilesRects)
  //   pushRegeneratedClips(this.levels[z])
  //   cleanArrowheadsInSubtiles(this.levels[z])
  //   pushArrowheadsToSubtiles(this.levels[z])
  //   cleanUpSubtilesAboveTile(this.levels[z])
  //   function cleanUpSubtilesAboveTile(level: IntPairMap<Tile>) {
  //     for (let i = 0; i < 2; i++)
  //       for (let j = 0; j < 2; j++) {
  //         const ti = 2 * key.x + i
  //         const tj = 2 * key.y + j
  //         const tile = level.get(ti, tj)
  //         if (tile == null) continue
  //         if (tile.isEmpty()) {
  //           level.delete(ti, tj)
  //         }
  //       }
  //   }
  //   function pushArrowheadsToSubtiles(level: IntPairMap<Tile>) {
  //     for (const arrowhead of upperTile.arrowheads) {
  //       const arrowheadBox = Rectangle.mkPP(arrowhead.base, arrowhead.tip)
  //       const d = arrowhead.tip.sub(arrowhead.base).div(3)
  //       const dRotated = d.rotate90Cw()
  //       arrowheadBox.add(arrowhead.base.add(dRotated))
  //       arrowheadBox.add(arrowhead.base.sub(dRotated))
  //       for (let i = 0; i < 2; i++)
  //         for (let j = 0; j < 2; j++) {
  //           const k = 2 * i + j
  //           if (arrowheadBox.intersects(subTilesRects[k])) {
  //             const ti = 2 * key.x + i
  //             const tj = 2 * key.y + j
  //             level.get(ti, tj).arrowheads.push(arrowhead)
  //           }
  //         }
  //     }
  //   }
  //   function cleanArrowheadsInSubtiles(levelMap: IntPairMap<Tile>) {
  //     for (let i = 0; i < 2; i++)
  //       for (let j = 0; j < 2; j++) {
  //         const ti = 2 * key.x + i
  //         const tj = 2 * key.y + j
  //         const tile = levelMap.get(ti, tj)
  //         if (tile == null) {
  //           continue
  //         }
  //         tile.arrowheads = []
  //       }
  //   }
  //   function pushRegeneratedClips(levelMap: IntPairMap<Tile>) {
  //     for (let i = 0; i < 2; i++)
  //       for (let j = 0; j < 2; j++) {
  //         const k = 2 * i + j
  //         const clips = clipsPerRect[k]
  //         const ti = 2 * key.x + i
  //         const tj = 2 * key.y + j
  //         let tile = levelMap.get(ti, tj)
  //         if (tile == null) {
  //           if (clips.length) {
  //             levelMap.set(ti, tj, (tile = new Tile(subTilesRects[k])))
  //           } else {
  //             continue
  //           }
  //         }
  //         tile.initCurveClips()
  //         for (const clip of clips) {
  //           tile.addElement({edge: clip.edge, curve: clip.curve})
  //         }
  //       }
  //   }
  //   function createSubTileRects() {
  //     const subTilesRects = new Array<Rectangle>()
  //     const w = upperTile.rect.width / 2
  //     const h = upperTile.rect.height / 2
  //     for (let i = 0; i < 2; i++)
  //       for (let j = 0; j < 2; j++) {
  //         const tileRect = new Rectangle({
  //           left: upperTile.rect.left + w * i,
  //           right: upperTile.rect.left + w * (i + 1),
  //           bottom: upperTile.rect.bottom + h * j,
  //           top: upperTile.rect.bottom + h * (j + 1),
  //         })
  //         subTilesRects.push(tileRect)
  //       }
  //     return subTilesRects
  //   }
  // }
  // lastLayerHasAllNodes(): boolean {
  //   const lastLayerNodes = new Set<Node>()
  //   for (const tile of this.levels[this.levels.length - 1].values()) {
  //     for (const n of tile.nodes) {
  //       lastLayerNodes.add(n.node)
  //     }
  //   }
  //   const gNodes = new Set<Node>(this.geomGraph.graph.nodesBreadthFirst)
  //   return setsAreEqual(gNodes, lastLayerNodes)
  // }
  calculateNodeRank() {
    this.nodeRank = /* @__PURE__ */ new Map();
    const t = this.sortedNodes.length, e = Math.log10(t);
    for (let i = 0; i < t; i++)
      this.nodeRank.set(this.sortedNodes[i], e - Math.log10(i + 1));
  }
  compareByPagerank(t, e) {
    return this.pageRank.get(e) - this.pageRank.get(t);
  }
  /** Fills the tiles up to the capacity.
   * Returns the number of inserted node.
   * An edge and its attributes is inserted just after its source and the target are inserted.
   * The nodes are sorted by rank here.  */
  filterOutEntities(t, e) {
    const i = this.transferDataOfLevelToMap(t);
    let s = 0;
    for (; s < this.sortedNodes.length; s++) {
      const n = this.sortedNodes[s];
      if (!this.addNodeToLevel(t, n, i))
        break;
    }
    return this.removeEmptyTiles(e), s;
  }
  /** Goes over all tiles where 'node' had presence and tries to add.
   *  If the above succeeds then all edges leading to the higher ranking nodes added without consulting with tileCapacity. The edge attributes added as well
   */
  addNodeToLevel(t, e, i) {
    const s = i.get(e);
    for (const r of s)
      if (r.tile.entityCount >= this.tileCapacity)
        return !1;
    for (const r of s) {
      const o = r.tile, l = r.data;
      o.addElement(l);
    }
    for (const r of e.selfEdges) {
      const o = i.get(r);
      for (const l of o) {
        const h = l.tile, c = l.data;
        h.addElement(c);
      }
      if (r.label)
        for (const l of i.get(r.label)) {
          const h = l.tile, c = l.data;
          h.addElement(c);
        }
    }
    const n = this.nodeIndexInSortedNodes.get(e);
    for (const r of e.inEdges) {
      const o = r.source;
      if (!(this.nodeIndexInSortedNodes.get(o) > n)) {
        for (const h of i.get(r)) {
          const c = h.tile, d = h.data;
          c.addElement(d);
        }
        if (r.label)
          for (const h of i.get(r.label)) {
            const c = h.tile, d = h.data;
            c.addElement(d);
          }
      }
    }
    for (const r of e.outEdges) {
      const o = r.target;
      if (!(this.nodeIndexInSortedNodes.get(o) > n)) {
        for (const h of i.get(r)) {
          const c = h.tile, d = h.data;
          c.addElement(d);
        }
        if (r.label && i.get(r.label))
          for (const h of i.get(r.label)) {
            const c = h.tile, d = h.data;
            c.addElement(d);
          }
      }
    }
    return !0;
  }
  transferDataOfLevelToMap(t) {
    const e = /* @__PURE__ */ new Map();
    for (const s of t.values()) {
      for (const n of s.curveClips) {
        const r = n.edge;
        i(r).push({ tile: s, data: n });
      }
      for (const n of s.labels) {
        const r = n.parent.edge;
        i(r).push({ tile: s, data: n });
      }
      for (const n of s.nodes) {
        const r = n.node;
        i(r).push({ tile: s, data: n });
      }
      for (const n of s.arrowheads) {
        const r = n.edge;
        i(r).push({ tile: s, data: n });
      }
      s.clear();
    }
    return e;
    function i(s) {
      let n = e.get(s);
      return n || e.set(s, n = new Array()), n;
    }
  }
  /** It is assumed that the previous level z-1 have been calculated.
   * Returns true if every edge is appears in some tile as the first edge
   */
  subdivideLevel(t) {
    if (console.log("subdivideLevel", t), this.levels[t] = new Ki(), this.subdivideTilesOnLevel(t))
      return console.log("done subdividing at level", t, "because each tile contains less than", this.tileCapacity), !0;
    const { w: i, h: s } = this.getWHOnLevel(t);
    return i <= this.minTileSize.width && s <= this.minTileSize.height ? (console.log("done subdividing at level", t, " because of tile size = ", i, s, "is less than ", this.minTileSize), !0) : !1;
  }
  countClips(t) {
    let e = 0;
    for (const i of this.levels[t].values())
      e += i.curveClips.length;
    return e;
  }
  getWHOnLevel(t) {
    for (let e = this.tileSizes.length; e <= t; e++) {
      const i = this.tileSizes[e - 1];
      this.tileSizes.push(new Ti(i.width / 2, i.height / 2));
    }
    return { w: this.tileSizes[t].width, h: this.tileSizes[t].height };
  }
  subdivideTilesOnLevel(t) {
    let e = !0;
    for (const [i, s] of this.levels[t - 1].keyValues()) {
      const n = this.subdivideTile(i, t, s, !1);
      e && (e = n.allSmall);
    }
    return this.removeEmptyTiles(t), console.log("generated", this.levels[t].size, "tiles"), e;
  }
  subdivideTile(t, e, i, s) {
    const { w: n, h: r } = this.getWHOnLevel(e), o = this.levels[e], l = t.x, h = t.y, c = this.topLevelTileRect.left + l * n * 2, d = this.topLevelTileRect.bottom + h * r * 2, f = new Array(4);
    for (let I = 0; I < 2; I++)
      for (let x = 0; x < 2; x++)
        f[I * 2 + x] = new U(l * 2 + I, h * 2 + x);
    s || this.generateSubtilesWithoutTileClips(c, n, d, r, f, i, e);
    const p = new v(c, d + r, c + 2 * n, d + r), P = new v(c + n, d, c + n, d + 2 * r);
    w();
    let y = 0, C = !0;
    for (const I of f) {
      const x = o.get(I.x, I.y);
      x != null && (y++, x.entityCount > this.tileCapacity && (C = !1));
    }
    return { count: y, allSmall: C };
    function w() {
      for (const I of i.curveClips) {
        const x = I.curve, V = N(x, I.startPar, I.endPar);
        if (lt.assert(V.length >= 2), V.length == 2) {
          const M = (V[0] + V[1]) / 2, X = x.value(M), Zt = X.x <= c + n ? 0 : 1, ot = X.y <= d + r ? 0 : 1, Ht = 2 * Zt + ot, se = f[Ht];
          let Rt = o.getI(se);
          if (!Rt) {
            const ne = c + Zt * n, de = d + ot * r;
            Rt = new tr(new T({ left: ne, bottom: de, top: de + r, right: ne + n })), o.setPair(se, Rt);
          }
          Rt.addCurveClip({ curve: x, edge: I.edge, startPar: V[0], endPar: V[1] });
        } else
          for (let M = 0; M < V.length - 1; M++) {
            const X = (V[M] + V[M + 1]) / 2, Zt = x.value(X), ot = Zt.x <= c + n ? 0 : 1, Ht = Zt.y <= d + r ? 0 : 1, se = 2 * ot + Ht, Rt = f[se];
            let ne = o.getI(Rt);
            if (!ne) {
              const de = c + ot * n, mi = d + Ht * r;
              ne = new tr(new T({ left: de, bottom: mi, top: mi + r, right: de + n })), o.setPair(Rt, ne);
            }
            ne.addCurveClip({ curve: x, edge: I.edge, startPar: V[M], endPar: V[M + 1] });
          }
      }
    }
    function N(I, x, V) {
      let M = Array.from(g.getAllIntersections(I, p, !0)).concat(Array.from(g.getAllIntersections(I, P, !0))).map((X) => X.par0);
      return M.sort((X, Zt) => X - Zt), [x].concat(M.filter((X) => X >= x && X <= V)).concat(V);
    }
  }
  /** returns the updated value of allTilesAreSmall */
  addSubtilesToLevel(t, e, i, s, n) {
    for (let r = 0; r < 2; r++)
      for (let o = 0; o < 2; o++) {
        const l = t[r * 2 + o];
        l.isEmpty() || (e.set(2 * i + r, 2 * s + o, l), n && l.entityCount > this.tileCapacity && (n = !1));
      }
    return n;
  }
  generateSubtilesWithoutTileClips(t, e, i, s, n, r, o) {
    let l = 0;
    for (let h = 0; h < 2; h++)
      for (let c = 0; c < 2; c++) {
        const d = new T({
          left: t + e * h,
          right: t + e * (h + 1),
          bottom: i + s * c,
          top: i + s * (c + 1)
        }), f = this.generateOneSubtileExceptEdgeClips(r, d);
        f && this.levels[o].set(n[l].x, n[l].y, f), l++;
      }
  }
  innerClips(t, e, i) {
    const s = [], n = Array.from(g.getAllIntersections(t, i, !0)).concat(Array.from(g.getAllIntersections(t, e, !0)));
    n.sort((o, l) => o.par0 - l.par0);
    const r = [t.parStart];
    for (let o = 0; o < n.length; o++) {
      const l = n[o];
      l.par0 > r[r.length - 1] + m.distanceEpsilon && r.push(l.par0);
    }
    if (t.parEnd > r[r.length - 1] + m.distanceEpsilon && r.push(t.parEnd), r.length <= 2)
      return s.push(t), s;
    for (let o = 0; o < r.length - 1; o++)
      s.push(t.trim(r[o], r[o + 1]));
    return s;
  }
  generateOneSubtileExceptEdgeClips(t, e) {
    const i = new tr(e);
    for (const s of t.nodes)
      s.boundingBox.intersects(e) && i.nodes.push(s);
    for (const s of t.labels)
      s.boundingBox.intersects(e) && i.labels.push(s);
    for (const s of t.arrowheads) {
      const n = T.mkPP(s.base, s.tip), o = s.tip.sub(s.base).div(3).rotate90Cw();
      n.add(s.base.add(o)), n.add(s.base.sub(o)), n.intersects(e) && i.arrowheads.push(s);
    }
    return i.isEmpty() ? null : i;
  }
}
class wn extends te {
  constructor(t, e) {
    super(), this.SetEdges(t, e);
  }
}
class Eg {
  *RegularMultiedges() {
    for (const [t, e] of this.Multiedges.keyValues())
      t.x !== t.y && (yield e);
  }
  *AllIntEdges() {
    for (const t of this.Multiedges.values())
      for (const e of t)
        yield e;
  }
  addFeedbackSet(t) {
    for (const e of t) {
      const i = new U(e.source, e.target), s = new U(e.target, e.source), n = this.Multiedges.get(i.x, i.y);
      for (const r of n)
        r.reverse();
      if (this.Multiedges.has(s.x, s.y)) {
        const r = this.Multiedges.get(s.x, s.y);
        for (const o of n)
          r.push(o);
      } else
        this.Multiedges.set(s.x, s.y, n);
      this.Multiedges.delete(i.x, i.y);
    }
  }
  constructor(t) {
    this.MultipleMiddles = /* @__PURE__ */ new Set(), this.Multiedges = new Ki();
  }
  registerOriginalEdgeInMultiedges(t) {
    let e = this.Multiedges.get(t.source, t.target);
    e == null && this.Multiedges.set(t.source, t.target, e = []), e.push(t);
  }
  *SkeletonEdges() {
    for (const [t, e] of this.Multiedges.keyValues())
      t.x !== t.y && (yield e[0]);
  }
  GetMultiedge(t, e) {
    return this.GetMultiedgeI(new U(t, e));
  }
  GetMultiedgeI(t) {
    return this.Multiedges.has(t.x, t.y) ? this.Multiedges.get(t.x, t.y) : new Array();
  }
}
function jo(a, t) {
  for (let e = 0; e < a.length; e++)
    t[e] = a[e];
}
class Bi {
  constructor(t) {
    this.initialize(t);
  }
  initialize(t) {
    this.y = t, this.verticesToX = null, this.layers = null;
  }
  // Returns the same arrays but with no empty layers.
  DropEmptyLayers() {
    const t = new Array(this.Layers.length);
    let e = 0;
    for (let r = 0; r < this.Layers.length; r++)
      t[r] = e, this.Layers[r].length === 0 && e++;
    if (e === 0)
      return this;
    const i = new Array(this.y.length);
    for (let r = 0; r < i.length; r++)
      i[r] = this.y[r] - t[this.y[r]];
    const s = new Array(this.layers.length - e);
    for (let r = 0; r < this.layers.length; r++)
      this.layers[r].length > 0 && (s[r - t[r]] = Array.from(this.layers[r]));
    const n = new Bi(i);
    return n.layers = s, n;
  }
  updateLayers(t) {
    this.layers == null && this.InitLayers();
    for (let e = 0; e < this.layers.length; e++)
      jo(t[e], this.layers[e]);
    this.UpdateXFromLayers();
  }
  UpdateXFromLayers() {
    this.layers == null && this.InitLayers(), this.verticesToX == null && (this.verticesToX = new Array(this.y.length));
    for (const t of this.layers) {
      let e = 0;
      for (const i of t)
        this.verticesToX[i] = e++;
    }
  }
  // gives the order of the vertices in the y-layer
  // <value></value>
  get x() {
    return this.verticesToX != null ? this.verticesToX : (this.verticesToX = new Array(this.y.length), this.UpdateXFromLayers(), this.verticesToX);
  }
  // returns the layer hierarchy where the order of the layers is reversed
  ReversedClone() {
    const t = new Array(this.y.length), e = this.Layers.length - 1;
    for (let i = 0; i < this.y.length; i++)
      t[i] = e - this.y[i];
    return new Bi(t);
  }
  // Layers[i] is the array of vertices of i-th layer
  get Layers() {
    return this.layers != null ? this.layers : (this.InitLayers(), this.layers);
  }
  set Layers(t) {
    this.layers = t;
  }
  InitLayers() {
    let t = 0;
    for (const i of this.y)
      i + 1 > t && (t = i + 1);
    const e = new Array(t).fill(0);
    for (const i of this.y)
      e[i]++;
    this.layers = new Array(t);
    for (let i = 0; i < t; i++)
      this.layers[i] = new Array(e[i]), e[i] = 0;
    for (let i = 0; i < this.y.length; i++) {
      const s = this.y[i];
      this.layers[s][e[s]++] = i;
    }
  }
}
class Ca extends ht {
  static Balance(t, e, i, s) {
    new Ca(t, e, i, s).run();
  }
  constructor(t, e, i, s) {
    super(s), this.jumpers = /* @__PURE__ */ new Set(), this.possibleJumperFeasibleIntervals = /* @__PURE__ */ new Map(), this.nodeCount = i, this.dag = t, this.layering = e, this.Init();
  }
  run() {
    for (; this.jumpers.size > 0; )
      this.Jump(this.ChooseJumper());
  }
  Init() {
    this.CalculateLayerCounts(), this.InitJumpers();
  }
  Jump(t) {
    this.jumpers.delete(t);
    const e = this.possibleJumperFeasibleIntervals.get(t), i = this.CalcJumpInfo(e.x, e.y, t);
    if (i == null)
      return;
    this.layering[t] = i.layerToJumpTo;
    const s = this.nodeCount[t];
    this.vertsCounts[i.jumperLayer] -= s, this.vertsCounts[i.layerToJumpTo] += s, this.UpdateRegionsForPossibleJumpersAndInsertJumpers(i.jumperLayer, t);
  }
  IsJumper(t) {
    return this.possibleJumperFeasibleIntervals.has(t);
  }
  // some other jumpers may stop being ones if the jump
  // was just in to their destination layer, so before the actual
  // jump we have to recheck if the jump makes sense
  //
  UpdateRegionsForPossibleJumpersAndInsertJumpers(t, e) {
    const i = /* @__PURE__ */ new Set();
    for (const n of this.dag.pred(e))
      this.IsJumper(n) && (this.CalculateRegionAndInsertJumper(n), i.add(n));
    for (const n of this.dag.succ(e))
      this.IsJumper(n) && (this.CalculateRegionAndInsertJumper(n), i.add(n));
    const s = new Array();
    for (const n of this.possibleJumperFeasibleIntervals)
      i.has(n[0]) || n[1].x > t && n[1].y < t && s.push(n[0]);
    for (const n of s)
      this.CalculateRegionAndInsertJumper(n);
  }
  InitJumpers() {
    const t = new Array(this.dag.nodeCount).fill(0);
    for (const e of this.dag.edges)
      t[e.source] -= e.weight, t[e.target] += e.weight;
    this.possibleJumperFeasibleIntervals = /* @__PURE__ */ new Map();
    for (let e = 0; e < this.dag.nodeCount; e++)
      t[e] === 0 && this.CalculateRegionAndInsertJumper(e);
  }
  CalculateRegionAndInsertJumper(t) {
    const e = new U(this.Up(t), this.Down(t));
    this.possibleJumperFeasibleIntervals.set(t, e), this.InsertJumper(e.x, e.y, t);
  }
  InsertJumper(t, e, i) {
    this.CalcJumpInfo(t, e, i) != null && this.jumpers.add(i);
  }
  // layerToJumpTo is -1 if there is no jump
  CalcJumpInfo(t, e, i) {
    const s = this.layering[i];
    let n = -1, r = this.vertsCounts[s] - 2 * this.nodeCount[i];
    for (let o = t - 1; o > s; o--)
      this.vertsCounts[o] < r && (r = this.vertsCounts[o], n = o);
    for (let o = s - 1; o > e; o--)
      this.vertsCounts[o] < r && (r = this.vertsCounts[o], n = o);
    if (n !== -1)
      return { jumperLayer: s, layerToJumpTo: n };
  }
  // Up returns the first infeasible layer up from i that i cannot jump to
  Up(t) {
    let e = Number.MAX_SAFE_INTEGER;
    for (const i of this.dag.inEdges[t]) {
      const s = this.layering[i.source] - i.separation + 1;
      s < e && (e = s);
    }
    return e === Number.MAX_SAFE_INTEGER && (e = this.layering[t] + 1), e;
  }
  // Returns the first infeasible layer down from i that i cannot jump to
  Down(t) {
    let e = Number.NEGATIVE_INFINITY;
    for (const i of this.dag.outEdges[t]) {
      const s = this.layering[i.target] + i.separation - 1;
      s > e && (e = s);
    }
    return e === Number.NEGATIVE_INFINITY && (e = this.layering[t] - 1), e;
  }
  CalculateLayerCounts() {
    this.vertsCounts = new Array(Math.max(...this.layering) + 1).fill(0);
    for (const t of this.layering)
      this.vertsCounts[t] += this.nodeCount[t];
  }
  ChooseJumper() {
    for (const t of this.jumpers)
      return t;
    throw new Error("there are no jumpers to choose");
  }
}
class ps {
  constructor(t) {
    this.Initialize(t);
  }
  Initialize(t) {
    this.BaseGraph = t, this.totalNumberOfNodes = t.nodeCount;
    for (const e of this.BaseGraph.edges)
      if (e.LayerEdges != null)
        for (const i of e.LayerEdges) {
          const s = Math.max(i.Source, i.Target) + 1;
          s > this.totalNumberOfNodes && (this.totalNumberOfNodes = s);
        }
    this.firstVirtualNode = Number.POSITIVE_INFINITY;
    for (const e of this.BaseGraph.edges)
      if (e.LayerEdges != null)
        for (let i = 1; i < e.LayerEdges.length; i++) {
          const s = e.LayerEdges[i];
          this.firstVirtualNode = Math.min(this.firstVirtualNode, s.Source);
        }
    this.firstVirtualNode === Number.POSITIVE_INFINITY && (this.firstVirtualNode = this.BaseGraph.nodeCount, this.totalNumberOfNodes = this.BaseGraph.nodeCount), this.virtualNodesToInEdges = new Array(this.totalNumberOfNodes - this.firstVirtualNode), this.virtualNodesToOutEdges = new Array(this.totalNumberOfNodes - this.firstVirtualNode);
    for (const e of this.BaseGraph.edges)
      if (e.LayerSpan > 0)
        for (const i of e.LayerEdges)
          i.Target !== e.target && (this.virtualNodesToInEdges[i.Target - this.firstVirtualNode] = i), i.Source !== e.source && (this.virtualNodesToOutEdges[i.Source - this.firstVirtualNode] = i);
  }
  // enumerates over the graph edges
  *edges_() {
    for (const t of this.BaseGraph.edges)
      if (t.LayerSpan > 0)
        for (const e of t.LayerEdges)
          yield e;
  }
  get Edges() {
    return this.edges_();
  }
  // enumerates over edges of a node
  *InEdges(t) {
    if (t < this.BaseGraph.nodeCount)
      for (const e of this.BaseGraph.inEdges[t])
        e.source !== e.target && e.LayerEdges != null && (yield ps.LastEdge(e));
    else t >= this.firstVirtualNode && (yield this.InEdgeOfVirtualNode(t));
  }
  static LastEdge(t) {
    return t.LayerEdges[t.LayerEdges.length - 1];
  }
  InEdgeOfVirtualNode(t) {
    return this.virtualNodesToInEdges[t - this.firstVirtualNode];
  }
  // enumerates over the node outcoming edges
  *OutEdges(t) {
    if (t < this.BaseGraph.nodeCount)
      for (const e of this.BaseGraph.outEdges[t])
        e.source !== e.target && e.LayerEdges != null && (yield ps.FirstEdge(e));
    else t >= this.firstVirtualNode && (yield this.OutEdgeOfVirtualNode(t));
  }
  OutDegreeIsMoreThanOne(t) {
    return t < this.BaseGraph.nodeCount ? this.BaseGraph.outEdges[t].length > 1 : !1;
  }
  InDegreeIsMoreThanOne(t) {
    return t < this.BaseGraph.nodeCount ? this.BaseGraph.inEdges[t].length > 1 : !1;
  }
  OutEdgeOfVirtualNode(t) {
    return this.virtualNodesToOutEdges[t - this.firstVirtualNode];
  }
  static FirstEdge(t) {
    return t.LayerEdges[0];
  }
  // returns the number of incoming edges for an edge
  InEdgesCount(t) {
    return this.RealInEdgesCount(t);
  }
  RealInEdgesCount(t) {
    return t < this.BaseGraph.nodeCount ? this.BaseGraph.inEdges[t].filter((e) => e.LayerEdges != null).length : 1;
  }
  // returns the number of outcoming edges for an edge
  OutEdgesCount(t) {
    return this.RealOutEdgesCount(t);
  }
  RealOutEdgesCount(t) {
    return t < this.BaseGraph.nodeCount ? this.BaseGraph.outEdges[t].filter((e) => e.LayerEdges != null).length : 1;
  }
  // returns the node count
  get NodeCount() {
    return this.totalNumberOfNodes;
  }
  IsRealNode(t) {
    return t < this.BaseGraph.nodeCount;
  }
  IsVirtualNode(t) {
    return !this.IsRealNode(t);
  }
  ReversedClone() {
    const t = this.CreateReversedEdges();
    return new ps(new wn(t, this.BaseGraph.nodeCount));
  }
  CreateReversedEdges() {
    const t = new Array();
    for (const e of this.BaseGraph.edges)
      e.isSelfEdge() || t.push(e.reversedClone());
    return t;
  }
  *Succ(t) {
    for (const e of this.OutEdges(t))
      yield e.Target;
  }
  *Pred(t) {
    for (const e of this.InEdges(t))
      yield e.Source;
  }
}
class _n {
  constructor(t, e, i, s) {
    this.la = e, this.database = i, this.layeredGraph = t, this.intGraph = s;
  }
  // the entry point of the class
  static InsertLayers(t, e, i, s) {
    const n = new _n(t, e, i, s);
    return n.InsertLayers(), {
      layeredGraph: n.nLayeredGraph,
      la: n.Nla.DropEmptyLayers()
    };
  }
  // new Y-layering
  get NLayering() {
    return this.Nla.y;
  }
  // does the main work
  InsertLayers() {
    this.EditOldLayering(), this.CreateFullLayeredGraph(), this.InitNewLayering(), this.MapVirtualNodesToEdges(), this.FillUnsortedNewOddLayers(), this.WidenOriginalLayers(), this.SortNewOddLayers();
  }
  // virtual nodes inside of an edge should be of the form i,i+1, ....
  EditOldLayering() {
    let t = this.intGraph.nodeCount;
    for (const e of this.database.RegularMultiedges()) {
      let i = 0;
      const s = e[0];
      if (i = s.LayerSpan * 2, i > 0) {
        for (const n of s.LayerEdges)
          n.Target !== s.target && (t++, this.UpdateOldLayer(t++, n.Target));
        t += (i - 1) * (e.length - 1) + 1;
      }
    }
  }
  UpdateOldLayer(t, e) {
    const i = this.la.x[e], s = this.la.y[e], n = this.la.Layers[s];
    n[i] = t;
  }
  // Original layers are represented by even layers of the new layering.
  // Here we add new virtices of such layers and
  // set new x-offsets of original and dummy vertices of these layers.
  WidenOriginalLayers() {
    for (let t = 0; t < this.la.Layers.length; t++) {
      const e = this.Nla.Layers[t * 2];
      let i = 0;
      for (const s of this.la.Layers[t]) {
        const n = this.virtNodesToIntEdges[s];
        if (n != null) {
          const r = this.NLayering[n.source] - this.NLayering[s], o = this.database.Multiedges.get(n.source, n.target);
          for (const l of o)
            if (l !== n) {
              const h = l.LayerEdges[r].Source;
              e[i] = h, this.Nla.x[h] = i++;
            } else
              e[i] = s, this.Nla.x[s] = i++;
        } else
          e[i] = s, this.Nla.x[s] = i++;
      }
    }
  }
  // filling new layers not corresponding to the original layers
  FillUnsortedNewOddLayers() {
    const t = new Array(this.Nla.Layers.length).fill(0);
    for (let e = this.intGraph.nodeCount; e < this.nLayeredGraph.NodeCount; e++) {
      const i = this.NLayering[e];
      i % 2 === 1 && (this.Nla.Layers[i][t[i]++] = e);
    }
  }
  // create the mapping from the vertices to edges to which they belong
  MapVirtualNodesToEdges() {
    this.virtNodesToIntEdges = new Array(this.NLayering.length);
    for (const t of this.database.AllIntEdges())
      if (t.source !== t.target && t.LayerEdges != null)
        for (const e of t.LayerEdges)
          e.Target !== t.target && (this.virtNodesToIntEdges[e.Target] = t);
  }
  // Creating buckets for multi edges and allocating the graph.
  CreateFullLayeredGraph() {
    this.totalNodes = this.intGraph.nodeCount;
    for (const t of this.database.RegularMultiedges()) {
      let e = 0, i = !0;
      for (const s of t)
        if (i && (i = !1, e = s.LayerSpan * 2), e > 0) {
          s.LayerEdges = new Array(e);
          for (let n = 0; n < e; n++) {
            const r = { currentVV: this.totalNodes }, o = ms.GetSource(r, s, n);
            this.totalNodes = r.currentVV;
            const l = ms.GetTarget(this.totalNodes, s, n, e);
            s.LayerEdges[n] = new qi(o, l, s.CrossingWeight);
          }
          _n.RegisterDontStepOnVertex(this.database, s);
        }
    }
    this.nLayeredGraph = new ps(this.intGraph);
  }
  // Sort new odd layers by the sum of x-coordinatates of predecessors and the successors of
  // dummy nodes.
  SortNewOddLayers() {
    for (let t = 1; t < this.Nla.Layers.length; t += 2) {
      const e = /* @__PURE__ */ new Map(), i = this.Nla.Layers[t];
      for (const r of i) {
        let o = -1;
        for (const c of this.nLayeredGraph.InEdges(r))
          o = c.Source;
        let l = -1;
        for (const c of this.nLayeredGraph.OutEdges(r))
          l = c.Target;
        const h = this.Nla.x[o] + this.Nla.x[l];
        if (e.has(h)) {
          const c = e.get(h);
          if (typeof c == "number") {
            const d = new Array();
            d.push(c), d.push(r), e.set(h, d);
          } else
            c.push(r);
        } else
          e.set(h, r);
      }
      const s = Array.from(e.entries()).sort((r, o) => r[0] - o[0]);
      let n = 0;
      for (const r of s.map((o) => o[1]))
        if (typeof r == "number")
          i[n++] = r;
        else
          for (const o of r)
            i[n++] = o;
      for (let r = 0; r < i.length; r++)
        this.Nla.x[i[r]] = r;
    }
  }
  // Allocating new layering and filling its y-layers
  InitNewLayering() {
    this.Nla = new Bi(new Array(this.totalNodes));
    for (let i = 0; i < this.layeredGraph.NodeCount; i++)
      this.NLayering[i] = this.la.y[i] * 2;
    for (const [i, s] of this.database.Multiedges.keyValues())
      if (i.x !== i.y && this.la.y[i.x] !== this.la.y[i.y]) {
        const n = this.la.y[i.x] * 2;
        for (const r of s) {
          let o = n - 1;
          for (const l of r.LayerEdges)
            l.Target !== r.target && (this.NLayering[l.Target] = o--);
        }
      }
    const t = new Array(2 * this.la.Layers.length - 1), e = new Array(t.length).fill(0);
    for (const i of this.NLayering)
      e[i]++;
    for (let i = 0; i < e.length; i++)
      t[i] = new Array(e[i]);
    this.Nla = new Bi(this.NLayering), this.Nla.Layers = t;
  }
  // mark the vertex as one representing a label
  // or a middle of a multi edge
  static RegisterDontStepOnVertex(t, e) {
    if (t.Multiedges.get(e.source, e.target).length > 1) {
      const i = e.LayerEdges[Math.floor(e.LayerEdges.length / 2)];
      t.MultipleMiddles.add(i.Source);
    }
  }
}
class ms {
  get NLayering() {
    return this.Nla.y;
  }
  static InsertPaths(t, e, i, s) {
    const n = new ms(t, e, i, s);
    return n.InsertPaths(), {
      layeredGraph: n.NLayeredGraph,
      la: n.Nla
    };
  }
  constructor(t, e, i, s) {
    this.virtNodesToIntEdges = /* @__PURE__ */ new Map(), this.la = e, this.database = i, this.layeredGraph = t, this.intGraph = s;
  }
  InsertPaths() {
    this.CreateFullLayeredGraph(), this.InitNewLayering(), this.MapVirtualNodesToEdges(), this.WidenOriginalLayers();
  }
  WidenOriginalLayers() {
    for (let t = 0; t < this.la.Layers.length; t++) {
      const e = this.Nla.Layers[t];
      let i = 0;
      for (const s of this.la.Layers[t]) {
        const n = this.virtNodesToIntEdges.get(s);
        if (n != null) {
          const r = this.NLayering[n.source] - this.NLayering[s], o = this.database.Multiedges.get(n.source, n.target);
          for (const l of o)
            if (!this.EdgeIsFlat(l))
              if (l !== n) {
                const h = l.LayerEdges[r].Source;
                e[i] = h, this.Nla.x[h] = i++;
              } else
                e[i] = s, this.Nla.x[s] = i++;
        } else
          e[i] = s, this.Nla.x[s] = i++;
      }
    }
  }
  EdgeIsFlat(t) {
    return this.la.y[t.source] === this.la.y[t.target];
  }
  MapVirtualNodesToEdges() {
    for (const t of this.database.RegularMultiedges())
      for (const e of t)
        if (!this.EdgeIsFlat(e))
          for (const i of e.LayerEdges)
            i.Target !== e.target && this.virtNodesToIntEdges.set(i.Target, e);
  }
  CreateFullLayeredGraph() {
    let t = this.layeredGraph.NodeCount;
    for (const [e, i] of this.database.Multiedges.keyValues())
      if (e.x !== e.y) {
        let s = !0, n = 0;
        for (const r of i) {
          if (s)
            s = !1, n = r.LayerSpan;
          else if (r.LayerEdges = new Array(n), n === 1)
            r.LayerEdges[0] = new qi(r.source, r.target, r.CrossingWeight);
          else
            for (let o = 0; o < n; o++) {
              const l = { currentVV: t }, h = ms.GetSource(l, r, o);
              t = l.currentVV;
              const c = ms.GetTarget(t, r, o, n);
              r.LayerEdges[o] = new qi(h, c, r.CrossingWeight);
            }
          _n.RegisterDontStepOnVertex(this.database, r);
        }
      }
    this.NLayeredGraph = new ps(this.intGraph);
  }
  static GetTarget(t, e, i, s) {
    return i < s - 1 ? t : e.target;
  }
  static GetSource(t, e, i) {
    return i === 0 ? e.source : t.currentVV++;
  }
  InitNewLayering() {
    this.Nla = new Bi(new Array(this.NLayeredGraph.NodeCount));
    for (let i = 0; i < this.layeredGraph.NodeCount; i++)
      this.NLayering[i] = this.la.y[i];
    for (const [i, s] of this.database.Multiedges.keyValues())
      if (i.x !== i.y && this.la.y[i.x] !== this.la.y[i.y]) {
        let n = 0, r = !0;
        for (const o of s) {
          r && (r = !1, n = this.la.y[o.source]);
          let l = n - 1;
          for (const h of o.LayerEdges)
            this.NLayering[h.Target] = l--;
        }
      }
    const t = new Array(this.la.Layers.length), e = new Array(t.length).fill(0);
    for (const i of this.NLayering)
      e[i]++;
    for (let i = 0; i < e.length; i++)
      t[i] = new Array(e[i]);
    this.Nla = new Bi(this.NLayering), this.Nla.Layers = t;
  }
}
class dn {
  constructor(t, e, i) {
    this.numberOfCrossings = e, this.la = t, this.virtVertexStart = i;
  }
  LayerGroupDisbalance(t, e, i) {
    return e === 1 ? this.LayerGroupDisbalanceWithOrigSeparators(t, i) : this.LayerGroupDisbalanceWithVirtSeparators(t, e);
  }
  LayerGroupDisbalanceWithVirtSeparators(t, e) {
    let i = 0;
    for (let s = 0; s < t.length; ) {
      const n = this.CurrentOrigGroupDelta(s, t, e);
      s = n.i, i += n.ret;
    }
    return i;
  }
  CurrentOrigGroupDelta(t, e, i) {
    let s = 0, n = t;
    for (; n < e.length && e[n] < this.virtVertexStart; n++)
      s++;
    return t = n + 1, { ret: Math.abs(i - s), i: t };
  }
  LayerGroupDisbalanceWithOrigSeparators(t, e) {
    let i = 0;
    for (let s = 0; s < t.length; ) {
      const n = this.CurrentVirtGroupDelta(s, t, e);
      i += n.ret, s = n.i;
    }
    return i;
  }
  CurrentVirtGroupDelta(t, e, i) {
    let s = 0, n = t;
    for (; n < e.length && e[n] >= this.virtVertexStart; n++)
      s++;
    return t = n + 1, { ret: Math.abs(i - s), i: t };
  }
  static less(t, e) {
    return t.numberOfCrossings < e.numberOfCrossings;
  }
  static greater(t, e) {
    return t.numberOfCrossings > e.numberOfCrossings;
  }
  IsPerfect() {
    return this.numberOfCrossings === 0;
  }
}
class wg {
  constructor(t) {
    this.x = t;
  }
  Compare(t, e) {
    const i = this.x[t.Source] - this.x[e.Source];
    return i !== 0 ? i : this.x[t.Target] - this.x[e.Target];
  }
}
class Ag {
  constructor(t) {
    this.x = t;
  }
  Compare(t, e) {
    const i = this.x[t.Target] - this.x[e.Target];
    return i !== 0 ? i : this.x[t.Source] - this.x[e.Source];
  }
}
function or() {
  return Xs(2) === 0;
}
function Tg(a, t, e) {
  const i = e.Layers[a + 1], s = e.Layers[a];
  return s.length <= i.length ? xg(s, t, e) : Og(i, s, t, e);
}
function Og(a, t, e, i) {
  const s = ic(t, e), n = new Ag(i.x);
  s.sort((h, c) => n.Compare(h, c));
  let r = 1;
  for (; r < a.length; )
    r *= 2;
  const o = new Array(2 * r - 1).fill(0);
  r--;
  let l = 0;
  for (const h of s) {
    let c = r + i.x[h.Source];
    const d = h.CrossingWeight;
    for (o[c] += d; c > 0; )
      c % 2 !== 0 && (l += d * o[c + 1]), c = Math.floor((c - 1) / 2), o[c] += d;
  }
  return l;
}
function xg(a, t, e) {
  const i = ic(a, t), s = new wg(e.x);
  i.sort((l, h) => s.Compare(l, h));
  let n = 1;
  for (; n < a.length; )
    n *= 2;
  const r = new Array(2 * n - 1).fill(0);
  n--;
  let o = 0;
  for (const l of i) {
    let h = n + e.x[l.Target];
    const c = l.CrossingWeight;
    for (r[h] += c; h > 0; )
      h % 2 !== 0 && (o += c * r[h + 1]), h = Math.floor((h - 1) / 2), r[h] += c;
  }
  return o;
}
function ic(a, t) {
  return Qn(a, (e) => t.InEdges(e));
}
function Ll(a, t) {
  let e = 0;
  for (let i = 0; i < t.Layers.length - 1; i++)
    e += Tg(i, a, t);
  return e;
}
class Vs extends ht {
  get NoGainStepsBound() {
    return this.SugSettings.NoGainAdjacentSwapStepsBound * this.SugSettings.NoGainStepsForOrderingMultiplier;
  }
  // gets the random seed for some random choices inside of layer ordering
  get SeedOfRandom() {
    return Xs(100);
  }
  constructor(t, e, i, s, n, r, o) {
    super(o), this.tryReverse = !0, this.MaxNumberOfAdjacentExchanges = 50, this.cancelToken = o, this.tryReverse = e, this.startOfVirtNodes = s, this.layerArrays = i, this.layering = i.y, this.nOfLayers = i.Layers.length, this.layers = i.Layers, this.properLayeredGraph = t, this.hasCrossWeights = n, this.SugSettings = r;
  }
  // an upper limit on a number of passes in layer ordering
  get MaxOfIterations() {
    return this.SugSettings.MaxNumberOfPassesInOrdering * this.SugSettings.NoGainStepsForOrderingMultiplier;
  }
  static OrderLayers(t, e, i, s, n) {
    let r = !1;
    for (const l of t.Edges)
      if (l.CrossingWeight !== 1) {
        r = !0;
        break;
      }
    new Vs(t, !0, e, i, r, s, n).run();
  }
  run() {
    if (this.Calculate(), /*orderingMeasure.x>0 &&*/
    this.tryReverse) {
      const t = this.layerArrays.ReversedClone(), e = new Vs(this.properLayeredGraph.ReversedClone(), !1, t, this.startOfVirtNodes, this.hasCrossWeights, this.SugSettings, this.cancelToken);
      if (e.run(), dn.less(e.measure, this.measure)) {
        for (let i = 0; i < this.nOfLayers; i++)
          jo(t.Layers[i], this.layerArrays.Layers[this.nOfLayers - 1 - i]);
        this.layerArrays.UpdateXFromLayers();
      }
    }
  }
  Calculate() {
    this.Init(), this.layerArraysCopy = Vs.CloneLayers(this.layers, this.layerArraysCopy);
    let t = 0;
    this.measure = new dn(this.layerArraysCopy, Ll(this.properLayeredGraph, this.layerArrays), this.startOfVirtNodes);
    for (let e = 0; e < this.MaxOfIterations && t < this.NoGainStepsBound && !this.measure.IsPerfect(); e++) {
      const i = e % 2 === 0;
      this.LayerByLayerSweep(i), this.AdjacentExchange();
      const s = new dn(this.layerArrays.Layers, Ll(this.properLayeredGraph, this.layerArrays), this.startOfVirtNodes);
      dn.less(this.measure, s) ? (this.Restore(), t++) : (dn.less(s, this.measure) || or()) && (t = 0, this.layerArraysCopy = Vs.CloneLayers(this.layers, this.layerArraysCopy), this.measure = s);
    }
  }
  static CloneLayers(t, e) {
    if (e == null) {
      e = new Array(t.length);
      for (let i = 0; i < t.length; i++)
        e[i] = t[i].map((s) => s);
    } else
      for (let i = 0; i < t.length; i++)
        jo(t[i], e[i]);
    return e;
  }
  Restore() {
    this.layerArrays.updateLayers(this.layerArraysCopy);
  }
  LayerByLayerSweep(t) {
    if (t)
      for (let e = 1; e < this.nOfLayers; e++)
        this.SweepLayer(e, !0);
    else
      for (let e = this.nOfLayers - 2; e >= 0; e--)
        this.SweepLayer(e, !1);
  }
  // the layer layer-1 is fixed if
  // upperLayer us true and layer+1 is fixed in
  // the opposite case
  // the layer with index "layer" is updated
  // of the strip</param>
  SweepLayer(t, e) {
    const i = this.layers[t], s = new Array(i.length);
    for (let r = 0; r < s.length; r++)
      s[r] = this.WMedian(i[r], e);
    this.Sort(t, s);
    const n = this.layerArrays.Layers[t];
    for (let r = 0; r < n.length; r++)
      this.layerArrays.x[n[r]] = r;
  }
  // sorts layerToSort according to medianValues
  // if medianValues[i] is -1 then layer[i] does not move
  Sort(t, e) {
    const i = /* @__PURE__ */ new Map(), s = this.layers[t];
    let n = 0;
    for (const l of e) {
      const h = s[n++];
      if (l !== -1)
        if (!i.has(l))
          i.set(l, h);
        else {
          const c = i.get(l);
          if (typeof c != "number") {
            const d = c;
            if (or())
              d.push(h);
            else {
              const f = Xs(d.length), p = d[f];
              d[f] = h, d.push(p);
            }
          } else {
            const d = c, f = new Array();
            i.set(l, f), or() ? (f.push(d), f.push(h)) : (f.push(h), f.push(d));
          }
        }
    }
    const r = Array.from(i).sort((l, h) => l[0] - h[0]).map((l) => l[1]);
    let o = 0;
    for (n = 0; n < s.length; )
      if (e[n] !== -1) {
        const l = r[o++];
        if (typeof l == "number")
          s[n++] = l;
        else {
          const h = l;
          for (const c of h) {
            for (; e[n] === -1; )
              n++;
            s[n++] = c;
          }
        }
      } else
        n++;
  }
  WMedian(t, e) {
    let i, s;
    if (e ? (i = this.properLayeredGraph.OutEdges(t), s = this.properLayeredGraph.OutEdgesCount(t)) : (i = this.properLayeredGraph.InEdges(t), s = this.properLayeredGraph.InEdgesCount(t)), s === 0)
      return -1;
    const n = new Array(s);
    let r = 0;
    if (e)
      for (const c of i)
        n[r++] = this.X[c.Target];
    else
      for (const c of i)
        n[r++] = this.X[c.Source];
    n.sort((c, d) => c - d);
    const o = Math.floor(s / 2);
    if (s % 2 === 1)
      return n[o];
    if (s === 2)
      return 0.5 * (n[0] + n[1]);
    const l = n[o - 1] - n[0], h = n[s - 1] - n[o];
    return Math.floor((n[o - 1] * l + n[o] * h) / (l + h));
  }
  // Just depth search and assign the index saying when the node was visited
  Init() {
    const t = new Array(this.nOfLayers).fill(0), e = new mt.Stack();
    for (let s = 0; s < this.properLayeredGraph.NodeCount; s++)
      this.properLayeredGraph.InEdgesCount(s) === 0 && e.push(s);
    const i = new Array(this.properLayeredGraph.NodeCount).fill(!1);
    for (; e.size > 0; ) {
      const s = e.pop(), n = this.layerArrays.y[s];
      this.layerArrays.Layers[n][t[n]] = s, this.layerArrays.x[s] = t[n], t[n]++;
      for (const r of this.properLayeredGraph.Succ(s))
        i[r] || (i[r] = !0, e.push(r));
    }
    this.X = this.layerArrays.x;
  }
  AdjacentExchange() {
    this.InitArrays();
    let t = 0, e = !0;
    for (; e && t++ < this.MaxNumberOfAdjacentExchanges; ) {
      e = !1;
      for (let i = 0; i < this.layers.length; i++)
        e = this.AdjExchangeLayer(i) || e;
      for (let i = this.layers.length - 2; i >= 0; i--)
        e = this.AdjExchangeLayer(i) || e;
    }
  }
  AllocArrays() {
    const t = this.properLayeredGraph.NodeCount;
    this.predecessors = new Array(t), this.successors = new Array(t), this.pOrder = new Array(t), this.sOrder = new Array(t), this.hasCrossWeights && (this.outCrossingCount = new Array(t), this.inCrossingCount = new Array(t));
    for (let e = 0; e < t; e++) {
      let i = this.properLayeredGraph.InEdgesCount(e);
      if (this.predecessors[e] = new Array(i), this.hasCrossWeights) {
        const s = this.inCrossingCount[e] = /* @__PURE__ */ new Map();
        for (const n of this.properLayeredGraph.InEdges(e))
          s.set(n.Source, n.CrossingWeight);
      }
      if (this.pOrder[e] = /* @__PURE__ */ new Map(), i = this.properLayeredGraph.OutEdgesCount(e), this.successors[e] = new Array(i), this.sOrder[e] = /* @__PURE__ */ new Map(), this.hasCrossWeights) {
        const s = this.outCrossingCount[e] = /* @__PURE__ */ new Map();
        for (const n of this.properLayeredGraph.OutEdges(e))
          s.set(n.Target, n.CrossingWeight);
      }
    }
  }
  // Is called just after median layer swap is done
  InitArrays() {
    this.successors == null && this.AllocArrays();
    for (let t = 0; t < this.properLayeredGraph.NodeCount; t++)
      this.pOrder[t] = /* @__PURE__ */ new Map(), this.sOrder[t] = /* @__PURE__ */ new Map();
    for (const t of this.layers)
      this.InitPsArraysForLayer(t);
  }
  // calculates the number of intersections between edges adjacent to u and v
  CalcPair(t, e) {
    const i = this.successors[t], s = this.successors[e], n = this.predecessors[t], r = this.predecessors[e];
    if (this.hasCrossWeights) {
      const o = this.outCrossingCount[t], l = this.outCrossingCount[e], h = this.inCrossingCount[t], c = this.inCrossingCount[e];
      return {
        cuv: this.CountOnArraysUV(i, s, o, l) + this.CountOnArraysUV(n, r, h, c),
        cvu: this.CountOnArraysUV(s, i, l, o) + this.CountOnArraysUV(r, n, c, h)
      };
    } else
      return {
        cuv: this.CountOnArrays(i, s) + this.CountOnArrays(n, r),
        cvu: this.CountOnArrays(s, i) + this.CountOnArrays(r, n)
      };
  }
  // Sweep layer from left to right and fill S,P arrays as we go.
  // The arrays P and S will be sorted according to X. Note that we will not keep them sorted
  // as we doing adjacent swaps. Initial sorting only needed to calculate initial clr,crl values.
  InitPsArraysForLayer(t) {
    for (const e of t) {
      for (const i of this.properLayeredGraph.Pred(e)) {
        const s = this.sOrder[i], n = s.size;
        this.successors[i][n] = e, s.set(e, n);
      }
      for (const i of this.properLayeredGraph.Succ(e)) {
        const s = this.pOrder[i], n = s.size;
        this.predecessors[i][n] = e, s.set(e, n);
      }
    }
  }
  CountOnArrays(t, e) {
    let i = 0;
    const s = e.length - 1;
    let n = -1, r = 0;
    for (const o of t) {
      const l = this.X[o];
      for (; n < s && this.X[e[n + 1]] < l; n++)
        r++;
      i += r;
    }
    return i;
  }
  // every inversion between unbs and vnbs gives an intersecton
  CountOnArraysUV(t, e, i, s) {
    let n = 0;
    const r = e.length - 1;
    let o = -1, l = 0;
    for (const h of t) {
      const c = this.X[h];
      let d;
      for (; o < r && this.X[d = e[o + 1]] < c; o++)
        l += s.get(d);
      n += l * i.get(h);
    }
    return n;
  }
  AdjExchangeLayer(t) {
    const e = this.layers[t];
    return this.ExchangeWithGainWithNoDisturbance(e) ? !0 : (this.DisturbLayer(e), this.ExchangeWithGainWithNoDisturbance(e));
  }
  //in this routine u and v are adjacent, and u is to the left of v before the swap
  Swap(t, e) {
    const i = this.X[t], s = this.X[e], n = this.layering[t], r = this.layers[n];
    r[i] = e, r[s] = t, this.X[t] = s, this.X[e] = i, this.UpdateSsContainingUv(t, e), this.UpdatePsContainingUv(t, e);
  }
  UpdatePsContainingUv(t, e) {
    if (this.successors[t].length <= this.successors[e].length)
      for (const i of this.successors[t]) {
        const s = this.pOrder[i];
        if (s.has(e)) {
          const n = s.get(e), r = this.predecessors[i];
          r[n - 1] = e, r[n] = t, s.set(e, n - 1), s.set(t, n);
        }
      }
    else
      for (const i of this.successors[e]) {
        const s = this.pOrder[i];
        if (s.has(t)) {
          const n = s.get(e), r = this.predecessors[i];
          r[n - 1] = e, r[n] = t, s.set(e, n - 1), s.set(t, n);
        }
      }
  }
  UpdateSsContainingUv(t, e) {
    if (this.predecessors[t].length <= this.predecessors[e].length)
      for (const i of this.predecessors[t]) {
        const s = this.sOrder[i];
        if (s.has(e)) {
          const n = s.get(e), r = this.successors[i];
          r[n - 1] = e, r[n] = t, s.set(e, n - 1), s.set(t, n);
        }
      }
    else
      for (const i of this.predecessors[e]) {
        const s = this.sOrder[i];
        if (s.has(t)) {
          const n = s.get(e), r = this.successors[i];
          r[n - 1] = e, r[n] = t, s.set(e, n - 1), s.set(t, n);
        }
      }
  }
  DisturbLayer(t) {
    for (let e = 0; e < t.length - 1; e++)
      this.AdjacentSwapToTheRight(t, e);
  }
  ExchangeWithGainWithNoDisturbance(t) {
    let e = !1, i;
    do
      i = this.ExchangeWithGain(t), e = e || i;
    while (i);
    return e;
  }
  ExchangeWithGain(t) {
    for (let e = 0; e < t.length - 1; e++)
      if (this.SwapWithGain(t[e], t[e + 1]))
        return this.SwapToTheLeft(t, e), this.SwapToTheRight(t, e + 1), !0;
    return !1;
  }
  SwapToTheLeft(t, e) {
    for (let i = e - 1; i >= 0; i--)
      this.AdjacentSwapToTheRight(t, i);
  }
  SwapToTheRight(t, e) {
    for (let i = e; i < t.length - 1; i++)
      this.AdjacentSwapToTheRight(t, i);
  }
  // swaps i-th element with i+1
  AdjacentSwapToTheRight(t, e) {
    const i = t[e], s = t[e + 1], n = this.SwapGain(i, s);
    (n > 0 || n === 0 && or()) && this.Swap(i, s);
  }
  SwapGain(t, e) {
    const i = this.CalcPair(t, e);
    return i.cuv - i.cvu;
  }
  UvAreOfSameKind(t, e) {
    return t < this.startOfVirtNodes && e < this.startOfVirtNodes || t >= this.startOfVirtNodes && e >= this.startOfVirtNodes;
  }
  NeighborsForbidTheSwap(t, e) {
    return this.UpperNeighborsForbidTheSwap(t, e) || this.LowerNeighborsForbidTheSwap(t, e);
  }
  LowerNeighborsForbidTheSwap(t, e) {
    let i, s;
    return (i = this.properLayeredGraph.OutEdgesCount(t)) === 0 || (s = this.properLayeredGraph.OutEdgesCount(e)) === 0 ? !1 : this.X[this.successors[t][i >> 1]] < this.X[this.successors[e][s >> 1]];
  }
  UpperNeighborsForbidTheSwap(t, e) {
    const i = this.properLayeredGraph.InEdgesCount(t), s = this.properLayeredGraph.InEdgesCount(e);
    return i === 0 || s === 0 ? !1 : this.X[this.predecessors[t][i >> 1]] < this.X[this.predecessors[e][s >> 1]];
  }
  CalcDeltaBetweenGroupsToTheLeftAndToTheRightOfTheSeparator(t, e, i) {
    const s = this.GetKindDelegate(i);
    let n = 0;
    for (let o = e - 1; o >= 0 && !s(t[o]); o--)
      n++;
    let r = 0;
    for (let o = e + 1; o < t.length && !s(t[o]); o++)
      r++;
    return n - r;
  }
  IsOriginal(t) {
    return t < this.startOfVirtNodes;
  }
  IsVirtual(t) {
    return t >= this.startOfVirtNodes;
  }
  GetKindDelegate(t) {
    return this.IsVirtual(t) ? this.IsVirtual : this.IsOriginal;
  }
  // swaps two vertices only if reduces the number of intersections
  SwapWithGain(t, e) {
    return this.SwapGain(t, e) > 0 ? (this.Swap(t, e), !0) : !1;
  }
}
class Hr {
  constructor(t, e, i) {
    this.properLayeredGraph = t, this.layerArrays = e, this.nodePositions = i;
  }
  // Reorder only points having identical nodePositions
  static UpdateLayerArrays0(t, e, i) {
    new Hr(t, e, i).UpdateLayerArrays();
  }
  // Reorder virtual nodes between the same pair of real nodes
  static UpdateLayerArrays1(t, e) {
    const i = Hr.BuildInitialNodePositions(t, e);
    this.UpdateLayerArrays0(t, e, i);
  }
  static BuildInitialNodePositions(t, e) {
    const i = /* @__PURE__ */ new Map();
    for (let s = 0; s < e.Layers.length; s++) {
      let n = 0, r = 0;
      for (; n < e.Layers[s].length; ) {
        for (; n < e.Layers[s].length && t.IsVirtualNode(e.Layers[s][n]); )
          n++;
        for (let o = r; o < n; o++)
          i.set(e.Layers[s][o], new u(s, r));
        n < e.Layers[s].length && i.set(e.Layers[s][n], new u(s, n)), n++, r = n;
      }
    }
    return i;
  }
  UpdateLayerArrays() {
    let t = this.CreateInitialOrdering();
    t = this.BuildOrdering(t), this.RestoreLayerArrays(t);
  }
  CreateInitialOrdering() {
    const t = new ii();
    for (const e of this.layerArrays.Layers)
      for (const i of e) {
        const s = this.nodePositions.get(i);
        t.hasxy(s.x, s.y) || t.setxy(s.x, s.y, []), t.getxy(s.x, s.y).push(i);
      }
    return t;
  }
  BuildOrdering(t) {
    const e = new ii(), i = /* @__PURE__ */ new Map();
    for (const s of this.layerArrays.Layers)
      for (const n of s) {
        const r = this.nodePositions.get(n);
        e.hasxy(r.x, r.y) || (this.BuildNodeOrdering(t.get(r), i), e.set(r, t.get(r)));
      }
    return e;
  }
  BuildNodeOrdering(t, e) {
    t.sort(this.Comparison(e));
    for (let i = 0; i < t.length; i++)
      e.set(t[i], i);
  }
  firstSucc(t) {
    for (const e of this.properLayeredGraph.Succ(t))
      return e;
  }
  firstPred(t) {
    for (const e of this.properLayeredGraph.Pred(t))
      return e;
  }
  Comparison(t) {
    return (e, i) => {
      const s = this.firstSucc(e), n = this.firstSucc(i);
      let r = this.firstPred(e), o = this.firstPred(i);
      const l = this.nodePositions.get(s), h = this.nodePositions.get(n), c = this.nodePositions.get(r), d = this.nodePositions.get(o);
      if (!l.equal(h))
        return c.equal(d) ? l.compareTo(h) : c.compareTo(d);
      if (this.properLayeredGraph.IsVirtualNode(s)) {
        if (!c.equal(d))
          return c.compareTo(d);
        const f = t.get(s), p = t.get(n);
        return yt(f, p);
      }
      for (; this.nodePositions.get(r).equal(this.nodePositions.get(o)) && this.properLayeredGraph.IsVirtualNode(r); )
        r = this.firstPred(r), o = this.firstPred(o);
      return this.nodePositions.get(r).equal(this.nodePositions.get(o)) ? yt(e, i) : this.nodePositions.get(r).compareTo(this.nodePositions.get(o));
    };
  }
  RestoreLayerArrays(t) {
    for (const e of this.layerArrays.Layers) {
      let i = 0, s = 0;
      for (; i < e.length; ) {
        for (; i < e.length && this.nodePositions.get(e[s]).equal(this.nodePositions.get(e[i])); )
          i++;
        const n = t.get(this.nodePositions.get(e[s]));
        for (let r = s; r < i; r++)
          e[r] = n[r - s];
        s = i;
      }
    }
    this.layerArrays.UpdateXFromLayers();
  }
}
class no {
  // Topological sort of a list of int edge tuples
  static getOrder(t, e) {
    const i = fi(e.map(([s, n]) => new U(s, n)), t);
    return no.getOrderOnGraph(i);
  }
  // The function returns an array arr such that
  // every edge points forward in the array. The input has to be a DAG
  static getOrderOnGraph(t) {
    const e = new Array(t.nodeCount).fill(!1), i = new mt.Stack(), s = [];
    let n;
    for (let r = 0; r < t.nodeCount; r++) {
      if (e[r])
        continue;
      let o = r;
      e[o] = !0;
      let l = 0;
      n = t.outEdges[r];
      do {
        for (; l < n.length; l++) {
          const h = n[l].target;
          e[h] || (e[h] = !0, i.push({ edges: n, index: l + 1, current_u: o }), o = h, n = t.outEdges[o], l = -1);
        }
        if (s.push(o), i.length > 0) {
          const h = i.pop();
          n = h.edges, l = h.index, o = h.current_u;
        } else
          break;
      } while (!0);
    }
    return s.reverse();
  }
}
class Lg {
  GetLayers() {
    const t = no.getOrderOnGraph(this.graph), e = new Array(this.graph.nodeCount).fill(0);
    let i = this.graph.nodeCount;
    for (; i-- > 0; ) {
      const s = t[i];
      for (const n of this.graph.inEdges[s]) {
        const r = n.source, o = e[s] + n.separation;
        e[r] < o && (e[r] = o);
      }
    }
    return e;
  }
  checkTopoOrder(t) {
    for (const e of this.graph.edges)
      if (Rg(e, t))
        return !1;
    return !0;
  }
  constructor(t) {
    this.graph = t;
  }
}
function Rg(a, t) {
  const e = t.findIndex((s) => s === a.source), i = t.findIndex((s) => s === a.target);
  return e === -1 || i === -1 || e >= i;
}
class oe {
  constructor(t) {
    this.inTree = !1, this.cut = oe.infinity, this.iedge = t;
  }
  get source() {
    return this.iedge.source;
  }
  get target() {
    return this.iedge.target;
  }
  get separation() {
    return this.iedge.separation;
  }
  get crossingWeight() {
    return this.iedge.CrossingWeight;
  }
  get weight() {
    return this.iedge.weight;
  }
}
oe.infinity = Number.MAX_SAFE_INTEGER;
function Ng(a) {
  const t = new Array();
  for (const e of a.edges)
    t.push(new oe(e));
  return fi(t, a.nodeCount);
}
class Co {
  constructor(t, e, i, s, n) {
    this.v = t, this.outEnum = e, this.i = i, this.inEnum = s, this.j = n;
  }
}
class sc {
  get weight() {
    return this.graph.edges.map((t) => t.weight * (this.layers[t.source] - this.layers[t.target])).reduce((t, e) => t + e, 0);
  }
  get nodeCount() {
    return this.vertices.length;
  }
  setLow(t, e) {
    this.vertices[t].low = e;
  }
  setLim(t, e) {
    this.vertices[t].lim = e;
  }
  setParent(t, e) {
    this.vertices[t].parent = e;
  }
  constructor(t, e) {
    this.layers = null, this.treeVertices = [], this.vertices = [], this.leaves = [], this.graph = Ng(t), this.networkCancelToken = e;
    for (let i = 0; i < this.graph.nodeCount; i++)
      this.vertices.push({
        inTree: !1,
        lim: -1,
        low: -1,
        parent: null
      });
  }
  GetLayers() {
    return this.layers == null && this.run(), this.layers;
  }
  shiftLayerToZero() {
    const t = Math.min(...this.layers);
    for (let e = 0; e < this.layers.length; e++)
      this.layers[e] -= t;
  }
  addVertexToTree(t) {
    this.vertices[t].inTree = !0;
  }
  vertexInTree(t) {
    return this.vertices[t].inTree;
  }
  lim(t) {
    return this.vertices[t].lim;
  }
  low(t) {
    return this.vertices[t].low;
  }
  parent(t) {
    return this.vertices[t].parent;
  }
  // The function feasibleTree constructs an initial feasible spanning tree.
  feasibleTree() {
    for (this.initLayers(); this.tightTree() < this.nodeCount; ) {
      const t = this.getNonTreeEdgeIncidentToTheTreeWithMinimalAmountOfSlack();
      if (t == null)
        break;
      let e = this.slack(t);
      this.vertexInTree(t.source) && (e = -e);
      for (const i of this.treeVertices)
        this.layers[i] += e;
    }
    this.initCutValues();
  }
  // A treeEdge, belonging to the tree, divides the vertices to source and target components
  // If v belongs to the source component we return 1
  // otherwise we return 0
  vertexSourceTargetVal(t, e) {
    const i = e.source, s = e.target;
    return this.lim(i) > this.lim(s) ? this.lim(t) <= this.lim(s) && this.low(s) <= this.lim(t) ? 0 : 1 : this.lim(t) <= this.lim(i) && this.low(i) <= this.lim(t) ? 1 : 0;
  }
  // a convenient wrapper of IncEdges incident to v
  incidentEdges(t) {
    return this.graph.incidentEdges(t);
  }
  allLowCutsHaveBeenDone(t) {
    for (const e of this.incidentEdges(t))
      if (e.inTree && e.cut === oe.infinity && e !== this.parent(t))
        return !1;
    return !0;
  }
  // treeEdge, belonging to the tree, divides the vertices to source and target components
  // e does not belong to the tree . If e goes from the source component to target component
  // then the return value is 1,
  // if e goes from the target component ot the source then the return value is -1
  // otherwise return zero
  edgeSourceTargetVal(t, e) {
    return this.vertexSourceTargetVal(t.source, e) - this.vertexSourceTargetVal(t.target, e);
  }
  // initCutValues computes the cut values of the tree edges.
  // For each tree edge, this is computed by marking the nodes as belonging to the source or
  // target component, and then performing the sum of the signed weights of all
  // edges whose source and target are in different components, the sign being negative for those edges
  // going from the source to the target component.
  // To reduce this cost, we note that the cut values can be computed using information local to an edge
  // if the search is ordered from the leaves of the feasible tree inward. It is trivial to compute the
  // cut value of a tree edge with one of its endpoints a leaf in the tree,
  // since either the source or the target component consists of a single node.
  // Now, assuming the cut values are known for all the edges incident on a given
  // node except one, the cut value of the remaining edge is the sum of the known cut
  // values plus a term dependent only on the edges incident to the given node.
  initCutValues() {
    this.initLimLowAndParent();
    let t = new mt.Stack();
    for (const i of this.leaves)
      t.push(i);
    let e = new mt.Stack();
    for (; t.length > 0; ) {
      for (; t.length > 0; ) {
        const s = t.pop(), n = this.parent(s);
        if (n == null)
          continue;
        let r = 0;
        for (const l of this.incidentEdges(s))
          if (l.inTree === !1) {
            const h = this.edgeSourceTargetVal(l, n);
            h !== 0 && (r += h * l.weight);
          } else if (l === n)
            r += l.weight;
          else {
            const h = n.source === l.target || n.target === l.source ? 1 : -1, c = this.edgeContribution(l, s);
            r += c * h;
          }
        n.cut = r;
        const o = n.source === s ? n.target : n.source;
        this.allLowCutsHaveBeenDone(o) && e.push(o);
      }
      const i = t;
      t = e, e = i;
    }
  }
  // e is a tree edge for which the cut has been calculted already.
  // EdgeContribution gives an amount that edge e brings to the cut of parent(w).
  // The contribution is the cut value minus the weight of e. Let S be the component of e source.
  // We should also substruct W(ie) for every ie going from S to w and add W(ie) going from w to S.
  // These numbers appear in e.cut but with opposite signs.
  edgeContribution(t, e) {
    let i = t.cut - t.weight;
    for (const s of this.incidentEdges(e))
      if (s.inTree === !1) {
        const n = this.edgeSourceTargetVal(s, t);
        n === -1 ? i += s.weight : n === 1 && (i -= s.weight);
      }
    return i;
  }
  // A quote:
  // Another valuable optimization, similar to a technique described in [Ch],
  // is to perform a postorder traversal of the tree, starting from some fixed
  // root node vroot, and labeling each node v with its postorder
  // traversal number lim(v), the least number low(v) of any descendant in the search,
  // and the edge parent(v) by which the node was reached (see figure 2-5).
  // This provides an inexpensive way to test whether a node lies in the
  // source or target component of a tree edge, and thus whether a non-tree edge
  // crosses between the two components. For example, if e = (u,v) is a
  // tree edge and vroot is in the source component of the edge (i.e., lim(u) less lim(v)),
  // then a node w is in the target component of e if and only if low(u) is less or equal than lim(w)
  // is less or equal than lim(u). These numbers can also be used to update the tree efficiently
  // during the network simplex iterations. If f = (w,x) is the entering edge, the
  // only edges whose cut values must be adjusted are those in the path
  // connecting w and x in the tree. This path is determined by following
  // the parent edges back from w and x until the least common ancestor is reached,
  // i.e., the first node l such that low(l) is less or equal lim(w) than ,
  // lim(x) is less or equal than lim(l).
  // Of course, these postorder parameters must also be adjusted when
  // exchanging tree edges, but only for nodes below l.
  initLimLowAndParent() {
    this.initLowLimParentAndLeavesOnSubtree(1, 0);
  }
  // initializes lim and low in the subtree
  initLowLimParentAndLeavesOnSubtree(t, e) {
    const i = new mt.Stack();
    let s = this.graph.outEdges[e], n = -1, r = this.graph.inEdges[e], o = -1;
    for (i.push(new Co(e, s, n, r, o)), this.vertices[e].low = t; i.length > 0; ) {
      const l = i.pop();
      e = l.v, s = l.outEnum, n = l.i, r = l.inEnum, o = l.j;
      let h;
      do {
        for (h = !0; ++n < s.length; ) {
          const c = s[n];
          !c.inTree || this.vertices[c.target].low > 0 || (i.push(new Co(e, s, n, r, o)), e = c.target, this.setParent(e, c), this.setLow(e, t), s = this.graph.outEdges[e], n = -1, r = this.graph.inEdges[e], o = -1);
        }
        for (; ++o < r.length; ) {
          const c = r[o];
          if (!(!c.inTree || this.vertices[c.source].low > 0)) {
            i.push(new Co(e, s, n, r, o)), e = c.source, this.setLow(e, t), this.setParent(e, c), s = this.graph.outEdges[e], n = -1, r = this.graph.inEdges[e], o = -1, h = !1;
            break;
          }
        }
      } while (!h);
      this.setLim(e, t++), this.lim(e) === this.low(e) && this.leaves.push(e);
    }
  }
  // here we update values lim and low for the subtree with the root l
  updateLimLowLeavesAndParentsUnderNode(t) {
    const e = this.vertices[t].low, i = this.vertices[t].lim;
    this.leaves = [];
    for (let s = 0; s < this.nodeCount; s++)
      e <= this.vertices[s].lim && this.vertices[s].lim <= i ? this.setLow(s, 0) : this.low(s) === this.lim(s) && this.leaves.push(s);
    this.initLowLimParentAndLeavesOnSubtree(e, t);
  }
  slack(t) {
    return this.layers[t.source] - this.layers[t.target] - t.separation;
  }
  // one of the returned edge vertices does not belong to the tree but another does
  getNonTreeEdgeIncidentToTheTreeWithMinimalAmountOfSlack() {
    let t = null, e = oe.infinity;
    for (const i of this.treeVertices) {
      for (const s of this.graph.outEdges[i]) {
        if (this.vertexInTree(s.source) && this.vertexInTree(s.target))
          continue;
        const n = this.slack(s);
        if (n < e && (t = s, e = n, n === 1))
          return s;
      }
      for (const s of this.graph.inEdges[i]) {
        if (this.vertexInTree(s.source) && this.vertexInTree(s.target))
          continue;
        const n = this.slack(s);
        if (n < e && (t = s, e = n, n === 1))
          return s;
      }
    }
    return t;
  }
  // The function TightTree finds a maximal tree of tight edges containing
  // some fixed node and returns the number of nodes in the tree.
  // Note that such a maximal tree is just a spanning tree for the subgraph
  // induced by all nodes reachable from the fixed node in the underlying
  // undirected graph using only tight edges. In particular, all such trees have the same number of nodes.
  // The function also builds the tree. It returns the number of verices in the tight tree
  tightTree() {
    this.treeVertices = [];
    for (const e of this.graph.edges)
      e.inTree = !1;
    for (let e = 1; e < this.nodeCount; e++)
      this.vertices[e].inTree = !1;
    this.vertices[0].inTree = !0, this.treeVertices.push(0);
    const t = new mt.Stack();
    for (t.push(0); t.length > 0; ) {
      const e = t.pop();
      for (const i of this.graph.outEdges[e])
        this.vertexInTree(i.target) || this.layers[i.source] - this.layers[i.target] === i.separation && (t.push(i.target), this.addVertexToTree(i.target), this.treeVertices.push(i.target), i.inTree = !0);
      for (const i of this.graph.inEdges[e])
        this.vertexInTree(i.source) || this.layers[i.source] - this.layers[i.target] === i.separation && (t.push(i.source), this.addVertexToTree(i.source), this.treeVertices.push(i.source), i.inTree = !0);
    }
    return this.treeVertices.length;
  }
  // leaveEnterEdge finds a non-tree edge to replace e.
  // This is done by breaking the tree, by removing e, into
  // the source and the target componentx.
  // All edges going from the source component to the
  // target are considered for the replacement, and an edge with the minimum
  // slack being chosen. This maintains feasibility.
  leaveEnterEdge() {
    let t, e, i = 0;
    for (const r of this.graph.edges)
      r.inTree && r.cut < i && (i = r.cut, t = r);
    if (t == null)
      return null;
    let s = !1, n = oe.infinity;
    for (const r of this.graph.edges) {
      const o = this.slack(r);
      if (r.inTree === !1 && this.edgeSourceTargetVal(r, t) === -1 && (o < n || o === n && (s = Xs(2) === 1))) {
        if (n = o, e = r, n === 0 && !s)
          break;
        s = !1;
      }
    }
    if (e == null)
      throw new Error();
    return { leaving: t, entering: e };
  }
  // If f = (w,x) is the entering edge, the
  // only edges whose cut values must be adjusted are those in the path
  // connecting w and x in the tree, excluding e. This path is determined by
  // following the parent edges back from w and x until the least common ancestor is
  // reached, i.e., the first node l such that low(l) less or equal lim(w) ,lim(x) less or equal lim(l).
  // Of course, these postorder parameters must also be adjusted when
  // exchanging tree edges, but only for nodes below l.
  // e - exiting edge, f - entering edge
  exchange(t, e) {
    const i = this.commonPredecessorOfSourceAndTargetOfF(e);
    this.createPathForCutUpdates(t, e, i), this.updateLimLowLeavesAndParentsUnderNode(i), this.updateCuts(t), this.updateLayersUnderNode(i);
  }
  updateLayersUnderNode(t) {
    const e = new mt.Stack();
    e.push(t);
    for (let i = 0; i < this.nodeCount; i++)
      this.low(t) <= this.lim(i) && this.lim(i) <= this.lim(t) && i !== t && (this.layers[i] = oe.infinity);
    for (; e.length > 0; ) {
      const i = e.pop();
      for (const s of this.graph.outEdges[i])
        s.inTree && this.layers[s.target] === oe.infinity && (this.layers[s.target] = this.layers[i] - s.separation, e.push(s.target));
      for (const s of this.graph.inEdges[i])
        s.inTree && this.layers[s.source] === oe.infinity && (this.layers[s.source] = this.layers[i] + s.separation, e.push(s.source));
    }
  }
  updateCuts(t) {
    let e = new mt.Stack(), i = new mt.Stack();
    for (e.push(t.source), e.push(t.target); e.length > 0; ) {
      for (; e.length > 0; ) {
        const n = e.pop(), r = this.parent(n);
        if (r == null || r.cut !== oe.infinity)
          continue;
        let o = 0;
        for (const h of this.incidentEdges(n))
          if (h.inTree === !1)
            o += this.edgeSourceTargetVal(h, r) * h.weight;
          else if (h === r)
            o += h.weight;
          else {
            const c = r.source === h.target || r.target === h.source ? 1 : -1, d = this.edgeContribution(h, n);
            o += d * c;
          }
        r.cut = o;
        const l = r.source === n ? r.target : r.source;
        this.allLowCutsHaveBeenDone(l) && i.push(l);
      }
      const s = e;
      e = i, i = s;
    }
  }
  createPathForCutUpdates(t, e, i) {
    let s = e.target;
    for (; s !== i; ) {
      const n = this.parent(s);
      n.cut = oe.infinity, s = n.source === s ? n.target : n.source;
    }
    e.cut = oe.infinity, t.inTree = !1, e.inTree = !0;
  }
  commonPredecessorOfSourceAndTargetOfF(t) {
    let e, i;
    this.lim(t.source) < this.lim(t.target) ? (e = this.lim(t.source), i = this.lim(t.target)) : (e = this.lim(t.target), i = this.lim(t.source));
    let s = t.source;
    for (; !(this.low(s) <= e && i <= this.lim(s)); ) {
      const n = this.parent(s);
      n.cut = oe.infinity, s = n.source === s ? n.target : n.source;
    }
    return s;
  }
  checkCutValues() {
    for (const t of this.graph.edges)
      if (t.inTree) {
        let e = 0;
        for (const i of this.graph.edges)
          e += this.edgeSourceTargetVal(i, t) * i.weight;
        t.cut !== e && console.log(Gt.String.format("cuts are wrong for {0}; should be {1} but is {2}", t, e, t.cut));
      }
  }
  initLayers() {
    const t = new Lg(this.graph);
    return this.layers = t.GetLayers();
  }
  run() {
    if (this.graph.edges.length === 0 && this.graph.nodeCount === 0)
      this.layers = [];
    else {
      this.feasibleTree();
      let t;
      for (; (t = this.leaveEnterEdge()) != null; )
        this.exchange(t.leaving, t.entering);
      this.shiftLayerToZero();
    }
  }
}
class Bg {
  GetLayers() {
    return new sc(this.graph, this.Cancel).GetLayers();
  }
  ShrunkComponent(t) {
    const e = [];
    for (const i of t) {
      const s = i[0], n = i[1];
      for (const r of this.graph.outEdges[s]) {
        const o = new Ye(n, t.get(r.target), r.edge);
        o.separation = r.separation, o.weight = r.weight, e.push(o);
      }
    }
    return new wn(e, t.size);
  }
  constructor(t, e) {
    this.graph = t, this.Cancel = e;
  }
}
class Pe {
  // ToString
  toString() {
    return "la:ra " + this.la + " " + this.ra + " ta:ba " + this.ta + " " + this.ba + " x:y " + this.x_ + " " + this.y_;
  }
  // distance for the center of the node to its left boundary
  get leftAnchor() {
    return this.la;
  }
  set leftAnchor(t) {
    this.la = Math.max(t, 0);
  }
  // distance from the center of the node to its right boundary
  get rightAnchor() {
    return this.ra;
  }
  set rightAnchor(t) {
    this.ra = Math.max(t, 0);
  }
  // distance from the center of the node to its top boundary
  get topAnchor() {
    return this.ta;
  }
  set topAnchor(t) {
    this.ta = Math.max(t, 0);
  }
  get bottomAnchor() {
    return this.ba;
  }
  set bottomAnchor(t) {
    this.ba = Math.max(t, 0);
  }
  // Left boundary of the node
  get left() {
    return this.x_ - this.la;
  }
  // right boundary of the node
  get right() {
    return this.x_ + this.ra;
  }
  // top boundary of the node
  get top() {
    return this.y_ + this.ta;
  }
  set top(t) {
    this.y_ += t - this.ta;
  }
  // bottom of the node
  get bottom() {
    return this.y_ - this.ba;
  }
  set bottom(t) {
    this.y_ += t - this.ba;
  }
  get leftTop() {
    return new u(this.left, this.top);
  }
  get leftBottom() {
    return new u(this.left, this.bottom);
  }
  // this.right bottom of the node
  get rightBottom() {
    return new u(this.right, this.bottom);
  }
  get node() {
    return this.node_;
  }
  set node(t) {
    this.node_ = t, this.polygonalBoundary_ = null;
  }
  // Right top of the node
  get rightTop() {
    return new u(this.right, this.top);
  }
  constructor(t) {
    this.padding = 0, this.alreadySitsOnASpline = !1, this.labelIsToTheLeftOfTheSpline = !1, this.labelIsToTheRightOfTheSpline = !1, this.labelCornersPreserveCoefficient = t;
  }
  // constructor
  static mkAnchor(t, e, i, s, n, r) {
    const o = new Pe(r);
    return o.la = t, o.ra = e, o.ta = i, o.ba = s, o.node = n, o;
  }
  // the x position
  get x() {
    return this.x_;
  }
  set x(t) {
    this.polygonalBoundary_ = null, this.x_ = t;
  }
  get y() {
    return this.y_;
  }
  set y(t) {
    this.polygonalBoundary_ = null, this.y_ = t;
  }
  // Center of the node
  get origin() {
    return new u(this.x, this.y);
  }
  get width() {
    return this.la + this.ra;
  }
  get height() {
    return this.ta + this.ba;
  }
  // set to true if the anchor has been introduced for a label
  get hasLabel() {
    return this.labelIsToTheLeftOfTheSpline || this.labelIsToTheLeftOfTheSpline;
  }
  get LabelWidth() {
    if (this.labelIsToTheLeftOfTheSpline)
      return this.leftAnchor;
    if (this.labelIsToTheRightOfTheSpline)
      return this.rightAnchor;
    throw new Error();
  }
  // the polygon representing the boundary of a node
  get polygonalBoundary() {
    return this.polygonalBoundary_ != null ? this.polygonalBoundary_ : this.polygonalBoundary_ = Pe.pad(this.creatPolygonalBoundaryWithoutPadding(), this.padding);
  }
  static pad(t, e) {
    return e === 0 ? t : Pe.curveIsConvex(t) ? Pe.padConvexCurve(t, e) : Pe.padConvexCurve(t.boundingBox.perimeter(), e);
  }
  static padCorner(t, e, i, s, n) {
    const r = Pe.getPaddedCorner(e, i, s, n);
    t.addPoint(r.a), r.numberOfPoints === 2 && t.addPoint(r.b);
  }
  static padConvexCurve(t, e) {
    const i = new B();
    Pe.padCorner(i, t.endPoint.prev, t.endPoint, t.startPoint, e), Pe.padCorner(i, t.endPoint, t.startPoint, t.startPoint.next, e);
    for (let s = t.startPoint; s.next.next != null; s = s.next)
      Pe.padCorner(i, s, s.next, s.next.next, e);
    return i.closed = !0, i;
  }
  static getPaddedCorner(t, e, i, s) {
    const n = t.point, r = e.point, o = i.point, l = u.getTriangleOrientation(n, r, o) === L.Counterclockwise, h = r.sub(n), c = h.rotate((l ? -Math.PI : Math.PI) / 2).normalize(), d = h.normalize().add(r.sub(o).normalize());
    if (d.length < m.intersectionEpsilon)
      return {
        a: r.add(c.mul(s)),
        b: null,
        numberOfPoints: 1
      };
    const f = d.normalize().mul(s), p = f.rotate(Math.PI / 2), P = (s - f.dot(c)) / p.dot(c);
    return {
      a: f.add(p.mul(P)).add(r),
      b: f.sub(p.mul(P)).add(r),
      numberOfPoints: 2
      //number of points to add
    };
  }
  static *orientations(t) {
    yield u.getTriangleOrientation(t.endPoint.point, t.startPoint.point, t.startPoint.next.point), yield u.getTriangleOrientation(t.endPoint.prev.point, t.endPoint.point, t.startPoint.point);
    let e = t.startPoint;
    for (; e.next.next != null; )
      yield u.getTriangleOrientation(e.point, e.next.point, e.next.next.point), e = e.next;
  }
  static curveIsConvex(t) {
    let e = L.Collinear;
    for (const i of Pe.orientations(t))
      if (i !== L.Collinear) {
        if (e === L.Collinear)
          e = i;
        else if (i !== e)
          return !1;
      }
    return !0;
  }
  //private static number TurnAfterSeg(Curve curve, int i) {
  //   return Point.SignedDoubledTriangleArea(curve.segs[i].start, curve.segs[i].End, curve.segs[(i + 1) / curve.segs.Count].End);
  //}
  creatPolygonalBoundaryWithoutPadding() {
    return this.hasLabel ? this.labelIsToTheLeftOfTheSpline ? this.polygonOnLeftLabel() : this.polygonOnRightLabel() : this.nodeBoundary == null ? this.standardRectBoundary() : g.polylineAroundClosedCurve(this.nodeBoundary);
  }
  get nodeBoundary() {
    return this.node == null ? null : this.node.boundaryCurve;
  }
  standardRectBoundary() {
    const t = new B();
    return t.addPoint(this.leftTop), t.addPoint(this.rightTop), t.addPoint(this.rightBottom), t.addPoint(this.leftBottom), t.closed = !0, t;
  }
  polygonOnLeftLabel() {
    const t = this.left + (1 - this.labelCornersPreserveCoefficient) * this.LabelWidth;
    return B.mkClosedFromPoints([
      new u(t, this.top),
      this.rightTop,
      this.rightBottom,
      new u(t, this.bottom),
      new u(this.left, this.y)
    ]);
  }
  polygonOnRightLabel() {
    const t = this.right - (1 - this.labelCornersPreserveCoefficient) * this.LabelWidth;
    return B.mkClosedFromPoints([
      new u(t, this.top),
      new u(this.right, this.y),
      new u(t, this.bottom),
      this.leftBottom,
      this.leftTop
    ]);
  }
  move(t) {
    this.x += t.x, this.y += t.y;
  }
}
class us {
  get CurrentEnumRightUp() {
    return (this.LR ? 0 : 1) + 2 * (this.BT ? 0 : 1);
  }
  // Returns true if v is a virtual vertex
  IsVirtual(t) {
    return t >= this.nOfOriginalVertices;
  }
  Source(t) {
    return this.BT ? t.Source : t.Target;
  }
  Target(t) {
    return this.BT ? t.Target : t.Source;
  }
  static CalculateXCoordinates(t, e, i, s, n) {
    new us(t, e, i, s, n).Calculate();
  }
  Calculate() {
    this.SortInAndOutEdges(), this.RightUpSetup(), this.CalcBiasedAlignment(), this.LeftUpSetup(), this.CalcBiasedAlignment(), this.RightDownSetup(), this.CalcBiasedAlignment(), this.LeftDownSetup(), this.CalcBiasedAlignment(), this.HorizontalBalancing();
  }
  // We need to find a median of a vertex neighbors from a specific layer. That is, if we have a vertex v and edges (v,coeff), (v,side1), (v,cornerC)
  // going down, and X[coeff]<X[side1]<X[cornerC], then side1 is the median.
  // There is an algorithm that finds the median with expected linear number of steps,
  // see for example http://www.ics.uci.edu/~eppstein/161/960125.html. However, I think we are better off
  // with sorting, since we are taking median at least twice.
  // Notice, that the sorting should be done only for original vertices since dummy vertices
  // have only one incoming edge and one outcoming edge.
  // Consider here reusing the sorting that comes from the ordering step,
  // if it is not broken by layer insertions.
  SortInAndOutEdges() {
    this.FillLowMedians(), this.FillUpperMedins();
  }
  FillUpperMedins() {
    this.upperMedians = new Array(this.graph.NodeCount);
    for (let t = 0; t < this.graph.NodeCount; t++)
      this.FillUpperMediansForNode(t);
  }
  CompareByX(t, e) {
    return this.la.x[t] - this.la.x[e];
  }
  FillUpperMediansForNode(t) {
    let e = this.graph.InEdgesCount(t);
    if (e > 0) {
      const i = new Array(e);
      e = 0;
      for (const n of this.graph.InEdges(t))
        i[e++] = n.Source;
      i.sort((n, r) => this.CompareByX(n, r));
      const s = Math.floor(e / 2);
      s * 2 === e ? this.upperMedians[t] = new U(i[s - 1], i[s]) : this.upperMedians[t] = i[s];
    } else
      this.upperMedians[t] = -1;
  }
  FillLowMedians() {
    this.lowMedians = new Array(this.graph.NodeCount);
    for (let t = 0; t < this.graph.NodeCount; t++)
      this.FillLowMediansForNode(t);
  }
  FillLowMediansForNode(t) {
    let e = this.graph.OutEdgesCount(t);
    if (e > 0) {
      const i = new Array(e);
      e = 0;
      for (const n of this.graph.OutEdges(t))
        i[e++] = n.Target;
      i.sort((n, r) => this.CompareByX(n, r));
      const s = Math.floor(e / 2);
      s * 2 === e ? this.lowMedians[t] = new U(i[s - 1], i[s]) : this.lowMedians[t] = i[s];
    } else
      this.lowMedians[t] = -1;
  }
  HorizontalBalancing() {
    let t = -1;
    const e = new Array(4), i = new Array(4);
    let s = Number.MAX_VALUE;
    for (let r = 0; r < 4; r++) {
      const o = { a: 0, b: 0 };
      this.AssignmentBounds(r, o), e[r] = o.a, i[r] = o.b;
      const l = i[r] - e[r];
      l < s && (t = r, s = l);
    }
    for (let r = 0; r < 4; r++) {
      let o;
      if (us.IsLeftMostAssignment(r) ? o = e[t] - e[r] : o = i[t] - i[r], this.x = this.xCoords[r], o !== 0)
        for (let l = 0; l < this.nOfVertices; l++)
          this.x[l] = this.x[l] + o;
    }
    const n = new Array(4);
    for (let r = 0; r < this.nOfVertices; r++)
      n[0] = this.xCoords[0][r], n[1] = this.xCoords[1][r], n[2] = this.xCoords[2][r], n[3] = this.xCoords[3][r], n.sort((o, l) => o - l), this.anchors[r].x = (n[1] + n[2]) / 2;
  }
  static IsLeftMostAssignment(t) {
    return t === 0 || t === 2;
  }
  AssignmentBounds(t, e) {
    if (this.nOfVertices === 0)
      e.a = 0, e.b = 0;
    else {
      this.x = this.xCoords[t], e.a = e.b = this.x[0];
      for (let i = 1; i < this.nOfVertices; i++) {
        const s = this.x[i];
        s < e.a ? e.a = s : s > e.b && (e.b = s);
      }
    }
  }
  CalcBiasedAlignment() {
    this.ConflictElimination(), this.Align();
  }
  LeftUpSetup() {
    this.LR = !1, this.BT = !0;
  }
  LeftDownSetup() {
    this.LR = !1, this.BT = !1;
  }
  RightDownSetup() {
    this.LR = !0, this.BT = !1;
  }
  RightUpSetup() {
    this.LR = !0, this.BT = !0;
  }
  // The code is written as if we go left up, but in fact the settings define the directions.
  //
  // We need to create a subgraph for alignment:
  // where no edge segments intersect, and every vertex has
  // at most one incoming and at most one outcoming edge.
  // This function marks edges to resolve conflicts with only one inner segment.
  // An inner segment is a segment between two dummy nodes.
  // We mark edges that later will not participate in the alignment.
  // Inner segments are preferred to other ones. So, in a conflict with one inner and one
  // non-inner edges we leave the inner edge to participate in the alignment.
  // At the moment we mark as not participating both of the two intersecting inner segments
  ConflictElimination() {
    this.RemoveMarksFromEdges(), this.MarkConflictingEdges();
  }
  // iterator
  *UpperEdgeMedians(t) {
    const e = this.BT ? this.upperMedians[t] : this.lowMedians[t];
    if (typeof e != "number") {
      const s = e;
      this.LR ? (yield s.x, yield s.y) : (yield s.y, yield s.x);
    } else {
      const s = e;
      s >= 0 && (yield s);
    }
  }
  // here we eliminate all constraints
  MarkConflictingEdges() {
    let t = this.LowerOf(0, this.h - 1);
    const e = t, i = this.UpperOf(0, this.h - 1), s = this.NextLower(i);
    for (; this.IsBelow(t, i); t = this.NextUpper(t))
      this.IsBelow(e, t) && this.IsBelow(t, s) && this.ConflictsWithAtLeastOneInnerEdgeForALayer(t);
  }
  // parameterized next upper
  NextUpper(t) {
    return this.BT ? t + 1 : t - 1;
  }
  // parameterized next lower
  NextLower(t) {
    return this.BT ? t - 1 : t + 1;
  }
  // parameterize highest of two numbers
  UpperOf(t, e) {
    return this.BT ? Math.max(t, e) : Math.min(t, e);
  }
  // parameterized lowest of a pair
  LowerOf(t, e) {
    return this.BT ? Math.min(t, e) : Math.max(t, e);
  }
  // returns parameterized below
  IsBelow(t, e) {
    return this.BT ? t < e : e < t;
  }
  // returns the "parameterized" left of the two positions
  LeftMost(t, e) {
    return this.LR ? Math.min(t, e) : Math.max(t, e);
  }
  // returns the "parameterized" right of the two positions
  RightMost(t, e) {
    return this.LR ? Math.max(t, e) : Math.min(t, e);
  }
  // Return true if i is to the left or equal to pos in a "parameterized" fasion
  IsNotRightFrom(t, e) {
    return this.LR ? t <= e : e <= t;
  }
  // Parameterized left relation
  IsLeftFrom(t, e) {
    return this.LR ? t < e : e < t;
  }
  // parameterized next right
  NextRight(t) {
    return this.LR ? t + 1 : t - 1;
  }
  // parameterized next left
  NextLeft(t) {
    return this.LR ? t - 1 : t + 1;
  }
  // // Eliminates conflicts with at least one inner edge inside of one layer
  // // <
  ConflictsWithAtLeastOneInnerEdgeForALayer(t) {
    if (t >= 0 && t < this.la.Layers.length) {
      const e = this.la.Layers[t];
      let i = null, s = this.LeftMost(0, e.length - 1);
      const n = this.RightMost(0, e.length - 1);
      for (; this.IsNotRightFrom(s, n) && i == null; s = this.NextRight(s))
        i = this.InnerEdgeByTarget(e[s]);
      if (i != null) {
        const r = this.Pos(this.Source(i));
        for (let l = this.LeftMost(0, e.length - 1); this.IsLeftFrom(l, s); l = this.NextRight(l))
          for (const h of this.InEdges(e[l]))
            this.IsLeftFrom(r, this.Pos(this.Source(h))) && this.MarkEdge(h);
        let o = this.Pos(this.Source(i));
        for (; this.IsNotRightFrom(s, n); ) {
          const l = this.AlignmentToTheRightOfInner(e, s, r);
          if (s = this.NextRight(s), l != null) {
            const h = this.Pos(this.Source(l));
            this.MarkEdgesBetweenInnerAndNewInnerEdges(e, i, l, o, h), i = l, o = h;
          }
        }
        for (let l = this.NextRight(this.Pos(this.Target(i))); this.IsNotRightFrom(l, n); l = this.NextRight(l))
          for (const h of this.InEdges(e[l]))
            this.IsLeftFrom(this.Pos(this.Source(h)), this.Pos(this.Source(i))) && this.MarkEdge(h);
      }
    }
  }
  InEdgeOfVirtualNode(t) {
    return this.BT ? this.graph.InEdgeOfVirtualNode(t) : this.graph.OutEdgeOfVirtualNode(t);
  }
  InEdges(t) {
    return this.BT ? this.graph.InEdges(t) : this.graph.OutEdges(t);
  }
  // // This function marks conflicting edges with targets positioned between innerEdge and newInnerEdge targets.
  // // <
  MarkEdgesBetweenInnerAndNewInnerEdges(t, e, i, s, n) {
    let r = this.NextRight(this.Pos(this.Target(e)));
    for (; this.IsLeftFrom(r, this.Pos(this.Target(i))); r = this.NextRight(r))
      for (const o of this.InEdges(t[r])) {
        const l = this.Pos(this.Source(o));
        this.IsLeftFrom(l, s) ? this.MarkEdge(o) : this.IsLeftFrom(n, l) && this.MarkEdge(o);
      }
  }
  // // Returns the inner non-conflicting edge incoming into i-th position
  // // of the layer or null if there is no such edge
  // // <
  AlignmentToTheRightOfInner(t, e, i) {
    if (this.NumberOfInEdges(t[e]) === 1) {
      let n = null;
      for (const r of this.InEdges(t[e]))
        n = r;
      return this.IsInnerEdge(n) && this.IsLeftFrom(i, this.Pos(n.Source)) ? n : null;
    }
    return null;
  }
  NumberOfInEdges(t) {
    return this.BT ? this.graph.InEdgesCount(t) : this.graph.OutEdgesCount(t);
  }
  Pos(t) {
    return this.la.x[t];
  }
  InnerEdgeByTarget(t) {
    if (this.IsVirtual(t)) {
      const e = this.InEdgeOfVirtualNode(t);
      if (this.IsVirtual(this.Source(e)))
        return e;
    }
    return null;
  }
  IsInnerEdge(t) {
    return this.IsVirtual(t.Source) && this.IsVirtual(t.Target);
  }
  RemoveMarksFromEdges() {
    this.markedEdges.clear();
  }
  // // private constructor
  // // <
  constructor(t, e, i, s, n) {
    this.xCoords = new Array(4), this.la = t, this.graph = e, this.nOfOriginalVertices = i, this.nOfVertices = this.graph.NodeCount, this.markedEdges = new ti(), this.h = this.la.Layers.length, this.root = new Array(this.nOfVertices), this.align = new Array(this.nOfVertices), this.anchors = s, this.nodeSep = n;
  }
  // Calculate the alignment based on the marked edges and greedily resolve the remaining conflicts on the fly, without marking
  Align() {
    this.CreateBlocks(), this.AssignCoordinatesByLongestPath();
  }
  AssignCoordinatesByLongestPath() {
    this.x = this.xCoords[this.CurrentEnumRightUp] = new Array(this.nOfVertices);
    const t = new Array();
    for (let s = 0; s < this.nOfVertices; s++)
      if (s === this.root[s]) {
        let n = s;
        do {
          const r = { neighbor: 0 };
          this.TryToGetRightNeighbor(n, r) && t.push(new Ye(s, this.root[r.neighbor], null)), n = this.align[n];
        } while (n !== s);
      }
    const e = fi(t, this.nOfVertices), i = no.getOrderOnGraph(e);
    for (const s of i)
      if (s === this.root[s]) {
        let n = 0, r = !0, o = s;
        do {
          const l = { neighbor: 0 };
          this.TryToGetLeftNeighbor(o, l) && (r ? (n = this.x[this.root[l.neighbor]] + this.DeltaBetweenVertices(l.neighbor, o), r = !1) : n = this.RightMost(n, this.x[this.root[l.neighbor]] + this.DeltaBetweenVertices(l.neighbor, o))), o = this.align[o];
        } while (o !== s);
        this.x[s] = n;
      }
    for (const s of i)
      if (s === this.root[s] && e.inEdges[s].length === 0) {
        let n = s, r = this.RightMost(-us.infinity, us.infinity);
        const o = r;
        do {
          const l = { neighbor: 0 };
          this.TryToGetRightNeighbor(n, l) && (r = this.LeftMost(r, this.x[this.root[l.neighbor]] - this.DeltaBetweenVertices(n, l.neighbor))), n = this.align[n];
        } while (n !== s);
        o !== r && (this.x[s] = r);
      }
    for (let s = 0; s < this.nOfVertices; s++)
      s !== this.root[s] && (this.x[s] = this.x[this.root[s]]);
  }
  // returns true is u has a right neighbor on its layer
  TryToGetRightNeighbor(t, e) {
    const i = this.NextRight(this.Pos(t)), s = this.la.Layers[this.la.y[t]];
    return i >= 0 && i < s.length ? (e.neighbor = s[i], !0) : !1;
  }
  // returns true is u has a right neighbor on its layer
  TryToGetLeftNeighbor(t, e) {
    const i = this.NextLeft(this.Pos(t)), s = this.la.Layers[this.la.y[t]];
    return i >= 0 && i < s.length ? (e.neighbor = s[i], !0) : !1;
  }
  // Organizes the vertices into blocks. A block is a maximal path in the alignment subgraph.
  // The alignment is defined by array align. Every vertex is connected to the top vertex of
  // the block by using root array. The alignment is cyclic. If we start from a root vertex v and
  // apply align then we return to v at some point.
  CreateBlocks() {
    for (let e = 0; e < this.nOfVertices; e++)
      this.root[e] = this.align[e] = e;
    const t = this.LowerOf(0, this.h - 1);
    for (let e = this.NextLower(this.UpperOf(0, this.h - 1)); !this.IsBelow(e, t); e = this.NextLower(e)) {
      const i = this.la.Layers[e];
      let s = this.LeftMost(-1, this.la.Layers[this.NextUpper(e)].length);
      const n = this.RightMost(0, i.length - 1);
      for (let r = this.LeftMost(0, i.length - 1); this.IsNotRightFrom(r, n); r = this.NextRight(r)) {
        const o = i[r];
        for (const l of this.UpperEdgeMedians(o))
          if (!this.IsMarked(o, l) && this.IsLeftFrom(s, this.Pos(l))) {
            this.align[l] = o, this.root[o] = this.root[l], this.align[o] = this.root[l], s = this.Pos(l);
            break;
          }
      }
    }
  }
  IsMarked(t, e) {
    return this.BT ? this.markedEdges.hasxy(e, t) : this.markedEdges.hasxy(t, e);
  }
  MarkEdge(t) {
    this.markedEdges.addNN(t.Source, t.Target);
  }
  // Calculates the minimum separation between two neighboring vertices: if u is to the left of v on the same layer return positive
  // number, otherwise negative.
  DeltaBetweenVertices(t, e) {
    let i;
    if (this.Pos(t) > this.Pos(e)) {
      const s = t;
      t = e, e = s, i = -1;
    } else
      i = 1;
    return (this.anchors[t].rightAnchor + this.anchors[e].leftAnchor + this.nodeSep) * i;
  }
}
us.infinity = 1e7;
class Gg extends te {
  // weight multiplier for edges with two virtual nodes
  /* internal */
  constructor(t, e, i, s, n) {
    super(), this.weightMultiplierOfOriginalOriginal = 1, this.weightMultOfOneVirtual = 3, this.weightMultiplierOfTwoVirtual = 8, this.SetEdges(s, n), this.virtualVerticesStart = t.nodeCount, this.virtualVerticesEnd = e.NodeCount - 1, this.layeredGraph = e, this.layerArrays = i;
  }
  // following Gansner etc 93 returning weight multplier bigger if there are virtual nodes
  EdgeWeightMultiplier(t) {
    const e = t.source, i = t.target;
    if (e < this.layeredGraph.NodeCount && this.layerArrays.y[e] === this.layerArrays.y[i] && this.layerArrays.x[e] === this.layerArrays.x[i] + 1)
      return 0;
    let s = 0, n = -1, r = -1;
    for (const l of this.outEdges[e])
      r === -1 ? r = l.target : n = l.target;
    return r >= this.virtualVerticesStart && r <= this.virtualVerticesEnd && s++, n >= this.virtualVerticesStart && n <= this.virtualVerticesEnd && s++, s === 0 ? this.weightMultiplierOfOriginalOriginal : s === 1 ? this.weightMultOfOneVirtual : this.weightMultiplierOfTwoVirtual;
  }
  // caching edges weights
  SetEdgeWeights() {
    for (const t of this.edges)
      t.weight = t.weight * this.EdgeWeightMultiplier(t);
  }
}
var kt;
(function(a) {
  a[a.Top = 0] = "Top", a[a.Internal = 1] = "Internal", a[a.Bottom = 2] = "Bottom";
})(kt || (kt = {}));
class Ds {
  static Calculate(t, e = 0) {
    return new Ds(t, e).Calculate();
  }
  constructor(t, e) {
    this.groupSplitThreshold = 2, this.initialNodes = t, this.groupSplitThreshold = e;
  }
  Calculate() {
    return this.Calc(this.initialNodes);
  }
  Calc(t) {
    if (t.length === 0)
      return null;
    if (t.length === 1)
      return t[0];
    const e = t[0].parallelogram;
    let i = 1, s = Q.parallelogramOfTwo(e, t[i].parallelogram).area;
    for (let c = 2; c < t.length; c++) {
      const d = Q.parallelogramOfTwo(e, t[c].parallelogram).area;
      d > s && (i = c, s = d);
    }
    let n;
    for (let c = 0; c < t.length; c++)
      if (c !== i) {
        n = c;
        break;
      }
    s = Q.parallelogramOfTwo(t[i].parallelogram, t[n].parallelogram).area;
    for (let c = 0; c < t.length; c++) {
      if (c === i)
        continue;
      const d = Q.parallelogramOfTwo(t[i].parallelogram, t[c].parallelogram).area;
      d > s && (n = c, s = d);
    }
    const r = new Array(), o = new Array();
    r.push(t[i]), o.push(t[n]);
    let l = t[i].parallelogram, h = t[n].parallelogram;
    for (let c = 0; c < t.length; c++) {
      if (c === i || c === n)
        continue;
      const d = Q.parallelogramOfTwo(l, t[c].parallelogram), f = d.area - l.area, p = Q.parallelogramOfTwo(h, t[c].parallelogram), P = p.area - h.area;
      r.length * this.groupSplitThreshold < o.length ? (r.push(t[c]), l = d) : o.length * this.groupSplitThreshold < r.length ? (o.push(t[c]), h = p) : f < P ? (r.push(t[c]), l = d) : (o.push(t[c]), h = p);
    }
    return {
      parallelogram: Q.parallelogramOfTwo(l, h),
      node: { children: [this.Calc(r), this.Calc(o)] },
      seg: void 0,
      leafBoxesOffset: void 0
    };
  }
}
class pe {
  constructor(t, e, i, s, n, r, o, l) {
    this.topNode = t, this.bottomNode = e, this.topSite = i, this.bottomSite = i.next, this.currentTopSite = i, this.currentBottomSite = i.next, this.layerArrays = s, this.layeredGraph = n, this.originalGraph = r, this.anchors = o, this.layerSeparation = l;
  }
  static Refine(t, e, i, s, n, r, o, l) {
    new pe(t, e, i, n, r, o, s, l).Refine();
  }
  Refine() {
    for (this.Init(); this.InsertSites(); )
      ;
  }
  FixCorner(t, e, i) {
    if (t.equal(e))
      return e;
    const s = u.ClosestPointAtLineSegment(e, t, i);
    let n = e.sub(s);
    const r = Math.abs(n.y), o = this.layerSeparation / 2;
    return r > o && (n = n.mul(o / (r * 2))), n.add(e);
  }
  InsertSites() {
    return Xs(2) === 0 ? this.CalculateNewTopSite() || this.CalculateNewBottomSite() : this.CalculateNewBottomSite() || this.CalculateNewTopSite();
  }
  // circimvating from the side
  CalculateNewBottomSite() {
    const t = this.currentBottomSite.point.sub(this.currentTopSite.point);
    let e = pe.absCotan(t), i, s = !1;
    for (const n of this.bottomCorners()) {
      const r = pe.absCotan(n.sub(this.currentBottomSite.point));
      r < e && (e = r, i = n, s = !0);
    }
    return s ? D(e, pe.absCotan(t)) ? !1 : (this.currentBottomSite = St.mkSiteSPS(this.currentTopSite, this.FixCorner(this.currentTopSite.point, i, this.currentBottomSite.point), this.currentBottomSite), !0) : !1;
  }
  static absCotan(t) {
    return Math.abs(t.x / t.y);
  }
  CalculateNewTopSite() {
    const t = this.currentBottomSite.point.sub(this.currentTopSite.point);
    let e = pe.absCotan(t), i, s = !1;
    for (const n of this.topCorners()) {
      const r = pe.absCotan(n.sub(this.currentTopSite.point));
      r < e && (e = r, i = n, s = !0);
    }
    return s ? D(e, pe.absCotan(t)) ? !1 : (this.currentTopSite = St.mkSiteSPS(this.currentTopSite, this.FixCorner(this.currentTopSite.point, i, this.currentBottomSite.point), this.currentBottomSite), !0) : !1;
  }
  // private CornerSite AvoidBottomLayer() {
  //    Point corner;
  //    if (StickingCornerFromTheBottomLayer(out corner)) {
  //        corner = FixCorner(this.currentTopSite.v, corner, this.currentBottomSite.v);
  //        return new CornerSite(this.currentTopSite, corner, this.currentBottomSite);
  //    } else
  //        return null;
  // }
  // private CornerSite AvoidTopLayer() {
  //    Point corner;
  //    if (StickingCornerFromTheTopLayer(out corner)) {
  //        corner = FixCorner(this.currentTopSite.v, corner, this.currentBottomSite.v);
  //        return new CornerSite(this.currentTopSite, corner, this.currentBottomSite);
  //    } else
  //        return null;
  // }
  // private bool StickingCornerFromTheTopLayer(out Point corner) {
  //    corner = this.currentBottomSite.v;
  //    foreach (Point l of this.topCorners()) {
  //        Point p = l;
  //        if (this.counterClockwise(ref currentTopSite.v, ref p, ref corner))
  //            corner = p;
  //    }
  //    return corner !== this.currentBottomSite.v;
  // }
  // private bool StickingCornerFromTheBottomLayer(out Point corner) {
  //    corner = this.currentTopSite.v;
  //    foreach (Point l of this.bottomCorners()) {
  //        Point p = l;
  //        if (this.counterClockwise(ref currentBottomSite.v, ref p, ref corner))
  //            corner = p;
  //    }
  //    return corner !== this.currentTopSite.v;
  // }
  Init() {
    this.IsTopToTheLeftOfBottom() ? (this.topCorners = () => this.CornersToTheRightOfTop(), this.bottomCorners = () => this.CornersToTheLeftOfBottom()) : (this.topCorners = () => this.CornersToTheLeftOfTop(), this.bottomCorners = () => this.CornersToTheRightOfBottom());
  }
  IsTopToTheLeftOfBottom() {
    return this.topSite.point.x < this.topSite.next.point.x;
  }
  *NodeCorners(t) {
    for (const e of this.anchors[t].polygonalBoundary.polylinePoints())
      yield e.point;
  }
  *CornersToTheLeftOfBottom() {
    const t = this.layerArrays.x[this.bottomNode], e = this.currentTopSite.point.x, i = this.currentBottomSite.point.x;
    for (const s of this.LeftFromTheNode(this.NodeLayer(this.bottomNode), t, kt.Bottom, e, i))
      for (const n of this.NodeCorners(s))
        n.y > this.currentBottomSite.point.y && pe.PossibleCorner(e, i, n) && (yield n);
  }
  *CornersToTheLeftOfTop() {
    const t = this.layerArrays.x[this.topNode], e = this.currentBottomSite.point.x, i = this.currentTopSite.point.x;
    for (const s of this.LeftFromTheNode(this.NodeLayer(this.topNode), t, kt.Top, e, i))
      for (const n of this.NodeCorners(s))
        n.y < this.currentTopSite.point.y && pe.PossibleCorner(e, i, n) && (yield n);
  }
  *CornersToTheRightOfBottom() {
    const t = this.layerArrays.x[this.bottomNode], e = this.currentBottomSite.point.x, i = this.currentTopSite.point.x;
    for (const s of this.RightFromTheNode(this.NodeLayer(this.bottomNode), t, kt.Bottom, e, i))
      for (const n of this.NodeCorners(s))
        n.y > this.currentBottomSite.point.y && pe.PossibleCorner(e, i, n) && (yield n);
  }
  *CornersToTheRightOfTop() {
    const t = this.layerArrays.x[this.topNode], e = this.currentTopSite.point.x, i = this.currentBottomSite.point.x;
    for (const s of this.RightFromTheNode(this.NodeLayer(this.topNode), t, kt.Top, e, i))
      for (const n of this.NodeCorners(s))
        n.y < this.currentTopSite.point.y && pe.PossibleCorner(e, i, n) && (yield n);
  }
  static PossibleCorner(t, e, i) {
    return i.x > t && i.x < e;
  }
  NodeLayer(t) {
    return this.layerArrays.Layers[this.layerArrays.y[t]];
  }
  IsLabel(t) {
    return this.anchors[t].hasLabel;
  }
  NodeUCanBeCrossedByNodeV(t, e) {
    return this.IsLabel(t) || this.IsLabel(e) ? !1 : !!(this.IsVirtualVertex(t) && this.IsVirtualVertex(e) && this.AdjacentEdgesIntersect(t, e));
  }
  AdjacentEdgesIntersect(t, e) {
    return this.Intersect(this.IncomingEdge(t), this.IncomingEdge(e)) || this.Intersect(this.OutcomingEdge(t), this.OutcomingEdge(e));
  }
  Intersect(t, e) {
    return (this.layerArrays.x[t.Source] - this.layerArrays.x[e.Source]) * (this.layerArrays.x[t.Target] - this.layerArrays.x[e.Target]) < 0;
  }
  IncomingEdge(t) {
    for (const e of this.layeredGraph.InEdges(t))
      return e;
    throw new Error();
  }
  // here u is a virtual vertex
  OutcomingEdge(t) {
    for (const e of this.layeredGraph.OutEdges(t))
      return e;
    throw new Error();
  }
  IsVirtualVertex(t) {
    return t >= this.originalGraph.shallowNodeCount;
  }
  *RightFromTheNode(t, e, i, s, n) {
    let r = 0, o = 0;
    i === kt.Bottom && (r = Number.MAX_VALUE), i === kt.Top && (o = Number.MAX_VALUE);
    const l = t[e];
    for (let h = e + 1; h < t.length; h++) {
      const c = t[h];
      if (this.NodeUCanBeCrossedByNodeV(c, l))
        continue;
      const d = this.anchors[c];
      if (d.left >= n)
        break;
      d.right > s && (d.topAnchor > o + m.distanceEpsilon ? (o = d.topAnchor, yield c) : d.bottomAnchor > r + m.distanceEpsilon && (r = d.bottomAnchor, yield c));
    }
  }
  *LeftFromTheNode(t, e, i, s, n) {
    let r = 0, o = 0;
    i === kt.Bottom && (r = Number.MAX_VALUE), i === kt.Top && (o = Number.MAX_VALUE);
    const l = t[e];
    for (let h = e - 1; h > -1; h--) {
      const c = t[h];
      if (this.NodeUCanBeCrossedByNodeV(c, l))
        continue;
      const d = this.anchors[c];
      if (d.right <= s)
        break;
      d.left < n && (d.topAnchor > o + m.distanceEpsilon ? (o = d.topAnchor, yield c) : d.bottomAnchor > r + m.distanceEpsilon && (r = d.bottomAnchor, yield c));
    }
  }
}
class jt {
  // Creates a smoothed polyline
  constructor(t, e, i, s, n, r, o) {
    this.thinRightNodes = new Array(), this.thinWestNodes = new Array(), this.database = o, this.edgePath = t, this.anchors = e, this.layerArrays = n, this.originalGraph = i, this.settings = s, this.layeredGraph = r, this.eastHierarchy = this.BuildEastHierarchy(), this.westHierarchy = this.BuildWestHierarchy();
  }
  BuildEastHierarchy() {
    const t = this.FindEastBoundaryAnchorCurves(), e = new Array();
    for (const i of t)
      e.push(i.pNodeOverICurve());
    return this.thinEastHierarchy = Ds.Calculate(this.thinRightNodes), Ds.Calculate(e);
  }
  BuildWestHierarchy() {
    const t = this.FindWestBoundaryAnchorCurves(), e = new Array();
    for (const i of t)
      e.push(i.pNodeOverICurve());
    return this.thinWestHierarchy = Ds.Calculate(this.thinWestNodes), Ds.Calculate(e);
  }
  FindEastBoundaryAnchorCurves() {
    const t = new Array();
    let e = 0;
    for (const i of this.edgePath) {
      let s = null;
      for (const n of this.EastBoundaryNodesOfANode(i, Xi.GetNodeKind(e, this.edgePath))) {
        const r = this.anchors[n];
        (s == null || s.origin.x > r.origin.x) && (s = r), t.push(r.polygonalBoundary);
      }
      s != null && this.thinRightNodes.push(v.mkLinePXY(s.origin, this.originalGraph.right, s.y).pNodeOverICurve()), e++;
    }
    return t;
  }
  FindWestBoundaryAnchorCurves() {
    const t = [];
    let e = 0;
    for (const i of this.edgePath.nodes()) {
      let s = -1;
      for (const n of this.LeftBoundaryNodesOfANode(i, Xi.GetNodeKind(e, this.edgePath)))
        (s === -1 || this.layerArrays.x[n] > this.layerArrays.x[s]) && (s = n), t.push(this.anchors[n].polygonalBoundary);
      if (s !== -1) {
        const n = this.anchors[s];
        this.thinWestNodes.push(v.mkLinePXY(n.origin, this.originalGraph.left, n.origin.y).pNodeOverICurve());
      }
      e++;
    }
    return t;
  }
  *FillRightTopAndBottomVerts(t, e, i) {
    let s = 0, n = 0;
    i === kt.Bottom ? s = Number.MAX_VALUE : i === kt.Top && (n = Number.MAX_VALUE);
    const r = t[e];
    for (let o = e + 1; o < t.length; o++) {
      const l = t[o], h = this.anchors[l];
      h.topAnchor > n ? this.NodeUCanBeCrossedByNodeV(l, r) || (n = h.topAnchor, h.bottomAnchor > s && (s = h.bottomAnchor), yield l) : h.bottomAnchor > s && (this.NodeUCanBeCrossedByNodeV(l, r) || (s = h.bottomAnchor, h.topAnchor > n && (n = h.topAnchor), yield l));
    }
  }
  *FillLeftTopAndBottomVerts(t, e, i) {
    let s = 0, n = 0;
    i === kt.Top ? n = Number.MAX_VALUE : i === kt.Bottom && (s = Number.MAX_VALUE);
    const r = t[e];
    for (let o = e - 1; o >= 0; o--) {
      const l = t[o], h = this.anchors[l];
      h.topAnchor > n + m.distanceEpsilon ? this.NodeUCanBeCrossedByNodeV(l, r) || (n = h.topAnchor, s = Math.max(s, h.bottomAnchor), yield l) : h.bottomAnchor > s + m.distanceEpsilon && (this.NodeUCanBeCrossedByNodeV(l, r) || (n = Math.max(n, h.topAnchor), s = h.bottomAnchor, yield l));
    }
  }
  IsVirtualVertex(t) {
    return t >= this.originalGraph.shallowNodeCount;
  }
  IsLabel(t) {
    return this.anchors[t].hasLabel;
  }
  NodeUCanBeCrossedByNodeV(t, e) {
    return this.IsLabel(t) || this.IsLabel(e) ? !1 : !!(this.IsVirtualVertex(t) && this.IsVirtualVertex(e) && this.EdgesIntersectSomewhere(t, e));
  }
  EdgesIntersectSomewhere(t, e) {
    return this.UVAreMiddlesOfTheSameMultiEdge(t, e) ? !1 : this.IntersectAbove(t, e) || this.IntersectBelow(t, e);
  }
  UVAreMiddlesOfTheSameMultiEdge(t, e) {
    return !!(this.database.MultipleMiddles.has(t) && this.database.MultipleMiddles.has(e) && this.SourceOfTheOriginalEdgeContainingAVirtualNode(t) === this.SourceOfTheOriginalEdgeContainingAVirtualNode(e));
  }
  SourceOfTheOriginalEdgeContainingAVirtualNode(t) {
    for (; this.IsVirtualVertex(t); )
      t = this.IncomingEdge(t).Source;
    return t;
  }
  IntersectBelow(t, e) {
    do {
      const i = this.OutcomingEdge(t), s = this.OutcomingEdge(e);
      if (this.Intersect(i, s))
        return !0;
      t = i.Target, e = s.Target;
    } while (this.IsVirtualVertex(t) && this.IsVirtualVertex(e));
    return t === e;
  }
  IntersectAbove(t, e) {
    do {
      const i = this.IncomingEdge(t), s = this.IncomingEdge(e);
      if (this.Intersect(i, s))
        return !0;
      t = i.Source, e = s.Source;
    } while (this.IsVirtualVertex(t) && this.IsVirtualVertex(e));
    return t === e;
  }
  Intersect(t, e) {
    const i = this.layerArrays.x[t.Source] - this.layerArrays.x[e.Source], s = this.layerArrays.x[t.Target] - this.layerArrays.x[e.Target];
    return i > 0 && s < 0 || i < 0 && s > 0;
  }
  IncomingEdge(t) {
    return this.layeredGraph.InEdgeOfVirtualNode(t);
  }
  // here u is a virtual vertex
  OutcomingEdge(t) {
    return this.layeredGraph.OutEdgeOfVirtualNode(t);
  }
  EastBoundaryNodesOfANode(t, e) {
    return this.FillRightTopAndBottomVerts(this.NodeLayer(t), this.layerArrays.x[t], e);
  }
  NodeLayer(t) {
    return this.layerArrays.Layers[this.layerArrays.y[t]];
  }
  LeftBoundaryNodesOfANode(t, e) {
    return this.FillLeftTopAndBottomVerts(this.NodeLayer(t), this.layerArrays.x[t], e);
  }
  getSpline(t) {
    return this.createRefinedPolyline(t), this.createSmoothedPolyline();
  }
  // Poly(): Curve {
  //  const c: Curve = new Curve()
  //  for (let s = this.headSite; s.next != null; s = s.next) {
  //    c.addSegment(
  //      new BezierSeg(s.point, Point.convSum(1 / 3, s.point, s.next.point), Point.convSum(2 / 3, s.point, s.next.point), s.next.point),
  //    )
  //  }
  //  return c
  // }
  get GetPolyline() {
    return new Tt(this.headSite);
  }
  LineSegIntersectBound(t, e) {
    const i = v.mkPP(t, e);
    return jt.CurveIntersectsHierarchy(i, this.westHierarchy) || jt.CurveIntersectsHierarchy(i, this.thinWestHierarchy) || jt.CurveIntersectsHierarchy(i, this.eastHierarchy) || jt.CurveIntersectsHierarchy(i, this.thinEastHierarchy);
  }
  SegIntersectWestBound(t, e) {
    return jt.SegIntersectsBound(t, e, this.westHierarchy) || jt.SegIntersectsBound(t, e, this.thinWestHierarchy);
  }
  SegIntersectEastBound(t, e) {
    return jt.SegIntersectsBound(t, e, this.eastHierarchy) || jt.SegIntersectsBound(t, e, this.thinEastHierarchy);
  }
  TryToRemoveInflectionCorner(t) {
    if (!t.s.next || !t.s.prev || t.s.turn === L.Counterclockwise && this.SegIntersectEastBound(t.s.prev, t.s.next) || t.s.turn === L.Clockwise && this.SegIntersectWestBound(t.s.prev, t.s.next)) {
      t.cut = !1, t.s = t.s.next;
      return;
    }
    const e = t.s.next;
    t.s.prev.next = e, e.prev = t.s.prev, t.s = e, t.cut = !0;
  }
  static SegIntersectsBound(t, e, i) {
    return jt.CurveIntersectsHierarchy(v.mkPP(t.point, e.point), i);
  }
  static CurveIntersectsHierarchy(t, e) {
    if (e == null || !Q.intersect(t.pNodeOverICurve().parallelogram, e.parallelogram))
      return !1;
    if (e.node.hasOwnProperty("children")) {
      const i = e.node;
      return jt.CurveIntersectsHierarchy(t, i.children[0]) || jt.CurveIntersectsHierarchy(t, i.children[1]);
    }
    return g.intersectionOne(t, e.seg, !1) != null;
  }
  static Flat(t) {
    return u.getTriangleOrientation(t.prev.point, t.point, t.next.point) === L.Collinear;
  }
  Reverse() {
    const t = new jt(this.edgePath, this.anchors, this.originalGraph, this.settings, this.layerArrays, this.layeredGraph, this.database);
    let e = this.headSite, i = null;
    for (; e != null; )
      t.headSite = e.clone(), t.headSite.next = i, i != null && (i.prev = t.headSite), i = t.headSite, e = e.next;
    return t;
  }
  createRefinedPolyline(t) {
    this.CreateInitialListOfSites();
    let e = this.headSite, i;
    for (let s = 0; s < this.edgePath.count; s++)
      i = e.next, this.RefineBeetweenNeighborLayers(e, this.EdgePathNode(s), this.EdgePathNode(s + 1)), e = i;
    this.TryToRemoveInflections(), t && this.OptimizeShortPath();
  }
  RefineBeetweenNeighborLayers(t, e, i) {
    pe.Refine(e, i, t, this.anchors, this.layerArrays, this.layeredGraph, this.originalGraph, this.settings.LayerSeparation);
  }
  CreateInitialListOfSites() {
    let t = this.headSite = St.mkSiteP(this.EdgePathPoint(0));
    for (let e = 1; e <= this.edgePath.count; e++)
      t = St.mkSiteSP(t, this.EdgePathPoint(e));
  }
  get TailSite() {
    let t = this.headSite;
    for (; t.next != null; )
      t = t.next;
    return t;
  }
  OptimizeForThreeSites() {
    const t = this.EdgePathNode(0), e = this.EdgePathNode(2), i = this.anchors[t], s = this.anchors[e];
    if (D(i.x, s.x))
      return;
    const n = { ax: i.x, bx: s.x, sign: 0 };
    if (!this.FindLegalPositions(i, s, n))
      return;
    const r = (i.y - s.y) / (i.bottom - s.top), o = 0.5 * (n.ax + n.bx), l = n.sign * ((n.ax - n.bx) * 0.5);
    n.ax = o + r * (l * n.sign), n.bx = o - r * (l * n.sign), this.headSite.point = new u(n.ax, i.y);
    const h = this.headSite.next, c = h.point.y;
    h.point = new u(this.MiddlePos(n.ax, n.bx, i, s, c), c), h.next.point = new u(n.bx, s.y);
    const d = this.anchors[this.EdgePathNode(1)];
    d.x = h.point.x;
  }
  OptimizeForTwoSites() {
    const t = this.EdgePathNode(0), e = this.EdgePathNode(1), i = this.anchors[t], s = this.anchors[e];
    if (D(i.x, s.x))
      return;
    const n = { ax: i.x, bx: s.x, sign: 0 };
    if (!this.FindPositions(i, s, n))
      return;
    const r = (i.y - s.y) / (i.bottom - s.top), o = 0.5 * (n.ax + n.bx), l = n.sign * ((n.ax - n.bx) * 0.5);
    n.ax = o + r * (l * n.sign), n.bx = o - r * (l * n.sign), this.headSite.point = new u(n.ax, i.y), this.headSite.next.point = new u(n.bx, s.y);
  }
  FindLegalPositions(t, e, i) {
    return this.FindPositions(t, e, i) ? this.PositionsAreLegal(i.ax, i.bx, i.sign, t, e, this.EdgePathNode(1)) : !1;
  }
  FindPositions(t, e, i) {
    let s, n;
    if (i.ax < i.bx ? (i.sign = 1, n = Math.max(i.ax, e.left), s = Math.min(t.right, i.bx)) : (i.sign = -1, n = Math.max(t.left, i.bx), s = Math.min(e.right, i.ax)), n <= s)
      i.bx = 0.5 * (n + s), i.ax = 0.5 * (n + s);
    else {
      if (this.OriginToOriginSegCrossesAnchorSide(t, e))
        return !1;
      i.sign === 1 ? (i.ax = t.right - 0.1 * t.rightAnchor, i.bx = e.left) : (i.ax = t.left + 0.1 * t.leftAnchor, i.bx = e.right);
    }
    return !0;
  }
  OriginToOriginSegCrossesAnchorSide(t, e) {
    const i = v.mkPP(t.origin, e.origin);
    return t.x < e.x && g.CurvesIntersect(i, v.mkPP(t.rightBottom, t.rightTop)) || g.CurvesIntersect(i, v.mkPP(e.leftBottom, t.leftTop)) || t.x > e.x && g.CurvesIntersect(i, v.mkPP(t.leftBottom, t.leftTop)) || g.CurvesIntersect(i, v.mkPP(e.rightBottom, t.rightTop));
  }
  OptimizeShortPath() {
    this.edgePath.count > 2 || (this.edgePath.count === 2 && this.headSite.next.next != null && this.headSite.next.next.next == null && this.anchors[this.EdgePathNode(1)].node == null ? this.OptimizeForThreeSites() : this.edgePath.count === 1 && this.OptimizeForTwoSites());
  }
  PositionsAreLegal(t, e, i, s, n, r) {
    if (!D(t, e) && (t - e) * i > 0)
      return !1;
    const o = this.anchors[r], l = this.MiddlePos(t, e, s, n, o.y);
    return this.MiddleAnchorLegal(l, r, o) ? !this.LineSegIntersectBound(new u(t, s.bottom), new u(e, n.top)) : !1;
  }
  MiddleAnchorLegal(t, e, i) {
    const s = this.NodeLayer(e), n = this.layerArrays.x[e], r = t - i.x;
    return !(n > 0 && this.anchors[s[n - 1]].right > r + i.left || n < s.length - 1 && this.anchors[s[n + 1]].left < r + i.right);
  }
  MiddlePos(t, e, i, s, n) {
    const r = i.y - n, o = n - s.y;
    return (t * r + e * o) / (r + o);
  }
  TryToRemoveInflections() {
    if (this.TurningAlwaySameDirection())
      return;
    let t = !0;
    for (; t; ) {
      t = !1;
      for (const e = { s: this.headSite, cut: !1 }; e.s; )
        this.TryToRemoveInflectionCorner(e), t = e.cut || t;
    }
  }
  TurningAlwaySameDirection() {
    let t = 0;
    for (let e = this.headSite.next; e != null && e.next != null; e = e.next) {
      const i = e.turn;
      if (t === 0)
        i > 0 ? t = 1 : i < 0 && (t = -1);
      else if (t * i < 0)
        return !1;
    }
    return !0;
  }
  EdgePathPoint(t) {
    return this.anchors[this.EdgePathNode(t)].origin;
  }
  EdgePathNode(t) {
    return t === this.edgePath.count ? this.edgePath.LayerEdges[this.edgePath.count - 1].Target : this.edgePath.LayerEdges[t].Source;
  }
  createSmoothedPolyline() {
    this.RemoveVerticesWithNoTurns();
    let t = new g();
    const e = this.headSite, i = g.findCorner(e);
    return i !== void 0 ? (this.createFilletCurve(t, { a: e, b: i.b, c: i.c }), t = this.ExtendCurveToEndpoints(t)) : t.addSegment(v.mkPP(this.headSite.point, this.TailSite.point)), t;
  }
  curveIsLegal(t) {
    return !0;
  }
  RemoveVerticesWithNoTurns() {
    for (; this.RemoveVerticesWithNoTurnsOnePass(); )
      ;
  }
  RemoveVerticesWithNoTurnsOnePass() {
    let t = !1;
    for (let e = this.headSite; e.next != null && e.next.next != null; e = e.next)
      jt.Flat(e.next) && (t = !0, e.next = e.next.next, e.next.prev = e);
    return t;
  }
  ExtendCurveToEndpoints(t) {
    let e = this.headSite.point;
    if (!u.closeDistEps(e, t.start)) {
      const i = new g();
      i.addSegs([v.mkPP(e, t.start), t]), t = i;
    }
    return e = this.TailSite.point, u.closeDistEps(e, t.end) || t.addSegment(v.mkPP(t.end, e)), t;
  }
  createFilletCurve(t, e) {
    for (; this.AddSmoothedCorner(e.a, e.b, e.c, t), e.a = e.b, e.b = e.c, e.b.next != null; )
      e.c = e.b.next;
  }
  AddSmoothedCorner(t, e, i, s) {
    let n = 0.5, r;
    do
      r = g.createBezierSeg(n, n, t, e, i), e.previouisBezierCoefficient = n, n /= 2;
    while (this.BezierSegIntersectsBoundary(r));
    if (n *= 2, n < 0.5) {
      n = 0.5 * (n + n * 2);
      const o = g.createBezierSeg(n, n, t, e, i);
      this.BezierSegIntersectsBoundary(o) || (e.nextBezierCoefficient = n, e.previouisBezierCoefficient = n, r = o);
    }
    s.segs.length > 0 && !u.closeDistEps(s.end, r.start) && s.addSegment(v.mkPP(s.end, r.start)), s.addSegment(r);
  }
  // getDebugCurvesForCorner(
  //  a: CornerSite,
  //  b: CornerSite,
  //  c: CornerSite,
  // ): //import{('../../math/geometry/debugCurve').}DebugCurve[] {
  //  let r = []
  //  r = r.concat(getHierDC(this.thinWestHierarchy, 'Red'))
  //  r = r.concat(getHierDC(this.westHierarchy, 'Orange'))
  //  r = r.concat(getHierDC(this.eastHierarchy, 'Blue'))
  //  r = r.concat(getHierDC(this.thinEastHierarchy, 'Green'))
  //  for (const a of this.anchors) {
  //    r.push(DebugCurve.mkDebugCurveTWCI(100, 0.3, 'Gray', a.polygonalBoundary))
  //  }
  //  r.push(
  //    DebugCurve.mkDebugCurveTWCI(
  //      100,
  //      2,
  //      'Blue',
  //      LineSegment.mkPP(a.point, b.point),
  //    ),
  //  )
  //  r.push(
  //    DebugCurve.mkDebugCurveTWCI(
  //      100,
  //      2,
  //      'Blue',
  //      LineSegment.mkPP(b.point, c.point),
  //    ),
  //  )
  //  const p = new Polyline()
  //  for (let i = 0; i <= this.edgePath.count; i++) {
  //    p.addPoint(this.EdgePathPoint(i))
  //  }
  //  r.push(DebugCurve.mkDebugCurveTWCI(100, 1, 'Yellow', p))
  //  return r
  // }
  BezierSegIntersectsBoundary(t) {
    return u.signedDoubledTriangleArea(t.B(0), t.B(1), t.B(2)) < 0 ? this.BezierSegIntersectsTree(t, this.thinWestHierarchy) || this.BezierSegIntersectsTree(t, this.westHierarchy) : this.BezierSegIntersectsTree(t, this.thinEastHierarchy) || this.BezierSegIntersectsTree(t, this.eastHierarchy);
  }
  BezierSegIntersectsTree(t, e) {
    if (e == null)
      return !1;
    if (Q.intersect(t.pNodeOverICurve().parallelogram, e.parallelogram))
      if (e.node.hasOwnProperty("children")) {
        const i = e.node;
        return this.BezierSegIntersectsTree(t, i.children[0]) || this.BezierSegIntersectsTree(t, i.children[1]);
      } else
        return jt.BezierSegIntersectsBoundary(t, e.seg);
    else
      return !1;
  }
  static BezierSegIntersectsBoundary(t, e) {
    for (const i of g.getAllIntersections(t, e, !1))
      if (e instanceof g) {
        const s = e;
        if (g.realCutWithClosedCurve(i, s, !1))
          return !0;
      } else
        return !0;
    return !1;
  }
}
class Xi extends ht {
  constructor(t, e, i, s, n, r) {
    super(null), this.settings = t, this.OriginalGraph = e, this.Database = i, this.ProperLayeredGraph = n, this.LayerArrays = s, this.IntGraph = r;
  }
  // Executes the actual algorithm.
  run() {
    this.createSplines();
  }
  // The method does the main work.
  createSplines() {
    this.createRegularSplines(), this.createSelfSplines(), this.IntGraph != null && this.RouteFlatEdges(), this.OriginalGraph.graph.parent == null && this.RouteUnroutedEdges();
  }
  RouteUnroutedEdges() {
    const t = [];
    for (const r of this.OriginalGraph.deepEdges)
      r.curve || t.push(r);
    if (t.length == 0)
      return;
    const i = (this.OriginalGraph.layoutSettings ? this.OriginalGraph.layoutSettings : new sn()).commonSettings.edgeRoutingSettings;
    new it(this.OriginalGraph, t, i.padding, i.polylinePadding, i.coneAngle, i.bundlingSettings, this.cancelToken).run(), z.constructorGA(this.OriginalGraph, t).run();
  }
  RouteFlatEdges() {
  }
  createRegularSplines() {
    for (const t of this.Database.RegularMultiedges()) {
      if (Mg(t))
        continue;
      const e = t.length, i = e === 1 && this.MayOptimizeEdge(t[0]);
      for (let s = Math.floor(e / 2); s < e; s++)
        this.createSplineForNonSelfEdge(t[s], i);
      for (let s = Math.floor(e / 2) - 1; s >= 0; s--)
        this.createSplineForNonSelfEdge(t[s], i);
    }
  }
  MayOptimizeEdge(t) {
    return !(this.ProperLayeredGraph.OutDegreeIsMoreThanOne(t.source) || this.ProperLayeredGraph.InDegreeIsMoreThanOne(t.target) || Rl(t.edge.source) || Rl(t.edge.target));
  }
  createSelfSplines() {
    for (const [t, e] of this.Database.Multiedges.keyValues()) {
      const i = t;
      if (i.x === i.y) {
        const s = this.Database.Anchors[i.x];
        let n = s.leftAnchor;
        for (const r of e) {
          const o = this.settings.NodeSeparation + (this.settings.MinNodeWidth + n), l = s.bottomAnchor / 2, h = s.origin, c = h.add(new u(0, l)), d = h.add(new u(o, l)), f = h.add(new u(o, -l)), p = h.add(new u(0, -l));
          let P = St.mkSiteP(h);
          const y = new Tt(P);
          P = St.mkSiteSP(P, c), P = St.mkSiteSP(P, d), P = St.mkSiteSP(P, f), P = St.mkSiteSP(P, p), St.mkSiteSP(P, h);
          const C = y.createCurve();
          if (r.curve = C, n = o, r.edge.label != null) {
            n += r.edge.label.width;
            const w = C.value((C.parStart + C.parEnd) / 2), N = new u(w.x + r.labelWidth / 2, s.y), I = new u(r.edge.label.width / 2, r.edge.label.height / 2), x = T.mkPP(N.add(I), N.sub(I));
            r.edge.label.width = x.width, r.edge.label.height = x.height, r.edge.label.positionCenter(N);
          }
          vt.trimSplineAndCalculateArrowheadsII(r.edge, r.edge.source.boundaryCurve, r.edge.target.boundaryCurve, C, !1);
        }
      }
    }
  }
  createSplineForNonSelfEdge(t, e) {
    t.LayerEdges != null && (this.drawSplineBySmothingThePolyline(t, e), t.IsVirtualEdge || (t.updateEdgeLabelPosition(this.Database.Anchors), vt.trimSplineAndCalculateArrowheadsII(t.edge, t.edge.source.boundaryCurve, t.edge.target.boundaryCurve, t.curve, !0)));
  }
  drawSplineBySmothingThePolyline(t, e) {
    const s = new jt(t, this.Database.Anchors, this.OriginalGraph, this.settings, this.LayerArrays, this.ProperLayeredGraph, this.Database).getSpline(e);
    t.reversed ? t.curve = s.reverse() : t.curve = s;
  }
  // void UpdateEdgeLabelPosition(LayerEdge[][] list, int i) {
  //    IntEdge e;
  //    int labelNodeIndex;
  //    if (Engine.GetLabelEdgeAndVirtualNode(list, i, out e, out labelNodeIndex)) {
  //        UpdateLabel(e, labelNodeIndex, db.Anchors);
  //    }
  // }
  static UpdateLabel(t, e) {
    let i = null;
    e.labelIsToTheRightOfTheSpline ? (t.label.positionCenter(new u(e.x + e.rightAnchor / 2, e.y)), i = v.mkPP(t.label.boundingBox.leftTop, t.label.boundingBox.leftBottom)) : e.labelIsToTheLeftOfTheSpline && (t.label.positionCenter(new u(e.x - e.leftAnchor / 2, e.y)), i = v.mkPP(t.label.boundingBox.rightTop, t.label.boundingBox.rightBottom));
    const s = Xi.GetSegmentInFrontOfLabel(t.curve, t.label.center.y);
    if (s != null && g.getAllIntersections(t.curve, g.polyFromBox(t.label.boundingBox), !1).length === 0) {
      const n = {
        curveClosestPoint: void 0,
        labelSideClosest: void 0
      };
      if (Xi.FindClosestPoints(n, s, i))
        Xi.ShiftLabel(t, n);
      else {
        const r = s.closestParameter(i.start), o = s.closestParameter(i.end);
        s.value(r).sub(i.start).length < s.value(o).sub(i.end).length ? (n.curveClosestPoint = s.value(r), n.labelSideClosest = i.start) : (n.curveClosestPoint = s.value(o), n.labelSideClosest = i.end), Xi.ShiftLabel(t, n);
      }
    }
  }
  static ShiftLabel(t, e) {
    const i = t.lineWidth / 2, s = e.curveClosestPoint.sub(e.labelSideClosest), n = s.length;
    n > i && t.label.positionCenter(t.label.center.add(s.div(n * (n - i))));
  }
  static FindClosestPoints(t, e, i) {
    const s = g.minDistWithinIntervals(e, i, e.parStart, e.parEnd, i.parStart, i.parEnd, (e.parStart + e.parEnd) / 2, (i.parStart + i.parEnd) / 2);
    return s ? (t.curveClosestPoint = s.aX, t.labelSideClosest = s.bX, !0) : !1;
  }
  static GetSegmentInFrontOfLabel(t, e) {
    if (t instanceof g) {
      const i = t;
      for (const s of i.segs)
        if ((s.start.y - e) * (s.end.y - e) <= 0)
          return s;
    }
    return null;
  }
  static GetNodeKind(t, e) {
    return t === 0 ? kt.Top : t < e.count ? kt.Internal : kt.Bottom;
  }
}
function Mg(a) {
  if (a.length < 4)
    return !1;
  for (const t of a)
    if (t.edge.label)
      return !1;
  return !0;
}
function Rl(a) {
  return a.node.selfEdges.size > 0;
}
class nc extends ht {
  /** return true if the ratio is less than 1/50 or greater than 50 */
  get extremeAspectRatio() {
    const t = this.originalGraph.boundingBox, e = t.width / t.height;
    return e < 1 / 50 || e > 50;
  }
  get verticalConstraints() {
    return this.sugiyamaSettings.verticalConstraints;
  }
  get HorizontalConstraints() {
    return this.sugiyamaSettings.horizontalConstraints;
  }
  constructor(t, e, i) {
    if (super(i), this.LayersAreDoubled = !1, t == null)
      return;
    this.originalGraph = t, this.sugiyamaSettings = e;
    const s = Array.from(t.shallowNodes);
    this.nodeIdToIndex = /* @__PURE__ */ new Map();
    let n = 0;
    for (const o of s)
      this.nodeIdToIndex.set(o.id, n++);
    const r = [];
    for (const o of this.originalGraph.shallowEdges) {
      const l = this.nodeIdToIndex.get(o.source.id);
      if (l == null)
        continue;
      const h = this.nodeIdToIndex.get(o.target.id);
      if (h == null)
        continue;
      const c = new Ye(l, h, o);
      r.push(c);
    }
    this.IntGraph = new wn(r, t.shallowNodeCount), this.IntGraph.nodes = s, this.database = new Eg(s.length);
    for (const o of this.IntGraph.edges)
      this.database.registerOriginalEdgeInMultiedges(o);
    this.cycleRemoval();
  }
  run() {
    if (this.originalGraph.shallowNodeCount === 0) {
      this.originalGraph.boundingBox = T.mkEmpty();
      return;
    }
    Jg(this.originalGraph, this.sugiyamaSettings.transform), this.engineLayerArrays = this.calculateLayers(), this.sugiyamaSettings.edgeRoutingSettings.EdgeRoutingMode === Jt.SugiyamaSplines && this.runPostLayering(), Kg(this.originalGraph, this.sugiyamaSettings.transform);
  }
  runPostLayering() {
    const t = this.sugiyamaSettings.commonSettings.edgeRoutingSettings, e = this.constrainedOrdering != null ? Jt.Spline : t.EdgeRoutingMode;
    this.extremeAspectRatio ? Xh(this.originalGraph, Array.from(this.originalGraph.deepEdges), this.cancelToken) : e === Jt.SugiyamaSplines ? this.calculateEdgeSplines() : Zh(this.originalGraph, Array.from(this.originalGraph.deepEdges), this.cancelToken);
  }
  SetLabels() {
    throw new Error("not implementedt");
  }
  cycleRemoval() {
    const t = this.sugiyamaSettings.verticalConstraints, e = t.isEmpty ? $i.getFeedbackSet(this.IntGraph) : t.getFeedbackSetExternal(this.IntGraph, this.nodeIdToIndex);
    this.database.addFeedbackSet(e);
  }
  calculateLayers() {
    this.CreateGluedDagSkeletonForLayering();
    const t = this.CalculateLayerArrays();
    return this.UpdateNodePositionData(), t;
  }
  UpdateNodePositionData() {
    for (let t = 0; t < this.IntGraph.nodeCount && t < this.database.Anchors.length; t++)
      this.IntGraph.nodes[t].center = this.database.Anchors[t].origin;
    if (this.sugiyamaSettings.GridSizeByX > 0)
      for (let t = 0; t < this.originalGraph.shallowNodeCount; t++)
        this.SnapLeftSidesOfTheNodeToGrid(t, this.sugiyamaSettings.GridSizeByX);
  }
  SnapLeftSidesOfTheNodeToGrid(t, e) {
    const i = this.IntGraph.nodes[t], s = this.database.Anchors[t];
    s.leftAnchor -= e / 2, s.rightAnchor -= e / 2;
    const n = i.boundingBox.left, r = Math.floor(n / e), o = n - r * e;
    Math.abs(o) < 1e-3 || (Math.abs(o) <= e / 2 ? i.center = i.center.add(new u(-o, 0)) : i.center = i.center.add(new u(e - o, 0)), s.x = i.center.x);
  }
  GetCurrentHeight() {
    const t = new ji();
    for (const e of this.NodeAnchors())
      t.AddValue(e.top), t.AddValue(e.bottom);
    return t.length;
  }
  *NodeAnchors() {
    const t = Math.min(this.IntGraph.nodeCount, this.anchors.length);
    for (let e = 0; e < t; e++)
      yield this.anchors[e];
  }
  GetCurrentWidth() {
    const t = new ji();
    for (const e of this.NodeAnchors())
      t.AddValue(e.left), t.AddValue(e.right);
    return t.length;
  }
  ExtendLayeringToUngluedSameLayerVertices(t) {
    const e = this.verticalConstraints;
    for (let i = 0; i < t.length; i++)
      t[i] = t[e.nodeToRepr(i)];
    return t;
  }
  calculateEdgeSplines() {
    new Xi(this.sugiyamaSettings, this.originalGraph, this.database, this.engineLayerArrays, this.properLayeredGraph, this.IntGraph).run();
  }
  YLayeringAndOrdering(t) {
    let e = t.GetLayers();
    Ca.Balance(this.gluedDagSkeletonForLayering, e, this.GetNodeCountsOfGluedDag(), null), e = this.ExtendLayeringToUngluedSameLayerVertices(e);
    let i = new Bi(e);
    if (this.HorizontalConstraints == null || this.HorizontalConstraints.IsEmpty)
      return i = this.YLayeringAndOrderingWithoutHorizontalConstraints(i), i;
    throw new Error("not implemented");
  }
  // Creating a proper layered graph, a graph where each
  // edge goes only one layer down from the i+1-th layer to the i-th layer.
  CreateProperLayeredGraph(t) {
    const e = t.length;
    let i = 0;
    for (const n of this.database.SkeletonEdges()) {
      const r = _g(t, n);
      r > 0 && (n.LayerEdges = new Array(r));
      let o = 0;
      if (r > 1) {
        let l = e + i++, h = new qi(n.source, l, n.CrossingWeight, n.weight);
        n.LayerEdges[o++] = h;
        for (let c = 0; c < r - 2; c++)
          l++, i++, h = new qi(l - 1, l, n.CrossingWeight, n.weight), n.LayerEdges[o++] = h;
        h = new qi(l, n.target, n.CrossingWeight, n.weight), n.LayerEdges[o] = h;
      } else if (r === 1) {
        const l = new qi(n.source, n.target, n.CrossingWeight, n.weight);
        n.LayerEdges[o] = l;
      }
    }
    const s = new Array(this.originalGraph.shallowNodeCount + i).fill(0);
    for (const n of this.database.SkeletonEdges())
      if (n.LayerEdges != null) {
        let r = t[n.source];
        s[n.source] = r--;
        for (const o of n.LayerEdges)
          s[o.Target] = r--;
      } else
        s[n.source] = t[n.source], s[n.target] = t[n.target];
    return this.properLayeredGraph = new ps(new wn(Array.from(this.database.SkeletonEdges()), t.length)), this.properLayeredGraph.BaseGraph.nodes = this.IntGraph.nodes, new Bi(s);
  }
  YLayeringAndOrderingWithoutHorizontalConstraints(t) {
    const e = this.CreateProperLayeredGraph(t.y);
    return Vs.OrderLayers(this.properLayeredGraph, e, this.originalGraph.shallowNodeCount, this.sugiyamaSettings, this.cancelToken), Hr.UpdateLayerArrays1(this.properLayeredGraph, e), e;
  }
  CalculateYLayers() {
    const t = this.YLayeringAndOrdering(new Bg(this.gluedDagSkeletonForLayering, this.cancelToken));
    return this.constrainedOrdering != null ? t : this.InsertLayersIfNeeded(t);
  }
  InsertLayersIfNeeded(t) {
    this.InsertVirtualEdgesIfNeeded(t);
    const e = this.AnalyzeNeedToInsertLayersAndHasMultiedges(t);
    if (e.needToInsertLayers) {
      const i = _n.InsertLayers(this.properLayeredGraph, t, this.database, this.IntGraph);
      this.properLayeredGraph = i.layeredGraph, t = i.la, this.LayersAreDoubled = !0;
    } else if (e.multipleEdges) {
      const i = ms.InsertPaths(this.properLayeredGraph, t, this.database, this.IntGraph);
      this.properLayeredGraph = i.layeredGraph, t = i.la;
    }
    return this.RecreateIntGraphFromDataBase(), t;
  }
  RecreateIntGraphFromDataBase() {
    let t = new Array();
    for (const e of this.database.Multiedges.values())
      t = t.concat(e);
    this.IntGraph.SetEdges(t, this.IntGraph.nodeCount);
  }
  InsertVirtualEdgesIfNeeded(t) {
    if (this.constrainedOrdering == null) {
      for (const [e, i] of this.database.Multiedges.keyValues())
        if (i.length % 2 === 0 && t.y[e.x] - 1 === t.y[e.y]) {
          const s = new Kt(null), n = new Ye(e.x, e.y, s);
          n.IsVirtualEdge = !0, i.splice(i.length / 2, 0, n), this.IntGraph.addEdge(n);
        }
    }
  }
  AnalyzeNeedToInsertLayersAndHasMultiedges(t) {
    let e = !1, i = !1;
    for (const s of this.IntGraph.edges)
      if (s.hasLabel && t.y[s.source] !== t.y[s.target]) {
        e = !0;
        break;
      }
    if (e === !1 && this.constrainedOrdering == null) {
      for (const [s, n] of this.database.Multiedges.keyValues())
        if (n.length > 1 && (i = !0, t.y[s.x] - t.y[s.y] === 1)) {
          e = !0;
          break;
        }
    }
    return {
      needToInsertLayers: e,
      multipleEdges: i
    };
  }
  UseBrandesXCalculations(t) {
    return t.x.length >= this.sugiyamaSettings.BrandesThreshold;
  }
  CalculateAnchorsAndYPositions(t) {
    this.anchors = Vg(this.database, this.properLayeredGraph, this.originalGraph, this.IntGraph, this.sugiyamaSettings), Dg(t, 500, this.originalGraph, this.database, this.IntGraph, this.sugiyamaSettings, this.LayersAreDoubled);
  }
  // put some labels to the left of the splines if it makes sense
  OptimizeEdgeLabelsLocations() {
    for (let t = 0; t < this.anchors.length; t++) {
      const e = this.anchors[t];
      if (e.labelIsToTheRightOfTheSpline) {
        const i = this.GetSuccessorAndPredecessor(t);
        if (!jg(e, i.predecessor, i.successor)) {
          const s = i.predecessor.origin.sub(e.origin).length + i.successor.origin.sub(e.origin).length, n = e.right - e.leftAnchor, r = new u(n, e.y);
          i.predecessor.origin.sub(r).length + i.successor.origin.sub(r).length < s && rc(e);
        }
      }
    }
  }
  GetSuccessorAndPredecessor(t) {
    let e;
    for (const s of this.properLayeredGraph.InEdges(t))
      e = s.Source;
    let i;
    for (const s of this.properLayeredGraph.OutEdges(t))
      i = s.Target;
    return {
      predecessor: this.anchors[e],
      successor: this.anchors[i]
    };
  }
  CalculateLayerArrays() {
    const t = this.CalculateYLayers();
    return this.constrainedOrdering == null ? (this.CalculateAnchorsAndYPositions(t), this.UseBrandesXCalculations(t) ? this.CalculateXPositionsByBrandes(t) : this.CalculateXLayersByGansnerNorth(t)) : this.anchors = this.database.Anchors, this.OptimizeEdgeLabelsLocations(), this.engineLayerArrays = t, this.StraightensShortEdges(), this.CalculateOriginalGraphBox(), t;
  }
  StretchToDesiredAspectRatio(t, e) {
    t > e ? this.StretchInYDirection(t / e) : t < e && this.StretchInXDirection(e / t);
  }
  StretchInYDirection(t) {
    const e = (this.originalGraph.boundingBox.top + this.originalGraph.boundingBox.bottom) / 2;
    for (const s of this.database.Anchors)
      s.bottomAnchor = s.bottomAnchor * t, s.topAnchor = s.topAnchor * t, s.y = e + t * (s.y - e);
    const i = this.originalGraph.height * t;
    this.originalGraph.boundingBox = new T({
      left: this.originalGraph.boundingBox.left,
      top: e + i / 2,
      right: this.originalGraph.boundingBox.right,
      bottom: e - i / 2
    });
  }
  StretchInXDirection(t) {
    const e = (this.originalGraph.boundingBox.left + this.originalGraph.boundingBox.right) / 2;
    for (const s of this.database.Anchors)
      s.leftAnchor = s.leftAnchor * t, s.rightAnchor = s.rightAnchor * t, s.x = e + t * (s.x - e);
    const i = this.originalGraph.width * t;
    this.originalGraph.boundingBox = new T({
      left: e - i / 2,
      top: this.originalGraph.boundingBox.top,
      right: e + i / 2,
      bottom: this.originalGraph.boundingBox.bottom
    });
  }
  CalculateOriginalGraphBox() {
    if (this.anchors.length === 0)
      return;
    const t = new T({
      left: this.anchors[0].left,
      top: this.anchors[0].top,
      right: this.anchors[0].right,
      bottom: this.anchors[0].bottom
    });
    for (let e = 1; e < this.anchors.length; e++) {
      const i = this.anchors[e];
      t.add(i.leftTop), t.add(i.rightBottom);
    }
    this.originalGraph.labelSize && this.originalGraph.addLabelToGraphBB(t), t.padEverywhere(this.originalGraph.margins), this.originalGraph.boundingBox = t;
  }
  StraightensShortEdges() {
    if (!(this.anchors.length < 20))
      for (; this.StraightenEdgePaths(); )
        ;
  }
  StraightenEdgePaths() {
    let t = !1;
    for (const e of this.database.AllIntEdges())
      e.LayerSpan === 2 && (t = this.ShiftVertexWithNeighbors(e.LayerEdges[0].Source, e.LayerEdges[0].Target, e.LayerEdges[1].Target) || t);
    return t;
  }
  ShiftVertexWithNeighbors(t, e, i) {
    const s = this.database.Anchors[t], n = this.database.Anchors[i], r = this.database.Anchors[e], o = (r.y - s.y) * ((n.x - s.x) / (n.y - s.y)) + s.x, l = 1e-4;
    return o > r.x + l ? this.TryShiftToTheRight(o, e) : o < r.x - l ? this.TryShiftToTheLeft(o, e) : !1;
  }
  TryShiftToTheLeft(t, e) {
    const i = this.engineLayerArrays.Layers[this.engineLayerArrays.y[e]], s = this.engineLayerArrays.x[e];
    if (s > 0) {
      const n = this.database.Anchors[i[s - 1]], r = Math.max(n.right + (this.sugiyamaSettings.NodeSeparation + this.database.Anchors[e].leftAnchor), t);
      return r < this.database.Anchors[e].x - 1 ? (this.database.Anchors[e].x = r, !0) : !1;
    }
    return this.database.Anchors[e].x = t, !0;
  }
  TryShiftToTheRight(t, e) {
    const i = this.engineLayerArrays.Layers[this.engineLayerArrays.y[e]], s = this.engineLayerArrays.x[e];
    if (s < i.length - 1) {
      const n = this.database.Anchors[i[s + 1]], r = Math.min(n.left - (this.sugiyamaSettings.NodeSeparation - this.database.Anchors[e].rightAnchor), t);
      return r > this.database.Anchors[e].x + 1 ? (this.database.Anchors[e].x = r, !0) : !1;
    }
    return this.database.Anchors[e].x = t, !0;
  }
  CalculateXLayersByGansnerNorth(t) {
    this.xLayoutGraph = this.CreateXLayoutGraph(t), this.CalculateXLayersByGansnerNorthOnProperLayeredGraph();
  }
  CalculateXLayersByGansnerNorthOnProperLayeredGraph() {
    const t = new sc(this.xLayoutGraph, null).GetLayers();
    for (let e = 0; e < this.database.Anchors.length; e++)
      this.anchors[e].x = t[e];
  }
  // // A quote from Gansner93.
  // // The method involves constructing an auxiliary graph as illustrated in figure 4-2.
  // // This transformation is the graphical analogue of the algebraic
  // // transformation mentioned above for removing the absolute values
  // // from the optimization problem. The nodes of the auxiliary graph G^ are the nodes of
  // // the original graph G plus, for every edge e in G, there is a new node ne.
  // // There are two kinds of edges in G^. One edge class encodes the
  // // cost of the original edges. Every edge e = (u,v) in G is replaced by two edges (ne ,u)
  // // and (ne, v) with d = 0 and w = w(e)W(e). The other class of edges separates nodes in the same layer.
  // // If v is the left neighbor of w, then G^ has an edge f = e(v,w) with d( f ) = r(v,w) and
  // // w( f ) = 0. This edge forces the nodes to be sufficiently
  // // separated but does not affect the cost of the layout.
  CreateXLayoutGraph(t) {
    let e = this.properLayeredGraph.NodeCount;
    const i = new Array();
    for (const n of this.properLayeredGraph.Edges) {
      const r = new Ye(e, n.Source, null), o = new Ye(e, n.Target, null);
      o.weight = n.Weight, r.weight = n.Weight, r.separation = 0, o.separation = 0, e++, i.push(r), i.push(o);
    }
    for (const n of t.Layers)
      for (let r = n.length - 1; r > 0; r--) {
        const o = n[r], l = n[r - 1], h = new Ye(o, l, null), c = this.database.Anchors[o], d = this.database.Anchors[l], f = c.leftAnchor + (d.rightAnchor + this.sugiyamaSettings.NodeSeparation);
        h.separation = Math.ceil(f + 0.5), i.push(h);
      }
    const s = new Gg(this.IntGraph, this.properLayeredGraph, t, i, e);
    return s.SetEdgeWeights(), s;
  }
  CalculateXPositionsByBrandes(t) {
    us.CalculateXCoordinates(t, this.properLayeredGraph, this.originalGraph.shallowNodeCount, this.database.Anchors, this.sugiyamaSettings.NodeSeparation);
  }
  GluedDagSkeletonEdges() {
    const t = new Ki();
    for (const [i, s] of this.database.Multiedges.keyValues()) {
      if (i.isDiagonal())
        continue;
      const n = this.verticalConstraints.gluedIntEdge(s[0]);
      n.source !== n.target && t.set(n.source, n.target, n);
    }
    const e = Array.from(this.verticalConstraints.gluedUpDownIntConstraints.values()).map((i) => kg(i, null));
    for (const i of e)
      t.set(i.source, i.target, i);
    return Array.from(t.values());
  }
  static CalcAnchorsForOriginalNode(t, e, i, s, n) {
    const r = {
      leftAnchor: 0,
      rightAnchor: 0,
      topAnchor: 0,
      bottomAnchor: 0
    };
    if (e.nodes != null) {
      const h = e.nodes[t];
      Xg(r, h, n);
    }
    Qg(t, r, s, n);
    const o = n.MinNodeWidth / 2;
    r.leftAnchor < o && (r.leftAnchor = o), r.rightAnchor < o && (r.rightAnchor = o);
    const l = n.MinNodeHeight / 2;
    r.topAnchor < l && (r.topAnchor = l), r.bottomAnchor < l && (r.bottomAnchor = l), i[t] = Pe.mkAnchor(r.leftAnchor, r.rightAnchor, r.topAnchor, r.bottomAnchor, e.nodes[t], n.LabelCornersPreserveCoefficient), i[t].padding = 1;
  }
  CreateGluedDagSkeletonForLayering() {
    this.gluedDagSkeletonForLayering = new wn(this.GluedDagSkeletonEdges(), this.originalGraph.shallowNodeCount), this.SetGluedEdgesWeights();
  }
  SetGluedEdgesWeights() {
    const t = new Ki();
    for (const e of this.gluedDagSkeletonForLayering.edges)
      t.set(e.source, e.target, e);
    for (const [e, i] of this.database.Multiedges.keyValues())
      if (e.x !== e.y) {
        const s = this.verticalConstraints.gluedIntPair(e);
        if (s.x === s.y)
          continue;
        const n = t.get(s.x, s.y);
        for (const r of i)
          n.weight += r.weight;
      }
  }
  GetNodeCountsOfGluedDag() {
    return this.verticalConstraints.isEmpty ? new Array(this.IntGraph.nodeCount).fill(1) : this.verticalConstraints.getGluedNodeCounts();
  }
}
function Nl(a, t) {
  if (t === 0)
    return 0;
  const e = Math.floor(a / t), i = a - e * t;
  return Math.abs(i) < 1e-4 ? 0 : t - i;
}
function Fg(a, t) {
  for (const e of a)
    if (e < t)
      return !0;
  return !1;
}
function Vg(a, t, e, i, s) {
  const n = a.Anchors = new Array(t.NodeCount);
  for (let r = 0; r < n.length; r++)
    n[r] = new Pe(s.LabelCornersPreserveCoefficient);
  for (let r = 0; r < e.shallowNodeCount; r++)
    nc.CalcAnchorsForOriginalNode(r, i, n, a, s);
  for (const r of a.AllIntEdges())
    if (r.LayerEdges != null) {
      for (const o of r.LayerEdges) {
        const l = o.Target;
        if (l !== r.target) {
          const h = n[l];
          a.MultipleMiddles.has(l) ? (h.leftAnchor = h.rightAnchor = Io() * 4, h.topAnchor = h.bottomAnchor = Bl(s) / 2) : (h.leftAnchor = h.rightAnchor = Io() / 2, h.topAnchor = h.bottomAnchor = Bl(s) / 2);
        }
      }
      if (r.hasLabel) {
        const o = r.LayerEdges[r.LayerEdges.length / 2].Source, l = n[o], h = r.labelWidth, c = r.labelHeight;
        l.rightAnchor = h, l.leftAnchor = Io() * 8, l.topAnchor < c / 2 && (l.topAnchor = l.bottomAnchor = c / 2), l.labelIsToTheRightOfTheSpline = !0;
      }
    }
  return n;
}
function Io() {
  return 1;
}
function Bl(a) {
  return a.MinNodeHeight * 1.5 / 8;
}
function Gl(a, t, e, i, s, n) {
  let r = 0;
  if (e > 0) {
    const o = qg(t.Layers[e - 1], t.y, i);
    if (o.length) {
      const l = s.LayerSeparation / 3, h = n;
      r = Math.max(...o.map((c) => Ug(c, h, l, a)));
    }
  }
  return r;
}
function Dg(a, t, e, i, s, n, r) {
  const o = i.Anchors;
  let l = e.margins.top + t, h = 0;
  for (const c of a.Layers) {
    let d = 0, f = 0;
    for (const w of c) {
      const N = o[w];
      N.bottomAnchor > d && (d = N.bottomAnchor), N.topAnchor > f && (f = N.topAnchor);
    }
    Wg(c, d, f, e.shallowNodeCount, i.Anchors);
    const p = Gl(i, a, h, s, n, l), P = l + d + p;
    let y = P + f;
    if (Hg(n)) {
      y += Nl(y, n.GridSizeByY);
      for (const w of c)
        o[w].top = y;
    } else if (zg(n)) {
      let w = P - d;
      w += Nl(w, w);
      for (const N of c)
        o[N].bottom = w, y = Math.max(o[N].top, y);
    } else
      for (const w of c)
        o[w].y = P;
    const C = n.ActualLayerSeparation(r);
    l = y + C, h++;
  }
  Gl(i, a, h, s, n, l);
}
function kg(a, t) {
  const e = new Ye(a.x, a.y, t);
  return e.weight = 0, e.separation = 1, e;
}
function _g(a, t) {
  return a[t.source] - a[t.target];
}
function Wg(a, t, e, i, s) {
  if (Fg(a, i)) {
    for (const n of a)
      if (n >= i) {
        const r = s[n];
        r.bottomAnchor = t, r.topAnchor = e;
      }
  }
}
function Hg(a) {
  return a.SnapToGridByY === Ks.Top;
}
function zg(a) {
  return a.SnapToGridByY === Ks.Bottom;
}
function jg(a, t, e) {
  if (a.labelIsToTheRightOfTheSpline) {
    if (u.getTriangleOrientation(t.origin, a.origin, e.origin) === L.Clockwise)
      return !0;
    const i = a.leftAnchor, s = a.rightAnchor, n = a.x;
    return rc(a), u.getTriangleOrientation(t.origin, a.origin, e.origin) === L.Counterclockwise ? !0 : (a.x = n, a.leftAnchor = i, a.rightAnchor = s, a.labelIsToTheRightOfTheSpline = !0, a.labelIsToTheLeftOfTheSpline = !1, !1);
  }
  return !1;
}
function rc(a) {
  const t = a.right, e = a.leftAnchor;
  a.leftAnchor = a.rightAnchor, a.rightAnchor = e, a.x = t - a.rightAnchor, a.labelIsToTheLeftOfTheSpline = !0, a.labelIsToTheRightOfTheSpline = !1;
}
function qg(a, t, e) {
  const i = new ti();
  for (const s of a)
    if (!(s >= e.nodeCount))
      for (const n of e.outEdges[s])
        t[n.source] === t[n.target] && i.addNN(n.source, n.target);
  return Array.from(i.values());
}
function Ug(a, t, e, i) {
  let s = 0;
  const n = i.GetMultiedgeI(a);
  for (const r of n) {
    s += e;
    const o = r.edge.label;
    o != null && (o.positionCenter(new u(o.center.x, t + s + o.height / 2)), s += o.height);
  }
  return s;
}
function Xg(a, t, e) {
  a.rightAnchor = a.leftAnchor = (t.width + e.GridSizeByX) / 2, a.topAnchor = a.bottomAnchor = t.height / 2;
}
function Qg(a, t, e, i) {
  const s = Yg(e, a, t, i);
  t.rightAnchor += s;
}
function Yg(a, t, e, i) {
  let s = 0;
  const n = a.GetMultiedge(t, t);
  if (n.length > 0) {
    for (const r of n)
      r.edge.label != null && (e.rightAnchor += r.edge.label.width, e.topAnchor < r.edge.label.height / 2 && (e.topAnchor = e.bottomAnchor = r.edge.label.height / 2));
    s += (i.NodeSeparation + i.MinNodeWidth) * n.length;
  }
  return s;
}
function Jg(a, t) {
  if (t.isIdentity())
    return;
  const e = t.inverse();
  for (const i of a.shallowNodes)
    i.transform(e);
  for (const i of a.shallowEdges)
    if (i.label != null) {
      const s = T.mkPP(e.multiplyPoint(new u(0, 0)), e.multiplyPoint(new u(i.label.width, i.label.height)));
      i.label.width = s.width, i.label.height = s.height;
    }
}
function Kg(a, t) {
  if (!t.isIdentity()) {
    for (const e of a.shallowNodes)
      e.transform(t);
    for (const e of a.shallowEdges)
      if (e.label != null) {
        const i = T.mkPP(t.multiplyPoint(new u(0, 0)), t.multiplyPoint(new u(e.label.width, e.label.height)));
        e.label.width = i.width, e.label.height = i.height;
      }
    Zg(a, t), a.graph.parent == null && (a.boundingBox = null);
  }
}
function Zg(a, t) {
  for (const e of a.shallowEdges)
    e.label && e.label.transform(t), $g(t, e);
}
function $g(a, t) {
  if (t.curve != null) {
    t.curve = t.curve.transform(a);
    const e = t;
    e.sourceArrowhead != null && (e.sourceArrowhead.tipPosition = a.multiplyPoint(e.sourceArrowhead.tipPosition)), e.targetArrowhead != null && (e.targetArrowhead.tipPosition = a.multiplyPoint(e.targetArrowhead.tipPosition)), tp(t, a);
  }
}
function tp(a, t) {
  if (a.smoothedPolyline != null)
    for (let e = a.smoothedPolyline.headSite; e != null; e = e.next)
      e.point = t.multiplyPoint(e.point);
}
var fe = 63710088e-1, oc = {
  centimeters: fe * 100,
  centimetres: fe * 100,
  degrees: 360 / (2 * Math.PI),
  feet: fe * 3.28084,
  inches: fe * 39.37,
  kilometers: fe / 1e3,
  kilometres: fe / 1e3,
  meters: fe,
  metres: fe,
  miles: fe / 1609.344,
  millimeters: fe * 1e3,
  millimetres: fe * 1e3,
  nauticalmiles: fe / 1852,
  radians: 1,
  yards: fe * 1.0936
};
function ep(a, t, e = {}) {
  const i = { type: "Feature" };
  return (e.id === 0 || e.id) && (i.id = e.id), e.bbox && (i.bbox = e.bbox), i.properties = t || {}, i.geometry = a, i;
}
function Ml(a, t, e = {}) {
  if (!a)
    throw new Error("coordinates is required");
  if (!Array.isArray(a))
    throw new Error("coordinates must be an Array");
  if (a.length < 2)
    throw new Error("coordinates must be at least 2 numbers long");
  if (!Fl(a[0]) || !Fl(a[1]))
    throw new Error("coordinates must contain numbers");
  return ep({
    type: "Point",
    coordinates: a
  }, t, e);
}
function ip(a, t = "kilometers") {
  const e = oc[t];
  if (!e)
    throw new Error(t + " units is invalid");
  return a * e;
}
function sp(a, t = "kilometers") {
  const e = oc[t];
  if (!e)
    throw new Error(t + " units is invalid");
  return a / e;
}
function qo(a) {
  return a % (2 * Math.PI) * 180 / Math.PI;
}
function Ke(a) {
  return a % 360 * Math.PI / 180;
}
function Fl(a) {
  return !isNaN(a) && a !== null && !Array.isArray(a);
}
function Wn(a) {
  if (!a)
    throw new Error("coord is required");
  if (!Array.isArray(a)) {
    if (a.type === "Feature" && a.geometry !== null && a.geometry.type === "Point")
      return [...a.geometry.coordinates];
    if (a.type === "Point")
      return [...a.coordinates];
  }
  if (Array.isArray(a) && a.length >= 2 && !Array.isArray(a[0]) && !Array.isArray(a[1]))
    return [...a];
  throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
function ac(a, t, e = {}) {
  if (e.final === !0)
    return np(a, t);
  const i = Wn(a), s = Wn(t), n = Ke(i[0]), r = Ke(s[0]), o = Ke(i[1]), l = Ke(s[1]), h = Math.sin(r - n) * Math.cos(l), c = Math.cos(o) * Math.sin(l) - Math.sin(o) * Math.cos(l) * Math.cos(r - n);
  return qo(Math.atan2(h, c));
}
function np(a, t) {
  let e = ac(t, a);
  return e = (e + 180) % 360, e;
}
function rp(a, t, e, i = {}) {
  const s = Wn(a), n = Ke(s[0]), r = Ke(s[1]), o = Ke(e), l = sp(t, i.units), h = Math.asin(
    Math.sin(r) * Math.cos(l) + Math.cos(r) * Math.sin(l) * Math.cos(o)
  ), c = n + Math.atan2(
    Math.sin(o) * Math.sin(l) * Math.cos(r),
    Math.cos(l) - Math.sin(r) * Math.sin(h)
  ), d = qo(c), f = qo(h);
  return s[2] !== void 0 ? Ml([d, f, s[2]], i.properties) : Ml([d, f], i.properties);
}
function lc(a, t, e = {}) {
  var i = Wn(a), s = Wn(t), n = Ke(s[1] - i[1]), r = Ke(s[0] - i[0]), o = Ke(i[1]), l = Ke(s[1]), h = Math.pow(Math.sin(n / 2), 2) + Math.pow(Math.sin(r / 2), 2) * Math.cos(o) * Math.cos(l);
  return ip(
    2 * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h)),
    e.units
  );
}
var op = lc;
function ap(a, t) {
  const e = lc(a, t), i = ac(a, t);
  return rp(a, e / 2, i);
}
var lp = ap;
function Lp(a) {
  return a.sort((t, e) => {
    const i = { Alerting: 1, Pending: 2, Normal: 3 }, s = t.newState.startsWith("Alerting") ? "Alerting" : t.newState.startsWith("Pending") ? "Pending" : "Normal", n = e.newState.startsWith("Alerting") ? "Alerting" : e.newState.startsWith("Pending") ? "Pending" : "Normal";
    return i[s] - i[n];
  });
}
function Rp(a) {
  let { graphA: t, graphB: e, panel: i, parPath: s, layerIdx: n, edgeId: r, dataRecord: o, commentsData: l, theme: h } = a;
  const { isLogic: c, graph: d } = i, { setEdge: f, findNode: p } = t, P = t.nodeCollection.findEdge, y = s[0], C = s.at(-1);
  if (typeof C != "string" || typeof y != "string")
    return;
  let w = p(y);
  if (!p(C) || !w)
    return;
  const I = [], x = [], V = [];
  if (s.forEach((ot, Ht) => {
    if (typeof ot == "string") {
      const Rt = p(ot);
      if (Rt) {
        const ne = Rt.data.wasmId;
        I.push(ne), x.push(ot), V.push(ot);
      }
    } else !i.isLogic && Array.isArray(ot) && (I.push(void 0), V.push(ot));
  }), !I.length)
    return;
  const M = r ?? y + "-" + C;
  let X = P(M), Zt;
  if (!X) {
    const ot = I;
    d.getEdgeVerticeIds.push([ot, n]), Zt = d.getEdgeVerticeIds.length - 1;
    const Ht = {
      dataRecord: o,
      parPath: V,
      edge_id: Zt,
      edgeId: M
    }, se = [];
    if (c && x.length > 2) {
      const [Rt, ne] = s.length ? hc(V, i.positions, p) : [];
      Rt.forEach((de, mi) => {
        const nn = mi ? "--" + mi : "", Ia = M + nn, ro = de[0].item.id, oo = de.at(-1).item.id, Pi = f(Ia, ro, oo);
        Pi && (Pi.setData(Ht), se.push(Pi));
      });
    } else {
      if (X = f(M, y, C, e), !X) {
        console.warn("edge from rxdb not found in your datasource. Mixed namespaces? (edgeId, sourceId, targetId)", M, y, C);
        return;
      }
      X?.setData(Ht), se.push(X);
    }
    d.getWasmId2Edges[Zt] = se;
  }
  s.forEach((ot, Ht) => {
    if (Array.isArray(ot) && ot.length > 2) {
      const se = ot[3], Rt = ot[4], ne = Rt && h.visualization.getColorByName(Rt), { style: de, layerName: mi } = o || {};
      if (se !== void 0 && de) {
        const nn = {
          text: se,
          iconColor: ne ?? "#4ec2fc",
          style: de,
          root: t,
          layerName: mi,
          index: Ht,
          coords: ot.slice(0, 2),
          edge: X
        };
        l[M] || (l[M] = /* @__PURE__ */ new Map()), l[M].set(Ht, nn);
      }
    }
  });
}
function hc(a, t, e) {
  if (a.length === 0)
    return [[]];
  const i = a.map((l, h) => typeof l == "string" ? e(l) : l).filter((l) => l), s = [], n = [];
  let r = [], o = [];
  for (let l = 0; l < i.length; l++) {
    const h = i[l], c = t[l];
    if (!c)
      continue;
    h.id && r.length > 0 && (r.push({ item: h, gIdx: l, coords: c }), o.push(t[l]), s.push(r), n.push(o), r = [], o = []), r.push({ item: h, gIdx: l, coords: c }), o.push(c);
  }
  return [s, n];
}
function hp(a) {
  return typeof a == "string";
}
function Vl(a) {
  return a.map((t, e) => hp(t) ? e : -1).filter((t) => t !== -1);
}
function cp(a, t, e) {
  const i = Vl(a);
  if (i.length < 2)
    return { parPath: a, wasmIds: t };
  e.length !== Vl(a).length - 1 && console.warn("Polyline / segment mismatch", { polylines: e, parPath: a });
  const s = [], n = [];
  let r = 0;
  for (let l = 0; l < i.length - 1; l++) {
    const h = i[l];
    i[l + 1], s.push(a[h]), n.push(t[h]);
    const c = e[r++] ?? [];
    for (const d of c)
      s.push(d), n.push(void 0);
  }
  const o = i.at(-1);
  return s.push(a[o]), n.push(t[o]), { parPath: s, wasmIds: n };
}
function up(a) {
  const t = Kt.getGeom(a);
  return t?.source ? Array.from(t.getSmoothPolyPoints()).slice(1, -1).map((e) => [e.x, e.y]) : [];
}
function Np(a) {
  const t = a.graph, e = Nt.getGeom(t);
  e.layoutSettings = new sn(), e.layoutSettings.layerDirection = je.RL, e.layoutSettings.LayerSeparation = 60, e.layoutSettings.commonSettings.NodeSeparation = 40, ig(e);
  const { getEdgeVerticeIds: i, wasm2Edges: s } = t;
  s.forEach((n) => {
    const r = n[0], o = r.data.edge_id, l = r.data.parPath, h = i[o][0], c = n.map(up), { parPath: d, wasmIds: f } = cp(l, h, c);
    r.data.parPath = d, i[o][0] = f;
  });
  for (const n of e.deepEdges)
    n.source, n.target, n.curve;
  for (const n of e.nodesBreadthFirst) {
    const r = n.node;
    if (!r.data)
      continue;
    const { feature: o, wasmId: l } = r.data;
    a.positions[l * 2] = n.center.x, a.positions[l * 2 + 1] = n.center.y;
  }
}
function dp(a, t, e, i, s) {
  const n = e - t, r = a * s;
  if (r === 0)
    return t + n * i;
  const o = n / r, l = o * o + 1, h = t, c = i;
  return Math.sqrt(c * (l - c)) * r + h;
}
function fp(a, t, e) {
  return e ? [
    (a[0] + t[0]) / 2,
    (a[1] + t[1]) / 2
  ] : lp(a, t).geometry.coordinates;
}
function Bp(a, t, e = !0) {
  if (a.id) {
    const i = a.data.wasmId, s = t.positions[i * 2], n = t.positions[i * 2 + 1];
    if (s !== void 0 && !n !== void 0)
      return [s, n];
  } else if (Array.isArray(a))
    return e ? a.slice(0, 2) : a;
  return null;
}
function gp(a, t, e, i = !0) {
  return a.map((n, r) => {
    if (typeof n == "string") {
      const o = t[r], l = e[o * 2], h = e[o * 2 + 1];
      return l !== void 0 && !h !== void 0 ? [l, h] : [l, h];
    } else if (Array.isArray(n))
      return i ? n.slice(0, 2) : n;
    return null;
  }).filter((n) => n);
}
const Gp = "#4ec2fc", pp = 1.5, mp = "default", Pp = "#0a55a1", Mp = "#000000", Fp = "#299c46", Vp = "#9acd32", Dp = "#299C46", Sp = "#ed8128", yp = "#f53636", kp = "#ed473b", bp = Pp, _p = "rgba(154, 205, 50)", vp = "#9acd32", Wp = {
  color: vp,
  lineWidth: pp,
  label: mp
}, Hp = "#f0fc", zp = "#e034b8cc", jp = "#ffdd57e6", qp = "#205299cc", Up = "#ffd70033", Xp = "#20529933", Qp = "#ffd70026", Yp = "#42a4f533", Jp = "#e6ca5ce6", Kp = "#dfff7bcc", Zp = "#2fa1deb3", $p = "#f0f0f0", tm = "#e0be8b", Eo = { Alerting: "#e0226e", Pending: "#ff9900", Normal: "#1b855e" }, em = "#cfe3d4", im = 0.5, wo = {
  255: [Eo.Alerting, "Alerting", [224, 34, 110, 254]],
  222: [Eo.Pending, "Pending", [255, 153, 0, 254]],
  111: [Eo.Normal, "Normal", [27, 133, 94, 254]]
}, sm = { Alerting: wo[255], Pending: wo[222], Normal: wo[111] }, nm = 20, rm = "new rule", om = !0, am = "", lm = "cisco/atm-switch", hm = -5, cm = 40, um = 45, dm = 16, fm = 2, gm = {}, pm = {
  shape: "binary-feature-collection",
  points: {
    type: "Point",
    positions: { value: new Float64Array([]), size: 2 },
    featureIds: { value: new Uint32Array([]), size: 1 },
    globalFeatureIds: { value: new Uint32Array([]), size: 1 },
    properties: []
  },
  polygons: {
    type: "Polygon",
    positions: { value: new Float32Array(), size: 2 },
    featureIds: { value: new Uint16Array(), size: 1 },
    globalFeatureIds: { value: new Uint16Array(), size: 1 },
    polygonIndices: { value: new Uint16Array(), size: 1 },
    primitivePolygonIndices: { value: new Uint16Array(), size: 1 },
    properties: []
  },
  lines: {
    type: "LineString",
    positions: { value: new Float32Array(), size: 2 },
    featureIds: { value: new Uint16Array(), size: 1 },
    pathIndices: { value: new Uint16Array(), size: 1 },
    globalFeatureIds: { value: new Uint16Array(), size: 1 },
    properties: []
  }
}, mm = [
  Sp,
  yp,
  bp
], Pm = "fixed", Sm = ".", ym = 25, bm = "mapgl", vm = "xy-namespaces", Cm = "cmn", Im = "external", Em = "annots & alerts query (built-in)", wm = "source", Am = {
  longitude: 0,
  latitude: 0,
  zoom: 1,
  yZoom: 2
};
var Dl;
(function(a) {
  a.GeoJson = "geojson", a.Polygons = "polygons", a.Path = "path", a.Markers = "markers", a.Nodes = "nodes", a.Edges = "edges", a.Hyperedges = "routed", a.Clusters = "clusters", a.SVG = "icon", a.Circle = "circle", a.Label = "label", a.Comments = "comments", a.Hull = "convex-hull", a.Text = "text", a.Bboxes = "bboxes";
})(Dl || (Dl = {}));
class be extends fc {
  root;
  isLogic = !1;
  comments = {};
  wasm2Edges = [];
  wasm_edge_vertice_ids = [];
  groupCounts = /* @__PURE__ */ new Map();
  positionRanges = [];
  disposeAutorun = () => {
  };
  /** Version the graph. A version is a number that is incremented every time the graph is updated. */
  version = 0;
  /** Is a panel root graph */
  isRoot = !1;
  constructor(t = "__graph__", e = !1, i = !0) {
    super(t), this.isRoot = e, this.isLogic = i, this.findNode = this.findNode.bind(this), this.addNode = this.addNode.bind(this), this.setEdge = this.setEdge.bind(this), this._bumpVersion = this._bumpVersion.bind(this), this.setRoot = this.setRoot.bind(this), this.findNodeRecursive = this.findNodeRecursive.bind(this), bh(this, {
      version: It,
      _bumpVersion: Ne,
      getVersion: li,
      getEdgesGeometry: li,
      getComments: li,
      groupCounts: It,
      getGroupCounts: li,
      addNode: Ne,
      setEdge: Ne,
      addToGroup: Ne,
      rmFromGroup: Ne
    });
  }
  addToGroup = (t, e) => {
    const i = this.groupCounts.get(t);
    i ? this.groupCounts.set(t, i + 1) : this.groupCounts.set(t, 1);
  };
  rmFromGroup = (t, e) => {
    const i = this.groupCounts.get(t);
    i && this.groupCounts.set(t, i - 1);
  };
  get getGroupCounts() {
    return this.groupCounts;
  }
  /// Untouched MSAGLJS graph
  remove(t) {
    this.nodeCollection.remove(t);
  }
  /** Removes itself from under the parent.
   *  Also removes all the edges leading out of the graph.
   */
  removeSubgraph() {
    const t = this.parent;
    t && t.removeNode(this);
    for (const e of this.outGoingEdges())
      e.attachedAtSource ? e.node.removeOutEdge(e.edge) : e.node.removeInEdge(e.edge);
  }
  /** returns the objects that show how the edge is adjacent to a node  that is outside of the graph */
  *outGoingEdges() {
    for (const t of this.outEdges) {
      const e = t.target;
      this.isAncestor(e) || (yield { edge: t, node: e, attachedAtSource: !1 });
    }
    for (const t of this.inEdges) {
      const e = t.source;
      this.isAncestor(e) || (yield { edge: t, node: e, attachedAtSource: !0 });
    }
    for (const t of this.nodesBreadthFirst) {
      for (const e of t.outEdges) {
        const i = e.target;
        i !== this && (this.isAncestor(i) || (yield { edge: e, node: i, attachedAtSource: !1 }));
      }
      for (const e of t.inEdges) {
        const i = e.source;
        i !== this && (this.isAncestor(i) || (yield { edge: e, node: i, attachedAtSource: !0 }));
      }
    }
  }
  isAncestor(t) {
    for (const e of t.getAncestors())
      if (e === this)
        return !0;
    return !1;
  }
  /**  Iterates over all connected components of the graph and for each component
   * returns all its nodes with "this" as the parent
   */
  *getClusteredConnectedComponents() {
    const t = /* @__PURE__ */ new Set(), e = new We.Queue();
    for (const i of this.nodesBreadthFirst) {
      if (t.has(i))
        continue;
      t.add(i), e.enqueue(i);
      const s = /* @__PURE__ */ new Set();
      do {
        const n = e.dequeue();
        n.parent === this && s.add(n);
        for (const r of this.reachableFrom(n))
          t.has(r) || (t.add(r), e.enqueue(r));
      } while (e.length > 0);
      yield Array.from(s);
    }
  }
  *reachableFrom(t) {
    for (const e of t.outEdges)
      yield e.target;
    for (const e of t.inEdges)
      yield e.source;
    t instanceof be && (yield* t.shallowNodes), t.parent != this && (yield t.parent);
  }
  hasSomeAttrOnIndex(t) {
    for (const e of this.nodesBreadthFirst)
      if (e.getAttr(t))
        return !0;
    for (const e of this.deepEdges)
      if (e.getAttr(t))
        return !0;
    return !1;
  }
  *graphs() {
    for (const t of this.nodeCollection.graphs)
      yield t;
  }
  noEmptySubgraphs() {
    for (const t of this.subgraphsBreadthFirst())
      if (t.shallowNodeCount === 0)
        return !1;
    return !0;
  }
  hasSubgraphs() {
    for (const t of this.shallowNodes)
      if (t instanceof be)
        return !0;
    return !1;
  }
  /** iterates breadth first  */
  *subgraphsBreadthFirst() {
    for (const t of this.nodesBreadthFirst)
      t instanceof be && (yield t);
  }
  isEmpty() {
    return this.shallowNodeCount === 0;
  }
  setEdge(t, e, i, s) {
    const n = this.nodeCollection.findShallow(e);
    if (n == null)
      return;
    const r = s ? s.nodeCollection.findShallow(i) : this.nodeCollection.findShallow(i);
    if (r == null)
      return;
    const o = new dc(t, n, r);
    return this.isLogic && new Kt(o), this.nodeCollection.addEdge(o), o;
  }
  /** Iterates over the nodes of the current graph but not entering the subgraphs.
  *  Yields the top subgraphs among the nodes as well
  */
  get shallowNodes() {
    return this.nodeCollection.nodesShallow;
  }
  /** Iterates over all the nodes of including the subgraphs.
   * The iteration happens in the breadth first pattern.
   */
  get nodesBreadthFirst() {
    return this.nodesBreadthFirst_();
  }
  /** iterates breadth first  */
  *nodesBreadthFirst_() {
    for (const t of this.nodeCollection.nodesShallow)
      yield t, t instanceof be && (yield* t.nodesBreadthFirst);
  }
  dispose() {
    this.disposeAutorun && this.disposeAutorun();
  }
  setRoot = (t) => {
    this.root = t;
  };
  /**
   * Finds the node with the givin id belonging to a graph or one of its subgraphs.
   */
  findNodeRecursive(t) {
    const e = this.nodeCollection.findShallow(t);
    if (e)
      return e;
    for (const i of this.shallowNodes)
      if (i instanceof be) {
        const s = i.findNodeRecursive(t);
        if (s)
          return s;
      }
    return null;
  }
  /** Returns a node belonging to this graph having the same id.
   * If a node with the given id belongs to a subgraph than it would no be returned.
   * To find such a deeper nested node use findNodeRecursive
   */
  findNode(t) {
    return this.nodeCollection.findShallow(t);
  }
  /** iterates over the edges of the graph which adjacent to the nodes of the graph:
   * not iterating over the subgraphs
   */
  get shallowEdges() {
    return this.nodeCollection.edges;
  }
  /** iterates over the edges of the graph including subgraphs */
  get deepEdges() {
    return this.deepEdgesIt();
  }
  *deepEdgesIt() {
    for (const t of this.nodesBreadthFirst) {
      for (const e of t.outEdges)
        yield e;
      for (const e of t.selfEdges)
        yield e;
      for (const e of t.inEdges)
        this.isAncestor(e.source) || (yield e);
    }
  }
  isConsistent() {
    return this.parent ? this.parent.isConsistent() : this.eachNodeIdIsUnique() && this.nodeCollection.isConsistent();
  }
  nodeIsConsistent(t) {
    return this.nodeCollection.nodeIsConsistent(t);
  }
  /** Detouches all the node's edges and removes the node from the graph.
   * This method does not change the parent of the node.
   */
  removeNode(t) {
    for (const e of t.outEdges)
      e.target.inEdges.delete(e);
    for (const e of t.inEdges)
      e.source.outEdges.delete(e);
    this.nodeCollection.remove(t);
    for (const e of this.subgraphsBreadthFirst())
      e.removeNode(t);
  }
  /** adds a node to the graph */
  addNode(t) {
    return uc.assert(this.findNodeRecursive(t.id) == null), t.parent = this, this.nodeCollection.addNode(t), t;
  }
  /// was private originally
  nodeCollection = new qa();
  get shallowNodeCount() {
    return this.nodeCollection.nodeShallowCount;
  }
  get nodeCountDeep() {
    let t = this.nodeCollection.size;
    for (const e of this.shallowNodes)
      e instanceof be && (t += e.nodeCountDeep);
    return t;
  }
  get edgeCount() {
    return this.nodeCollection.edgeCount;
  }
  // If n has an ancestor which is the graph child then return it.
  // Otherwise return null
  liftNode(t) {
    for (; t != null && t.parent !== this; )
      t = t.parent;
    return t;
  }
  /** return the number of all edges in the graph, including the subgraphs */
  get deepEdgesCount() {
    let t = 0;
    for (const e of this.nodesBreadthFirst)
      t += e.outDegree + e.selfDegree;
    return t;
  }
  eachNodeIdIsUnique() {
    const t = /* @__PURE__ */ new Set();
    for (const e of this.nodesBreadthFirst) {
      if (t.has(e.id))
        return !1;
      t.add(e.id);
    }
    return !0;
  }
  /** returns all the nodes under graph and the edges with at least one end adjacent to the graph */
  *allElements() {
    for (const t of this.allSuccessorsWidthFirst()) {
      yield t;
      for (const e of t.selfEdges)
        yield e;
      for (const e of t.outEdges)
        yield e;
      for (const e of t.inEdges)
        this.isAncestor(e.source) || (yield e);
    }
    yield* this.edges;
  }
  *allSuccessorsWidthFirst() {
    for (const t of this.shallowNodes)
      yield t;
    for (const t of this.shallowNodes)
      t instanceof be && (yield* t.allSuccessorsWidthFirst());
  }
  *allSuccessorsDepthFirst() {
    for (const t of this.shallowNodes)
      t instanceof be && (yield* t.allSuccessorsDepthFirst()), yield t;
  }
  /**
   * Clean up all the nodes in the graph.
   */
  resetNodes = () => {
    this.nodeCollection = new qa(), this.positionRanges = [];
  };
  get getNodes() {
    return this.nodeCollection.nodesShallow;
  }
  /**
   * Clean up everything in the graph.
   */
  reset = () => {
    this.resetNodes(), this.groupCounts = /* @__PURE__ */ new Map(), this.wasm2Edges = [], this.wasm_edge_vertice_ids = [];
  };
  /**
   * Trigger an update to the graph.
   */
  triggerUpdate = () => {
    this._bumpVersion();
  };
  /**
   * Check the equality of two graphs data by checking last update time stamp
   * @param  {Object} g Another graph to be compared against itself
   * @return {Bool}   True if the graph is the same as itself.
   */
  equals = (t) => !t || !(t instanceof be) ? !1 : this.version === t.version;
  _bumpVersion() {
    this.version += 1;
  }
  get getVersion() {
    return this.version;
  }
  get getComments() {
    return this.comments;
  }
  get getWasmId2Edges() {
    return this.wasm2Edges;
  }
  get getEdgeVerticeIds() {
    return this.wasm_edge_vertice_ids;
  }
  get getEdgesGeometry() {
    const t = {}, e = {}, s = this.root.panel.positions;
    return this.wasm2Edges.forEach((n, r) => {
      if (!n.length)
        return;
      const o = n[0], { source: l, data: h } = o, c = l.parent, d = this.findNode;
      if (!h)
        return;
      const f = h?.dataRecord;
      h?.edge_id;
      const { parPath: p } = h || {}, P = p[0];
      let y = p;
      const C = this.wasm_edge_vertice_ids[r][0];
      let w = gp(y, C, s, !0);
      const [N, I] = p.length ? hc(y, w, d) : [];
      let x = I;
      N.length || Array.isArray(p) && N.push([{
        item: P,
        gIdx: 0
      }, { item: p.at(-1), gIdx: 1 }]);
      const V = Kt.getGeom(o);
      if (V?.source && (V?.curve?.start ? x.forEach((Pi, Yn) => {
        Pi.length > 3 && (x[Yn] = Pi.slice(1, -1));
      }) : (console.warn("Invalid controlPoints or polyPoints", P, o.id), x = [x])), !x.length)
        return;
      const M = f, X = {
        //id: counter,
        edgeId: o.id,
        type: "Feature",
        geometry: {
          type: "MultiLineString",
          coordinates: x
        },
        rowIndex: f?.rowIndex,
        // can't pick original index without explicitely stating it
        properties: {
          ...M ?? {},
          locName: P,
          segrPath: N
        }
      }, Zt = X.properties, ot = x[0][0], Ht = x.at(-1).at(-1);
      e[c.id] || (e[c.id] = []), e[c.id].push(X), o.setLineId(e[c.id].length - 1);
      const { arcStyle: se } = Zt, Rt = se?.arcConfig.height, ne = { units: "meters" };
      function de(Pi, Yn) {
        const Ea = Yn[0] - Pi[0], wa = Yn[1] - Pi[1];
        return Math.sqrt(Ea * Ea + wa * wa);
      }
      const mi = this.isLogic ? de(ot, Ht) : op(ot, Ht, ne), nn = dp(mi, 0, 0, 0.5, Rt !== void 0 ? Rt : 0.5), ro = [
        ...fp(ot, Ht, this.isLogic),
        nn
      ], oo = {
        sourcePosition: ot,
        targetPosition: Ht,
        midPoint: ro,
        properties: Zt,
        edgeId: o.id
      };
      t[c.id] || (t[c.id] = []), t[c.id].push(oo);
    }), [e, t];
  }
}
class Tm {
  colType;
  layerName;
  __state = {};
  frameRefId;
  features = [];
  positionRanges = [];
  colorThresholds;
  useMockData = !1;
  groups = [];
  constructor(t, e) {
    this.colType = t, this.layerName = e, this.getState = this.getState.bind(this), this.setThresholds = this.setThresholds.bind(this), this.setFeatures = this.setFeatures.bind(this), this.setPositionRanges = this.setPositionRanges.bind(this), this.clear = this.clear.bind(this);
  }
  setGroups = (t) => {
    this.groups = t;
  };
  addGroup = (t) => {
    this.groups.push(t);
  };
  get getGroups() {
    return this.groups;
  }
  setThresholds = (t) => {
    this.colorThresholds = t ?? {};
  };
  setFeatures(t, e) {
    this.frameRefId = e, this.features = t;
  }
  setPositionRanges(t) {
    this.positionRanges = t;
  }
  getState() {
    return this.__state;
  }
  clear() {
    this.features = [];
  }
}
export {
  sm as ALERTING_NUMS,
  Eo as ALERTING_STATES,
  wo as ALERT_MAP,
  Em as ANNOTS_LABEL,
  tm as ANNOT_CLUSTER_BK_COLOR,
  fr as AttributeRegistry,
  em as BBOX_OUTLINE_COLOR,
  im as BBOX_OUTLINE_WIDTH,
  Im as CMN_NAMESPACE,
  Cm as CMN_NAMESPACE_PREFIX,
  gp as CoordsConvert,
  pt as CurveFactory,
  Up as DARK_AUTO_HIGHLIGHT,
  jp as DARK_CENTER_PLOT,
  Qp as DARK_HULL_HIGHLIGHT,
  $p as DEFAULT_CLUSTER_BK_COLOR,
  um as DEFAULT_CLUSTER_ICON_SIZE,
  dm as DEFAULT_CLUSTER_MAX_ZOOM,
  cm as DEFAULT_CLUSTER_SCALE,
  mp as DEFAULT_COLOR_LABEL,
  Vp as DEFAULT_COLOR_PICKER,
  Gp as DEFAULT_COMMENT_COLOR,
  yp as DEFAULT_CRITICAL_COLOR,
  zp as DEFAULT_EDIT_HANDLE_COLOR,
  am as DEFAULT_ICON_NAME,
  lm as DEFAULT_ICON_NAME2,
  om as DEFAULT_ICON_RULE_IS_COLLAPSED,
  rm as DEFAULT_ICON_RULE_LABEL,
  nm as DEFAULT_ICON_SIZE,
  pp as DEFAULT_LINE_WIDTH,
  vp as DEFAULT_NO_DATA_COLOR,
  _p as DEFAULT_NO_DATA_COLOR_RGBA,
  bp as DEFAULT_NO_THRESHOLD_COLOR,
  kp as DEFAULT_NUMS_COLOR,
  Fp as DEFAULT_OK_COLOR,
  Dp as DEFAULT_OK_COLOR_SELECTED,
  hm as DEFAULT_SVG_ICON_V_OFFSET,
  Sp as DEFAULT_WARNING_COLOR,
  dc as Edge,
  Jt as EdgeRoutingMode,
  Hp as FEATURE_EDIT_HANDLE_COLOR,
  Pm as FIXED_COLOR_LABEL,
  Tm as FeatSource,
  Mp as GLOBAL_BORDER_COLOR,
  Pp as GLOBAL_FILL_COLOR,
  mm as GLOBAL_OVERRIDE_COLORS,
  Nt as GeomGraph,
  Yt as GeomNode,
  be as Graph,
  Xp as LIGHT_AUTO_HIGHLIGHT,
  qp as LIGHT_CENTER_PLOT,
  Yp as LIGHT_HULL_HIGHLIGHT,
  Jp as LINES_EDIT_HANDLE_COLOR,
  Kp as LINES_SNAP_SOURCE_COLOR,
  Zp as LINES_SNAP_TARGET_COLOR,
  je as LayerDirectionEnum,
  wm as MOC_LOC_FIELD,
  ym as NS_PADDING,
  Sm as NS_SEPARATOR,
  fc as Node,
  u as Point,
  vm as RXDB_LOGIC_NAMESPACES,
  bm as RXDB_NS_PREFIX,
  fm as SEL_LINE_WIDTH_MULTIPLIER,
  Bp as SingleCoordsConvert,
  sn as SugiyamaLayoutSettings,
  xp as TileMap,
  gm as blankHoverInfo,
  Dl as colTypes,
  Am as defViewState,
  Wp as defaultThreshold,
  pm as emptyBiCol,
  ap as getMiddleCoords,
  ig as layoutGeomGraph,
  Rp as pushPath,
  Np as runLayout,
  Lp as sortAnnotations
};
