var Kn = {}, on = {}, Ta;
function Wl() {
  if (Ta) return on;
  Ta = 1, Object.defineProperty(on, "__esModule", { value: !0 });
  class o {
    constructor(...i) {
      this._head = this._tail = null, this._length = 0, i.length > 0 && i.forEach((s) => {
        this.append(s);
      });
    }
    *iterator() {
      let i = this._head;
      for (; i; )
        yield i.value, i = i.next;
    }
    [Symbol.iterator]() {
      return this.iterator();
    }
    get head() {
      return this._head ? this._head.value : null;
    }
    get tail() {
      return this._tail ? this._tail.value : null;
    }
    get length() {
      return this._length;
    }
    // Adds the element at a specific position inside the linked list
    insert(i, s, n = !1) {
      if (n && this.isDuplicate(i))
        return !1;
      let r = new t(i), a = this._head;
      if (a)
        for (; ; ) {
          if (a.value === s)
            return r.next = a.next, r.prev = a, a.next = r, r.next ? r.next.prev = r : this._tail = r, this._length++, !0;
          if (a.next)
            a = a.next;
          else
            return !1;
        }
      else
        return !1;
    }
    // Adds the element at the end of the linked list
    append(i, s = !1) {
      if (s && this.isDuplicate(i))
        return !1;
      let n = new t(i);
      return this._tail ? (this._tail.next = n, n.prev = this._tail, this._tail = n) : this._head = this._tail = n, this._length++, !0;
    }
    // Add the element at the beginning of the linked list
    prepend(i, s = !1) {
      if (s && this.isDuplicate(i))
        return !1;
      let n = new t(i);
      return this._head ? (n.next = this._head, this._head.prev = n, this._head = n) : this._head = this._tail = n, this._length++, !0;
    }
    remove(i) {
      let s = this._head;
      if (s) {
        if (s.value === i)
          return this._head = s.next, this._head.prev = null, s.next = s.prev = null, this._length--, s.value;
        for (; ; ) {
          if (s.value === i)
            return s.next ? (s.prev.next = s.next, s.next.prev = s.prev, s.next = s.prev = null) : (s.prev.next = null, this._tail = s.prev, s.next = s.prev = null), this._length--, s.value;
          if (s.next)
            s = s.next;
          else
            return;
        }
      }
    }
    removeHead() {
      let i = this._head;
      if (i)
        return this._head.next ? (this._head.next.prev = null, this._head = this._head.next, i.next = i.prev = null) : (this._head = null, this._tail = null), this._length--, i.value;
    }
    removeTail() {
      let i = this._tail;
      if (i)
        return this._tail.prev ? (this._tail.prev.next = null, this._tail = this._tail.prev, i.next = i.prev = null) : (this._head = null, this._tail = null), this._length--, i.value;
    }
    first(i) {
      let s = this.iterator(), n = [], r = Math.min(i, this.length);
      for (let a = 0; a < r; a++) {
        let l = s.next();
        n.push(l.value);
      }
      return n;
    }
    toArray() {
      return [...this];
    }
    isDuplicate(i) {
      return new Set(this.toArray()).has(i);
    }
  }
  on.LinkedList = o;
  class t {
    constructor(i) {
      this.value = i, this.next = null, this.prev = null;
    }
  }
  return on.LinkedListItem = t, on;
}
var Oa;
function dc() {
  if (Oa) return Kn;
  Oa = 1, Object.defineProperty(Kn, "__esModule", { value: !0 });
  const o = Wl();
  class t extends o.LinkedList {
    constructor(...i) {
      super(...i);
    }
    get front() {
      return this.head;
    }
    enqueue(i) {
      this.append(i);
    }
    dequeue() {
      return this.removeHead();
    }
  }
  return Kn.Queue = t, Kn;
}
var We = dc();
let fc = class {
  //@ts-ignore
  static assert(t, e = null) {
    if (!t)
      throw e != null ? new Error(e) : new Error("condition does not hold");
  }
}, gr = class {
  static GeomObjectIndex = 0;
  static DrawingObjectIndex = 1;
  static AlgorithmDataIndex = 2;
  static ViewerIndex = 3;
  /// Extra from Mapgl
  static NodeDataIndex = 4;
  static EdgeDataIndex = 5;
}, Xo = class {
  constructor() {
    this.attrs = [], this._parent = null;
  }
  /** adds an event function */
  addEvent(t) {
    this.events.push(t);
  }
  /** trying to remove an event function */
  removeEvent(t) {
    const e = this.events.indexOf(t);
    e >= 0 && (this.events = this.events.splice(e, 1));
  }
  /** raises all available events on the given data */
  raiseEvents(t) {
    this.events.forEach((e) => e(t));
  }
  /** removes all the attributes form the entity */
  clearAttr() {
    this.attrs = [];
  }
  /** sets the attribute at the given position */
  setAttr(t, e) {
    this.attrs[t] = e;
  }
  /** gets the attribute at the given position */
  getAttr(t) {
    return this.attrs[t];
  }
  get parent() {
    return this._parent;
  }
  set parent(t) {
    this._parent = t;
  }
  *getAncestors() {
    let t = this.parent;
    for (; t != null; )
      yield t, t = t.parent;
  }
  /**  Determines if this node is a descendant of the given graph.*/
  isDescendantOf(t) {
    for (const e of this.getAncestors())
      if (e === t)
        return !0;
    return !1;
  }
};
class Hl extends Xo {
  /** sets the attribute at the given position */
  setAttrProp(t, e, i) {
    const s = this.getAttr(t);
    s && (s[e] = i);
  }
}
var pn;
(function(o) {
  o[o.None = 0] = "None", o[o.FromAncestor = 1] = "FromAncestor", o[o.ToAncestor = 2] = "ToAncestor";
})(pn || (pn = {}));
let gc = class extends Hl {
  _id;
  /** the unique, in the parent graph, id of the edge */
  get id() {
    return this._id;
  }
  _lineId;
  get lineId() {
    return this._lineId;
  }
  label;
  source;
  target;
  constructor(t, e, i) {
    super(), this._id = t, this.source = e, this.target = i, e !== i ? (e.outEdges.add(this), i.inEdges.add(this)) : e.selfEdges.add(this);
  }
  setLineId(t) {
    this._lineId = t;
  }
  get data() {
    return this.getAttr(gr.EdgeDataIndex);
  }
  setData(t) {
    this.setAttr(gr.EdgeDataIndex, t);
  }
  add() {
    this.source !== this.target ? (this.source.outEdges.add(this), this.target.inEdges.add(this)) : this.source.selfEdges.add(this);
  }
  remove() {
    this.source !== this.target ? (this.source.outEdges.delete(this), this.target.inEdges.delete(this)) : this.source.selfEdges.delete(this);
  }
  toString() {
    return "(" + this.source.toString() + "->" + this.target.toString() + ")";
  }
  isInterGraphEdge() {
    return this.source.parent !== this.target.parent;
  }
  EdgeToAncestor() {
    return this.source instanceof be && this.target.isDescendantOf(this.source) ? pn.FromAncestor : this.target instanceof be && this.source.isDescendantOf(this.target) ? pn.ToAncestor : pn.None;
  }
}, pc = class extends Hl {
  removeOutEdge(t) {
    this.outEdges.delete(t);
  }
  removeInEdge(t) {
    this.inEdges.delete(t);
  }
  //@ts-ignore
  _id;
  /** the unique, in the parent graph, id of the node */
  get id() {
    return this._id;
  }
  set id(t) {
    this._id = t;
  }
  inEdges = /* @__PURE__ */ new Set();
  outEdges = /* @__PURE__ */ new Set();
  selfEdges = /* @__PURE__ */ new Set();
  toString() {
    return this.id;
  }
  constructor(t) {
    super(), this.id = t;
  }
  *_edges() {
    for (const t of this.inEdges)
      yield t;
    for (const t of this.outEdges)
      yield t;
    for (const t of this.selfEdges)
      yield t;
  }
  get edges() {
    return this._edges();
  }
  get outDegree() {
    return this.outEdges.size;
  }
  get inDegree() {
    return this.inEdges.size;
  }
  get selfDegree() {
    return this.selfEdges.size;
  }
  get degree() {
    return this.outDegree + this.inDegree + this.selfDegree;
  }
  get data() {
    return this.getAttr(gr.NodeDataIndex);
  }
  setData(t) {
    this.setAttr(gr.NodeDataIndex, t);
  }
};
var mc = {
  0: "Invalid value for configuration 'enforceActions', expected 'never', 'always' or 'observed'",
  1: function(t, e) {
    return "Cannot apply '" + t + "' to '" + e.toString() + "': Field not found.";
  },
  /*
  2(prop) {
      return `invalid decorator for '${prop.toString()}'`
  },
  3(prop) {
      return `Cannot decorate '${prop.toString()}': action can only be used on properties with a function value.`
  },
  4(prop) {
      return `Cannot decorate '${prop.toString()}': computed can only be used on getter properties.`
  },
  */
  5: "'keys()' can only be used on observable objects, arrays, sets and maps",
  6: "'values()' can only be used on observable objects, arrays, sets and maps",
  7: "'entries()' can only be used on observable objects, arrays and maps",
  8: "'set()' can only be used on observable objects, arrays and maps",
  9: "'remove()' can only be used on observable objects, arrays and maps",
  10: "'has()' can only be used on observable objects, arrays and maps",
  11: "'get()' can only be used on observable objects, arrays and maps",
  12: "Invalid annotation",
  13: "Dynamic observable objects cannot be frozen. If you're passing observables to 3rd party component/function that calls Object.freeze, pass copy instead: toJS(observable)",
  14: "Intercept handlers should return nothing or a change object",
  15: "Observable arrays cannot be frozen. If you're passing observables to 3rd party component/function that calls Object.freeze, pass copy instead: toJS(observable)",
  16: "Modification exception: the internal structure of an observable array was changed.",
  17: function(t, e) {
    return "[mobx.array] Index out of bounds, " + t + " is larger than " + e;
  },
  18: "mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js",
  19: function(t) {
    return "Cannot initialize from classes that inherit from Map: " + t.constructor.name;
  },
  20: function(t) {
    return "Cannot initialize map from " + t;
  },
  21: function(t) {
    return "Cannot convert to map from '" + t + "'";
  },
  22: "mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js",
  23: "It is not possible to get index atoms from arrays",
  24: function(t) {
    return "Cannot obtain administration from " + t;
  },
  25: function(t, e) {
    return "the entry '" + t + "' does not exist in the observable map '" + e + "'";
  },
  26: "please specify a property",
  27: function(t, e) {
    return "no observable property '" + t.toString() + "' found on the observable object '" + e + "'";
  },
  28: function(t) {
    return "Cannot obtain atom from " + t;
  },
  29: "Expecting some object",
  30: "invalid action stack. did you forget to finish an action?",
  31: "missing option for computed: get",
  32: function(t, e) {
    return "Cycle detected in computation " + t + ": " + e;
  },
  33: function(t) {
    return "The setter of computed value '" + t + "' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?";
  },
  34: function(t) {
    return "[ComputedValue '" + t + "'] It is not possible to assign a new value to a computed value.";
  },
  35: "There are multiple, different versions of MobX active. Make sure MobX is loaded only once or use `configure({ isolateGlobalState: true })`",
  36: "isolateGlobalState should be called before MobX is running any reactions",
  37: function(t) {
    return "[mobx] `observableArray." + t + "()` mutates the array in-place, which is not allowed inside a derivation. Use `array.slice()." + t + "()` instead";
  },
  38: "'ownKeys()' can only be used on observable objects",
  39: "'defineProperty()' can only be used on observable objects"
}, Pc = mc;
function R(o) {
  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    e[i - 1] = arguments[i];
  {
    var s = typeof o == "string" ? o : Pc[o];
    throw typeof s == "function" && (s = s.apply(null, e)), new Error("[MobX] " + s);
  }
}
var Sc = {};
function Qo() {
  return typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : Sc;
}
var zl = Object.assign, pr = Object.getOwnPropertyDescriptor, ci = Object.defineProperty, jr = Object.prototype, mr = [];
Object.freeze(mr);
var jl = {};
Object.freeze(jl);
var yc = typeof Proxy < "u", bc = /* @__PURE__ */ Object.toString();
function ql() {
  yc || R("`Proxy` objects are not available in the current environment. Please configure MobX to enable a fallback implementation.`");
}
function an(o) {
  A.verifyProxies && R("MobX is currently configured to be able to run in ES5 mode, but in ES5 MobX won't be able to " + o);
}
function si() {
  return ++A.mobxGuid;
}
function Yo(o) {
  var t = !1;
  return function() {
    if (!t)
      return t = !0, o.apply(this, arguments);
  };
}
var Os = function() {
};
function Lt(o) {
  return typeof o == "function";
}
function ms(o) {
  var t = typeof o;
  switch (t) {
    case "string":
    case "symbol":
    case "number":
      return !0;
  }
  return !1;
}
function qr(o) {
  return o !== null && typeof o == "object";
}
function gi(o) {
  if (!qr(o))
    return !1;
  var t = Object.getPrototypeOf(o);
  if (t == null)
    return !0;
  var e = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return typeof e == "function" && e.toString() === bc;
}
function Ul(o) {
  var t = o?.constructor;
  return t ? t.name === "GeneratorFunction" || t.displayName === "GeneratorFunction" : !1;
}
function Ur(o, t, e) {
  ci(o, t, {
    enumerable: !1,
    writable: !0,
    configurable: !0,
    value: e
  });
}
function Xl(o, t, e) {
  ci(o, t, {
    enumerable: !1,
    writable: !1,
    configurable: !0,
    value: e
  });
}
function Is(o, t) {
  var e = "isMobX" + o;
  return t.prototype[e] = !0, function(i) {
    return qr(i) && i[e] === !0;
  };
}
function Ks(o) {
  return o != null && Object.prototype.toString.call(o) === "[object Map]";
}
function vc(o) {
  var t = Object.getPrototypeOf(o), e = Object.getPrototypeOf(t), i = Object.getPrototypeOf(e);
  return i === null;
}
function wi(o) {
  return o != null && Object.prototype.toString.call(o) === "[object Set]";
}
var Ql = typeof Object.getOwnPropertySymbols < "u";
function Cc(o) {
  var t = Object.keys(o);
  if (!Ql)
    return t;
  var e = Object.getOwnPropertySymbols(o);
  return e.length ? [].concat(t, e.filter(function(i) {
    return jr.propertyIsEnumerable.call(o, i);
  })) : t;
}
var Xr = typeof Reflect < "u" && Reflect.ownKeys ? Reflect.ownKeys : Ql ? function(o) {
  return Object.getOwnPropertyNames(o).concat(Object.getOwnPropertySymbols(o));
} : (
  /* istanbul ignore next */
  Object.getOwnPropertyNames
);
function To(o) {
  return typeof o == "string" ? o : typeof o == "symbol" ? o.toString() : new String(o).toString();
}
function Yl(o) {
  return o === null ? null : typeof o == "object" ? "" + o : o;
}
function De(o, t) {
  return jr.hasOwnProperty.call(o, t);
}
var Ic = Object.getOwnPropertyDescriptors || function(t) {
  var e = {};
  return Xr(t).forEach(function(i) {
    e[i] = pr(t, i);
  }), e;
};
function ve(o, t) {
  return !!(o & t);
}
function Ce(o, t, e) {
  return e ? o |= t : o &= ~t, o;
}
function xa(o, t) {
  (t == null || t > o.length) && (t = o.length);
  for (var e = 0, i = Array(t); e < t; e++) i[e] = o[e];
  return i;
}
function wc(o, t) {
  for (var e = 0; e < t.length; e++) {
    var i = t[e];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(o, Ac(i.key), i);
  }
}
function Zs(o, t, e) {
  return t && wc(o.prototype, t), Object.defineProperty(o, "prototype", {
    writable: !1
  }), o;
}
function xs(o, t) {
  var e = typeof Symbol < "u" && o[Symbol.iterator] || o["@@iterator"];
  if (e) return (e = e.call(o)).next.bind(e);
  if (Array.isArray(o) || (e = Tc(o)) || t) {
    e && (o = e);
    var i = 0;
    return function() {
      return i >= o.length ? {
        done: !0
      } : {
        done: !1,
        value: o[i++]
      };
    };
  }
  throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Li() {
  return Li = Object.assign ? Object.assign.bind() : function(o) {
    for (var t = 1; t < arguments.length; t++) {
      var e = arguments[t];
      for (var i in e) ({}).hasOwnProperty.call(e, i) && (o[i] = e[i]);
    }
    return o;
  }, Li.apply(null, arguments);
}
function Jl(o, t) {
  o.prototype = Object.create(t.prototype), o.prototype.constructor = o, Oo(o, t);
}
function Oo(o, t) {
  return Oo = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, i) {
    return e.__proto__ = i, e;
  }, Oo(o, t);
}
function Ec(o, t) {
  if (typeof o != "object" || !o) return o;
  var e = o[Symbol.toPrimitive];
  if (e !== void 0) {
    var i = e.call(o, t);
    if (typeof i != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(o);
}
function Ac(o) {
  var t = Ec(o, "string");
  return typeof t == "symbol" ? t : t + "";
}
function Tc(o, t) {
  if (o) {
    if (typeof o == "string") return xa(o, t);
    var e = {}.toString.call(o).slice(8, -1);
    return e === "Object" && o.constructor && (e = o.constructor.name), e === "Map" || e === "Set" ? Array.from(o) : e === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e) ? xa(o, t) : void 0;
  }
}
var he = /* @__PURE__ */ Symbol("mobx-stored-annotations");
function ui(o) {
  function t(e, i) {
    if (jn(i))
      return o.decorate_20223_(e, i);
    zn(e, i, o);
  }
  return Object.assign(t, o);
}
function zn(o, t, e) {
  if (De(o, he) || Ur(o, he, Li({}, o[he])), Sr(e) && !De(o[he], t)) {
    var i = o.constructor.name + ".prototype." + t.toString();
    R("'" + i + "' is decorated with 'override', but no such decorated member was found on prototype.");
  }
  Oc(o, e, t), Sr(e) || (o[he][t] = e);
}
function Oc(o, t, e) {
  if (!Sr(t) && De(o[he], e)) {
    var i = o.constructor.name + ".prototype." + e.toString(), s = o[he][e].annotationType_, n = t.annotationType_;
    R("Cannot apply '@" + n + "' to '" + i + "':" + (`
The field is already decorated with '@` + s + "'.") + `
Re-decorating fields is not allowed.
Use '@override' decorator for methods overridden by subclass.`);
  }
}
function xc(o) {
  return De(o, he) || Ur(o, he, Li({}, o[he])), o[he];
}
function jn(o) {
  return typeof o == "object" && typeof o.kind == "string";
}
function Qr(o, t) {
  t.includes(o.kind) || R("The decorator applied to '" + String(o.name) + "' cannot be used on a " + o.kind + " element");
}
var k = /* @__PURE__ */ Symbol("mobx administration"), $i = /* @__PURE__ */ (function() {
  function o(e) {
    e === void 0 && (e = "Atom@" + si()), this.name_ = void 0, this.flags_ = 0, this.observers_ = /* @__PURE__ */ new Set(), this.lastAccessedBy_ = 0, this.lowestObserverState_ = J.NOT_TRACKING_, this.onBOL = void 0, this.onBUOL = void 0, this.name_ = e;
  }
  var t = o.prototype;
  return t.onBO = function() {
    this.onBOL && this.onBOL.forEach(function(i) {
      return i();
    });
  }, t.onBUO = function() {
    this.onBUOL && this.onBUOL.forEach(function(i) {
      return i();
    });
  }, t.reportObserved = function() {
    return uh(this);
  }, t.reportChanged = function() {
    Ge(), dh(this), Fe();
  }, t.toString = function() {
    return this.name_;
  }, Zs(o, [{
    key: "isBeingObserved",
    get: function() {
      return ve(this.flags_, o.isBeingObservedMask_);
    },
    set: function(i) {
      this.flags_ = Ce(this.flags_, o.isBeingObservedMask_, i);
    }
  }, {
    key: "isPendingUnobservation",
    get: function() {
      return ve(this.flags_, o.isPendingUnobservationMask_);
    },
    set: function(i) {
      this.flags_ = Ce(this.flags_, o.isPendingUnobservationMask_, i);
    }
  }, {
    key: "diffValue",
    get: function() {
      return ve(this.flags_, o.diffValueMask_) ? 1 : 0;
    },
    set: function(i) {
      this.flags_ = Ce(this.flags_, o.diffValueMask_, i === 1);
    }
  }]);
})();
$i.isBeingObservedMask_ = 1;
$i.isPendingUnobservationMask_ = 2;
$i.diffValueMask_ = 4;
var Jo = /* @__PURE__ */ Is("Atom", $i);
function Kl(o, t, e) {
  t === void 0 && (t = Os), e === void 0 && (e = Os);
  var i = new $i(o);
  return t !== Os && _u(i, t), e !== Os && Sh(i, e), i;
}
function Lc(o, t) {
  return Lh(o, t);
}
function Rc(o, t) {
  return Object.is ? Object.is(o, t) : o === t ? o !== 0 || 1 / o === 1 / t : o !== o && t !== t;
}
var Pr = {
  structural: Lc,
  default: Rc
};
function Ps(o, t, e) {
  return xn(o) ? o : Array.isArray(o) ? It.array(o, {
    name: e
  }) : gi(o) ? It.object(o, void 0, {
    name: e
  }) : Ks(o) ? It.map(o, {
    name: e
  }) : wi(o) ? It.set(o, {
    name: e
  }) : typeof o == "function" && !bs(o) && !On(o) ? Ul(o) ? _s(o) : Tn(e, o) : o;
}
function Nc(o, t, e) {
  if (o == null || Qn(o) || Zr(o) || ts(o) || ai(o))
    return o;
  if (Array.isArray(o))
    return It.array(o, {
      name: e,
      deep: !1
    });
  if (gi(o))
    return It.object(o, void 0, {
      name: e,
      deep: !1
    });
  if (Ks(o))
    return It.map(o, {
      name: e,
      deep: !1
    });
  if (wi(o))
    return It.set(o, {
      name: e,
      deep: !1
    });
  R("The shallow modifier / decorator can only used in combination with arrays, objects, maps and sets");
}
function Yr(o) {
  return o;
}
function Bc(o, t) {
  return xn(o) && R("observable.struct should not be used with observable values"), Lh(o, t) ? t : o;
}
var Mc = "override";
function Sr(o) {
  return o.annotationType_ === Mc;
}
function qn(o, t) {
  return {
    annotationType_: o,
    options_: t,
    make_: Gc,
    extend_: Fc,
    decorate_20223_: Vc
  };
}
function Gc(o, t, e, i) {
  var s;
  if ((s = this.options_) != null && s.bound)
    return this.extend_(o, t, e, !1) === null ? 0 : 1;
  if (i === o.target_)
    return this.extend_(o, t, e, !1) === null ? 0 : 2;
  if (bs(e.value))
    return 1;
  var n = Zl(o, this, t, e, !1);
  return ci(i, t, n), 2;
}
function Fc(o, t, e, i) {
  var s = Zl(o, this, t, e);
  return o.defineProperty_(t, s, i);
}
function Vc(o, t) {
  Qr(t, ["method", "field"]);
  var e = t.kind, i = t.name, s = t.addInitializer, n = this, r = function(h) {
    var c, d, f, p;
    return Ss((c = (d = n.options_) == null ? void 0 : d.name) != null ? c : i.toString(), h, (f = (p = n.options_) == null ? void 0 : p.autoAction) != null ? f : !1);
  };
  if (e == "field")
    return function(l) {
      var h, c = l;
      return bs(c) || (c = r(c)), (h = n.options_) != null && h.bound && (c = c.bind(this), c.isMobxAction = !0), c;
    };
  if (e == "method") {
    var a;
    return bs(o) || (o = r(o)), (a = this.options_) != null && a.bound && s(function() {
      var l = this, h = l[i].bind(l);
      h.isMobxAction = !0, l[i] = h;
    }), o;
  }
  R("Cannot apply '" + n.annotationType_ + "' to '" + String(i) + "' (kind: " + e + "):" + (`
'` + n.annotationType_ + "' can only be used on properties with a function value."));
}
function Dc(o, t, e, i) {
  var s = t.annotationType_, n = i.value;
  Lt(n) || R("Cannot apply '" + s + "' to '" + o.name_ + "." + e.toString() + "':" + (`
'` + s + "' can only be used on properties with a function value."));
}
function Zl(o, t, e, i, s) {
  var n, r, a, l, h, c, d;
  s === void 0 && (s = A.safeDescriptors), Dc(o, t, e, i);
  var f = i.value;
  if ((n = t.options_) != null && n.bound) {
    var p;
    f = f.bind((p = o.proxy_) != null ? p : o.target_);
  }
  return {
    value: Ss(
      (r = (a = t.options_) == null ? void 0 : a.name) != null ? r : e.toString(),
      f,
      (l = (h = t.options_) == null ? void 0 : h.autoAction) != null ? l : !1,
      // https://github.com/mobxjs/mobx/discussions/3140
      (c = t.options_) != null && c.bound ? (d = o.proxy_) != null ? d : o.target_ : void 0
    ),
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: s ? o.isPlainObject_ : !0,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: !1,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: !s
  };
}
function $l(o, t) {
  return {
    annotationType_: o,
    options_: t,
    make_: kc,
    extend_: _c,
    decorate_20223_: Wc
  };
}
function kc(o, t, e, i) {
  var s;
  if (i === o.target_)
    return this.extend_(o, t, e, !1) === null ? 0 : 2;
  if ((s = this.options_) != null && s.bound && (!De(o.target_, t) || !On(o.target_[t])) && this.extend_(o, t, e, !1) === null)
    return 0;
  if (On(e.value))
    return 1;
  var n = th(o, this, t, e, !1, !1);
  return ci(i, t, n), 2;
}
function _c(o, t, e, i) {
  var s, n = th(o, this, t, e, (s = this.options_) == null ? void 0 : s.bound);
  return o.defineProperty_(t, n, i);
}
function Wc(o, t) {
  var e;
  Qr(t, ["method"]);
  var i = t.name, s = t.addInitializer;
  return On(o) || (o = _s(o)), (e = this.options_) != null && e.bound && s(function() {
    var n = this, r = n[i].bind(n);
    r.isMobXFlow = !0, n[i] = r;
  }), o;
}
function Hc(o, t, e, i) {
  var s = t.annotationType_, n = i.value;
  Lt(n) || R("Cannot apply '" + s + "' to '" + o.name_ + "." + e.toString() + "':" + (`
'` + s + "' can only be used on properties with a generator function value."));
}
function th(o, t, e, i, s, n) {
  n === void 0 && (n = A.safeDescriptors), Hc(o, t, e, i);
  var r = i.value;
  if (On(r) || (r = _s(r)), s) {
    var a;
    r = r.bind((a = o.proxy_) != null ? a : o.target_), r.isMobXFlow = !0;
  }
  return {
    value: r,
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: n ? o.isPlainObject_ : !0,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: !1,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: !n
  };
}
function Ko(o, t) {
  return {
    annotationType_: o,
    options_: t,
    make_: zc,
    extend_: jc,
    decorate_20223_: qc
  };
}
function zc(o, t, e) {
  return this.extend_(o, t, e, !1) === null ? 0 : 1;
}
function jc(o, t, e, i) {
  return Uc(o, this, t, e), o.defineComputedProperty_(t, Li({}, this.options_, {
    get: e.get,
    set: e.set
  }), i);
}
function qc(o, t) {
  Qr(t, ["getter"]);
  var e = this, i = t.name, s = t.addInitializer;
  return s(function() {
    var n = $s(this)[k], r = Li({}, e.options_, {
      get: o,
      context: this
    });
    r.name || (r.name = n.name_ + "." + i.toString()), n.values_.set(i, new He(r));
  }), function() {
    return this[k].getObservablePropValue_(i);
  };
}
function Uc(o, t, e, i) {
  var s = t.annotationType_, n = i.get;
  n || R("Cannot apply '" + s + "' to '" + o.name_ + "." + e.toString() + "':" + (`
'` + s + "' can only be used on getter(+setter) properties."));
}
function Jr(o, t) {
  return {
    annotationType_: o,
    options_: t,
    make_: Xc,
    extend_: Qc,
    decorate_20223_: Yc
  };
}
function Xc(o, t, e) {
  return this.extend_(o, t, e, !1) === null ? 0 : 1;
}
function Qc(o, t, e, i) {
  var s, n;
  return Jc(o, this, t, e), o.defineObservableProperty_(t, e.value, (s = (n = this.options_) == null ? void 0 : n.enhancer) != null ? s : Ps, i);
}
function Yc(o, t) {
  {
    if (t.kind === "field")
      throw R("Please use `@observable accessor " + String(t.name) + "` instead of `@observable " + String(t.name) + "`");
    Qr(t, ["accessor"]);
  }
  var e = this, i = t.kind, s = t.name, n = /* @__PURE__ */ new WeakSet();
  function r(a, l) {
    var h, c, d = $s(a)[k], f = new us(l, (h = (c = e.options_) == null ? void 0 : c.enhancer) != null ? h : Ps, d.name_ + "." + s.toString(), !1);
    d.values_.set(s, f), n.add(a);
  }
  if (i == "accessor")
    return {
      get: function() {
        return n.has(this) || r(this, o.get.call(this)), this[k].getObservablePropValue_(s);
      },
      set: function(l) {
        return n.has(this) || r(this, l), this[k].setObservablePropValue_(s, l);
      },
      init: function(l) {
        return n.has(this) || r(this, l), l;
      }
    };
}
function Jc(o, t, e, i) {
  var s = t.annotationType_;
  "value" in i || R("Cannot apply '" + s + "' to '" + o.name_ + "." + e.toString() + "':" + (`
'` + s + "' cannot be used on getter/setter properties"));
}
var Kc = "true", Zc = /* @__PURE__ */ eh();
function eh(o) {
  return {
    annotationType_: Kc,
    options_: o,
    make_: $c,
    extend_: tu,
    decorate_20223_: eu
  };
}
function $c(o, t, e, i) {
  var s, n;
  if (e.get)
    return li.make_(o, t, e, i);
  if (e.set) {
    var r = bs(e.set) ? e.set : Ss(t.toString(), e.set);
    return i === o.target_ ? o.defineProperty_(t, {
      configurable: A.safeDescriptors ? o.isPlainObject_ : !0,
      set: r
    }) === null ? 0 : 2 : (ci(i, t, {
      configurable: !0,
      set: r
    }), 2);
  }
  if (i !== o.target_ && typeof e.value == "function") {
    var a;
    if (Ul(e.value)) {
      var l, h = (l = this.options_) != null && l.autoBind ? _s.bound : _s;
      return h.make_(o, t, e, i);
    }
    var c = (a = this.options_) != null && a.autoBind ? Tn.bound : Tn;
    return c.make_(o, t, e, i);
  }
  var d = ((s = this.options_) == null ? void 0 : s.deep) === !1 ? It.ref : It;
  if (typeof e.value == "function" && (n = this.options_) != null && n.autoBind) {
    var f;
    e.value = e.value.bind((f = o.proxy_) != null ? f : o.target_);
  }
  return d.make_(o, t, e, i);
}
function tu(o, t, e, i) {
  var s, n;
  if (e.get)
    return li.extend_(o, t, e, i);
  if (e.set)
    return o.defineProperty_(t, {
      configurable: A.safeDescriptors ? o.isPlainObject_ : !0,
      set: Ss(t.toString(), e.set)
    }, i);
  if (typeof e.value == "function" && (s = this.options_) != null && s.autoBind) {
    var r;
    e.value = e.value.bind((r = o.proxy_) != null ? r : o.target_);
  }
  var a = ((n = this.options_) == null ? void 0 : n.deep) === !1 ? It.ref : It;
  return a.extend_(o, t, e, i);
}
function eu(o, t) {
  R("'" + this.annotationType_ + "' cannot be used as a decorator");
}
var iu = "observable", su = "observable.ref", nu = "observable.shallow", ru = "observable.struct", ih = {
  deep: !0,
  name: void 0,
  defaultDecorator: void 0,
  proxy: !0
};
Object.freeze(ih);
function Zn(o) {
  return o || ih;
}
var xo = /* @__PURE__ */ Jr(iu), ou = /* @__PURE__ */ Jr(su, {
  enhancer: Yr
}), au = /* @__PURE__ */ Jr(nu, {
  enhancer: Nc
}), lu = /* @__PURE__ */ Jr(ru, {
  enhancer: Bc
}), sh = /* @__PURE__ */ ui(xo);
function $n(o) {
  return o.deep === !0 ? Ps : o.deep === !1 ? Yr : cu(o.defaultDecorator);
}
function hu(o) {
  var t;
  return o ? (t = o.defaultDecorator) != null ? t : eh(o) : void 0;
}
function cu(o) {
  var t, e;
  return o && (t = (e = o.options_) == null ? void 0 : e.enhancer) != null ? t : Ps;
}
function nh(o, t, e) {
  if (jn(t))
    return xo.decorate_20223_(o, t);
  if (ms(t)) {
    zn(o, t, xo);
    return;
  }
  return xn(o) ? o : gi(o) ? It.object(o, t, e) : Array.isArray(o) ? It.array(o, t) : Ks(o) ? It.map(o, t) : wi(o) ? It.set(o, t) : typeof o == "object" && o !== null ? o : It.box(o, t);
}
zl(nh, sh);
var uu = {
  box: function(t, e) {
    var i = Zn(e);
    return new us(t, $n(i), i.name, !0, i.equals);
  },
  array: function(t, e) {
    var i = Zn(e);
    return (A.useProxies === !1 || i.proxy === !1 ? hd : $u)(t, $n(i), i.name);
  },
  map: function(t, e) {
    var i = Zn(e);
    return new wh(t, $n(i), i.name);
  },
  set: function(t, e) {
    var i = Zn(e);
    return new Eh(t, $n(i), i.name);
  },
  object: function(t, e, i) {
    return Es(function() {
      return Wu(A.useProxies === !1 || i?.proxy === !1 ? $s({}, i) : Ju({}, i), t, e);
    });
  },
  ref: /* @__PURE__ */ ui(ou),
  shallow: /* @__PURE__ */ ui(au),
  deep: sh,
  struct: /* @__PURE__ */ ui(lu)
}, It = /* @__PURE__ */ zl(nh, uu), rh = "computed", du = "computed.struct", Lo = /* @__PURE__ */ Ko(rh), fu = /* @__PURE__ */ Ko(du, {
  equals: Pr.structural
}), li = function(t, e) {
  if (jn(e))
    return Lo.decorate_20223_(t, e);
  if (ms(e))
    return zn(t, e, Lo);
  if (gi(t))
    return ui(Ko(rh, t));
  Lt(t) || R("First argument to `computed` should be an expression."), Lt(e) && R("A setter as second argument is no longer supported, use `{ set: fn }` option instead");
  var i = gi(e) ? e : {};
  return i.get = t, i.name || (i.name = t.name || ""), new He(i);
};
Object.assign(li, Lo);
li.struct = /* @__PURE__ */ ui(fu);
var La, Ra, yr = 0, gu = 1, pu = (La = (Ra = /* @__PURE__ */ pr(function() {
}, "name")) == null ? void 0 : Ra.configurable) != null ? La : !1, Na = {
  value: "action",
  configurable: !0,
  writable: !1,
  enumerable: !1
};
function Ss(o, t, e, i) {
  e === void 0 && (e = !1), Lt(t) || R("`action` can only be invoked on functions"), (typeof o != "string" || !o) && R("actions should have valid names, got: '" + o + "'");
  function s() {
    return mu(o, e, t, i || this, arguments);
  }
  return s.isMobxAction = !0, s.toString = function() {
    return t.toString();
  }, pu && (Na.value = o, ci(s, "name", Na)), s;
}
function mu(o, t, e, i, s) {
  var n = Pu(o, t, i, s);
  try {
    return e.apply(i, s);
  } catch (r) {
    throw n.error_ = r, r;
  } finally {
    Su(n);
  }
}
function Pu(o, t, e, i) {
  var s = Ht() && !!o, n = 0;
  if (s) {
    n = Date.now();
    var r = i ? Array.from(i) : mr;
    Ie({
      type: ea,
      name: o,
      object: e,
      arguments: r
    });
  }
  var a = A.trackingDerivation, l = !t || !a;
  Ge();
  var h = A.allowStateChanges;
  l && (ws(), h = Zo(!0));
  var c = ta(!0), d = {
    runAsAction_: l,
    prevDerivation_: a,
    prevAllowStateChanges_: h,
    prevAllowStateReads_: c,
    notifySpy_: s,
    startTime_: n,
    actionId_: gu++,
    parentActionId_: yr
  };
  return yr = d.actionId_, d;
}
function Su(o) {
  yr !== o.actionId_ && R(30), yr = o.parentActionId_, o.error_ !== void 0 && (A.suppressReactionErrors = !0), $o(o.prevAllowStateChanges_), mn(o.prevAllowStateReads_), Fe(), o.runAsAction_ && xi(o.prevDerivation_), o.notifySpy_ && we({
    time: Date.now() - o.startTime_
  }), A.suppressReactionErrors = !1;
}
function Zo(o) {
  var t = A.allowStateChanges;
  return A.allowStateChanges = o, t;
}
function $o(o) {
  A.allowStateChanges = o;
}
var yu = "create", us = /* @__PURE__ */ (function(o) {
  function t(i, s, n, r, a) {
    var l;
    if (n === void 0 && (n = "ObservableValue@" + si()), r === void 0 && (r = !0), a === void 0 && (a = Pr.default), l = o.call(this, n) || this, l.enhancer = void 0, l.name_ = void 0, l.equals = void 0, l.hasUnreportedChange_ = !1, l.interceptors_ = void 0, l.changeListeners_ = void 0, l.value_ = void 0, l.dehancer = void 0, l.enhancer = s, l.name_ = n, l.equals = a, l.value_ = s(i, void 0, n), r && Ht()) {
      var h;
      ys({
        type: yu,
        object: l,
        observableKind: "value",
        debugObjectName: l.name_,
        newValue: "" + ((h = l.value_) == null ? void 0 : h.toString())
      });
    }
    return l;
  }
  Jl(t, o);
  var e = t.prototype;
  return e.dehanceValue = function(s) {
    return this.dehancer !== void 0 ? this.dehancer(s) : s;
  }, e.set = function(s) {
    var n = this.value_;
    if (s = this.prepareNewValue_(s), s !== A.UNCHANGED) {
      var r = Ht();
      r && Ie({
        type: Je,
        object: this,
        observableKind: "value",
        debugObjectName: this.name_,
        newValue: s,
        oldValue: n
      }), this.setNewValue_(s), r && we();
    }
  }, e.prepareNewValue_ = function(s) {
    if (hi(this), Be(this)) {
      var n = Me(this, {
        object: this,
        type: Je,
        newValue: s
      });
      if (!n)
        return A.UNCHANGED;
      s = n.newValue;
    }
    return s = this.enhancer(s, this.value_, this.name_), this.equals(this.value_, s) ? A.UNCHANGED : s;
  }, e.setNewValue_ = function(s) {
    var n = this.value_;
    this.value_ = s, this.reportChanged(), Ze(this) && $e(this, {
      type: Je,
      object: this,
      newValue: s,
      oldValue: n
    });
  }, e.get = function() {
    return this.reportObserved(), this.dehanceValue(this.value_);
  }, e.intercept_ = function(s) {
    return Un(this, s);
  }, e.observe_ = function(s, n) {
    return n && s({
      observableKind: "value",
      debugObjectName: this.name_,
      object: this,
      type: Je,
      newValue: this.value_,
      oldValue: void 0
    }), Xn(this, s);
  }, e.raw = function() {
    return this.value_;
  }, e.toJSON = function() {
    return this.get();
  }, e.toString = function() {
    return this.name_ + "[" + this.value_ + "]";
  }, e.valueOf = function() {
    return Yl(this.get());
  }, e[Symbol.toPrimitive] = function() {
    return this.valueOf();
  }, t;
})($i), He = /* @__PURE__ */ (function() {
  function o(e) {
    this.dependenciesState_ = J.NOT_TRACKING_, this.observing_ = [], this.newObserving_ = null, this.observers_ = /* @__PURE__ */ new Set(), this.runId_ = 0, this.lastAccessedBy_ = 0, this.lowestObserverState_ = J.UP_TO_DATE_, this.unboundDepsCount_ = 0, this.value_ = new br(null), this.name_ = void 0, this.triggeredBy_ = void 0, this.flags_ = 0, this.derivation = void 0, this.setter_ = void 0, this.isTracing_ = ke.NONE, this.scope_ = void 0, this.equals_ = void 0, this.requiresReaction_ = void 0, this.keepAlive_ = void 0, this.onBOL = void 0, this.onBUOL = void 0, e.get || R(31), this.derivation = e.get, this.name_ = e.name || "ComputedValue@" + si(), e.set && (this.setter_ = Ss(this.name_ + "-setter", e.set)), this.equals_ = e.equals || (e.compareStructural || e.struct ? Pr.structural : Pr.default), this.scope_ = e.context, this.requiresReaction_ = e.requiresReaction, this.keepAlive_ = !!e.keepAlive;
  }
  var t = o.prototype;
  return t.onBecomeStale_ = function() {
    Eu(this);
  }, t.onBO = function() {
    this.onBOL && this.onBOL.forEach(function(i) {
      return i();
    });
  }, t.onBUO = function() {
    this.onBUOL && this.onBUOL.forEach(function(i) {
      return i();
    });
  }, t.get = function() {
    if (this.isComputing && R(32, this.name_, this.derivation), A.inBatch === 0 && // !globalState.trackingDerivatpion &&
    this.observers_.size === 0 && !this.keepAlive_)
      Ro(this) && (this.warnAboutUntrackedRead_(), Ge(), this.value_ = this.computeValue_(!1), Fe());
    else if (uh(this), Ro(this)) {
      var i = A.trackingContext;
      this.keepAlive_ && !i && (A.trackingContext = this), this.trackAndCompute() && wu(this), A.trackingContext = i;
    }
    var s = this.value_;
    if (lr(s))
      throw s.cause;
    return s;
  }, t.set = function(i) {
    if (this.setter_) {
      this.isRunningSetter && R(33, this.name_), this.isRunningSetter = !0;
      try {
        this.setter_.call(this.scope_, i);
      } finally {
        this.isRunningSetter = !1;
      }
    } else
      R(34, this.name_);
  }, t.trackAndCompute = function() {
    var i = this.value_, s = (
      /* see #1208 */
      this.dependenciesState_ === J.NOT_TRACKING_
    ), n = this.computeValue_(!0), r = s || lr(i) || lr(n) || !this.equals_(i, n);
    return r && (this.value_ = n, Ht() && ys({
      observableKind: "computed",
      debugObjectName: this.name_,
      object: this.scope_,
      type: "update",
      oldValue: i,
      newValue: n
    })), r;
  }, t.computeValue_ = function(i) {
    this.isComputing = !0;
    var s = Zo(!1), n;
    if (i)
      n = oh(this, this.derivation, this.scope_);
    else if (A.disableErrorBoundaries === !0)
      n = this.derivation.call(this.scope_);
    else
      try {
        n = this.derivation.call(this.scope_);
      } catch (r) {
        n = new br(r);
      }
    return $o(s), this.isComputing = !1, n;
  }, t.suspend_ = function() {
    this.keepAlive_ || (No(this), this.value_ = void 0, this.isTracing_ !== ke.NONE && console.log("[mobx.trace] Computed value '" + this.name_ + "' was suspended and it will recompute on the next access."));
  }, t.observe_ = function(i, s) {
    var n = this, r = !0, a = void 0;
    return Gu(function() {
      var l = n.get();
      if (!r || s) {
        var h = ws();
        i({
          observableKind: "computed",
          debugObjectName: n.name_,
          type: Je,
          object: n,
          newValue: l,
          oldValue: a
        }), xi(h);
      }
      r = !1, a = l;
    });
  }, t.warnAboutUntrackedRead_ = function() {
    this.isTracing_ !== ke.NONE && console.log("[mobx.trace] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute."), (typeof this.requiresReaction_ == "boolean" ? this.requiresReaction_ : A.computedRequiresReaction) && console.warn("[mobx] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute.");
  }, t.toString = function() {
    return this.name_ + "[" + this.derivation.toString() + "]";
  }, t.valueOf = function() {
    return Yl(this.get());
  }, t[Symbol.toPrimitive] = function() {
    return this.valueOf();
  }, Zs(o, [{
    key: "isComputing",
    get: function() {
      return ve(this.flags_, o.isComputingMask_);
    },
    set: function(i) {
      this.flags_ = Ce(this.flags_, o.isComputingMask_, i);
    }
  }, {
    key: "isRunningSetter",
    get: function() {
      return ve(this.flags_, o.isRunningSetterMask_);
    },
    set: function(i) {
      this.flags_ = Ce(this.flags_, o.isRunningSetterMask_, i);
    }
  }, {
    key: "isBeingObserved",
    get: function() {
      return ve(this.flags_, o.isBeingObservedMask_);
    },
    set: function(i) {
      this.flags_ = Ce(this.flags_, o.isBeingObservedMask_, i);
    }
  }, {
    key: "isPendingUnobservation",
    get: function() {
      return ve(this.flags_, o.isPendingUnobservationMask_);
    },
    set: function(i) {
      this.flags_ = Ce(this.flags_, o.isPendingUnobservationMask_, i);
    }
  }, {
    key: "diffValue",
    get: function() {
      return ve(this.flags_, o.diffValueMask_) ? 1 : 0;
    },
    set: function(i) {
      this.flags_ = Ce(this.flags_, o.diffValueMask_, i === 1);
    }
  }]);
})();
He.isComputingMask_ = 1;
He.isRunningSetterMask_ = 2;
He.isBeingObservedMask_ = 4;
He.isPendingUnobservationMask_ = 8;
He.diffValueMask_ = 16;
var Kr = /* @__PURE__ */ Is("ComputedValue", He), J;
(function(o) {
  o[o.NOT_TRACKING_ = -1] = "NOT_TRACKING_", o[o.UP_TO_DATE_ = 0] = "UP_TO_DATE_", o[o.POSSIBLY_STALE_ = 1] = "POSSIBLY_STALE_", o[o.STALE_ = 2] = "STALE_";
})(J || (J = {}));
var ke;
(function(o) {
  o[o.NONE = 0] = "NONE", o[o.LOG = 1] = "LOG", o[o.BREAK = 2] = "BREAK";
})(ke || (ke = {}));
var br = function(t) {
  this.cause = void 0, this.cause = t;
};
function lr(o) {
  return o instanceof br;
}
function Ro(o) {
  switch (o.dependenciesState_) {
    case J.UP_TO_DATE_:
      return !1;
    case J.NOT_TRACKING_:
    case J.STALE_:
      return !0;
    case J.POSSIBLY_STALE_: {
      for (var t = ta(!0), e = ws(), i = o.observing_, s = i.length, n = 0; n < s; n++) {
        var r = i[n];
        if (Kr(r)) {
          if (A.disableErrorBoundaries)
            r.get();
          else
            try {
              r.get();
            } catch {
              return xi(e), mn(t), !0;
            }
          if (o.dependenciesState_ === J.STALE_)
            return xi(e), mn(t), !0;
        }
      }
      return lh(o), xi(e), mn(t), !1;
    }
  }
}
function hi(o) {
  var t = o.observers_.size > 0;
  !A.allowStateChanges && (t || A.enforceActions === "always") && console.warn("[MobX] " + (A.enforceActions ? "Since strict-mode is enabled, changing (observed) observable values without using an action is not allowed. Tried to modify: " : "Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, a computed value or the render function of a React component? You can wrap side effects in 'runInAction' (or decorate functions with 'action') if needed. Tried to modify: ") + o.name_);
}
function bu(o) {
  !A.allowStateReads && A.observableRequiresReaction && console.warn("[mobx] Observable '" + o.name_ + "' being read outside a reactive context.");
}
function oh(o, t, e) {
  var i = ta(!0);
  lh(o), o.newObserving_ = new Array(
    // Reserve constant space for initial dependencies, dynamic space otherwise.
    // See https://github.com/mobxjs/mobx/pull/3833
    o.runId_ === 0 ? 100 : o.observing_.length
  ), o.unboundDepsCount_ = 0, o.runId_ = ++A.runId;
  var s = A.trackingDerivation;
  A.trackingDerivation = o, A.inBatch++;
  var n;
  if (A.disableErrorBoundaries === !0)
    n = t.call(e);
  else
    try {
      n = t.call(e);
    } catch (r) {
      n = new br(r);
    }
  return A.inBatch--, A.trackingDerivation = s, Cu(o), vu(o), mn(i), n;
}
function vu(o) {
  o.observing_.length === 0 && (typeof o.requiresObservable_ == "boolean" ? o.requiresObservable_ : A.reactionRequiresObservable) && console.warn("[mobx] Derivation '" + o.name_ + "' is created/updated without reading any observable value.");
}
function Cu(o) {
  for (var t = o.observing_, e = o.observing_ = o.newObserving_, i = J.UP_TO_DATE_, s = 0, n = o.unboundDepsCount_, r = 0; r < n; r++) {
    var a = e[r];
    a.diffValue === 0 && (a.diffValue = 1, s !== r && (e[s] = a), s++), a.dependenciesState_ > i && (i = a.dependenciesState_);
  }
  for (e.length = s, o.newObserving_ = null, n = t.length; n--; ) {
    var l = t[n];
    l.diffValue === 0 && hh(l, o), l.diffValue = 0;
  }
  for (; s--; ) {
    var h = e[s];
    h.diffValue === 1 && (h.diffValue = 0, Iu(h, o));
  }
  i !== J.UP_TO_DATE_ && (o.dependenciesState_ = i, o.onBecomeStale_());
}
function No(o) {
  var t = o.observing_;
  o.observing_ = [];
  for (var e = t.length; e--; )
    hh(t[e], o);
  o.dependenciesState_ = J.NOT_TRACKING_;
}
function ah(o) {
  var t = ws();
  try {
    return o();
  } finally {
    xi(t);
  }
}
function ws() {
  var o = A.trackingDerivation;
  return A.trackingDerivation = null, o;
}
function xi(o) {
  A.trackingDerivation = o;
}
function ta(o) {
  var t = A.allowStateReads;
  return A.allowStateReads = o, t;
}
function mn(o) {
  A.allowStateReads = o;
}
function lh(o) {
  if (o.dependenciesState_ !== J.UP_TO_DATE_) {
    o.dependenciesState_ = J.UP_TO_DATE_;
    for (var t = o.observing_, e = t.length; e--; )
      t[e].lowestObserverState_ = J.UP_TO_DATE_;
  }
}
var lo = function() {
  this.version = 6, this.UNCHANGED = {}, this.trackingDerivation = null, this.trackingContext = null, this.runId = 0, this.mobxGuid = 0, this.inBatch = 0, this.pendingUnobservations = [], this.pendingReactions = [], this.isRunningReactions = !1, this.allowStateChanges = !1, this.allowStateReads = !0, this.enforceActions = !0, this.spyListeners = [], this.globalReactionErrorHandlers = [], this.computedRequiresReaction = !1, this.reactionRequiresObservable = !1, this.observableRequiresReaction = !1, this.disableErrorBoundaries = !1, this.suppressReactionErrors = !1, this.useProxies = !0, this.verifyProxies = !1, this.safeDescriptors = !0;
}, ho = !0, A = /* @__PURE__ */ (function() {
  var o = /* @__PURE__ */ Qo();
  return o.__mobxInstanceCount > 0 && !o.__mobxGlobals && (ho = !1), o.__mobxGlobals && o.__mobxGlobals.version !== new lo().version && (ho = !1), ho ? o.__mobxGlobals ? (o.__mobxInstanceCount += 1, o.__mobxGlobals.UNCHANGED || (o.__mobxGlobals.UNCHANGED = {}), o.__mobxGlobals) : (o.__mobxInstanceCount = 1, o.__mobxGlobals = /* @__PURE__ */ new lo()) : (setTimeout(function() {
    R(35);
  }, 1), new lo());
})();
function Iu(o, t) {
  o.observers_.add(t), o.lowestObserverState_ > t.dependenciesState_ && (o.lowestObserverState_ = t.dependenciesState_);
}
function hh(o, t) {
  o.observers_.delete(t), o.observers_.size === 0 && ch(o);
}
function ch(o) {
  o.isPendingUnobservation === !1 && (o.isPendingUnobservation = !0, A.pendingUnobservations.push(o));
}
function Ge() {
  A.inBatch++;
}
function Fe() {
  if (--A.inBatch === 0) {
    ph();
    for (var o = A.pendingUnobservations, t = 0; t < o.length; t++) {
      var e = o[t];
      e.isPendingUnobservation = !1, e.observers_.size === 0 && (e.isBeingObserved && (e.isBeingObserved = !1, e.onBUO()), e instanceof He && e.suspend_());
    }
    A.pendingUnobservations = [];
  }
}
function uh(o) {
  bu(o);
  var t = A.trackingDerivation;
  return t !== null ? (t.runId_ !== o.lastAccessedBy_ && (o.lastAccessedBy_ = t.runId_, t.newObserving_[t.unboundDepsCount_++] = o, !o.isBeingObserved && A.trackingContext && (o.isBeingObserved = !0, o.onBO())), o.isBeingObserved) : (o.observers_.size === 0 && A.inBatch > 0 && ch(o), !1);
}
function dh(o) {
  o.lowestObserverState_ !== J.STALE_ && (o.lowestObserverState_ = J.STALE_, o.observers_.forEach(function(t) {
    t.dependenciesState_ === J.UP_TO_DATE_ && (t.isTracing_ !== ke.NONE && fh(t, o), t.onBecomeStale_()), t.dependenciesState_ = J.STALE_;
  }));
}
function wu(o) {
  o.lowestObserverState_ !== J.STALE_ && (o.lowestObserverState_ = J.STALE_, o.observers_.forEach(function(t) {
    t.dependenciesState_ === J.POSSIBLY_STALE_ ? (t.dependenciesState_ = J.STALE_, t.isTracing_ !== ke.NONE && fh(t, o)) : t.dependenciesState_ === J.UP_TO_DATE_ && (o.lowestObserverState_ = J.UP_TO_DATE_);
  }));
}
function Eu(o) {
  o.lowestObserverState_ === J.UP_TO_DATE_ && (o.lowestObserverState_ = J.POSSIBLY_STALE_, o.observers_.forEach(function(t) {
    t.dependenciesState_ === J.UP_TO_DATE_ && (t.dependenciesState_ = J.POSSIBLY_STALE_, t.onBecomeStale_());
  }));
}
function fh(o, t) {
  if (console.log("[mobx.trace] '" + o.name_ + "' is invalidated due to a change in: '" + t.name_ + "'"), o.isTracing_ === ke.BREAK) {
    var e = [];
    gh(Hu(o), e, 1), new Function(`debugger;
/*
Tracing '` + o.name_ + `'

You are entering this break point because derivation '` + o.name_ + "' is being traced and '" + t.name_ + `' is now forcing it to update.
Just follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update
The stackframe you are looking for is at least ~6-8 stack-frames up.

` + (o instanceof He ? o.derivation.toString().replace(/[*]\//g, "/") : "") + `

The dependencies for this derivation are:

` + e.join(`
`) + `
*/
    `)();
  }
}
function gh(o, t, e) {
  if (t.length >= 1e3) {
    t.push("(and many more)");
    return;
  }
  t.push("" + "	".repeat(e - 1) + o.name), o.dependencies && o.dependencies.forEach(function(i) {
    return gh(i, t, e + 1);
  });
}
var Qi = /* @__PURE__ */ (function() {
  function o(e, i, s, n) {
    e === void 0 && (e = "Reaction@" + si()), this.name_ = void 0, this.onInvalidate_ = void 0, this.errorHandler_ = void 0, this.requiresObservable_ = void 0, this.observing_ = [], this.newObserving_ = [], this.dependenciesState_ = J.NOT_TRACKING_, this.runId_ = 0, this.unboundDepsCount_ = 0, this.flags_ = 0, this.isTracing_ = ke.NONE, this.name_ = e, this.onInvalidate_ = i, this.errorHandler_ = s, this.requiresObservable_ = n;
  }
  var t = o.prototype;
  return t.onBecomeStale_ = function() {
    this.schedule_();
  }, t.schedule_ = function() {
    this.isScheduled || (this.isScheduled = !0, A.pendingReactions.push(this), ph());
  }, t.runReaction_ = function() {
    if (!this.isDisposed) {
      Ge(), this.isScheduled = !1;
      var i = A.trackingContext;
      if (A.trackingContext = this, Ro(this)) {
        this.isTrackPending = !0;
        try {
          this.onInvalidate_(), this.isTrackPending && Ht() && ys({
            name: this.name_,
            type: "scheduled-reaction"
          });
        } catch (s) {
          this.reportExceptionInDerivation_(s);
        }
      }
      A.trackingContext = i, Fe();
    }
  }, t.track = function(i) {
    if (!this.isDisposed) {
      Ge();
      var s = Ht(), n;
      s && (n = Date.now(), Ie({
        name: this.name_,
        type: "reaction"
      })), this.isRunning = !0;
      var r = A.trackingContext;
      A.trackingContext = this;
      var a = oh(this, i, void 0);
      A.trackingContext = r, this.isRunning = !1, this.isTrackPending = !1, this.isDisposed && No(this), lr(a) && this.reportExceptionInDerivation_(a.cause), s && we({
        time: Date.now() - n
      }), Fe();
    }
  }, t.reportExceptionInDerivation_ = function(i) {
    var s = this;
    if (this.errorHandler_) {
      this.errorHandler_(i, this);
      return;
    }
    if (A.disableErrorBoundaries)
      throw i;
    var n = "[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '" + this + "'";
    A.suppressReactionErrors ? console.warn("[mobx] (error in reaction '" + this.name_ + "' suppressed, fix error of causing action below)") : console.error(n, i), Ht() && ys({
      type: "error",
      name: this.name_,
      message: n,
      error: "" + i
    }), A.globalReactionErrorHandlers.forEach(function(r) {
      return r(i, s);
    });
  }, t.dispose = function() {
    this.isDisposed || (this.isDisposed = !0, this.isRunning || (Ge(), No(this), Fe()));
  }, t.getDisposer_ = function(i) {
    var s = this, n = function r() {
      s.dispose(), i == null || i.removeEventListener == null || i.removeEventListener("abort", r);
    };
    return i == null || i.addEventListener == null || i.addEventListener("abort", n), n[k] = this, "dispose" in Symbol && typeof Symbol.dispose == "symbol" && (n[Symbol.dispose] = n), n;
  }, t.toString = function() {
    return "Reaction[" + this.name_ + "]";
  }, t.trace = function(i) {
    i === void 0 && (i = !1), Xu(this, i);
  }, Zs(o, [{
    key: "isDisposed",
    get: function() {
      return ve(this.flags_, o.isDisposedMask_);
    },
    set: function(i) {
      this.flags_ = Ce(this.flags_, o.isDisposedMask_, i);
    }
  }, {
    key: "isScheduled",
    get: function() {
      return ve(this.flags_, o.isScheduledMask_);
    },
    set: function(i) {
      this.flags_ = Ce(this.flags_, o.isScheduledMask_, i);
    }
  }, {
    key: "isTrackPending",
    get: function() {
      return ve(this.flags_, o.isTrackPendingMask_);
    },
    set: function(i) {
      this.flags_ = Ce(this.flags_, o.isTrackPendingMask_, i);
    }
  }, {
    key: "isRunning",
    get: function() {
      return ve(this.flags_, o.isRunningMask_);
    },
    set: function(i) {
      this.flags_ = Ce(this.flags_, o.isRunningMask_, i);
    }
  }, {
    key: "diffValue",
    get: function() {
      return ve(this.flags_, o.diffValueMask_) ? 1 : 0;
    },
    set: function(i) {
      this.flags_ = Ce(this.flags_, o.diffValueMask_, i === 1);
    }
  }]);
})();
Qi.isDisposedMask_ = 1;
Qi.isScheduledMask_ = 2;
Qi.isTrackPendingMask_ = 4;
Qi.isRunningMask_ = 8;
Qi.diffValueMask_ = 16;
var Ba = 100, Au = function(t) {
  return t();
};
function ph() {
  A.inBatch > 0 || A.isRunningReactions || Au(Tu);
}
function Tu() {
  A.isRunningReactions = !0;
  for (var o = A.pendingReactions, t = 0; o.length > 0; ) {
    ++t === Ba && (console.error("Reaction doesn't converge to a stable state after " + Ba + " iterations." + (" Probably there is a cycle in the reactive function: " + o[0])), o.splice(0));
    for (var e = o.splice(0), i = 0, s = e.length; i < s; i++)
      e[i].runReaction_();
  }
  A.isRunningReactions = !1;
}
var vr = /* @__PURE__ */ Is("Reaction", Qi);
function Ht() {
  return !!A.spyListeners.length;
}
function ys(o) {
  if (A.spyListeners.length)
    for (var t = A.spyListeners, e = 0, i = t.length; e < i; e++)
      t[e](o);
}
function Ie(o) {
  var t = Li({}, o, {
    spyReportStart: !0
  });
  ys(t);
}
var Ou = {
  type: "report-end",
  spyReportEnd: !0
};
function we(o) {
  ys(o ? Li({}, o, {
    type: "report-end",
    spyReportEnd: !0
  }) : Ou);
}
function xu(o) {
  return A.spyListeners.push(o), Yo(function() {
    A.spyListeners = A.spyListeners.filter(function(t) {
      return t !== o;
    });
  });
}
var ea = "action", Lu = "action.bound", mh = "autoAction", Ru = "autoAction.bound", Nu = "<unnamed action>", Bo = /* @__PURE__ */ qn(ea), Bu = /* @__PURE__ */ qn(Lu, {
  bound: !0
}), Mo = /* @__PURE__ */ qn(mh, {
  autoAction: !0
}), Mu = /* @__PURE__ */ qn(Ru, {
  autoAction: !0,
  bound: !0
});
function Ph(o) {
  var t = function(i, s) {
    if (Lt(i))
      return Ss(i.name || Nu, i, o);
    if (Lt(s))
      return Ss(i, s, o);
    if (jn(s))
      return (o ? Mo : Bo).decorate_20223_(i, s);
    if (ms(s))
      return zn(i, s, o ? Mo : Bo);
    if (ms(i))
      return ui(qn(o ? mh : ea, {
        name: i,
        autoAction: o
      }));
    R("Invalid arguments for `action`");
  };
  return t;
}
var Ne = /* @__PURE__ */ Ph(!1);
Object.assign(Ne, Bo);
var Tn = /* @__PURE__ */ Ph(!0);
Object.assign(Tn, Mo);
Ne.bound = /* @__PURE__ */ ui(Bu);
Tn.bound = /* @__PURE__ */ ui(Mu);
function bs(o) {
  return Lt(o) && o.isMobxAction === !0;
}
function Gu(o, t) {
  var e, i, s, n;
  t === void 0 && (t = jl), Lt(o) || R("Autorun expects a function as first argument"), bs(o) && R("Autorun does not accept actions since actions are untrackable");
  var r = (e = (i = t) == null ? void 0 : i.name) != null ? e : o.name || "Autorun@" + si(), a = !t.scheduler && !t.delay, l;
  if (a)
    l = new Qi(r, function() {
      this.track(d);
    }, t.onError, t.requiresObservable);
  else {
    var h = Vu(t), c = !1;
    l = new Qi(r, function() {
      c || (c = !0, h(function() {
        c = !1, l.isDisposed || l.track(d);
      }));
    }, t.onError, t.requiresObservable);
  }
  function d() {
    o(l);
  }
  return (s = t) != null && (s = s.signal) != null && s.aborted || l.schedule_(), l.getDisposer_((n = t) == null ? void 0 : n.signal);
}
var Fu = function(t) {
  return t();
};
function Vu(o) {
  return o.scheduler ? o.scheduler : o.delay ? function(t) {
    return setTimeout(t, o.delay);
  } : Fu;
}
var Du = "onBO", ku = "onBUO";
function _u(o, t, e) {
  return yh(Du, o, t, e);
}
function Sh(o, t, e) {
  return yh(ku, o, t, e);
}
function yh(o, t, e, i) {
  var s = Ws(t), n = Lt(i) ? i : e, r = o + "L";
  return s[r] ? s[r].add(n) : s[r] = /* @__PURE__ */ new Set([n]), function() {
    var a = s[r];
    a && (a.delete(n), a.size === 0 && delete s[r]);
  };
}
function Wu(o, t, e, i) {
  arguments.length > 4 && R("'extendObservable' expected 2-4 arguments"), typeof o != "object" && R("'extendObservable' expects an object as first argument"), ts(o) && R("'extendObservable' should not be used on maps, use map.merge instead"), gi(t) || R("'extendObservable' only accepts plain objects as second argument"), (xn(t) || xn(e)) && R("Extending an object with another observable (object) is not supported");
  var s = Ic(t);
  return Es(function() {
    var n = $s(o, i)[k];
    Xr(s).forEach(function(r) {
      n.extend_(
        r,
        s[r],
        // must pass "undefined" for { key: undefined }
        e && r in e ? e[r] : !0
      );
    });
  }), o;
}
function Hu(o, t) {
  return bh(Ws(o, t));
}
function bh(o) {
  var t = {
    name: o.name_
  };
  return o.observing_ && o.observing_.length > 0 && (t.dependencies = zu(o.observing_).map(bh)), t;
}
function zu(o) {
  return Array.from(new Set(o));
}
var ju = 0;
function vh() {
  this.message = "FLOW_CANCELLED";
}
vh.prototype = /* @__PURE__ */ Object.create(Error.prototype);
var co = /* @__PURE__ */ $l("flow"), qu = /* @__PURE__ */ $l("flow.bound", {
  bound: !0
}), _s = /* @__PURE__ */ Object.assign(function(t, e) {
  if (jn(e))
    return co.decorate_20223_(t, e);
  if (ms(e))
    return zn(t, e, co);
  arguments.length !== 1 && R("Flow expects single argument with generator function");
  var i = t, s = i.name || "<unnamed flow>", n = function() {
    var a = this, l = arguments, h = ++ju, c = Ne(s + " - runid: " + h + " - init", i).apply(a, l), d, f = void 0, p = new Promise(function(P, y) {
      var C = 0;
      d = y;
      function E(x) {
        f = void 0;
        var V;
        try {
          V = Ne(s + " - runid: " + h + " - yield " + C++, c.next).call(c, x);
        } catch (G) {
          return y(G);
        }
        I(V);
      }
      function N(x) {
        f = void 0;
        var V;
        try {
          V = Ne(s + " - runid: " + h + " - yield " + C++, c.throw).call(c, x);
        } catch (G) {
          return y(G);
        }
        I(V);
      }
      function I(x) {
        if (Lt(x?.then)) {
          x.then(I, y);
          return;
        }
        return x.done ? P(x.value) : (f = Promise.resolve(x.value), f.then(E, N));
      }
      E(void 0);
    });
    return p.cancel = Ne(s + " - runid: " + h + " - cancel", function() {
      try {
        f && Ma(f);
        var P = c.return(void 0), y = Promise.resolve(P.value);
        y.then(Os, Os), Ma(y), d(new vh());
      } catch (C) {
        d(C);
      }
    }), p;
  };
  return n.isMobXFlow = !0, n;
}, co);
_s.bound = /* @__PURE__ */ ui(qu);
function Ma(o) {
  Lt(o.cancel) && o.cancel();
}
function On(o) {
  return o?.isMobXFlow === !0;
}
function Uu(o, t) {
  return o ? Qn(o) || !!o[k] || Jo(o) || vr(o) || Kr(o) : !1;
}
function xn(o) {
  return arguments.length !== 1 && R("isObservable expects only 1 argument. Use isObservableProp to inspect the observability of a property"), Uu(o);
}
function Xu() {
  for (var o = !1, t = arguments.length, e = new Array(t), i = 0; i < t; i++)
    e[i] = arguments[i];
  typeof e[e.length - 1] == "boolean" && (o = e.pop());
  var s = Qu(e);
  if (!s)
    return R("'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly");
  s.isTracing_ === ke.NONE && console.log("[mobx.trace] '" + s.name_ + "' tracing enabled"), s.isTracing_ = o ? ke.BREAK : ke.LOG;
}
function Qu(o) {
  switch (o.length) {
    case 0:
      return A.trackingDerivation;
    case 1:
      return Ws(o[0]);
    case 2:
      return Ws(o[0], o[1]);
  }
}
function Ei(o, t) {
  t === void 0 && (t = void 0), Ge();
  try {
    return o.apply(t);
  } finally {
    Fe();
  }
}
function is(o) {
  return o[k];
}
var Yu = {
  has: function(t, e) {
    return A.trackingDerivation && an("detect new properties using the 'in' operator. Use 'has' from 'mobx' instead."), is(t).has_(e);
  },
  get: function(t, e) {
    return is(t).get_(e);
  },
  set: function(t, e, i) {
    var s;
    return ms(e) ? (is(t).values_.has(e) || an("add a new observable property through direct assignment. Use 'set' from 'mobx' instead."), (s = is(t).set_(e, i, !0)) != null ? s : !0) : !1;
  },
  deleteProperty: function(t, e) {
    var i;
    return an("delete properties from an observable object. Use 'remove' from 'mobx' instead."), ms(e) ? (i = is(t).delete_(e, !0)) != null ? i : !0 : !1;
  },
  defineProperty: function(t, e, i) {
    var s;
    return an("define property on an observable object. Use 'defineProperty' from 'mobx' instead."), (s = is(t).defineProperty_(e, i)) != null ? s : !0;
  },
  ownKeys: function(t) {
    return A.trackingDerivation && an("iterate keys to detect added / removed properties. Use 'keys' from 'mobx' instead."), is(t).ownKeys_();
  },
  preventExtensions: function(t) {
    R(13);
  }
};
function Ju(o, t) {
  var e, i;
  return ql(), o = $s(o, t), (i = (e = o[k]).proxy_) != null ? i : e.proxy_ = new Proxy(o, Yu);
}
function Be(o) {
  return o.interceptors_ !== void 0 && o.interceptors_.length > 0;
}
function Un(o, t) {
  var e = o.interceptors_ || (o.interceptors_ = []);
  return e.push(t), Yo(function() {
    var i = e.indexOf(t);
    i !== -1 && e.splice(i, 1);
  });
}
function Me(o, t) {
  var e = ws();
  try {
    for (var i = [].concat(o.interceptors_ || []), s = 0, n = i.length; s < n && (t = i[s](t), t && !t.type && R(14), !!t); s++)
      ;
    return t;
  } finally {
    xi(e);
  }
}
function Ze(o) {
  return o.changeListeners_ !== void 0 && o.changeListeners_.length > 0;
}
function Xn(o, t) {
  var e = o.changeListeners_ || (o.changeListeners_ = []);
  return e.push(t), Yo(function() {
    var i = e.indexOf(t);
    i !== -1 && e.splice(i, 1);
  });
}
function $e(o, t) {
  var e = ws(), i = o.changeListeners_;
  if (i) {
    i = i.slice();
    for (var s = 0, n = i.length; s < n; s++)
      i[s](t);
    xi(e);
  }
}
function Ch(o, t, e) {
  return Es(function() {
    var i, s = $s(o, e)[k];
    t && o[he] && R("makeObservable second arg must be nullish when using decorators. Mixing @decorator syntax with annotations is not supported."), (i = t) != null || (t = xc(o)), Xr(t).forEach(function(n) {
      return s.make_(n, t[n]);
    });
  }), o;
}
var Ga = "splice", Je = "update", Ku = 1e4, Zu = {
  get: function(t, e) {
    var i = t[k];
    return e === k ? i : e === "length" ? i.getArrayLength_() : typeof e == "string" && !isNaN(e) ? i.get_(parseInt(e)) : De(Cr, e) ? Cr[e] : t[e];
  },
  set: function(t, e, i) {
    var s = t[k];
    return e === "length" && s.setArrayLength_(i), typeof e == "symbol" || isNaN(e) ? t[e] = i : s.set_(parseInt(e), i), !0;
  },
  preventExtensions: function() {
    R(15);
  }
}, ia = /* @__PURE__ */ (function() {
  function o(e, i, s, n) {
    e === void 0 && (e = "ObservableArray@" + si()), this.owned_ = void 0, this.legacyMode_ = void 0, this.atom_ = void 0, this.values_ = [], this.interceptors_ = void 0, this.changeListeners_ = void 0, this.enhancer_ = void 0, this.dehancer = void 0, this.proxy_ = void 0, this.lastKnownLength_ = 0, this.owned_ = s, this.legacyMode_ = n, this.atom_ = new $i(e), this.enhancer_ = function(r, a) {
      return i(r, a, e + "[..]");
    };
  }
  var t = o.prototype;
  return t.dehanceValue_ = function(i) {
    return this.dehancer !== void 0 ? this.dehancer(i) : i;
  }, t.dehanceValues_ = function(i) {
    return this.dehancer !== void 0 && i.length > 0 ? i.map(this.dehancer) : i;
  }, t.intercept_ = function(i) {
    return Un(this, i);
  }, t.observe_ = function(i, s) {
    return s === void 0 && (s = !1), s && i({
      observableKind: "array",
      object: this.proxy_,
      debugObjectName: this.atom_.name_,
      type: "splice",
      index: 0,
      added: this.values_.slice(),
      addedCount: this.values_.length,
      removed: [],
      removedCount: 0
    }), Xn(this, i);
  }, t.getArrayLength_ = function() {
    return this.atom_.reportObserved(), this.values_.length;
  }, t.setArrayLength_ = function(i) {
    (typeof i != "number" || isNaN(i) || i < 0) && R("Out of range: " + i);
    var s = this.values_.length;
    if (i !== s)
      if (i > s) {
        for (var n = new Array(i - s), r = 0; r < i - s; r++)
          n[r] = void 0;
        this.spliceWithArray_(s, 0, n);
      } else
        this.spliceWithArray_(i, s - i);
  }, t.updateArrayLength_ = function(i, s) {
    i !== this.lastKnownLength_ && R(16), this.lastKnownLength_ += s, this.legacyMode_ && s > 0 && Oh(i + s + 1);
  }, t.spliceWithArray_ = function(i, s, n) {
    var r = this;
    hi(this.atom_);
    var a = this.values_.length;
    if (i === void 0 ? i = 0 : i > a ? i = a : i < 0 && (i = Math.max(0, a + i)), arguments.length === 1 ? s = a - i : s == null ? s = 0 : s = Math.max(0, Math.min(s, a - i)), n === void 0 && (n = mr), Be(this)) {
      var l = Me(this, {
        object: this.proxy_,
        type: Ga,
        index: i,
        removedCount: s,
        added: n
      });
      if (!l)
        return mr;
      s = l.removedCount, n = l.added;
    }
    n = n.length === 0 ? n : n.map(function(d) {
      return r.enhancer_(d, void 0);
    }), this.legacyMode_;
    var h = n.length - s;
    this.updateArrayLength_(a, h);
    var c = this.spliceItemsIntoValues_(i, s, n);
    return (s !== 0 || n.length !== 0) && this.notifyArraySplice_(i, n, c), this.dehanceValues_(c);
  }, t.spliceItemsIntoValues_ = function(i, s, n) {
    if (n.length < Ku) {
      var r;
      return (r = this.values_).splice.apply(r, [i, s].concat(n));
    } else {
      var a = this.values_.slice(i, i + s), l = this.values_.slice(i + s);
      this.values_.length += n.length - s;
      for (var h = 0; h < n.length; h++)
        this.values_[i + h] = n[h];
      for (var c = 0; c < l.length; c++)
        this.values_[i + n.length + c] = l[c];
      return a;
    }
  }, t.notifyArrayChildUpdate_ = function(i, s, n) {
    var r = !this.owned_ && Ht(), a = Ze(this), l = a || r ? {
      observableKind: "array",
      object: this.proxy_,
      type: Je,
      debugObjectName: this.atom_.name_,
      index: i,
      newValue: s,
      oldValue: n
    } : null;
    r && Ie(l), this.atom_.reportChanged(), a && $e(this, l), r && we();
  }, t.notifyArraySplice_ = function(i, s, n) {
    var r = !this.owned_ && Ht(), a = Ze(this), l = a || r ? {
      observableKind: "array",
      object: this.proxy_,
      debugObjectName: this.atom_.name_,
      type: Ga,
      index: i,
      removed: n,
      added: s,
      removedCount: n.length,
      addedCount: s.length
    } : null;
    r && Ie(l), this.atom_.reportChanged(), a && $e(this, l), r && we();
  }, t.get_ = function(i) {
    if (this.legacyMode_ && i >= this.values_.length) {
      console.warn("[mobx.array] Attempt to read an array index (" + i + ") that is out of bounds (" + this.values_.length + "). Please check length first. Out of bound indices will not be tracked by MobX");
      return;
    }
    return this.atom_.reportObserved(), this.dehanceValue_(this.values_[i]);
  }, t.set_ = function(i, s) {
    var n = this.values_;
    if (this.legacyMode_ && i > n.length && R(17, i, n.length), i < n.length) {
      hi(this.atom_);
      var r = n[i];
      if (Be(this)) {
        var a = Me(this, {
          type: Je,
          object: this.proxy_,
          // since "this" is the real array we need to pass its proxy
          index: i,
          newValue: s
        });
        if (!a)
          return;
        s = a.newValue;
      }
      s = this.enhancer_(s, r);
      var l = s !== r;
      l && (n[i] = s, this.notifyArrayChildUpdate_(i, s, r));
    } else {
      for (var h = new Array(i + 1 - n.length), c = 0; c < h.length - 1; c++)
        h[c] = void 0;
      h[h.length - 1] = s, this.spliceWithArray_(n.length, 0, h);
    }
  }, o;
})();
function $u(o, t, e, i) {
  return e === void 0 && (e = "ObservableArray@" + si()), i === void 0 && (i = !1), ql(), Es(function() {
    var s = new ia(e, t, i, !1);
    Xl(s.values_, k, s);
    var n = new Proxy(s.values_, Zu);
    return s.proxy_ = n, o && o.length && s.spliceWithArray_(0, 0, o), n;
  });
}
var Cr = {
  clear: function() {
    return this.splice(0);
  },
  replace: function(t) {
    var e = this[k];
    return e.spliceWithArray_(0, e.values_.length, t);
  },
  // Used by JSON.stringify
  toJSON: function() {
    return this.slice();
  },
  /*
   * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
   * since these functions alter the inner structure of the array, the have side effects.
   * Because the have side effects, they should not be used in computed function,
   * and for that reason the do not call dependencyState.notifyObserved
   */
  splice: function(t, e) {
    for (var i = arguments.length, s = new Array(i > 2 ? i - 2 : 0), n = 2; n < i; n++)
      s[n - 2] = arguments[n];
    var r = this[k];
    switch (arguments.length) {
      case 0:
        return [];
      case 1:
        return r.spliceWithArray_(t);
      case 2:
        return r.spliceWithArray_(t, e);
    }
    return r.spliceWithArray_(t, e, s);
  },
  spliceWithArray: function(t, e, i) {
    return this[k].spliceWithArray_(t, e, i);
  },
  push: function() {
    for (var t = this[k], e = arguments.length, i = new Array(e), s = 0; s < e; s++)
      i[s] = arguments[s];
    return t.spliceWithArray_(t.values_.length, 0, i), t.values_.length;
  },
  pop: function() {
    return this.splice(Math.max(this[k].values_.length - 1, 0), 1)[0];
  },
  shift: function() {
    return this.splice(0, 1)[0];
  },
  unshift: function() {
    for (var t = this[k], e = arguments.length, i = new Array(e), s = 0; s < e; s++)
      i[s] = arguments[s];
    return t.spliceWithArray_(0, 0, i), t.values_.length;
  },
  reverse: function() {
    return A.trackingDerivation && R(37, "reverse"), this.replace(this.slice().reverse()), this;
  },
  sort: function() {
    A.trackingDerivation && R(37, "sort");
    var t = this.slice();
    return t.sort.apply(t, arguments), this.replace(t), this;
  },
  remove: function(t) {
    var e = this[k], i = e.dehanceValues_(e.values_).indexOf(t);
    return i > -1 ? (this.splice(i, 1), !0) : !1;
  }
};
rt("at", Ae);
rt("concat", Ae);
rt("flat", Ae);
rt("includes", Ae);
rt("indexOf", Ae);
rt("join", Ae);
rt("lastIndexOf", Ae);
rt("slice", Ae);
rt("toString", Ae);
rt("toLocaleString", Ae);
rt("toSorted", Ae);
rt("toSpliced", Ae);
rt("with", Ae);
rt("every", ni);
rt("filter", ni);
rt("find", ni);
rt("findIndex", ni);
rt("findLast", ni);
rt("findLastIndex", ni);
rt("flatMap", ni);
rt("forEach", ni);
rt("map", ni);
rt("some", ni);
rt("toReversed", ni);
rt("reduce", Ih);
rt("reduceRight", Ih);
function rt(o, t) {
  typeof Array.prototype[o] == "function" && (Cr[o] = t(o));
}
function Ae(o) {
  return function() {
    var t = this[k];
    t.atom_.reportObserved();
    var e = t.dehanceValues_(t.values_);
    return e[o].apply(e, arguments);
  };
}
function ni(o) {
  return function(t, e) {
    var i = this, s = this[k];
    s.atom_.reportObserved();
    var n = s.dehanceValues_(s.values_);
    return n[o](function(r, a) {
      return t.call(e, r, a, i);
    });
  };
}
function Ih(o) {
  return function() {
    var t = this, e = this[k];
    e.atom_.reportObserved();
    var i = e.dehanceValues_(e.values_), s = arguments[0];
    return arguments[0] = function(n, r, a) {
      return s(n, r, a, t);
    }, i[o].apply(i, arguments);
  };
}
var td = /* @__PURE__ */ Is("ObservableArrayAdministration", ia);
function Zr(o) {
  return qr(o) && td(o[k]);
}
var ed = {}, _i = "add", Ir = "delete", wh = /* @__PURE__ */ (function() {
  function o(e, i, s) {
    var n = this;
    i === void 0 && (i = Ps), s === void 0 && (s = "ObservableMap@" + si()), this.enhancer_ = void 0, this.name_ = void 0, this[k] = ed, this.data_ = void 0, this.hasMap_ = void 0, this.keysAtom_ = void 0, this.interceptors_ = void 0, this.changeListeners_ = void 0, this.dehancer = void 0, this.enhancer_ = i, this.name_ = s, Lt(Map) || R(18), Es(function() {
      n.keysAtom_ = Kl(n.name_ + ".keys()"), n.data_ = /* @__PURE__ */ new Map(), n.hasMap_ = /* @__PURE__ */ new Map(), e && n.merge(e);
    });
  }
  var t = o.prototype;
  return t.has_ = function(i) {
    return this.data_.has(i);
  }, t.has = function(i) {
    var s = this;
    if (!A.trackingDerivation)
      return this.has_(i);
    var n = this.hasMap_.get(i);
    if (!n) {
      var r = n = new us(this.has_(i), Yr, this.name_ + "." + To(i) + "?", !1);
      this.hasMap_.set(i, r), Sh(r, function() {
        return s.hasMap_.delete(i);
      });
    }
    return n.get();
  }, t.set = function(i, s) {
    var n = this.has_(i);
    if (Be(this)) {
      var r = Me(this, {
        type: n ? Je : _i,
        object: this,
        newValue: s,
        name: i
      });
      if (!r)
        return this;
      s = r.newValue;
    }
    return n ? this.updateValue_(i, s) : this.addValue_(i, s), this;
  }, t.delete = function(i) {
    var s = this;
    if (hi(this.keysAtom_), Be(this)) {
      var n = Me(this, {
        type: Ir,
        object: this,
        name: i
      });
      if (!n)
        return !1;
    }
    if (this.has_(i)) {
      var r = Ht(), a = Ze(this), l = a || r ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: Ir,
        object: this,
        oldValue: this.data_.get(i).value_,
        name: i
      } : null;
      return r && Ie(l), Ei(function() {
        var h;
        s.keysAtom_.reportChanged(), (h = s.hasMap_.get(i)) == null || h.setNewValue_(!1);
        var c = s.data_.get(i);
        c.setNewValue_(void 0), s.data_.delete(i);
      }), a && $e(this, l), r && we(), !0;
    }
    return !1;
  }, t.updateValue_ = function(i, s) {
    var n = this.data_.get(i);
    if (s = n.prepareNewValue_(s), s !== A.UNCHANGED) {
      var r = Ht(), a = Ze(this), l = a || r ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: Je,
        object: this,
        oldValue: n.value_,
        name: i,
        newValue: s
      } : null;
      r && Ie(l), n.setNewValue_(s), a && $e(this, l), r && we();
    }
  }, t.addValue_ = function(i, s) {
    var n = this;
    hi(this.keysAtom_), Ei(function() {
      var h, c = new us(s, n.enhancer_, n.name_ + "." + To(i), !1);
      n.data_.set(i, c), s = c.value_, (h = n.hasMap_.get(i)) == null || h.setNewValue_(!0), n.keysAtom_.reportChanged();
    });
    var r = Ht(), a = Ze(this), l = a || r ? {
      observableKind: "map",
      debugObjectName: this.name_,
      type: _i,
      object: this,
      name: i,
      newValue: s
    } : null;
    r && Ie(l), a && $e(this, l), r && we();
  }, t.get = function(i) {
    return this.has(i) ? this.dehanceValue_(this.data_.get(i).get()) : this.dehanceValue_(void 0);
  }, t.dehanceValue_ = function(i) {
    return this.dehancer !== void 0 ? this.dehancer(i) : i;
  }, t.keys = function() {
    return this.keysAtom_.reportObserved(), this.data_.keys();
  }, t.values = function() {
    var i = this, s = this.keys();
    return Fa({
      next: function() {
        var r = s.next(), a = r.done, l = r.value;
        return {
          done: a,
          value: a ? void 0 : i.get(l)
        };
      }
    });
  }, t.entries = function() {
    var i = this, s = this.keys();
    return Fa({
      next: function() {
        var r = s.next(), a = r.done, l = r.value;
        return {
          done: a,
          value: a ? void 0 : [l, i.get(l)]
        };
      }
    });
  }, t[Symbol.iterator] = function() {
    return this.entries();
  }, t.forEach = function(i, s) {
    for (var n = xs(this), r; !(r = n()).done; ) {
      var a = r.value, l = a[0], h = a[1];
      i.call(s, h, l, this);
    }
  }, t.merge = function(i) {
    var s = this;
    return ts(i) && (i = new Map(i)), Ei(function() {
      gi(i) ? Cc(i).forEach(function(n) {
        return s.set(n, i[n]);
      }) : Array.isArray(i) ? i.forEach(function(n) {
        var r = n[0], a = n[1];
        return s.set(r, a);
      }) : Ks(i) ? (vc(i) || R(19, i), i.forEach(function(n, r) {
        return s.set(r, n);
      })) : i != null && R(20, i);
    }), this;
  }, t.clear = function() {
    var i = this;
    Ei(function() {
      ah(function() {
        for (var s = xs(i.keys()), n; !(n = s()).done; ) {
          var r = n.value;
          i.delete(r);
        }
      });
    });
  }, t.replace = function(i) {
    var s = this;
    return Ei(function() {
      for (var n = id(i), r = /* @__PURE__ */ new Map(), a = !1, l = xs(s.data_.keys()), h; !(h = l()).done; ) {
        var c = h.value;
        if (!n.has(c)) {
          var d = s.delete(c);
          if (d)
            a = !0;
          else {
            var f = s.data_.get(c);
            r.set(c, f);
          }
        }
      }
      for (var p = xs(n.entries()), P; !(P = p()).done; ) {
        var y = P.value, C = y[0], E = y[1], N = s.data_.has(C);
        if (s.set(C, E), s.data_.has(C)) {
          var I = s.data_.get(C);
          r.set(C, I), N || (a = !0);
        }
      }
      if (!a)
        if (s.data_.size !== r.size)
          s.keysAtom_.reportChanged();
        else
          for (var x = s.data_.keys(), V = r.keys(), G = x.next(), X = V.next(); !G.done; ) {
            if (G.value !== X.value) {
              s.keysAtom_.reportChanged();
              break;
            }
            G = x.next(), X = V.next();
          }
      s.data_ = r;
    }), this;
  }, t.toString = function() {
    return "[object ObservableMap]";
  }, t.toJSON = function() {
    return Array.from(this);
  }, t.observe_ = function(i, s) {
    return s === !0 && R("`observe` doesn't support fireImmediately=true in combination with maps."), Xn(this, i);
  }, t.intercept_ = function(i) {
    return Un(this, i);
  }, Zs(o, [{
    key: "size",
    get: function() {
      return this.keysAtom_.reportObserved(), this.data_.size;
    }
  }, {
    key: Symbol.toStringTag,
    get: function() {
      return "Map";
    }
  }]);
})(), ts = /* @__PURE__ */ Is("ObservableMap", wh);
function Fa(o) {
  return o[Symbol.toStringTag] = "MapIterator", na(o);
}
function id(o) {
  if (Ks(o) || ts(o))
    return o;
  if (Array.isArray(o))
    return new Map(o);
  if (gi(o)) {
    var t = /* @__PURE__ */ new Map();
    for (var e in o)
      t.set(e, o[e]);
    return t;
  } else
    return R(21, o);
}
var sd = {}, Eh = /* @__PURE__ */ (function() {
  function o(e, i, s) {
    var n = this;
    i === void 0 && (i = Ps), s === void 0 && (s = "ObservableSet@" + si()), this.name_ = void 0, this[k] = sd, this.data_ = /* @__PURE__ */ new Set(), this.atom_ = void 0, this.changeListeners_ = void 0, this.interceptors_ = void 0, this.dehancer = void 0, this.enhancer_ = void 0, this.name_ = s, Lt(Set) || R(22), this.enhancer_ = function(r, a) {
      return i(r, a, s);
    }, Es(function() {
      n.atom_ = Kl(n.name_), e && n.replace(e);
    });
  }
  var t = o.prototype;
  return t.dehanceValue_ = function(i) {
    return this.dehancer !== void 0 ? this.dehancer(i) : i;
  }, t.clear = function() {
    var i = this;
    Ei(function() {
      ah(function() {
        for (var s = xs(i.data_.values()), n; !(n = s()).done; ) {
          var r = n.value;
          i.delete(r);
        }
      });
    });
  }, t.forEach = function(i, s) {
    for (var n = xs(this), r; !(r = n()).done; ) {
      var a = r.value;
      i.call(s, a, a, this);
    }
  }, t.add = function(i) {
    var s = this;
    if (hi(this.atom_), Be(this)) {
      var n = Me(this, {
        type: _i,
        object: this,
        newValue: i
      });
      if (!n)
        return this;
      i = n.newValue;
    }
    if (!this.has(i)) {
      Ei(function() {
        s.data_.add(s.enhancer_(i, void 0)), s.atom_.reportChanged();
      });
      var r = Ht(), a = Ze(this), l = a || r ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: _i,
        object: this,
        newValue: i
      } : null;
      r && Ie(l), a && $e(this, l), r && we();
    }
    return this;
  }, t.delete = function(i) {
    var s = this;
    if (Be(this)) {
      var n = Me(this, {
        type: Ir,
        object: this,
        oldValue: i
      });
      if (!n)
        return !1;
    }
    if (this.has(i)) {
      var r = Ht(), a = Ze(this), l = a || r ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: Ir,
        object: this,
        oldValue: i
      } : null;
      return r && Ie(l), Ei(function() {
        s.atom_.reportChanged(), s.data_.delete(i);
      }), a && $e(this, l), r && we(), !0;
    }
    return !1;
  }, t.has = function(i) {
    return this.atom_.reportObserved(), this.data_.has(this.dehanceValue_(i));
  }, t.entries = function() {
    var i = this.values();
    return Va({
      next: function() {
        var n = i.next(), r = n.value, a = n.done;
        return a ? {
          value: void 0,
          done: a
        } : {
          value: [r, r],
          done: a
        };
      }
    });
  }, t.keys = function() {
    return this.values();
  }, t.values = function() {
    this.atom_.reportObserved();
    var i = this, s = this.data_.values();
    return Va({
      next: function() {
        var r = s.next(), a = r.value, l = r.done;
        return l ? {
          value: void 0,
          done: l
        } : {
          value: i.dehanceValue_(a),
          done: l
        };
      }
    });
  }, t.intersection = function(i) {
    if (wi(i) && !ai(i))
      return i.intersection(this);
    var s = new Set(this);
    return s.intersection(i);
  }, t.union = function(i) {
    if (wi(i) && !ai(i))
      return i.union(this);
    var s = new Set(this);
    return s.union(i);
  }, t.difference = function(i) {
    return new Set(this).difference(i);
  }, t.symmetricDifference = function(i) {
    if (wi(i) && !ai(i))
      return i.symmetricDifference(this);
    var s = new Set(this);
    return s.symmetricDifference(i);
  }, t.isSubsetOf = function(i) {
    return new Set(this).isSubsetOf(i);
  }, t.isSupersetOf = function(i) {
    return new Set(this).isSupersetOf(i);
  }, t.isDisjointFrom = function(i) {
    if (wi(i) && !ai(i))
      return i.isDisjointFrom(this);
    var s = new Set(this);
    return s.isDisjointFrom(i);
  }, t.replace = function(i) {
    var s = this;
    return ai(i) && (i = new Set(i)), Ei(function() {
      Array.isArray(i) ? (s.clear(), i.forEach(function(n) {
        return s.add(n);
      })) : wi(i) ? (s.clear(), i.forEach(function(n) {
        return s.add(n);
      })) : i != null && R("Cannot initialize set from " + i);
    }), this;
  }, t.observe_ = function(i, s) {
    return s === !0 && R("`observe` doesn't support fireImmediately=true in combination with sets."), Xn(this, i);
  }, t.intercept_ = function(i) {
    return Un(this, i);
  }, t.toJSON = function() {
    return Array.from(this);
  }, t.toString = function() {
    return "[object ObservableSet]";
  }, t[Symbol.iterator] = function() {
    return this.values();
  }, Zs(o, [{
    key: "size",
    get: function() {
      return this.atom_.reportObserved(), this.data_.size;
    }
  }, {
    key: Symbol.toStringTag,
    get: function() {
      return "Set";
    }
  }]);
})(), ai = /* @__PURE__ */ Is("ObservableSet", Eh);
function Va(o) {
  return o[Symbol.toStringTag] = "SetIterator", na(o);
}
var Da = /* @__PURE__ */ Object.create(null), ka = "remove", Go = /* @__PURE__ */ (function() {
  function o(e, i, s, n) {
    i === void 0 && (i = /* @__PURE__ */ new Map()), n === void 0 && (n = Zc), this.target_ = void 0, this.values_ = void 0, this.name_ = void 0, this.defaultAnnotation_ = void 0, this.keysAtom_ = void 0, this.changeListeners_ = void 0, this.interceptors_ = void 0, this.proxy_ = void 0, this.isPlainObject_ = void 0, this.appliedAnnotations_ = void 0, this.pendingKeys_ = void 0, this.target_ = e, this.values_ = i, this.name_ = s, this.defaultAnnotation_ = n, this.keysAtom_ = new $i(this.name_ + ".keys"), this.isPlainObject_ = gi(this.target_), Rh(this.defaultAnnotation_) || R("defaultAnnotation must be valid annotation"), this.appliedAnnotations_ = {};
  }
  var t = o.prototype;
  return t.getObservablePropValue_ = function(i) {
    return this.values_.get(i).get();
  }, t.setObservablePropValue_ = function(i, s) {
    var n = this.values_.get(i);
    if (n instanceof He)
      return n.set(s), !0;
    if (Be(this)) {
      var r = Me(this, {
        type: Je,
        object: this.proxy_ || this.target_,
        name: i,
        newValue: s
      });
      if (!r)
        return null;
      s = r.newValue;
    }
    if (s = n.prepareNewValue_(s), s !== A.UNCHANGED) {
      var a = Ze(this), l = Ht(), h = a || l ? {
        type: Je,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        oldValue: n.value_,
        name: i,
        newValue: s
      } : null;
      l && Ie(h), n.setNewValue_(s), a && $e(this, h), l && we();
    }
    return !0;
  }, t.get_ = function(i) {
    return A.trackingDerivation && !De(this.target_, i) && this.has_(i), this.target_[i];
  }, t.set_ = function(i, s, n) {
    return n === void 0 && (n = !1), De(this.target_, i) ? this.values_.has(i) ? this.setObservablePropValue_(i, s) : n ? Reflect.set(this.target_, i, s) : (this.target_[i] = s, !0) : this.extend_(i, {
      value: s,
      enumerable: !0,
      writable: !0,
      configurable: !0
    }, this.defaultAnnotation_, n);
  }, t.has_ = function(i) {
    if (!A.trackingDerivation)
      return i in this.target_;
    this.pendingKeys_ || (this.pendingKeys_ = /* @__PURE__ */ new Map());
    var s = this.pendingKeys_.get(i);
    return s || (s = new us(i in this.target_, Yr, this.name_ + "." + To(i) + "?", !1), this.pendingKeys_.set(i, s)), s.get();
  }, t.make_ = function(i, s) {
    if (s === !0 && (s = this.defaultAnnotation_), s !== !1) {
      if (Ha(this, s, i), !(i in this.target_)) {
        var n;
        if ((n = this.target_[he]) != null && n[i])
          return;
        R(1, s.annotationType_, this.name_ + "." + i.toString());
      }
      for (var r = this.target_; r && r !== jr; ) {
        var a = pr(r, i);
        if (a) {
          var l = s.make_(this, i, a, r);
          if (l === 0)
            return;
          if (l === 1)
            break;
        }
        r = Object.getPrototypeOf(r);
      }
      Wa(this, s, i);
    }
  }, t.extend_ = function(i, s, n, r) {
    if (r === void 0 && (r = !1), n === !0 && (n = this.defaultAnnotation_), n === !1)
      return this.defineProperty_(i, s, r);
    Ha(this, n, i);
    var a = n.extend_(this, i, s, r);
    return a && Wa(this, n, i), a;
  }, t.defineProperty_ = function(i, s, n) {
    n === void 0 && (n = !1), hi(this.keysAtom_);
    try {
      Ge();
      var r = this.delete_(i);
      if (!r)
        return r;
      if (Be(this)) {
        var a = Me(this, {
          object: this.proxy_ || this.target_,
          name: i,
          type: _i,
          newValue: s.value
        });
        if (!a)
          return null;
        var l = a.newValue;
        s.value !== l && (s = Li({}, s, {
          value: l
        }));
      }
      if (n) {
        if (!Reflect.defineProperty(this.target_, i, s))
          return !1;
      } else
        ci(this.target_, i, s);
      this.notifyPropertyAddition_(i, s.value);
    } finally {
      Fe();
    }
    return !0;
  }, t.defineObservableProperty_ = function(i, s, n, r) {
    r === void 0 && (r = !1), hi(this.keysAtom_);
    try {
      Ge();
      var a = this.delete_(i);
      if (!a)
        return a;
      if (Be(this)) {
        var l = Me(this, {
          object: this.proxy_ || this.target_,
          name: i,
          type: _i,
          newValue: s
        });
        if (!l)
          return null;
        s = l.newValue;
      }
      var h = _a(i), c = {
        configurable: A.safeDescriptors ? this.isPlainObject_ : !0,
        enumerable: !0,
        get: h.get,
        set: h.set
      };
      if (r) {
        if (!Reflect.defineProperty(this.target_, i, c))
          return !1;
      } else
        ci(this.target_, i, c);
      var d = new us(s, n, this.name_ + "." + i.toString(), !1);
      this.values_.set(i, d), this.notifyPropertyAddition_(i, d.value_);
    } finally {
      Fe();
    }
    return !0;
  }, t.defineComputedProperty_ = function(i, s, n) {
    n === void 0 && (n = !1), hi(this.keysAtom_);
    try {
      Ge();
      var r = this.delete_(i);
      if (!r)
        return r;
      if (Be(this)) {
        var a = Me(this, {
          object: this.proxy_ || this.target_,
          name: i,
          type: _i,
          newValue: void 0
        });
        if (!a)
          return null;
      }
      s.name || (s.name = this.name_ + "." + i.toString()), s.context = this.proxy_ || this.target_;
      var l = _a(i), h = {
        configurable: A.safeDescriptors ? this.isPlainObject_ : !0,
        enumerable: !1,
        get: l.get,
        set: l.set
      };
      if (n) {
        if (!Reflect.defineProperty(this.target_, i, h))
          return !1;
      } else
        ci(this.target_, i, h);
      this.values_.set(i, new He(s)), this.notifyPropertyAddition_(i, void 0);
    } finally {
      Fe();
    }
    return !0;
  }, t.delete_ = function(i, s) {
    if (s === void 0 && (s = !1), hi(this.keysAtom_), !De(this.target_, i))
      return !0;
    if (Be(this)) {
      var n = Me(this, {
        object: this.proxy_ || this.target_,
        name: i,
        type: ka
      });
      if (!n)
        return null;
    }
    try {
      var r;
      Ge();
      var a = Ze(this), l = Ht(), h = this.values_.get(i), c = void 0;
      if (!h && (a || l)) {
        var d;
        c = (d = pr(this.target_, i)) == null ? void 0 : d.value;
      }
      if (s) {
        if (!Reflect.deleteProperty(this.target_, i))
          return !1;
      } else
        delete this.target_[i];
      if (delete this.appliedAnnotations_[i], h && (this.values_.delete(i), h instanceof us && (c = h.value_), dh(h)), this.keysAtom_.reportChanged(), (r = this.pendingKeys_) == null || (r = r.get(i)) == null || r.set(i in this.target_), a || l) {
        var f = {
          type: ka,
          observableKind: "object",
          object: this.proxy_ || this.target_,
          debugObjectName: this.name_,
          oldValue: c,
          name: i
        };
        l && Ie(f), a && $e(this, f), l && we();
      }
    } finally {
      Fe();
    }
    return !0;
  }, t.observe_ = function(i, s) {
    return s === !0 && R("`observe` doesn't support the fire immediately property for observable objects."), Xn(this, i);
  }, t.intercept_ = function(i) {
    return Un(this, i);
  }, t.notifyPropertyAddition_ = function(i, s) {
    var n, r = Ze(this), a = Ht();
    if (r || a) {
      var l = r || a ? {
        type: _i,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        name: i,
        newValue: s
      } : null;
      a && Ie(l), r && $e(this, l), a && we();
    }
    (n = this.pendingKeys_) == null || (n = n.get(i)) == null || n.set(!0), this.keysAtom_.reportChanged();
  }, t.ownKeys_ = function() {
    return this.keysAtom_.reportObserved(), Xr(this.target_);
  }, t.keys_ = function() {
    return this.keysAtom_.reportObserved(), Object.keys(this.target_);
  }, o;
})();
function $s(o, t) {
  var e;
  if (t && Qn(o) && R("Options can't be provided for already observable objects."), De(o, k))
    return xh(o) instanceof Go || R("Cannot convert '" + wr(o) + `' into observable object:
The target is already observable of different type.
Extending builtins is not supported.`), o;
  Object.isExtensible(o) || R("Cannot make the designated object observable; it is not extensible");
  var i = (e = t?.name) != null ? e : (gi(o) ? "ObservableObject" : o.constructor.name) + "@" + si(), s = new Go(o, /* @__PURE__ */ new Map(), String(i), hu(t));
  return Ur(o, k, s), o;
}
var nd = /* @__PURE__ */ Is("ObservableObjectAdministration", Go);
function _a(o) {
  return Da[o] || (Da[o] = {
    get: function() {
      return this[k].getObservablePropValue_(o);
    },
    set: function(e) {
      return this[k].setObservablePropValue_(o, e);
    }
  });
}
function Qn(o) {
  return qr(o) ? nd(o[k]) : !1;
}
function Wa(o, t, e) {
  var i;
  o.appliedAnnotations_[e] = t, (i = o.target_[he]) == null || delete i[e];
}
function Ha(o, t, e) {
  if (Rh(t) || R("Cannot annotate '" + o.name_ + "." + e.toString() + "': Invalid annotation."), !Sr(t) && De(o.appliedAnnotations_, e)) {
    var i = o.name_ + "." + e.toString(), s = o.appliedAnnotations_[e].annotationType_, n = t.annotationType_;
    R("Cannot apply '" + n + "' to '" + i + "':" + (`
The field is already annotated with '` + s + "'.") + `
Re-annotating fields is not allowed.
Use 'override' annotation for methods overridden by subclass.`);
  }
}
var rd = /* @__PURE__ */ Th(0), od = /* @__PURE__ */ (function() {
  var o = !1, t = {};
  return Object.defineProperty(t, "0", {
    set: function() {
      o = !0;
    }
  }), Object.create(t)[0] = 1, o === !1;
})(), uo = 0, Ah = function() {
};
function ad(o, t) {
  Object.setPrototypeOf ? Object.setPrototypeOf(o.prototype, t) : o.prototype.__proto__ !== void 0 ? o.prototype.__proto__ = t : o.prototype = t;
}
ad(Ah, Array.prototype);
var sa = /* @__PURE__ */ (function(o) {
  function t(i, s, n, r) {
    var a;
    return n === void 0 && (n = "ObservableArray@" + si()), r === void 0 && (r = !1), a = o.call(this) || this, Es(function() {
      var l = new ia(n, s, r, !0);
      l.proxy_ = a, Xl(a, k, l), i && i.length && a.spliceWithArray(0, 0, i), od && Object.defineProperty(a, "0", rd);
    }), a;
  }
  Jl(t, o);
  var e = t.prototype;
  return e.concat = function() {
    this[k].atom_.reportObserved();
    for (var s = arguments.length, n = new Array(s), r = 0; r < s; r++)
      n[r] = arguments[r];
    return Array.prototype.concat.apply(
      this.slice(),
      //@ts-ignore
      n.map(function(a) {
        return Zr(a) ? a.slice() : a;
      })
    );
  }, e[Symbol.iterator] = function() {
    var i = this, s = 0;
    return na({
      next: function() {
        return s < i.length ? {
          value: i[s++],
          done: !1
        } : {
          done: !0,
          value: void 0
        };
      }
    });
  }, Zs(t, [{
    key: "length",
    get: function() {
      return this[k].getArrayLength_();
    },
    set: function(s) {
      this[k].setArrayLength_(s);
    }
  }, {
    key: Symbol.toStringTag,
    get: function() {
      return "Array";
    }
  }]);
})(Ah);
Object.entries(Cr).forEach(function(o) {
  var t = o[0], e = o[1];
  t !== "concat" && Ur(sa.prototype, t, e);
});
function Th(o) {
  return {
    enumerable: !1,
    configurable: !0,
    get: function() {
      return this[k].get_(o);
    },
    set: function(e) {
      this[k].set_(o, e);
    }
  };
}
function ld(o) {
  ci(sa.prototype, "" + o, Th(o));
}
function Oh(o) {
  if (o > uo) {
    for (var t = uo; t < o + 100; t++)
      ld(t);
    uo = o;
  }
}
Oh(1e3);
function hd(o, t, e) {
  return new sa(o, t, e);
}
function Ws(o, t) {
  if (typeof o == "object" && o !== null) {
    if (Zr(o))
      return t !== void 0 && R(23), o[k].atom_;
    if (ai(o))
      return o.atom_;
    if (ts(o)) {
      if (t === void 0)
        return o.keysAtom_;
      var e = o.data_.get(t) || o.hasMap_.get(t);
      return e || R(25, t, wr(o)), e;
    }
    if (Qn(o)) {
      if (!t)
        return R(26);
      var i = o[k].values_.get(t);
      return i || R(27, t, wr(o)), i;
    }
    if (Jo(o) || Kr(o) || vr(o))
      return o;
  } else if (Lt(o) && vr(o[k]))
    return o[k];
  R(28);
}
function xh(o, t) {
  if (o || R(29), Jo(o) || Kr(o) || vr(o) || ts(o) || ai(o))
    return o;
  if (o[k])
    return o[k];
  R(24, o);
}
function wr(o, t) {
  var e;
  if (t !== void 0)
    e = Ws(o, t);
  else {
    if (bs(o))
      return o.name;
    Qn(o) || ts(o) || ai(o) ? e = xh(o) : e = Ws(o);
  }
  return e.name_;
}
function Es(o) {
  var t = ws(), e = Zo(!0);
  Ge();
  try {
    return o();
  } finally {
    Fe(), $o(e), xi(t);
  }
}
var za = jr.toString;
function Lh(o, t, e) {
  return e === void 0 && (e = -1), Fo(o, t, e);
}
function Fo(o, t, e, i, s) {
  if (o === t)
    return o !== 0 || 1 / o === 1 / t;
  if (o == null || t == null)
    return !1;
  if (o !== o)
    return t !== t;
  var n = typeof o;
  if (n !== "function" && n !== "object" && typeof t != "object")
    return !1;
  var r = za.call(o);
  if (r !== za.call(t))
    return !1;
  switch (r) {
    // Strings, numbers, regular expressions, dates, and booleans are compared by value.
    case "[object RegExp]":
    // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
    case "[object String]":
      return "" + o == "" + t;
    case "[object Number]":
      return +o != +o ? +t != +t : +o == 0 ? 1 / +o === 1 / t : +o == +t;
    case "[object Date]":
    case "[object Boolean]":
      return +o == +t;
    case "[object Symbol]":
      return typeof Symbol < "u" && Symbol.valueOf.call(o) === Symbol.valueOf.call(t);
    case "[object Map]":
    case "[object Set]":
      e >= 0 && e++;
      break;
  }
  o = ja(o), t = ja(t);
  var a = r === "[object Array]";
  if (!a) {
    if (typeof o != "object" || typeof t != "object")
      return !1;
    var l = o.constructor, h = t.constructor;
    if (l !== h && !(Lt(l) && l instanceof l && Lt(h) && h instanceof h) && "constructor" in o && "constructor" in t)
      return !1;
  }
  if (e === 0)
    return !1;
  e < 0 && (e = -1), i = i || [], s = s || [];
  for (var c = i.length; c--; )
    if (i[c] === o)
      return s[c] === t;
  if (i.push(o), s.push(t), a) {
    if (c = o.length, c !== t.length)
      return !1;
    for (; c--; )
      if (!Fo(o[c], t[c], e - 1, i, s))
        return !1;
  } else {
    var d = Object.keys(o), f = d.length;
    if (Object.keys(t).length !== f)
      return !1;
    for (var p = 0; p < f; p++) {
      var P = d[p];
      if (!(De(t, P) && Fo(o[P], t[P], e - 1, i, s)))
        return !1;
    }
  }
  return i.pop(), s.pop(), !0;
}
function ja(o) {
  return Zr(o) ? o.slice() : Ks(o) || ts(o) || wi(o) || ai(o) ? Array.from(o.entries()) : o;
}
var qa, cd = ((qa = Qo().Iterator) == null ? void 0 : qa.prototype) || {};
function na(o) {
  return o[Symbol.iterator] = ud, Object.assign(Object.create(cd), o);
}
function ud() {
  return this;
}
function Rh(o) {
  return (
    // Can be function
    o instanceof Object && typeof o.annotationType_ == "string" && Lt(o.make_) && Lt(o.extend_)
  );
}
["Symbol", "Map", "Set"].forEach(function(o) {
  var t = Qo();
  typeof t[o] > "u" && R("MobX requires global '" + o + "' to be available or polyfilled");
});
typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ == "object" && __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
  spy: xu,
  extras: {
    getDebugName: wr
  },
  $mobx: k
});
let Ua = class {
  remove(t) {
    this.nodeMap.delete(t.id);
  }
  addEdge(t) {
    this._edgeMap[t.id] = t;
  }
  findEdge = (t) => this._edgeMap[t];
  get size() {
    return this.nodeMap.size;
  }
  get getEdgesMap() {
    return this._edgeMap;
  }
  /** List of object edges. */
  //private _edgeMap: Record<string, Edge> = {};
  _edgeMap = {};
  *nodes_() {
    for (const t of this.nodeMap.values())
      yield t;
  }
  *graphs_() {
    for (const t of this.nodes_())
      t instanceof be && (yield t);
  }
  constructor() {
    Ch(this, {
      nodeMap: It,
      _edgeMap: It,
      getNodeMap: li,
      getEdgesMap: li,
      remove: Ne
    }, { autoBind: !0 }), this.findEdge = this.findEdge.bind(this);
  }
  findShallow(t) {
    return this.nodeMap.get(t);
  }
  get nodesShallow() {
    return this.nodes_();
  }
  get graphs() {
    return this.graphs_();
  }
  nodeMap = /* @__PURE__ */ new Map();
  get getNodeMap() {
    return this.nodeMap;
  }
  *_edges() {
    for (const t of this.nodeMap.values()) {
      for (const e of t.outEdges)
        yield e;
      for (const e of t.selfEdges)
        yield e;
    }
  }
  interGraphEdges() {
    throw new Error("not implemented");
  }
  get nodeShallowCount() {
    return this.nodeMap.size;
  }
  // caution: it is a linear by the number of nodes method
  get edgeCount() {
    let t = 0;
    for (const e of this.nodeMap.values())
      t += e.outDegree + e.selfDegree;
    return t;
  }
  /**  returns the edges of shallow nodes */
  get edges() {
    return this._edges();
  }
  addNode(t) {
    this.nodeMap.set(t.id, t);
  }
  nodeIsConsistent(t) {
    for (const e of t.outEdges)
      if (e.source !== t || e.source === e.target)
        return !1;
    for (const e of t.inEdges)
      if (e.target !== t || e.source === e.target)
        return !1;
    for (const e of t.selfEdges)
      if (e.target !== e.source || e.source !== t)
        return !1;
    return !0;
  }
  isConsistent() {
    for (const t of this.nodeMap.values())
      if (!this.nodeIsConsistent(t))
        return !1;
    return !0;
  }
};
class Nh {
  /** this in the index of where the attribute is positioned in the attribute array of the entity */
  bind(t) {
    this.entity && this.entity.setAttr(t, this);
  }
  /** The arguments are the underlying entity and the attribute index in the attribute array */
  constructor(t, e) {
    this.entity = t, this.bind(e);
  }
}
class _e {
}
_e.GeomObjectIndex = 0;
_e.DrawingObjectIndex = 1;
_e.AlgorithmDataIndex = 2;
_e.ViewerIndex = 3;
class $ extends Nh {
  constructor(t) {
    super(t, _e.GeomObjectIndex);
  }
  static getGeom(t) {
    return t == null ? null : t.getAttr(_e.GeomObjectIndex);
  }
  get parent() {
    const t = this.entity.parent;
    return t ? $.getGeom(t) : null;
  }
  rebind(t) {
    this.entity = t, this.bind(_e.GeomObjectIndex);
  }
  *getAncestors() {
    let t = this.parent;
    for (; t != null; )
      yield t, t = t.parent;
  }
}
class Yi {
  static solve(t, e, i, s, n, r) {
    const a = t * n - s * e;
    if (!(Math.abs(a) < Yi.eps))
      return {
        x: (i * n - r * e) / a,
        y: (t * r - s * i) / a
      };
  }
}
Yi.eps = 1e-8;
class m {
}
m.distanceEpsilonPrecision = 6;
m.mult = Math.pow(10, 6);
m.defaultLeafBoxesOffset = 0.5;
m.lineSegmentThreshold = 0.05;
m.intersectionEpsilon = 1e-4;
m.distanceEpsilon = Math.pow(10, -m.distanceEpsilonPrecision);
m.squareOfDistanceEpsilon = Math.pow(10, -m.distanceEpsilonPrecision * 2);
m.tolerance = 1e-8;
function dd(o, t) {
  return (o ? 1 : 0) - (t ? 1 : 0);
}
function yt(o, t) {
  const e = o - t;
  return e < 0 ? -1 : e === 0 ? 0 : 1;
}
function hr(o, t) {
  const e = yt(o.y, t.y);
  return e || yt(o.x, t.x);
}
function D(o, t) {
  const e = o - t;
  return -m.distanceEpsilon <= e && e <= m.distanceEpsilon;
}
function fo(o, t) {
  return Er(o, t) > 0;
}
function Er(o, t) {
  const e = o - t;
  return e <= -m.distanceEpsilon ? -1 : e >= m.distanceEpsilon ? 1 : 0;
}
var L;
(function(o) {
  o[o.Clockwise = 0] = "Clockwise", o[o.Counterclockwise = 1] = "Counterclockwise", o[o.Collinear = 2] = "Collinear";
})(L || (L = {}));
function Z(o, t) {
  return o.sub(t).length;
}
class u {
  static RoundPoint(t) {
    return new u(u.RoundDouble(t.x), u.RoundDouble(t.y));
  }
  static RoundDouble(t) {
    return Math.round(t * m.mult) / m.mult;
  }
  toJSON() {
    return { x: this.x, y: this.y };
  }
  static fromJSON(t) {
    return new u(t.x, t.y);
  }
  /** c is projected to line through a, b */
  static ProjectionToLine(t, e, i) {
    let s = e.sub(t);
    const n = s.length;
    if (n < m.distanceEpsilon)
      return t;
    s = s.div(n);
    const r = i.sub(t).dot(s);
    return t.add(s.mul(r));
  }
  static RayIntersectsRayInteriors(t, e, i, s) {
    const n = u.lineLineIntersection(t, t.add(e), i, i.add(s));
    if (n && n.sub(t).dot(e.div(e.l1)) > m.distanceEpsilon && n.sub(i).dot(s.div(s.l1)) > m.distanceEpsilon)
      return n;
  }
  static IntervalIntersectsRay(t, e, i, s) {
    const n = u.lineLineIntersection(t, e, i, i.add(s));
    if (!n)
      return;
    const r = t.sub(n), a = n.sub(e);
    if (!(r.dot(a) <= 0) && !(n.sub(i).dot(s) < 0) && r.dot(r) > m.squareOfDistanceEpsilon && a.dot(a) >= m.squareOfDistanceEpsilon)
      return n;
  }
  static PointToTheLeftOfLineOrOnLine(t, e, i) {
    return u.signedDoubledTriangleArea(t, e, i) >= 0;
  }
  // returns true if "point" lies to the left of the line linePoint0, linePoint1
  static PointToTheLeftOfLine(t, e, i) {
    return u.signedDoubledTriangleArea(t, e, i) > 0;
  }
  static PointIsInsideCone(t, e, i, s) {
    return u.PointToTheRightOfLineOrOnLine(t, e, i) && u.PointToTheLeftOfLineOrOnLine(t, e, s);
  }
  static PointToTheRightOfLineOrOnLine(t, e, i) {
    return u.signedDoubledTriangleArea(e, i, t) <= 0;
  }
  static PointToTheRightOfLine(t, e, i) {
    return u.signedDoubledTriangleArea(e, i, t) < 0;
  }
  static closeIntersections(t, e) {
    return u.close(t, e, m.intersectionEpsilon);
  }
  get l1() {
    return Math.abs(this.x_) + Math.abs(this.y_);
  }
  dot(t) {
    return this.x * t.x + this.y * t.y;
  }
  get x() {
    return this.x_;
  }
  get y() {
    return this.y_;
  }
  compareTo(t) {
    const e = yt(this.x, t.x);
    return e !== 0 ? e : yt(this.y, t.y);
  }
  toString() {
    return "(" + this.x + "," + this.y + ")";
  }
  static close(t, e, i) {
    return t.sub(e).length <= i;
  }
  static closeSquare(t, e, i) {
    const s = e.sub(t);
    return s.dot(s) <= i;
  }
  static closeDistEps(t, e, i = m.distanceEpsilon) {
    return t.sub(e).length <= i;
  }
  normalize() {
    const t = this.length;
    return new u(this.x / t, this.y / t);
  }
  get length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  get lengthSquared() {
    return this.x * this.x + this.y * this.y;
  }
  constructor(t, e) {
    this.x_ = t, this.y_ = e;
  }
  static middle(t, e) {
    return t.add(e).div(2);
  }
  scale(t, e) {
    return new u(this.x * t, this.y * e);
  }
  add(t) {
    return new u(this.x + t.x, this.y + t.y);
  }
  sub(t) {
    return new u(this.x - t.x, this.y - t.y);
  }
  mul(t) {
    return new u(this.x * t, this.y * t);
  }
  div(t) {
    return new u(this.x / t, this.y / t);
  }
  equal(t) {
    return t.x === this.x && t.y === this.y;
  }
  neg() {
    return new u(-this.x, -this.y);
  }
  static lineLineIntersection(t, e, i, s) {
    const n = e.sub(t), r = i.sub(s), a = i.sub(t), l = Yi.solve(n.x, r.x, a.x, n.y, r.y, a.y);
    if (l !== void 0)
      return t.add(n.mul(l.x));
  }
  static segSegIntersection(t, e, i, s) {
    const n = e.sub(t), r = i.sub(s), a = i.sub(t), l = m.tolerance, h = Yi.solve(n.x, r.x, a.x, n.y, r.y, a.y);
    if (h !== void 0 && h.x > -l && h.x < 1 + l && h.y > -l && h.y < 1 + l)
      return t.add(n.mul(h.x));
  }
  static parallelWithinEpsilon(t, e, i) {
    const s = t.length, n = e.length;
    return s < i || n < i ? !0 : (t = t.div(s), e = e.div(n), Math.abs(-t.x * e.y + t.y * e.x) < i);
  }
  static crossProduct(t, e) {
    return t.x * e.y - t.y * e.x;
  }
  static dot(t, e) {
    return t.x * e.x + t.y * e.y;
  }
  static add(t, e) {
    return t.add(e);
  }
  rotate90Ccw() {
    return new u(-this.y, this.x);
  }
  rotate90Cw() {
    return new u(this.y, -this.x);
  }
  clone() {
    return new u(this.x, this.y);
  }
  // returns this rotated by the angle counterclockwise; does not change "this" value
  rotate(t) {
    const e = Math.cos(t), i = Math.sin(t);
    return new u(e * this.x - i * this.y, i * this.x + e * this.y);
  }
  static mkPoint(t, e, i, s) {
    return e.mul(t).add(s.mul(i));
  }
  static convSum(t, e, i) {
    return e.add(i.sub(e).mul(t));
  }
  static anglePCP(t, e, i) {
    return u.angle(t.sub(e), i.sub(e));
  }
  // The angle you need to turn "side0" counterclockwise to make it collinear with "side1"
  static angle(t, e) {
    const i = t.x, s = t.y, n = e.x, r = e.y, a = i * r - s * n, l = i * n + s * r;
    if (Math.abs(l) < m.tolerance)
      return Math.abs(a) < m.tolerance ? 0 : a < -m.tolerance ? 3 * Math.PI / 2 : Math.PI / 2;
    if (Math.abs(a) < m.tolerance)
      return l < -m.tolerance ? Math.PI : 0;
    const h = Math.atan2(a, l);
    return a >= -m.tolerance ? h : Math.PI * 2 + h;
  }
  static signedDoubledTriangleArea(t, e, i) {
    return (e.x - t.x) * (i.y - t.y) - (i.x - t.x) * (e.y - t.y);
  }
  static getTriangleOrientation(t, e, i) {
    const s = u.signedDoubledTriangleArea(t, e, i);
    return s > m.distanceEpsilon ? L.Counterclockwise : s < -m.distanceEpsilon ? L.Clockwise : L.Collinear;
  }
  static getTriangleOrientationWithIntersectionEpsilon(t, e, i) {
    const s = u.signedDoubledTriangleArea(t, e, i);
    return s > m.intersectionEpsilon ? L.Counterclockwise : s < -m.intersectionEpsilon ? L.Clockwise : L.Collinear;
  }
  static ClosestPointAtLineSegment(t, e, i) {
    const s = i.sub(e), n = t.sub(e), r = s.dot(n), a = s.dot(s);
    return r <= 0 + m.tolerance ? e : a <= r + m.tolerance ? i : e.add(s.mul(r / a));
  }
  static pointToTheLeftOfLineOrOnLine(t, e, i) {
    return u.signedDoubledTriangleArea(t, e, i) >= 0;
  }
  // returns true if "point" lies to the left of the line linePoint0, linePoint1
  static pointToTheLeftOfLine(t, e, i) {
    return u.signedDoubledTriangleArea(t, e, i) > 0;
  }
  // returns true if "point" lies to the right of the line linePoint0, linePoint1
  static pointToTheRightOfLineOrOnLine(t, e, i) {
    return u.signedDoubledTriangleArea(e, i, t) <= 0;
  }
  static pointToTheRightOfLine(t, e, i) {
    return u.signedDoubledTriangleArea(e, i, t) < 0;
  }
  static canProject(t, e, i) {
    const s = i.sub(e);
    return !(t.sub(e).dot(s) < 0 || t.sub(i).dot(s) > 0);
  }
  static distToLineSegment(t, e, i) {
    const s = i.sub(e), n = t.sub(e);
    let r, a;
    if ((r = s.dot(n)) <= m.tolerance)
      return { par: 0, dist: n.length };
    if ((a = s.dot(s)) <= r + m.tolerance)
      return { par: 1, dist: t.sub(i).length };
    const l = r / a;
    return { par: l, dist: e.add(s.mul(l)).length };
  }
}
class ei {
  constructor() {
    this._next = null, this.prev = null;
  }
  get point() {
    return this._point;
  }
  set point(t) {
    this._point = t;
  }
  get next() {
    return this._next;
  }
  set next(t) {
    this._next = t;
  }
  get nextOnPolyline() {
    return this.polyline.next(this);
  }
  get prevOnPolyline() {
    return this.polyline.prev(this);
  }
  //
  getNext() {
    return this.next;
  }
  setNext(t) {
    this.next = t, this.polyline != null && this.polyline.setInitIsRequired();
  }
  //
  getPrev() {
    return this.prev;
  }
  setPrev(t) {
    this.prev = t, this.polyline != null && this.polyline.setInitIsRequired();
  }
  static mkFromPoint(t) {
    const e = new ei();
    return e.point = t, e;
  }
}
var bi;
(function(o) {
  o[o.Corner = 0] = "Corner", o[o.VertexA = 1] = "VertexA", o[o.otherCorner = 2] = "otherCorner", o[o.VertexB = 3] = "VertexB";
})(bi || (bi = {}));
class Q {
  // Return true if the parallelogram contains the point
  contains(t) {
    const e = t.sub(this.corner), i = m.distanceEpsilon, s = e.dot(this.bRot);
    if (s > this.abRot + i || s < -i)
      return !1;
    const n = e.dot(this.aRot);
    return n <= this.baRot + i && n >= -i;
  }
  get area() {
    return Math.abs(this.a.x * this.b.y - this.a.y * this.b.x);
  }
  vertex(t) {
    switch (t) {
      case bi.Corner:
        return this.corner;
      case bi.VertexA:
        return this.aPlusCorner;
      case bi.otherCorner:
        return this.otherCorner;
      case bi.VertexB:
        return this.bPlusCorner;
      default:
        return;
    }
  }
  static parallelogramOfTwo(t, e) {
    const i = new Q(), s = t.corner, n = {
      minx: s.x,
      maxx: s.x,
      miny: s.y,
      maxy: s.y
    };
    return Q.pumpMinMax(n, t.aPlusCorner), Q.pumpMinMax(n, t.otherCorner), Q.pumpMinMax(n, t.bPlusCorner), Q.pumpMinMax(n, e.corner), Q.pumpMinMax(n, e.aPlusCorner), Q.pumpMinMax(n, e.otherCorner), Q.pumpMinMax(n, e.bPlusCorner), i.corner = new u(n.minx, n.miny), i.a = new u(0, n.maxy - n.miny), i.b = new u(n.maxx - n.minx, 0), i.aPlusCorner = i.a.add(i.corner), i.otherCorner = i.b.add(i.aPlusCorner), i.bPlusCorner = i.b.add(i.corner), i.aRot = new u(-i.a.y, i.a.x), i.aRot.length > 0.5 && (i.aRot = i.aRot.normalize()), i.bRot = new u(-i.b.y, i.b.x), i.bRot.length > 0.5 && (i.bRot = i.bRot.normalize()), i.abRot = i.a.dot(i.bRot), i.baRot = i.b.dot(i.aRot), i.abRot < 0 && (i.abRot = -i.abRot, i.bRot = i.bRot.neg()), i.baRot < 0 && (i.baRot = -i.baRot, i.aRot = i.aRot.neg()), i.isSeg = i.a.sub(i.b).length < m.distanceEpsilon, i;
  }
  static pumpMinMax(t, e) {
    e.x < t.minx ? t.minx = e.x : e.x > t.maxx && (t.maxx = e.x), e.y < t.miny ? t.miny = e.y : e.y > t.maxy && (t.maxy = e.y);
  }
  // returns true if parallelograms intersect
  static intersect(t, e) {
    return !(Q.separByA(t, e) || Q.separByA(e, t) || Q.separByB(t, e) || Q.separByB(e, t)) === !1 ? !1 : !(t.isSeg && e.isSeg) || !u.parallelWithinEpsilon(t.otherCorner.sub(t.corner), e.otherCorner.sub(e.corner), 1e-5) ? !0 : Q.ParallelSegsIntersect(e, t);
  }
  static ParallelSegsIntersect(t, e) {
    const i = t.corner, s = t.otherCorner, n = e.corner, r = e.otherCorner, a = s.sub(i), l = 0, h = a.dot(a);
    let c = n.sub(i).dot(a), d = r.sub(i).dot(a);
    if (c > d) {
      const f = c;
      c = d, d = f;
    }
    return !(d < l - m.distanceEpsilon || c > h + m.distanceEpsilon);
  }
  static separByB(t, e) {
    const i = m.distanceEpsilon, s = e.vertex(0).sub(t.corner).dot(t.bRot), n = [bi.VertexA, bi.otherCorner, bi.VertexB];
    if (s > t.abRot + i) {
      for (const r of n)
        if (e.vertex(r).sub(t.corner).dot(t.bRot) <= t.abRot + i)
          return !1;
      return !0;
    } else if (s < -i) {
      for (const r of n)
        if (e.vertex(r).sub(t.corner).dot(t.bRot) >= -i)
          return !1;
      return !0;
    }
    return !1;
  }
  static separByA(t, e) {
    const i = m.distanceEpsilon;
    let s = e.corner.sub(t.corner);
    const n = u.dot(s, t.aRot);
    return n > t.baRot + i ? (s = e.aPlusCorner.sub(t.corner), !(u.dot(s, t.aRot) <= t.baRot + i || (s = e.bPlusCorner.sub(t.corner), u.dot(s, t.aRot) <= t.baRot + i) || (s = e.otherCorner.sub(t.corner), u.dot(s, t.aRot) <= t.baRot + i))) : n < -i ? (s = e.aPlusCorner.sub(t.corner), !(u.dot(s, t.aRot) >= -i || (s = e.bPlusCorner.sub(t.corner), u.dot(s, t.aRot) >= -i) || (s = e.otherCorner.sub(t.corner), u.dot(s, t.aRot) >= -i))) : !1;
  }
  static parallelogramByCornerSideSide(t, e, i) {
    const s = new Q();
    return s.corner = t, s.a = e, s.b = i, s.aRot = new u(-e.y, e.x), s.aRot.length > 0.5 && (s.aRot = s.aRot.normalize()), s.bRot = new u(-i.y, i.x), s.bRot.length > 0.5 && (s.bRot = s.bRot.normalize()), s.abRot = s.bRot.dot(e), s.baRot = i.dot(s.aRot), s.abRot < 0 && (s.abRot = -s.abRot, s.bRot = s.bRot.neg()), s.baRot < 0 && (s.baRot = -s.baRot, s.aRot = s.aRot.neg()), s.isSeg = e.sub(i).length < m.distanceEpsilon, s.aPlusCorner = e.add(t), s.otherCorner = i.add(s.aPlusCorner), s.bPlusCorner = i.add(t), s;
  }
  static getParallelogramOfAGroup(t) {
    let e = 0, i = 0, s = 0, n = 0, r = !0;
    for (const a of t) {
      const l = fd(a);
      for (const h of l) {
        const c = h.x, d = h.y;
        r ? (r = !1, e = i = c, s = n = d) : (c < e ? e = c : c > i && (i = c), d < s ? s = d : d > n && (n = d));
      }
    }
    return Q.parallelogramByCornerSideSide(new u(e, s), new u(0, n - s), new u(i - e, 0));
  }
}
function* fd(o) {
  yield o.corner, yield o.aPlusCorner, yield o.otherCorner, yield o.bPlusCorner;
}
class v {
  static fromJSON(t) {
    return v.mkPP(u.fromJSON(t.start), u.fromJSON(t.end));
  }
  toJSON() {
    return { start: this.start.toJSON(), end: this.end.toJSON() };
  }
  // Offsets the curve in the direction of dir
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  offsetCurve(t, e) {
    return null;
  }
  constructor(t, e, i, s) {
    this.parStart = 0, this.parEnd = 1, this.start = new u(t, e), this.end = new u(i, s);
  }
  // Returns the trim curve
  trim(t, e) {
    if (t = Math.max(this.parStart, t), e = Math.min(this.parEnd, e), t > e)
      throw "wrong params in trimming";
    const i = this.value(t), s = this.value(e);
    return u.close(i, s, m.distanceEpsilon) ? null : v.mkPP(i, s);
  }
  value(t) {
    return this.start.add(this.end.sub(this.start).mul(t));
  }
  // Not Implemented: Returns the trimmed curve, wrapping around the end if start is greater than end.
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  trimWithWrap(t, e) {
    return null;
  }
  // not implemented
  // A tree of ParallelogramNodes covering the curve.
  // This tree is used in curve intersections routines.
  // <value></value>
  pNodeOverICurve() {
    const t = this.end.sub(this.start).mul(0.5);
    return {
      parallelogram: Q.parallelogramByCornerSideSide(this.start, t, t),
      seg: this,
      leafBoxesOffset: 0,
      node: {
        low: 0,
        high: 1,
        chord: this
      }
    };
  }
  normal() {
    let t = this.start.sub(this.end);
    return t = t.div(t.length), new u(-t.y, t.x);
  }
  // construct a line segment
  static mkPP(t, e) {
    return new v(t.x, t.y, e.x, e.y);
  }
  // constructs a line segment
  static mkLinePXY(t, e, i) {
    return new v(t.x, t.y, e, i);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  derivative(t) {
    return this.end.sub(this.start);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  secondDerivative(t) {
    return new u(0, 0);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  thirdDerivative(t) {
    return new u(0, 0);
  }
  reverse() {
    return v.mkPP(this.end, this.start);
  }
  /*
  static internal IntersectionInfo Cross(LineSeg coeff, LineSeg side1){
  IntersectionInfo xx=CrossTwoLines(coeff.start, coeff.End-coeff.start,side1.start, side1.End-side1.start);
  if (xx == null )
  {
  //parallel segs
  Point adir=coeff.d1(0);
  Point bdir=side1.d1(0);
  
  if (adir.length > bdir.length)
  {
  if (adir.length > Curve.DistEps)
  {
  adir = adir.normalize();
  if(Math.Abs((coeff-side1)*adir<Curve.DistEps)){
  
  }
  }
  }
  return null;
  }
  
  if(xx.Par0>1){
  if (Point.closeDistEps(coeff.End, xx.x))
  {
  xx.x = coeff.End;
  xx.Par0 = 1;
  }
  else
  return null;
  }
  else if(xx.Par0<0){
  if(Point.closeDistEps(coeff.start,xx.x)){
  xx.x=coeff.start;
  xx.Par0=1;
  }
  else
  return null;
  }
  
  if (xx.Par1 > 1)
  {
  if (Point.closeDistEps(side1.End, xx.x))
  {
  xx.x = coeff.End;
  xx.Par1 = 1;
  }
  else
  return null;
  }
  else if (xx.Par1 < 0)
  {
  if (Point.closeDistEps(side1.start, xx.x))
  {
  xx.x = coeff.start;
  xx.Par1 = 1;
  }
  else
  return null;
  }
  
  return xx;
  }
  * */
  // mutable! changes this
  // Returns the curved moved by delta
  translate(t) {
    this.start = this.start.add(t), this.end = this.end.add(t);
  }
  // Scale (multiply) from origin by x and y
  scaleFromOrigin(t, e) {
    return v.mkPP(this.start.scale(t, e), this.end.scale(t, e));
  }
  // gets the parameter at a specific length from the start along the curve
  getParameterAtLength(t) {
    const e = this.end.sub(this.start).length;
    if (e < m.tolerance)
      return 0;
    const i = t / e;
    return i > 1 ? 1 : i < 0 ? 0 : i;
  }
  // Return the transformed curve
  transform(t) {
    return v.mkPP(t.multiplyPoint(this.start), t.multiplyPoint(this.end));
  }
  // returns a parameter t such that the distance between curve[t] and targetPoint is minimal
  // and t belongs to the closed segment [low,high]
  closestParameterWithinBounds(t, e, i) {
    let s = this.closestParameter(t);
    return s < e && (s = e), s > i && (s = i), s;
  }
  // return length of the curve segment [start,end]
  lengthPartial(t, e) {
    return this.value(e).sub(this.value(t)).length;
  }
  // Get the length of the curve
  get length() {
    return this.start.sub(this.end).length;
  }
  // The bounding box of the line
  get boundingBox() {
    return T.mkPP(this.start, this.end);
  }
  // clones the curve.
  clone() {
    return v.mkPP(this.start.clone(), this.end.clone());
  }
  static closestParameterOnLineSegment(t, e, i) {
    const s = i.sub(e), n = t.sub(e), r = s.dot(n);
    if (r <= 0 + m.tolerance)
      return 0;
    const a = s.dot(s);
    return a <= r + m.tolerance ? 1 : r / a;
  }
  // returns a parameter t such that the distance between curve[t] and a is minimal
  closestParameter(t) {
    return v.closestParameterOnLineSegment(t, this.start, this.end);
  }
  // left derivative at t
  leftDerivative(t) {
    return this.derivative(t);
  }
  // right derivative at t
  rightDerivative(t) {
    return this.derivative(t);
  }
  // returns true if segments are not parallel and are intesecting
  static IntersectPPPP(t, e, i, s) {
    const n = u.lineLineIntersection(t, e, i, s);
    if (n != null && Ls(n, t, e) && Ls(n, i, s))
      return n;
  }
  //
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  curvature(t) {
    return 0;
  }
  //
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  curvatureDerivative(t) {
    return 0;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  curvatureSecondDerivative(t) {
    return 0;
  }
  // [a,b] and [c,d] are the segments. u and v are the corresponding closest point params
  // see http://www.geometrictools.com/Documentation/DistanceLine3Line3.pdf
  static minDistBetweenLineSegments(t, e, i, s) {
    const n = e.sub(t), r = s.sub(i), a = t.sub(i), l = u.crossProduct(n, r), h = n.dot(n), c = n.dot(r), d = r.dot(r), f = n.dot(a), p = r.dot(a);
    let P, y;
    const C = Math.abs(l);
    let E = C, N = C;
    C < m.tolerance ? (P = 0, E = 1, y = p, N = d) : (P = u.crossProduct(r, a), y = u.crossProduct(n, a), l < 0 && (P = -P, y = -y), P < 0 ? (P = 0, y = p, N = d) : P > E && (P = E = 1, y = p + c, N = d)), y < 0 ? (y = 0, -f < 0 ? P = 0 : -f > h ? P = E : (P = -f, E = h)) : y > N && (y = N = 1, -f + c < 0 ? P = 0 : -f + c > h ? P = E : (P = -f + c, E = h));
    const I = Math.abs(P) < m.tolerance ? 0 : P / E, x = Math.abs(y) < m.tolerance ? 0 : y / N;
    return {
      parab: I,
      parcd: x,
      // get the difference of the two closest points
      //           const dP = w + (parab * u) - (parcd * v),
      dist: a.add(n.mul(I).sub(r.mul(x))).length
      // return the closest distance
    };
  }
}
function Ls(o, t, e) {
  return o.x >= Math.min(t.x, e.x) - m.distanceEpsilon && o.y >= Math.min(t.y, e.y) - m.distanceEpsilon && o.x <= Math.max(t.x, e.x) + m.distanceEpsilon && o.y <= Math.max(t.y, e.y) + m.distanceEpsilon;
}
function Bh(o, t, e, i) {
  const s = u.getTriangleOrientation(o, t, e), n = u.getTriangleOrientation(o, t, i), r = u.getTriangleOrientation(e, i, o), a = u.getTriangleOrientation(e, i, t);
  return !!(s != n && r != a || s == L.Collinear && Ls(e, o, t) || n == L.Collinear && Ls(i, o, t) || r == L.Collinear && Ls(o, e, i) || a == L.Collinear && Ls(t, e, i));
}
function gd(o, t, e, i, s) {
  return {
    parallelogram: e,
    seg: i,
    leafBoxesOffset: s,
    node: {
      low: o,
      high: t,
      chord: null
      // create a cord only the segment and the chord are within intersectionEpsilon
    }
  };
}
class Ct {
  static distToSegm(t, e, i) {
    const s = i.sub(e);
    if (s.length < m.intersectionEpsilon)
      return t.sub(e.add(i).div(2)).length;
    let n = new u(-s.y, s.x);
    return n = n.mul(1 / n.length), Math.abs(t.sub(e).dot(n));
  }
  static createParallelogramOnSubSeg(t, e, i) {
    let s = i.derivative(t);
    const n = i.derivative(e), r = new u(-n.y, n.x), a = i.value(t), l = i.value(e), c = l.sub(a).dot(r), d = s.dot(r), f = Math.abs(c) < m.distanceEpsilon;
    if (!f && Math.abs(d) < m.distanceEpsilon)
      return;
    const p = f ? 0 : c / d;
    return s = s.mul(p), Q.parallelogramByCornerSideSide(a, s, l.sub(a).sub(s));
  }
  static createParallelogramNodeForCurveSeg(t, e, i, s) {
    if (t === i.parStart && e === i.parEnd && u.close(i.start, i.end, m.distanceEpsilon))
      return Ct.createNodeWithSegmentSplit(t, e, i, s);
    const r = i.value(t), a = i.value(e), l = a.sub(r), h = i.value((t + e) / 2);
    if (Ct.distToSegm(h, r, a) <= m.intersectionEpsilon && l.dot(l) < m.lineSegmentThreshold * m.lineSegmentThreshold && e - t < m.lineSegmentThreshold) {
      const c = v.mkPP(r, a), d = c.pNodeOverICurve();
      d.seg = i;
      const f = d.node;
      return f.low = t, f.high = e, f.chord = c, d;
    }
    if (Ct.WithinEpsilon(i, t, e, s)) {
      const c = Ct.createParallelogramOnSubSeg(t, e, i);
      if (c !== void 0)
        return gd(t, e, c, i, s);
    }
    return Ct.createNodeWithSegmentSplit(t, e, i, s);
  }
  static WithinEpsilon(t, e, i, s) {
    const r = (i - e) / 3, a = t.value(e), l = t.value(i);
    return Ct.distToSegm(t.value(e + r), a, l) > s ? !1 : Ct.distToSegm(t.value(e + r * 2), a, l) <= s;
  }
  static createParallelogramNodeForCurveSegDefaultOffset(t) {
    return Ct.createParallelogramNodeForCurveSeg(t.parStart, t.parEnd, t, m.defaultLeafBoxesOffset);
  }
  static createNodeWithSegmentSplit(t, e, i, s) {
    const n = {
      parallelogram: null,
      seg: i,
      leafBoxesOffset: 1,
      node: { children: [] }
    }, r = n.node;
    return r.children.push(Ct.createParallelogramNodeForCurveSeg(t, 0.5 * (t + e), i, s)), r.children.push(Ct.createParallelogramNodeForCurveSeg(0.5 * (t + e), e, i, s)), n.parallelogram = Q.parallelogramOfTwo(r.children[0].parallelogram, r.children[1].parallelogram), n;
  }
}
class Mi {
  // the constructor
  constructor(t, e, i, s, n) {
    this.par0 = t, this.par1 = e, this.x = i, this.seg0 = s, this.seg1 = n;
  }
}
class Ar {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static closestPoint(t, e, i, s, n) {
    let l = i, h = 0, c = 0, d, f = !1;
    do {
      const p = t.value(l), P = t.derivative(l), y = t.secondDerivative(l), C = P.dot(P) + p.sub(e).dot(y);
      if (Math.abs(C) < m.tolerance)
        return l;
      d = p.sub(e).dot(P.div(C)), l -= d, l > n + m.tolerance ? (l = n, c++) : l < s - m.tolerance && (l = s, c++), h++;
    } while (Math.abs(d) > m.tolerance && !(f = h >= 5 || c >= 5));
    return f && t.value(i).sub(e).length < m.distanceEpsilon && (l = i), l;
  }
}
class j {
  isFullEllipse() {
    return this.parEnd === Math.PI * 2 && this.parStart === 0;
  }
  static fromJSON(t) {
    return new j(t.parStart, t.parEnd, u.fromJSON(t.axis0), u.fromJSON(t.axis1), u.fromJSON(t.center));
  }
  toJSON() {
    return {
      parStart: this.parStart,
      parEnd: this.parEnd,
      axis0: this.aAxis.toJSON(),
      axis1: this.bAxis.toJSON(),
      center: this.center.toJSON()
    };
  }
  /** offsets the curve in the given direction */
  offsetCurve(t, e) {
    const i = e.sub(this.center), s = u.angle(this.aAxis, i);
    if (this.aAxis.mul(Math.cos(s)).add(this.bAxis.mul(Math.sin(s))).length < i.length) {
      const r = this.aAxis.length, a = this.bAxis.length;
      return j.mkEllipsePPP(this.aAxis.normalize().mul(r + t), this.bAxis.normalize().mul(a + t), this.center);
    }
    {
      const r = this.aAxis.length, a = this.bAxis.length;
      return j.mkEllipsePPP(this.aAxis.normalize().mul(r - t), this.bAxis.normalize().mul(a - t), this.center);
    }
  }
  /** Reverse the ellipe: not implemented. */
  reverse() {
    return null;
  }
  static mkEllipsePPP(t, e, i) {
    return new j(0, Math.PI * 2, t, e, i);
  }
  constructor(t, e, i, s, n) {
    for (this.parStart = t, this.parEnd = e, this.aAxis = i, this.bAxis = s, this.center = n, this.pNode = null, this.setBoundingBox(); this.parStart < 0; )
      this.parStart += Math.PI * 2, this.parEnd += Math.PI * 2;
  }
  get start() {
    return this.value(this.parStart);
  }
  get end() {
    return this.value(this.parEnd);
  }
  /** Trims the curve */
  trim(t, e) {
    return new j(Math.max(t, this.parStart), Math.min(e, this.parEnd), this.aAxis, this.bAxis, this.center);
  }
  // Not Implemented: Returns the trimmed curve, wrapping around the end if start is greater than end.
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  trimWithWrap(t, e) {
    return null;
  }
  /** The bounding box of the ellipse */
  get boundingBox() {
    return this.box;
  }
  /** Returns the point on the curve corresponding to parameter t */
  value(t) {
    return this.center.add(u.mkPoint(Math.cos(t), this.aAxis, Math.sin(t), this.bAxis));
  }
  /** first derivative */
  derivative(t) {
    return u.mkPoint(-Math.sin(t), this.aAxis, Math.cos(t), this.bAxis);
  }
  /** second derivative */
  secondDerivative(t) {
    return u.mkPoint(-Math.cos(t), this.aAxis, -Math.sin(t), this.bAxis);
  }
  /** third derivative */
  thirdDerivative(t) {
    return u.mkPoint(Math.sin(t), this.aAxis, -Math.cos(t), this.bAxis);
  }
  /** a tree of ParallelogramNodes covering the edge */
  pNodeOverICurve() {
    return this.pNode != null ? this.pNode : this.pNode = Ct.createParallelogramNodeForCurveSegDefaultOffset(this);
  }
  setBoundingBox() {
    if (D(this.parStart, 0) && D(this.parEnd, Math.PI * 2))
      this.box = this.fullBox();
    else {
      this.box = T.mkPP(this.start, this.end);
      let t;
      for (let e = Math.ceil(this.parStart / (Math.PI / 2)); (t = e * Math.PI / 2) < this.parEnd; e++)
        t > this.parStart && this.box.add(this.value(t));
    }
  }
  static mkEllipse(t, e, i, s, n, r) {
    return new j(t, e, i, s, new u(n, r));
  }
  /** Construct a full ellipse by two axes */
  static mkFullEllipsePPP(t, e, i) {
    return new j(0, Math.PI * 2, t, e, i);
  }
  /** Constructs a full ellipse with axes aligned to X and Y directions */
  static mkFullEllipseNNP(t, e, i) {
    return new j(0, Math.PI * 2, new u(t, 0), new u(0, e), i);
  }
  /** creates a circle by a given radius and the center */
  static mkCircle(t, e) {
    return j.mkFullEllipseNNP(t, t, e);
  }
  /** Moves the ellipse to the delta vector */
  translate(t) {
    this.center = this.center.add(t), this.box.center = this.box.center.add(t), this.pNode = null;
  }
  /** Scales the ellipse by x and by y */
  scaleFromOrigin(t, e) {
    return new j(this.parStart, this.parEnd, this.aAxis.mul(t), this.bAxis.mul(e), this.center.scale(t, e));
  }
  //
  getParameterAtLength(t) {
    let i = this.parStart, s = this.parEnd;
    const n = t + 1e-3, r = t - 1e-3;
    for (; s - i > m.distanceEpsilon; ) {
      const a = 0.5 * (s + i), l = this.lengthPartial(this.parStart, a);
      if (l > n)
        s = a;
      else if (l < r)
        i = a;
      else
        return a;
    }
    return (s + i) / 2;
  }
  /** Transforms the ellipse */
  transform(t) {
    if (t != null) {
      const e = t.multiplyPoint(this.aAxis).sub(t.offset()), i = t.multiplyPoint(this.bAxis).sub(t.offset());
      return new j(this.parStart, this.parEnd, e, i, t.multiplyPoint(this.center));
    }
    return this.clone();
  }
  /** returns a parameter t such that the distance between curve[t] and targetPoint is minimal
   * and t belongs to the closed segment [low,high] */
  closestParameterWithinBounds(t, e, i) {
    const n = (i - e) / 9;
    let r = e, a = Number.MAX_VALUE;
    for (let h = 0; h <= 8; h++) {
      const c = e + h * n, d = t.sub(this.value(c)), f = d.dot(d);
      f < a && (a = f, r = c);
    }
    r === 0 && i === Math.PI * 2 && (e = -Math.PI);
    let l = Ar.closestPoint(this, t, r, e, i);
    return l < 0 && (l += 2 * Math.PI), l;
  }
  // return length of the curve segment [start,end] : not implemented
  lengthPartial(t, e) {
    return g.lengthWithInterpolationAndThreshold(this.trim(t, e), m.lineSegmentThreshold / 100);
  }
  get length() {
    return (this.aAxis.length + this.bAxis.length) * Math.abs(this.parEnd - this.parStart) / 2;
  }
  /** clones the ellipse . */
  clone() {
    return new j(this.parStart, this.parEnd, this.aAxis.clone(), this.bAxis.clone(), this.center.clone());
  }
  /** returns a parameter t such that the distance between curve[t] and a is minimal */
  closestParameter(t) {
    let e = 0;
    const i = 8, s = (this.parEnd - this.parStart) / (i + 1);
    let n = this.parStart, r = Number.MAX_VALUE;
    for (let h = 0; h <= i; h++) {
      const c = this.parStart + h * s, d = t.sub(this.value(c)), f = d.dot(d);
      f < r && (r = f, n = c);
    }
    let a = !1;
    n === 0 && this.parEnd === Math.PI * 2 && (a = !0, e = this.parStart, this.parStart = -Math.PI);
    let l = Ar.closestPoint(this, t, n, this.parStart, this.parEnd);
    return l < 0 && (l += 2 * Math.PI), a && (this.parStart = e), l;
  }
  // left derivative at t
  leftDerivative(t) {
    return this.derivative(t);
  }
  // right derivative at t
  rightDerivative(t) {
    return this.derivative(t);
  }
  //
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  curvature(t) {
    throw "NotImplementedException()";
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  curvatureDerivative(t) {
    throw "NotImplementedException();";
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  curvatureSecondDerivative(t) {
    throw "NotImplementedException()";
  }
  // returns true if the ellipse goes counterclockwise
  orientedCounterclockwise() {
    return u.crossProduct(this.aAxis, this.bAxis) > 0;
  }
  //returns the box of the ellipse that this ellipse is a part of
  fullBox() {
    const t = this.aAxis.add(this.bAxis);
    return T.mkPP(this.center.add(t), this.center.sub(t));
  }
  /**is it a proper arc? meaning that it just a part of a circle */
  isArc() {
    return Math.abs(this.aAxis.dot(this.bAxis)) < m.tolerance && Math.abs(this.aAxis.length - this.bAxis.length) < m.tolerance && u.closeDistEps(this.aAxis.rotate90Ccw(), this.bAxis);
  }
}
class pd {
  initValues() {
    this.a = this.curveA.value(this.si), this.b = this.curveB.value(this.ti), this.a_b = this.a.sub(this.b), this.ad = this.curveA.derivative(this.si), this.add = this.curveA.secondDerivative(this.si), this.bd = this.curveB.derivative(this.ti), this.bdd = this.curveB.secondDerivative(this.ti);
  }
  // curveAPar">first curve</param>
  // curveBPar">second curve</param>
  // lowBound0">the first curve minimal parameter</param>
  // upperBound0">the first curve maximal parameter</param>
  // lowBound1">the second curve minimal parameter</param>
  // upperBound1">the first curve maximal parameter</param>
  // guess0"></param>
  // guess1"></param>
  constructor(t, e, i, s, n, r, a, l) {
    this.curveA = t, this.curveB = e, this.aMin = i, this.bMin = n, this.aMax = s, this.bMax = r, this.aGuess = a, this.bGuess = l, this.si = a, this.ti = l;
  }
  //we ignore the mulitplier 2 here fore efficiency reasons
  Fs() {
    return (
      /*2**/
      this.a_b.dot(this.ad)
    );
  }
  Fss() {
    return (
      /*2**/
      this.a_b.dot(this.add) + this.ad.dot(this.ad)
    );
  }
  Fst() {
    return -/*2**/
    this.bd.dot(this.ad);
  }
  Ftt() {
    return (
      /*2**/
      -this.a_b.dot(this.bdd) + this.bd.dot(this.bd)
    );
  }
  Ft() {
    return -/*2**/
    this.a_b.dot(this.bd);
  }
  // xy - the first row
  // uw - the second row
  delta(t, e, i, s) {
    return t * s - i * e;
  }
  //Fs + Fss*ds + Fst*dt = 0
  //Ft + Fst*ds + Ftt*dt = 0
  solve() {
    let t = 0;
    const e = 10;
    let i = 0;
    const s = 100;
    let n = !1;
    if (this.initValues(), this.curveA instanceof v && this.curveB instanceof v) {
      let a = this.curveB.derivative(0);
      a = a.div(a.length);
      const l = this.curveA.normal(), h = Math.abs(l.dot(a));
      if (Math.abs(h) < m.distanceEpsilon || this.delta(this.Fss(), this.Fst(), this.Fst(), this.Ftt()) < m.tolerance) {
        this.success = !0, this.parallelLineSegLineSegMinDist();
        return;
      }
    }
    let r;
    do {
      const a = this.delta(this.Fss(), this.Fst(), this.Fst(), this.Ftt());
      if (Math.abs(a) < m.tolerance) {
        this.success = !1, n = !0;
        break;
      }
      r = {
        s: this.delta(-this.Fs(), this.Fst(), -this.Ft(), this.Ftt()) / a,
        t: this.delta(this.Fss(), -this.Fs(), this.Fst(), -this.Ft()) / a
      };
      const l = this.si + r.s, h = this.ti + r.t;
      let c;
      l > this.aMax + m.distanceEpsilon || l < this.aMin - m.distanceEpsilon || h > this.bMax + m.distanceEpsilon || h < this.bMin - m.distanceEpsilon ? (t++, this.chopDsDt(r), this.si += r.s, this.ti += r.t, c = !0) : (c = !1, this.si = l, this.ti = h, this.si > this.aMax ? this.si = this.aMax : this.si < this.aMin && (this.si = this.aMin), this.ti > this.bMax ? this.ti = this.bMax : this.ti < this.bMin && (this.ti = this.bMin)), this.initValues(), i++, n = t >= e || i >= s || r.s === 0 && r.t === 0 && c;
    } while ((Math.abs(r.s) >= m.tolerance || Math.abs(r.t) >= m.tolerance) && !n);
    if (n) {
      const a = this.curveA.value(this.aGuess).sub(this.curveB.value(this.bGuess));
      if (a.dot(a) < m.distanceEpsilon * m.distanceEpsilon) {
        this.aSolution = this.aGuess, this.bSolution = this.bGuess, this.aPoint = this.curveA.value(this.aGuess), this.bPoint = this.curveB.value(this.bGuess), this.success = !0;
        return;
      }
    }
    this.aSolution = this.si, this.bSolution = this.ti, this.aPoint = this.a, this.bPoint = this.b, this.success = !n;
  }
  // d is is {s:number; d:number}
  chopDsDt(t) {
    if (t.s !== 0 && t.t !== 0) {
      let e = 1;
      this.si + t.s > this.aMax ? e = (this.aMax - this.si) / t.s : this.si + t.s < this.aMin && (e = (this.aMin - this.si) / t.s);
      let i = 1;
      this.ti + t.t > this.bMax ? i = (this.bMax - this.ti) / t.t : this.ti + t.t < this.bMin && (i = (this.bMin - this.ti) / t.t);
      const s = Math.min(e, i);
      t.s *= s, t.t *= s;
    } else t.s === 0 ? this.ti + t.t > this.bMax ? t.t = this.bMax - this.ti : this.ti + t.t < this.bMin && (t.t = this.bMin - this.ti) : this.si + t.s > this.aMax ? t.s = this.aMax - this.si : this.si + t.s < this.aMin && (t.s = this.aMin - this.si);
  }
  parallelLineSegLineSegMinDist() {
    const t = this.curveA, e = this.curveB, i = t.start, s = t.end, n = e.start, r = e.end;
    let a = s.sub(i);
    const l = a.length;
    let h = 0, c, d, f;
    if (l > m.distanceEpsilon) {
      a = a.div(l), c = a.dot(s.sub(i)), d = a.dot(n.sub(i)), f = a.dot(r.sub(i));
      let p = !1;
      if (d > f) {
        p = !0;
        const P = d;
        d = f, f = P;
      }
      if (f < h)
        this.aSolution = 0, this.bSolution = p ? 0 : 1;
      else if (d > c)
        this.aSolution = 1, this.bSolution = p ? 1 : 0;
      else {
        const P = Math.min(c, f);
        this.aSolution = P / (c - h), this.bSolution = (P - d) / (f - d), p && (this.bSolution = 1 - this.bSolution);
      }
    } else {
      let p = r.sub(n);
      const P = p.length;
      if (P > m.distanceEpsilon)
        if (p = p.div(P), h = 0, c = p.dot(r.sub(n)), d = p.dot(i.sub(n)), d < h)
          this.bSolution = 0, this.aSolution = 1;
        else if (d > c)
          this.bSolution = 1, this.aSolution = 0;
        else {
          const y = Math.min(c, d);
          this.bSolution = y / (c - h), this.aSolution = 0;
        }
      else
        this.aSolution = 0, this.bSolution = 0;
    }
    this.aPoint = this.curveA.value(this.aSolution), this.bPoint = this.curveB.value(this.bSolution);
  }
}
class st {
  toJSON() {
    return { b: this.b.map((t) => t.toJSON()) };
  }
  static fromJSON(t) {
    return st.mkBezier(t.b.map(u.fromJSON));
  }
  leftDerivative(t) {
    return this.derivative(t);
  }
  rightDerivative(t) {
    return this.derivative(t);
  }
  /** get a control point */
  B(t) {
    return this.b[t];
  }
  /** A tree of ParallelogramNodes covering the curve.
   This tree is used in curve intersections routines. */
  pNodeOverICurve() {
    return this.pBoxNode != null ? this.pBoxNode : this.pBoxNode = Ct.createParallelogramNodeForCurveSegDefaultOffset(this);
  }
  /** Returns the point on the curve corresponding to parameter t */
  value(t) {
    const e = t * t, i = e * t;
    return this.l.mul(i).add(this.e.mul(e).add(this.c.mul(t)).add(this.b[0]));
  }
  static adjustParamTo01(t) {
    return t > 1 ? 1 : t < 0 ? 0 : t;
  }
  /**throw away the segments [0,u] and [v,1] of the segment,
  Returns the trimmed curve */
  trim(t, e) {
    if (t = st.adjustParamTo01(t), e = st.adjustParamTo01(e), t > e)
      return this.trim(e, t);
    if (t > 1 - m.tolerance)
      return new st(this.b[3], this.b[3], this.b[3], this.b[3]);
    const i = new Array(3), s = new Array(2), n = this.casteljau(t, i, s), r = new st(n, s[1], i[2], this.b[3]), a = r.casteljau((e - t) / (1 - t), i, s);
    return new st(r.b[0], i[0], s[0], a);
  }
  // Not Implemented: Returns the trimmed curve, wrapping around the end if start is greater than end.
  trimWithWrap(t, e) {
    throw "NotImplementedException()";
  }
  //array for casteljau method
  casteljau(t, e, i) {
    const s = 1 - t;
    for (let n = 0; n < 3; n++)
      e[n] = u.mkPoint(s, this.b[n], t, this.b[n + 1]);
    for (let n = 0; n < 2; n++)
      i[n] = u.mkPoint(s, e[n], t, e[n + 1]);
    return u.mkPoint(s, i[0], t, i[1]);
  }
  // first derivative
  derivative(t) {
    return this.l.mul(3 * t * t).add(this.e.mul(2 * t)).add(this.c);
  }
  // second derivative
  secondDerivative(t) {
    return u.mkPoint(6 * t, this.l, 2, this.e);
  }
  // third derivative
  thirdDerivative(t) {
    return this.l.mul(6);
  }
  // the constructor
  constructor(t, e, i, s) {
    this.b = new Array(4), this.parStart = 0, this.parEnd = 1, this.b[0] = t, this.b[1] = e, this.b[2] = i, this.b[3] = s, this.c = this.b[1].sub(this.b[0]).mul(3), this.e = this.b[2].sub(this.b[1]).mul(3).sub(this.c), this.l = this.b[3].sub(this.b[0]).sub(this.c).sub(this.e);
  }
  get start() {
    return this.b[0];
  }
  get end() {
    return this.b[3];
  }
  // this[Reverse[t]]=this[ParEnd+ParStart-t]
  reverse() {
    return new st(this.b[3], this.b[2], this.b[1], this.b[0]);
  }
  // mutable! changes "this"
  // Returns the curved moved by delta
  translate(t) {
    this.b[0] = this.b[0].add(t), this.b[1] = this.b[1].add(t), this.b[2] = this.b[2].add(t), this.b[3] = this.b[3].add(t), this.c = this.b[1].sub(this.b[0]).mul(3), this.e = this.b[2].sub(this.b[1]).mul(3).sub(this.c), this.l = this.b[3].sub(this.b[0]).sub(this.c).sub(this.e), this.bbox && (this.bbox = T.translate(this.bbox, t)), this.pBoxNode = null;
  }
  // Returns the curved scaled by x and y
  scaleFromOrigin(t, e) {
    return new st(this.b[0].scale(t, e), this.b[1].scale(t, e), this.b[2].scale(t, e), this.b[3].scale(t, e));
  }
  // Offsets the curve in the direction of dir
  offsetCurve(t, e) {
    return null;
  }
  // return length of the curve segment [start,end]
  lengthPartial(t, e) {
    return this.trim(t, e).length;
  }
  // Get the length of the curve
  get length() {
    return st.lengthOnControlPolygon(this.b[0], this.b[1], this.b[2], this.b[3]);
  }
  //
  static lengthOnControlPolygon(t, e, i, s) {
    const n = s.sub(t).length, r = e.sub(t).length + i.sub(e).length + s.sub(i).length;
    if (r - n > m.lineSegmentThreshold) {
      const a = u.middle(t, e), l = u.middle(e, i), h = u.middle(i, s), c = u.middle(a, l), d = u.middle(h, l), f = u.middle(c, d);
      return st.lengthOnControlPolygon(t, a, c, f) + st.lengthOnControlPolygon(f, d, h, s);
    }
    return (r + n) / 2;
  }
  // the segment bounding box
  get boundingBox() {
    return this.bbox ? this.bbox : this.bbox = T.mkOnPoints(this.b);
  }
  // Return the transformed curve
  transform(t) {
    return new st(t.multiplyPoint(this.b[0]), t.multiplyPoint(this.b[1]), t.multiplyPoint(this.b[2]), t.multiplyPoint(this.b[3]));
  }
  // returns a parameter t such that the distance between curve[t] and targetPoint is minimal
  // and t belongs to the closed segment [low,high]
  closestParameterWithinBounds(t, e, i) {
    const s = (i - e) / 8;
    let n = 0, r = Number.MAX_VALUE;
    for (let a = 0; a < 9; a++) {
      const l = t.sub(this.value(a * s + e)), h = l.dot(l);
      h < r && (r = h, n = a * s + e);
    }
    return Ar.closestPoint(this, t, n, e, i);
  }
  // clones the curve.
  clone() {
    return new st(this.b[0], this.b[1], this.b[2], this.b[3]);
  }
  static mkBezier(t) {
    return new st(t[0], t[1], t[2], t[3]);
  }
  // the signed curvature of the segment at t
  curvature(t) {
    const e = this.G(t);
    return this.F(t) / e;
  }
  F(t) {
    return this.Xp(t) * this.Ypp(t) - this.Yp(t) * this.Xpp(t);
  }
  // G(t) is the denomenator of the curvature
  G(t) {
    const e = this.Xp(t), i = this.Yp(t), s = e * e + i * i;
    return Math.sqrt(s * s * s);
  }
  // the first derivative of x-coord
  Xp(t) {
    return 3 * this.l.x * t * t + 2 * this.e.x * t + this.c.x;
  }
  // the second derivativ of y-coordinate
  Ypp(t) {
    return 6 * this.l.y * t + 2 * this.e.y;
  }
  // the first derivative of y-coord
  Yp(t) {
    return 3 * this.l.y * t * t + 2 * this.e.y * t + this.c.y;
  }
  // the seconde derivative of x coord
  Xpp(t) {
    return 6 * this.l.x * t + 2 * this.e.x;
  }
  // the third derivative of x coordinate
  Xppp(t) {
    return 6 * this.l.x;
  }
  // the third derivative of y coordinate
  Yppp(t) {
    return 6 * this.l.y;
  }
  // the derivative of the curvature at t
  curvatureDerivative(t) {
    const e = this.G(t);
    return (this.Fp(t) * e - this.Gp(t) * this.F(t)) / (e * e);
  }
  Fp(t) {
    return this.Xp(t) * this.Yppp(t) - this.Yp(t) * this.Xppp(t);
  }
  Fpp(t) {
    return this.Xpp(t) * this.Yppp(t) - // + Xp(t) * Ypppp(t)=0
    this.Ypp(t) * this.Xppp(t);
  }
  // returns a parameter t such that the distance between curve[t] and a is minimal
  closestParameter(t) {
    let i = 0, s = Number.MAX_VALUE;
    for (let n = 0; n < 9; n++) {
      const r = t.sub(this.value(n * 0.125)), a = r.dot(r);
      a < s && (s = a, i = n * 0.125);
    }
    return Ar.closestPoint(this, t, i, 0, 1);
  }
  //
  curvatureSecondDerivative(t) {
    const e = this.G(t);
    return (this.Qp(t) * e - 2 * this.Q(t) * this.Gp(t)) / (e * e * e);
  }
  Q(t) {
    return this.Fp(t) * this.G(t) - this.Gp(t) * this.F(t);
  }
  Qp(t) {
    return this.Fpp(t) * this.G(t) - this.Gpp(t) * this.F(t);
  }
  Gpp(t) {
    const e = this.Xp(t), i = this.Yp(t), s = this.Xpp(t), n = this.Ypp(t), r = this.Xppp(t), a = this.Yppp(t), l = Math.sqrt(e * e + i * i), h = e * s + i * n;
    return 3 * (h * h / l + l * (s * s + e * r + n * n + i * a));
  }
  Gp(t) {
    const e = this.Xp(t), i = this.Yp(t), s = this.Xpp(t), n = this.Ypp(t);
    return 3 * Math.sqrt(e * e + i * i) * (e * s + i * n);
  }
  getParameterAtLength(t) {
    let e = 0, i = 1;
    for (; i - e > m.tolerance; ) {
      const s = (i + e) / 2, n = this.evaluateError(t, s);
      if (n > 0)
        i = s;
      else if (n < 0)
        e = s;
      else
        return s;
    }
    return (e + i) / 2;
  }
  evaluateError(t, e) {
    const i = 1 - e, s = u.mkPoint(i, this.b[0], e, this.b[1]), n = u.mkPoint(i, this.b[1], e, this.b[2]), r = u.mkPoint(i, this.b[2], e, this.b[3]), a = u.mkPoint(i, s, e, n), l = u.mkPoint(i, n, e, r), h = u.mkPoint(i, a, e, l), c = st.lengthOnControlPolygon(this.b[0], s, a, h);
    return c > t + m.distanceEpsilon ? 1 : c < t - m.distanceEpsilon ? -1 : 0;
  }
}
function md(o) {
  return o.seg.value(o.par);
}
function Pd(o) {
  return o.seg.derivative(o.par);
}
function Sd(o) {
  return o.seg.secondDerivative(o.par);
}
function yd(o) {
  return o.seg.thirdDerivative(o.par);
}
var F;
(function(o) {
  o[o.Outside = 0] = "Outside", o[o.Boundary = 1] = "Boundary", o[o.Inside = 2] = "Inside";
})(F || (F = {}));
function bd(o) {
  if (o instanceof j)
    return { tag: "ellipse", segData: o.toJSON() };
  if (o instanceof v)
    return { tag: "lineSegment", segData: o.toJSON() };
  if (o instanceof st)
    return { tag: "bezier", segData: o.toJSON() };
  throw new Error("not implemented");
}
class g {
  static fromJSON(t) {
    const e = new g();
    for (const i of t.segs)
      switch (i.tag) {
        case "bezier":
          e.addSegment(st.fromJSON(i.segData));
          break;
        case "ellipse":
          e.addSegment(j.fromJSON(i.segData));
          break;
        case "lineSegment":
          e.addSegment(v.fromJSON(i.segData));
          break;
        default:
          throw new Error("not implemented");
      }
    return e;
  }
  toJSON() {
    return { segs: this.segs.map((t) => bd(t)) };
  }
  static CurvesIntersect(t, e) {
    return t === e || g.intersectionOne(t, e, !1) != null;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static lengthWithInterpolationAndThreshold(t, e) {
    throw new Error("not implemented");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static lengthWithInterpolation(t) {
    throw "not implemented";
  }
  get parStart() {
    return 0;
  }
  get parEnd() {
    return this.parEnd_;
  }
  lengthPartial(t, e) {
    const i = {
      start: t,
      end: e
    };
    this.adjustStartEndEndParametersToDomain(i);
    const s = this.getSegIndexParam(t), n = this.getSegIndexParam(e);
    if (s.segIndex < n.segIndex) {
      let r = this.segs[s.segIndex], a = r.lengthPartial(s.par, r.parEnd);
      for (let l = s.segIndex + 1; l < n.segIndex; l++)
        a += this.segs[l].length;
      return r = this.segs[n.segIndex], a + r.lengthPartial(r.parStart, n.par);
    } else
      throw new Error("not implemented.");
  }
  // this[Reverse[t]]=this[ParEnd+ParStart-t]
  reverse() {
    const t = new g();
    for (let e = this.segs.length - 1; e >= 0; e--)
      t.addSegment(this.segs[e].reverse());
    return t;
  }
  // Constructs the curve for a given number of segments
  constructor() {
    this.segs = [], this.parEnd_ = 0;
  }
  mkCurveWithSegs(t) {
    this.segs = t;
    for (const e of t)
      this.parEnd_ += g.paramSpan(e);
  }
  get start() {
    return this.segs[0].start;
  }
  get end() {
    return this.segs[this.segs.length - 1].end;
  }
  scaleFromOrigin(t, e) {
    const i = new g();
    for (const s of this.segs)
      i.addSegment(s.scaleFromOrigin(t, e));
    return i;
  }
  // Returns the trimmed curve
  trim(t, e) {
    const i = {
      start: t,
      end: e
    };
    this.adjustStartEndEndParametersToDomain(i);
    const s = this.getSegIndexParam(i.start), n = this.getSegIndexParam(i.end);
    if (s.segIndex === n.segIndex)
      return this.segs[s.segIndex].trim(s.par, n.par);
    let r = new g();
    s.par < this.segs[s.segIndex].parEnd && (r = r.addSegment(this.segs[s.segIndex].trim(s.par, this.segs[s.segIndex].parEnd)));
    for (let a = s.segIndex + 1; a < n.segIndex; a++)
      r = r.addSegment(this.segs[a]);
    return this.segs[n.segIndex].parStart < n.par && (r = r.addSegment(this.segs[n.segIndex].trim(this.segs[n.segIndex].parStart, n.par))), r;
  }
  translate(t) {
    for (const e of this.segs)
      e.translate(t);
    this.boundingBox_ && (this.boundingBox_ = T.translate(this.boundingBox_, t)), this.pBNode = null;
  }
  adjustStartEndEndParametersToDomain(t) {
    if (t.start > t.end) {
      const e = t.start;
      t.start = t.end, t.end = e;
    }
    t.start < this.parStart && (t.start = this.parStart), t.end > this.parEnd && (t.end = this.parEnd);
  }
  // Returns the trimmed curve, wrapping around the end if start is greater than end.
  trimWithWrap(t, e) {
    if (t < e)
      return this.trim(t, e);
    const i = new g();
    return i.addSegment(this.trim(t, this.parEnd)), i.addSegment(this.trim(this.parStart, e)), i;
  }
  addSegs(t) {
    for (const e of t)
      this.addSegment(e);
    return this;
  }
  // Adds a segment to the curve
  addSegment(t) {
    if (t == null)
      return this;
    if (this.boundingBox_ = null, !(t instanceof g))
      this.segs.push(t), this.parEnd_ += g.paramSpan(t);
    else
      for (const e of t.segs)
        this.segs.push(e), this.parEnd_ += g.paramSpan(e);
    return this;
  }
  // A tree of ParallelogramNodes covering the curve.
  // This tree is used in curve intersections routines.
  pNodeOverICurve() {
    if (this.pBNode != null)
      return this.pBNode;
    const t = [], e = [];
    for (const i of this.segs) {
      const s = i.pNodeOverICurve();
      t.push(s.parallelogram), e.push(s);
    }
    return this.pBNode = {
      parallelogram: Q.getParallelogramOfAGroup(t),
      seg: this,
      leafBoxesOffset: m.defaultLeafBoxesOffset,
      node: { children: e }
    }, this.pBNode;
  }
  // finds an intersection between to curves,
  static intersectionOne(t, e, i) {
    let s = g.curveCurveXWithParallelogramNodesOne(t.pNodeOverICurve(), e.pNodeOverICurve());
    return i && s != null && (s = g.liftIntersectionToCurves(t, e, s)), s;
  }
  /**
   *   Calculates all intersections between curve0 and curve1.
   *  If liftIntersections is true then the intersections parameters
   *  recalculated, lifted, to the curve parameter domain. Otherwise they * stay in the segment domains
   */
  static getAllIntersections(t, e, i) {
    return t instanceof v ? g.getAllIntersectionsOfLineAndICurve(t, e, i) : g.getAllIntersectionsInternal(t, e, i);
  }
  static getAllIntersectionsInternal(t, e, i) {
    const s = [];
    if (g.curveCurveXWithParallelogramNodes(t.pNodeOverICurve(), e.pNodeOverICurve(), s), i)
      for (let n = 0; n < s.length; n++)
        s[n] = g.liftIntersectionToCurves(t, e, s[n]);
    return s;
  }
  static getAllIntersectionsOfLineAndICurve(t, e, i) {
    return e instanceof B ? g.getAllIntersectionsOfLineAndPolyline(t, e) : e instanceof g ? g.getAllIntersectionsOfLineAndCurve(t, e, i) : e instanceof j && e.isArc() ? g.getAllIntersectionsOfLineAndArc(t, e) : g.getAllIntersectionsInternal(t, e, i);
  }
  static getAllIntersectionsOfLineAndCurve(t, e, i) {
    const s = [], n = t.pNodeOverICurve(), r = e.pNodeOverICurve();
    if (Q.intersect(n.parallelogram, r.parallelogram) === !1)
      return s;
    let a = 0;
    for (const l of e.segs) {
      const h = g.getAllIntersections(t, l, !1);
      if (i) {
        for (const c of h)
          c.par1 += a - l.parStart, c.seg1 = e;
        a += l.parEnd - l.parStart;
      }
      for (const c of h)
        g.alreadyInside(s, c) || s.push(c);
    }
    return s;
  }
  static closeIntersections(t, e) {
    return u.close(t.x, e.x, m.intersectionEpsilon);
  }
  static closeIntersectionPoints(t, e) {
    return u.close(t, e, m.intersectionEpsilon);
  }
  static alreadyInside(t, e) {
    for (let i = 0; i < t.length; i++) {
      const s = t[i];
      if (g.closeIntersections(s, e))
        return !0;
    }
    return !1;
  }
  static getAllIntersectionsOfLineAndArc(t, e) {
    let i = t.end.sub(t.start);
    const s = [], n = i.length;
    if (n < m.distanceEpsilon) {
      const d = t.start.sub(e.center);
      if (D(d.length, e.aAxis.length)) {
        let f = u.angle(e.aAxis, d);
        e.parStart - m.tolerance <= f && (f = Math.max(f, e.parStart), f <= e.parEnd + m.tolerance && (f = Math.min(e.parEnd, f), s.push(new Mi(0, f, t.start, t, e))));
      }
      return s;
    }
    const r = i.rotate90Ccw().div(n), a = t.start.sub(e.center).dot(r), l = e.center.add(r.mul(a)), h = e.aAxis.length, c = Math.abs(a);
    if (h < c - m.distanceEpsilon)
      return s;
    if (i = r.rotate90Cw(), D(h, c))
      g.tryToAddPointToLineCircleCrossing(t, e, s, l, n, i);
    else {
      const d = Math.sqrt(h * h - a * a), f = i.mul(d);
      g.tryToAddPointToLineCircleCrossing(t, e, s, l.add(f), n, i), g.tryToAddPointToLineCircleCrossing(t, e, s, l.sub(f), n, i);
    }
    return s;
  }
  static tryToAddPointToLineCircleCrossing(t, e, i, s, n, r) {
    let l = s.sub(t.start).dot(r);
    if (l < -m.distanceEpsilon || (l = Math.max(l, 0), l > n + m.distanceEpsilon))
      return;
    l = Math.min(l, n), l /= n;
    let h = u.angle(e.aAxis, s.sub(e.center));
    e.parStart - m.tolerance <= h && (h = Math.max(h, e.parStart), h <= e.parEnd + m.tolerance && (h = Math.min(e.parEnd, h), i.push(new Mi(l, h, s, t, e))));
  }
  static getAllIntersectionsOfLineAndPolyline(t, e) {
    const i = [];
    let s = 0, n = e.startPoint;
    for (; n != null && n.getNext() != null; n = n.getNext()) {
      const r = g.crossTwoLineSegs(t.start, t.end, n.point, n.getNext().point, 0, 1, 0, 1);
      r && (g.adjustSolution(t.start, t.end, n.point, n.getNext().point, r), g.oldIntersection(i, r.x) || i.push(new Mi(r.aSol, s + r.bSol, r.x, t, e))), s++;
    }
    if (e.closed) {
      const r = g.crossTwoLineSegs(t.start, t.end, n.point, e.start, 0, 1, 0, 1);
      r && (g.adjustSolution(t.start, t.end, n.point, e.start, r), g.oldIntersection(i, r.x) || i.push(new Mi(r.aSol, s + r.bSol, r.x, t, e)));
    }
    return i;
  }
  static adjustSolution(t, e, i, s, n) {
    g.closeIntersectionPoints(n.x, t) ? (n.x = t, n.aSol = 0) : g.closeIntersectionPoints(n.x, e) && (n.x = e, n.aSol = 1), g.closeIntersectionPoints(n.x, i) ? (n.x = i, n.bSol = Math.floor(n.bSol)) : g.closeIntersectionPoints(n.x, s) && (n.x = s, n.bSol = Math.ceil(n.bSol));
  }
  static curveCurveXWithParallelogramNodesOne(t, e) {
    if (!Q.intersect(t.parallelogram, e.parallelogram))
      return null;
    const i = t.node, s = e.node, n = i.hasOwnProperty("children"), r = s.hasOwnProperty("children");
    if (n && r)
      for (const a of i.children)
        for (const l of s.children) {
          const h = g.curveCurveXWithParallelogramNodesOne(a, l);
          if (h != null)
            return h;
        }
    else if (r)
      for (const a of s.children) {
        const l = g.curveCurveXWithParallelogramNodesOne(t, a);
        if (l != null)
          return l;
      }
    else if (n)
      for (const a of i.children) {
        const l = g.curveCurveXWithParallelogramNodesOne(a, e);
        if (l != null)
          return l;
      }
    else
      return g.crossOverIntervalsOne(t, e);
    return null;
  }
  static curveCurveXWithParallelogramNodes(t, e, i) {
    if (!Q.intersect(t.parallelogram, e.parallelogram))
      return;
    const s = t.node.hasOwnProperty("children"), n = e.node.hasOwnProperty("children");
    if (s && n)
      for (const r of t.node.children)
        for (const a of e.node.children)
          g.curveCurveXWithParallelogramNodes(r, a, i);
    else if (n)
      for (const r of e.node.children)
        g.curveCurveXWithParallelogramNodes(t, r, i);
    else if (s)
      for (const r of t.node.children)
        g.curveCurveXWithParallelogramNodes(r, e, i);
    else
      i = g.crossOverLeaves(t, e, i);
  }
  static crossOverIntervalsOne(t, e) {
    const i = t.node, s = e.node, n = (i.high - i.low) / 2, r = (s.high - s.low) / 2;
    for (let a = 1; a < 2; a++) {
      const l = a * n + i.low;
      for (let h = 1; h < 2; h++) {
        const c = h * r + s.low;
        let d;
        if (i.chord == null && s.chord == null ? d = g.crossWithinIntervalsWithGuess(t.seg, e.seg, i.low, i.high, s.low, s.high, l, c) : i.chord != null && s.chord == null ? d = g.crossWithinIntervalsWithGuess(i.chord, e.seg, 0, 1, s.low, s.high, 0.5 * a, c) : i.chord == null ? (d = g.crossWithinIntervalsWithGuess(t.seg, s.chord, i.low, i.high, 0, 1, l, 0.5 * h), d && (d.bSol = s.low + d.bSol * (s.high - s.low))) : (d = g.crossWithinIntervalsWithGuess(i.chord, s.chord, 0, 1, 0, 1, 0.5 * a, 0.5 * h), d && (d.aSol = i.low + d.aSol * (i.high - i.low), d.bSol = s.low + d.bSol * (s.high - s.low))), d)
          return g.createIntersectionOne(t, e, d.aSol, d.bSol, d.x);
      }
    }
    return g.goDeeperOne(t, e);
  }
  static crossOverLeaves(t, e, i) {
    const s = t.node, n = e.node;
    let r = !1;
    const a = (s.high - s.low) / 2 + s.low, l = (n.high - n.low) / 2 + n.low;
    let h;
    return s.chord == null && n.chord == null ? h = g.crossWithinIntervalsWithGuess(t.seg, e.seg, s.low, s.high, n.low, n.high, a, l) : s.chord != null && n.chord == null ? (h = g.crossWithinIntervalsWithGuess(s.chord, e.seg, 0, 1, n.low, n.high, 0.5, l), h && (h.aSol = s.low + h.aSol * (s.high - s.low))) : s.chord == null ? (h = g.crossWithinIntervalsWithGuess(t.seg, n.chord, s.low, s.high, 0, 1, a, 0.5), h && (h.bSol = n.low + h.bSol * (n.high - n.low))) : (h = g.crossWithinIntervalsWithGuess(s.chord, n.chord, 0, 1, 0, 1, 0.5, 0.5), h && (h.bSol = n.low + h.bSol * (n.high - n.low), h.aSol = s.low + h.aSol * (s.high - s.low))), h && (g.addIntersection(t, e, i, h), r = !0), r || g.goDeeper(i, t, e), i;
  }
  static addIntersection(t, e, i, s) {
    const n = t.node;
    g.closeIntersectionPoints(s.x, t.seg.value(n.low)) ? (s.x = t.seg.value(n.low), s.aSol = n.low) : g.closeIntersectionPoints(s.x, t.seg.value(n.high)) && (s.x = t.seg.value(n.high), s.aSol = n.high);
    const r = e.node;
    if (g.closeIntersectionPoints(s.x, e.seg.value(r.low)) ? (s.x = e.seg.value(r.low), s.bSol = r.low) : g.closeIntersectionPoints(s.x, e.seg.value(r.high)) && (s.x = e.seg.value(r.high), s.bSol = r.high), !g.oldIntersection(i, s.x)) {
      const l = new Mi(s.aSol, s.bSol, s.x, t.seg, e.seg);
      i.push(l);
    }
  }
  // returns true if the intersection exists already
  static oldIntersection(t, e) {
    for (const i of t)
      if (e.sub(i.x).length < m.distanceEpsilon * 100)
        return !0;
    return !1;
  }
  static createIntersectionOne(t, e, i, s, n) {
    const r = t.node, a = e.node;
    return g.closeIntersectionPoints(n, t.seg.value(r.low)) ? (n = t.seg.value(r.low), i = r.low) : g.closeIntersectionPoints(n, t.seg.value(r.high)) && (n = t.seg.value(r.high), i = r.high), g.closeIntersectionPoints(n, e.seg.value(a.low)) ? (n = e.seg.value(a.low), s = a.low) : g.closeIntersectionPoints(n, e.seg.value(a.high)) && (n = e.seg.value(a.high), s = a.high), new Mi(i, s, n, t.seg, e.seg);
  }
  static liftIntersectionToCurves_(t, e, i, s, n, r, a) {
    const l = t instanceof g ? g.liftParameterToCurve(t, i - r.parStart, r) : i, h = e instanceof g ? g.liftParameterToCurve(e, s - a.parStart, a) : s;
    return new Mi(l, h, n, t, e);
  }
  static DropIntersectionToSegs(t) {
    let e, i;
    if (t.seg0 instanceof g) {
      const r = t.seg0.getSegParam(t.par0);
      e = r.seg, i = r.par;
    } else
      i = t.par0, e = t.seg0;
    let s, n;
    if (t.seg1 instanceof g) {
      const r = t.seg1.getSegParam(t.par1);
      n = r.par, s = r.seg;
    } else
      n = t.par1, s = t.seg1;
    return new Mi(i, n, t.x, e, s);
  }
  static liftIntersectionToCurves(t, e, i) {
    return g.liftIntersectionToCurves_(t, e, i.par0, i.par1, i.x, i.seg0, i.seg1);
  }
  static liftParameterToCurve(t, e, i) {
    if (t === i)
      return e;
    if (!t.hasOwnProperty("segs"))
      return;
    const s = t;
    let n = 0;
    for (const r of s.segs) {
      if (r === i)
        return e + n;
      n += g.paramSpan(r);
    }
    throw "bug in liftParameterToCurve";
  }
  static paramSpan(t) {
    return t.parEnd - t.parStart;
  }
  static goDeeperOne(t, e) {
    const i = t.node, s = e.node;
    if (t.leafBoxesOffset > m.distanceEpsilon && e.leafBoxesOffset > m.distanceEpsilon) {
      const a = Ct.createParallelogramNodeForCurveSeg(i.low, i.high, t.seg, t.leafBoxesOffset / 2), l = Ct.createParallelogramNodeForCurveSeg(s.low, s.high, e.seg, e.leafBoxesOffset / 2);
      return g.curveCurveXWithParallelogramNodesOne(a, l);
    }
    if (t.leafBoxesOffset > m.distanceEpsilon) {
      const a = Ct.createParallelogramNodeForCurveSeg(i.low, i.high, t.seg, t.leafBoxesOffset / 2);
      return g.curveCurveXWithParallelogramNodesOne(a, e);
    }
    if (e.leafBoxesOffset > m.distanceEpsilon) {
      const a = Ct.createParallelogramNodeForCurveSeg(s.low, s.high, e.seg, e.leafBoxesOffset / 2);
      return g.curveCurveXWithParallelogramNodesOne(t, a);
    }
    const n = t.seg.value(i.low), r = t.seg.value(i.high);
    if (!u.closeDistEps(n, r)) {
      const a = e.seg.value(s.low), l = e.seg.value(s.high);
      if (!u.closeDistEps(a, l)) {
        const h = t.seg instanceof v ? t.seg : v.mkPP(n, r), c = e.seg instanceof v ? e.seg : v.mkPP(a, l), d = g.crossWithinIntervalsWithGuess(h, c, 0, 1, 0, 1, 0.5, 0.5);
        if (d)
          return g.adjustParameters(t, h, e, c, d), g.createIntersectionOne(t, e, d.aSol, d.bSol, d.x);
      }
    }
    return null;
  }
  static goDeeper(t, e, i) {
    const s = e.node, n = i.node, r = e.leafBoxesOffset > m.distanceEpsilon, a = i.leafBoxesOffset > m.distanceEpsilon;
    if (r && a) {
      const l = Ct.createParallelogramNodeForCurveSeg(s.low, s.high, e.seg, e.leafBoxesOffset / 2), h = Ct.createParallelogramNodeForCurveSeg(n.low, n.high, i.seg, i.leafBoxesOffset / 2);
      g.curveCurveXWithParallelogramNodes(l, h, t);
    } else if (r) {
      const l = Ct.createParallelogramNodeForCurveSeg(s.low, s.high, e.seg, e.leafBoxesOffset / 2);
      g.curveCurveXWithParallelogramNodes(l, i, t);
    } else if (a) {
      const l = Ct.createParallelogramNodeForCurveSeg(n.low, n.high, i.seg, i.leafBoxesOffset / 2);
      g.curveCurveXWithParallelogramNodes(e, l, t);
    } else {
      const l = e.seg.value(s.low), h = e.seg.value(s.high);
      if (!u.closeDistEps(l, h)) {
        const c = i.seg.value(n.low), d = i.seg.value(n.high);
        if (!u.closeDistEps(c, d)) {
          const f = e.seg instanceof v ? e.seg : v.mkPP(l, h), p = i.seg instanceof v ? i.seg : v.mkPP(c, d), P = g.crossWithinIntervalsWithGuess(f, p, 0, 1, 0, 1, 0.5, 0.5);
          P && (g.adjustParameters(e, f, i, p, P), g.addIntersection(e, i, t, P));
        }
      }
    }
  }
  static adjustParameters(t, e, i, s, n) {
    if (e !== t.seg && !(t.seg instanceof B))
      n.aSol = t.seg.closestParameter(n.x);
    else {
      const r = t.node;
      n.aSol = r.low + n.aSol * (r.high - r.low);
    }
    if (s !== i.seg && !(i.seg instanceof B))
      n.bSol = i.seg.closestParameter(n.x);
    else {
      const r = i.node;
      n.bSol = r.low + n.bSol * (r.high - r.low);
    }
  }
  // returns the segment correspoinding to t and the segment parameter
  getSegParam(t) {
    let e = this.parStart;
    for (const s of this.segs) {
      const n = e + s.parEnd - s.parStart;
      if (t >= e && t <= n)
        return {
          par: t - e + s.parStart,
          seg: s
        };
      e = n;
    }
    const i = this.segs[this.segs.length - 1];
    return {
      seg: i,
      par: i.parEnd
    };
  }
  /** return the segment index and the parameter inside of the segment */
  getSegIndexParam(t) {
    let e = 0;
    const i = this.segs.length;
    for (let n = 0; n < i; n++) {
      const r = this.segs[n], a = e + r.parEnd - r.parStart;
      if (t >= e && t <= a)
        return {
          segIndex: n,
          par: t - e + r.parStart
        };
      e = a;
    }
    const s = this.segs[i - 1];
    return {
      segIndex: i - 1,
      par: s.parEnd
    };
  }
  // Returns the point on the curve corresponding to parameter t
  value(t) {
    return md(this.getSegParam(t));
  }
  // first derivative at t
  derivative(t) {
    return Pd(this.getSegParam(t));
  }
  // second derivative
  secondDerivative(t) {
    return Sd(this.getSegParam(t));
  }
  // third derivative
  thirdDerivative(t) {
    return yd(this.getSegParam(t));
  }
  // For curves A(s) and B(t), when we have some evidence that
  // there is at most one intersection point, and we have a guess for the parameters (s0, t0)...
  // You are trying to bring to (0,0) the vector F(s,t) = A(s) - B(t).  To minimize the length of F(s,t)
  // we solve the system of equations:
  //F*Fs + (F*Fss + Fs*Fs)ds + (F*Fst + Fs*Ft)dt = 0
  //F*Ft + (F*Fst + Fs*Ft)ds + (F*Ftt + Ft*Ft)dt = 0
  //
  //Where F = F(si,ti), Fs and Ft are the first partials at si, ti, Fxx are the second partials,
  //   and s(i+1) = si+ds, t(i+1) = ti+dt.
  //We adjust ds and dt to stay in the domain.
  static crossWithinIntervalsWithGuess(t, e, i, s, n, r, a, l) {
    if (t instanceof v && e instanceof v) {
      const d = g.crossTwoLineSegs(t.start, t.end, e.start, e.end, i, s, n, r);
      if (d !== void 0)
        return d;
    }
    const h = g.minDistWithinIntervals(t, e, i, s, n, r, a, l);
    if (h == null)
      return;
    const c = h.aX.sub(h.bX);
    return c.dot(c) >= m.distanceEpsilon ? void 0 : {
      aSol: h.aSol,
      bSol: h.bSol,
      x: u.middle(h.aX, h.bX)
    };
  }
  static crossTwoLineSegs(t, e, i, s, n, r, a, l) {
    const h = e.sub(t), c = i.sub(s), d = i.sub(t), f = Yi.solve(h.x, c.x, d.x, h.y, c.y, d.y);
    if (f == null)
      return;
    let p = f.x, P = f.y;
    const y = t.add(h.mul(p));
    if (!(p < n - m.tolerance) && (p = Math.max(p, n), !(p > r + m.tolerance) && (p = Math.min(p, r), !(P < a - m.tolerance) && (P = Math.max(P, a), !(P > l + m.tolerance)))))
      return P = Math.min(P, l), {
        aSol: p,
        bSol: P,
        x: y
      };
  }
  // Decides if the point lies inside, outside or on the curve
  static PointRelativeToCurveLocation(t, e) {
    if (!e.boundingBox.contains(t))
      return F.Outside;
    const i = 2 * e.boundingBox.diagonal, s = Math.PI / 180;
    let n = 0;
    for (let r = 13; r < 360; r += 13) {
      const a = new u(Math.cos(r * s), Math.sin(r * s)), l = v.mkPP(t, t.add(a.mul(i))), h = this.getAllIntersectionsOfLineAndICurve(l, e, !0);
      if (g.AllIntersectionsAreGood(h, e)) {
        for (const d of h)
          if (u.closeDistEps(d.x, t))
            return F.Boundary;
        if (h.length % 2 === 1 ? n++ : n--, n >= 2)
          return F.Inside;
        if (n <= -2)
          return F.Outside;
      }
    }
    return F.Boundary;
  }
  static AllIntersectionsAreGood(t, e) {
    const i = e.hasOwnProperty("segs");
    let s = null;
    if (i || e instanceof B && (s = e.toCurve()), s) {
      for (const n of t)
        if (!g.RealCut(g.DropIntersectionToSegs(n), s, !1))
          return !1;
    }
    return !0;
  }
  static RealCut(t, e, i) {
    const s = t.seg0, n = t.seg1, r = t.par0, a = t.par1, l = t.x, h = s.derivative(r).normalize(), c = n.derivative(a).normalize().rotate(Math.PI / 2);
    if (u.closeDistEps(l, n.end)) {
      let f = null;
      for (let y = 0; y < e.segs.length - 1; y++)
        if (e.segs[y] === n) {
          f = e.segs[y + 1];
          break;
        }
      if (f == null)
        return !1;
      const p = h.rotate(Math.PI / 2);
      return !(p.dot(n.derivative(n.parEnd)) * p.dot(f.derivative(f.parStart)) < m.tolerance);
    }
    if (u.closeDistEps(l, n.start)) {
      let f = null;
      for (let y = e.segs.length - 1; y > 0; y--)
        if (e.segs[y] === n) {
          f = e.segs[y - 1];
          break;
        }
      if (f == null)
        return !1;
      const p = h.rotate(Math.PI / 2);
      return !(p.dot(n.derivative(n.parStart)) * p.dot(f.derivative(f.parEnd)) < m.tolerance);
    }
    const d = h.dot(c);
    return i ? d > m.distanceEpsilon : Math.abs(d) > m.distanceEpsilon;
  }
  //   static boolean debug;
  // Returns true if curves do not touch in the intersection point
  // only when the second curve cuts the first one from the inside</param>
  static realCutWithClosedCurve(t, e, i) {
    const s = t.seg0, n = t.seg1, r = t.par0, a = t.par1, l = t.x, h = s.derivative(r).normalize(), c = n.derivative(a).normalize().rotate(Math.PI / 2);
    if (u.closeDistEps(l, n.end)) {
      let f = null;
      for (let y = 0; y < e.segs.length; y++)
        if (e.segs[y] === n) {
          f = e.segs[(y + 1) % e.segs.length];
          break;
        }
      if (f == null)
        throw new Error();
      const p = h.rotate(Math.PI / 2);
      return !(p.dot(n.derivative(n.parEnd)) * p.dot(f.derivative(f.parStart)) < m.tolerance);
    }
    if (u.closeDistEps(l, n.start)) {
      let f = null;
      for (let y = 0; y < e.segs.length; y++)
        if (e.segs[y] === n) {
          f = e.segs[y > 0 ? y - 1 : e.segs.length - 1];
          break;
        }
      const p = h.rotate(Math.PI / 2);
      return !(p.dot(n.derivative(n.parStart)) * p.dot(f.derivative(f.parEnd)) < m.tolerance);
    }
    const d = h.dot(c);
    return i ? d > m.distanceEpsilon : Math.abs(d) > m.distanceEpsilon;
  }
  /*
  
  if (Point.closeDistEps(x, pseg.start)) {
  //so pseg exits the spline
  ICurve enterSeg = null;
  for (int i = polyline.segs.length - 1; i > 0; i--)
  if (polyline.segs[i] === pseg) {
  enterSeg = polyline.segs[i - 1];
  break;
  }
  if (enterSeg == null )
  return false;
  Point tsn = ts.rotate((Math.PI/2));
  boolean touch = (tsn*pseg.derivative(pseg.Parstart))*
  (tsn*enterSeg.derivative(enterSeg.parEnd)) < GeomConstants.tolerance;
  
  return !touch;
  }
  
  number d = ts*pn;
  if (onlyFromInsideCuts)
  return d > GeomConstants.distanceEpsilon;
  return Math.Abs(d) > GeomConstants.distanceEpsilon;
  }
  */
  static minDistWithinIntervals(t, e, i, s, n, r, a, l) {
    const h = new pd(t, e, i, s, n, r, a, l);
    return h.solve(), h.success ? {
      aSol: h.aSolution,
      bSol: h.bSolution,
      aX: h.aPoint,
      bX: h.bPoint
    } : void 0;
  }
  /*
      #if DEBUGCURVES
      public override string ToString()
      {
      boolean poly = true;
      for (ICurve s of segs)
      if (s is LineSeg === false)
      {
      poly = false;
      break;
      }
      
      string ret;
      if (!poly)
      {
      ret = "{";
      
      for (ICurve seg of Segs)
      {
      ret += seg + ",";
      }
      
      
      return ret + "}";
      }
      ret = "{";
      if (segs.length > 0)
      ret += segs[0].start.x.ToString() + "," + segs[0].start.y.ToString()+" ";
      for(LineSeg s of segs)
      ret += s.end.x.ToString() + "," + s.end.y.ToString() + " ";
      return ret + "}";
      }
      #endif
   */
  // Offsets the curve in the direction of dir
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  offsetCurve(t, e) {
    throw new Error("Method not implemented.");
  }
  /**
   * The bounding rectangle of the curve
   */
  get boundingBox() {
    if (this.boundingBox_)
      return this.boundingBox_;
    if (this.segs.length === 0)
      this.boundingBox_ = T.mkEmpty();
    else {
      const t = this.segs[0].boundingBox.clone();
      for (let e = 1; e < this.segs.length; e++)
        t.addRecSelf(this.segs[e].boundingBox);
      return this.boundingBox_ = t;
    }
  }
  /**  clones the curve */
  clone() {
    const t = new g();
    for (const e of this.segs)
      t.addSegment(e.clone());
    return this.boundingBox_ != null && (t.boundingBox_ = this.boundingBox_.clone()), t;
  }
  getParameterAtLength(t) {
    let e = 0;
    for (const i of this.segs) {
      const s = i.length;
      if (s >= t)
        return e + i.getParameterAtLength(t);
      t -= s, e += i.parEnd - i.parStart;
    }
    return this.parEnd;
  }
  get length() {
    let t = 0;
    for (const e of this.segs)
      t += e.length;
    return t;
  }
  /** returns a new curve */
  transform(t) {
    const e = new g();
    for (const i of this.segs)
      e.addSegment(i.transform(t));
    return this.boundingBox_ && (e.boundingBox_ = this.boundingBox_.transform(t)), e;
  }
  // returns a parameter t such that the distance between curve[t] and targetPoint is minimal
  // and t belongs to the closed segment [low,high]
  closestParameterWithinBounds(t, e, i) {
    let s = 0, n = Number.MAX_VALUE, r = 0;
    for (const a of this.segs) {
      if (r > i)
        break;
      const l = g.paramSpan(a);
      if (r + l >= e) {
        const c = Math.max(a.parStart, a.parStart + (e - r)), d = Math.min(a.parEnd, a.parStart + (i - r)), f = a.closestParameterWithinBounds(t, c, d), p = t.sub(a.value(f)), P = p.dot(p);
        P < n && (s = r + f - a.parStart, n = P);
      }
      r += l;
    }
    return s;
  }
  // returns a parameter t such that the distance between curve[t] and a is minimal
  closestParameter(t) {
    let e = 0, i = Number.MAX_VALUE, s = 0;
    for (const n of this.segs) {
      const r = n.closestParameter(t), a = t.sub(n.value(r)), l = a.dot(a);
      if (l < i) {
        if (e = s + r - n.parStart, l === 0)
          break;
        i = l;
      }
      s += g.paramSpan(n);
    }
    return e;
  }
  static addLineSegment(t, e, i) {
    return t.addSegment(v.mkPP(e, i));
  }
  static addLineSegmentCNNP(t, e, i, s) {
    return g.addLineSegment(t, new u(e, i), s);
  }
  // adds a line segment to the curve
  static addLineSegmentCNNNN(t, e, i, s, n) {
    g.addLineSegment(t, new u(e, i), new u(s, n));
  }
  // adds a line segment to the curve
  static continueWithLineSegmentNN(t, e, i) {
    g.addLineSegment(t, t.end, new u(e, i));
  }
  // adds a line segment to the curve
  static continueWithLineSegmentP(t, e) {
    g.addLineSegment(t, t.end, e);
  }
  static closeCurve(t) {
    return g.continueWithLineSegmentP(t, t.start), t;
  }
  // left derivative at t
  leftDerivative(t) {
    const e = this.tryToGetLeftSegment(t);
    return e != null ? e.derivative(e.parEnd) : this.derivative(t);
  }
  // right derivative at t
  rightDerivative(t) {
    const e = this.tryToGetRightSegment(t);
    return e != null ? e.derivative(e.parStart) : this.derivative(t);
  }
  tryToGetLeftSegment(t) {
    if (Math.abs(t - this.parStart) < m.tolerance)
      return this.start.equal(this.end) ? this.segs[this.segs.length - 1] : null;
    for (const e of this.segs)
      if (t -= g.paramSpan(e), Math.abs(t) < m.tolerance)
        return e;
    return null;
  }
  tryToGetRightSegment(t) {
    if (Math.abs(t - this.parEnd) < m.tolerance)
      return this.start === this.end ? this.segs[0] : null;
    for (const e of this.segs) {
      if (Math.abs(t) < m.tolerance)
        return e;
      t -= g.paramSpan(e);
    }
    return null;
  }
  /*
         // gets the closest point together with its parameter
         public static number closestParameterWithPoint(ICurve curve, Point location, out Point pointOnCurve) {
  
         number t = curve.closestParameter(location);
         pointOnCurve = curve[t];
         return t;
         }
         */
  // gets the point on the curve that is closest to the given point
  static ClosestPoint(t, e) {
    return t.value(t.closestParameter(e));
  }
  // Tests whether the first curve is inside the second.
  // We suppose that the curves are convex and they are
  // not degenerated into a point
  static CurveIsInsideOther(t, e) {
    if (!e.boundingBox.containsRect(t.boundingBox))
      return !1;
    const i = g.getAllIntersections(t, e, !0);
    if (i.length === 0)
      return g.NonIntersectingCurveIsInsideOther(t, e);
    if (i.length === 1)
      return t.start.equal(i[0].x) ? g.PointRelativeToCurveLocation(t.value((t.parStart + t.parEnd) / 2), e) == F.Inside : g.PointRelativeToCurveLocation(t.start, e) === F.Inside;
    for (const s of g.PointsBetweenIntersections(t, i))
      if (g.PointRelativeToCurveLocation(s, e) === F.Outside)
        return !1;
    return !0;
  }
  // Return points between but not including the intersections.
  static *PointsBetweenIntersections(t, e) {
    e.sort((a, l) => a.par0 - l.par0);
    for (let a = 0; a < e.length - 1; a++)
      yield t.value((e[a].par0 + e[a + 1].par0) / 2);
    const i = e[e.length - 1].par0, s = e[0].par0, n = t.parEnd - i + (s - t.parStart);
    let r = i + n / 2;
    r > t.parEnd && (r = t.parStart + (r - t.parEnd)), yield t.value(r);
  }
  static NonIntersectingCurveIsInsideOther(t, e) {
    for (let i = t.parStart; i < t.parEnd; i += 0.5) {
      const s = g.PointRelativeToCurveLocation(t.value(i), e);
      if (F.Boundary !== s)
        return F.Inside === s;
    }
    return F.Outside !== g.PointRelativeToCurveLocation(t.end, e);
  }
  // Tests whether the interiors of two closed convex curves intersect
  static ClosedCurveInteriorsIntersect(t, e) {
    if (!e.boundingBox.intersects(t.boundingBox))
      return !1;
    const i = g.getAllIntersections(t, e, !0);
    if (i.length === 0)
      return g.NonIntersectingCurveIsInsideOther(t, e) || g.NonIntersectingCurveIsInsideOther(e, t);
    if (i.length === 1)
      return t.start.equal(i[0].x) ? g.PointRelativeToCurveLocation(t.value((t.parStart + t.parEnd) / 2), e) === F.Inside || !e.start.equal(i[0].x) ? g.PointRelativeToCurveLocation(e.start, t) === F.Inside : g.PointRelativeToCurveLocation(e.value((e.parStart + e.parEnd) / 2), t) === F.Inside : g.PointRelativeToCurveLocation(t.start, e) === F.Inside;
    for (const s of g.PointsBetweenIntersections(t, i))
      if (g.PointRelativeToCurveLocation(s, e) === F.Inside)
        return !0;
    return !0;
  }
  // ICurve Members
  curvature(t) {
    const e = this.getSegParam(t);
    return e.seg.curvature(e.par);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  curvatureDerivative(t) {
    throw new Error("Not implemente");
  }
  //
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  curvatureSecondDerivative(t) {
    throw new Error("Not implemented");
  }
  /*  #endregion
       
       public static boolean CurvesIntersect(ICurve curve1, ICurve curve2) {
       return curve1 === curve2 || (CurveCurveIntersectionOne(curve1, curve2, false) != null);
       }
       */
  static createBezierSeg(t, e, i, s, n) {
    const r = u.mkPoint(t, i.point, 1 - t, s.point), a = u.mkPoint(e, n.point, 1 - e, s.point), l = s.point.mul(2 / 3);
    return new st(r, r.div(3).add(l), l.add(a.div(3)), a);
  }
  static createBezierSegN(t, e, i, s) {
    const n = i.mul(s);
    return new st(t, t.add(n), e.add(n), e);
  }
  static findCorner(t) {
    const e = t.next;
    if (e.next == null)
      return;
    const i = e.next;
    if (i != null)
      return { b: e, c: i };
  }
  static trimEdgeSplineWithNodeBoundaries(t, e, i, s) {
    let n = i.parStart, r = i.parEnd;
    t != null && (n = g.findNewStart(i, n, t, s)), e != null && (r = g.findNewEnd(i, e, s, r));
    const a = Math.min(n, r), l = Math.max(n, r);
    return a < l ? i.trim(a, l) : i;
  }
  static findNewEnd(t, e, i, s) {
    const n = g.getAllIntersections(t, e, !0);
    if (n.length === 0)
      return s = t.parEnd, s;
    if (i) {
      s = t.parEnd;
      for (const r of n)
        r.par0 < s && (s = r.par0);
    } else {
      s = t.parStart;
      for (const r of n)
        r.par0 > s && (s = r.par0);
    }
    return s;
  }
  static findNewStart(t, e, i, s) {
    const n = g.getAllIntersections(t, i, !0);
    if (n.length === 0) {
      e = t.parStart;
      return;
    }
    if (s) {
      e = t.parStart;
      for (const r of n)
        r.par0 > e && (e = r.par0);
    } else {
      e = t.parEnd;
      for (const r of n)
        r.par0 < e && (e = r.par0);
    }
    return e;
  }
  static polylineAroundClosedCurve(t) {
    if (t instanceof j)
      return g.refineEllipse(t);
    if (t instanceof B)
      return t;
    if (t instanceof g && g.allSegsAreLines(t)) {
      const e = new B();
      for (const i of t.segs)
        e.addPoint(i.start);
      if (e.closed = !0, !e.isClockwise())
        return e.reverse();
    }
    return t.boundingBox.perimeter();
  }
  static allSegsAreLines(t) {
    for (const e of t.segs)
      if (!(e instanceof v))
        return !1;
    return !0;
  }
  // this code only works for the standard ellipse
  static refineEllipse(t) {
    const e = t.boundingBox.perimeter(), i = Math.PI / 4, s = t.boundingBox.width, n = t.boundingBox.height, r = Math.sqrt(s * s + n * n), a = [];
    for (let h = 0; h < 4; h++) {
      const c = i + h * Math.PI / 2, d = t.value(c), f = t.derivative(c).normalize().mul(r), p = v.mkPP(d.sub(f), d.add(f));
      for (const P of g.getAllIntersections(e, p, !0))
        a.push(P);
    }
    a.sort((h, c) => h.par0 < c.par0 ? -1 : h.par0 > c.par0 ? 1 : 0);
    const l = new B();
    return a.forEach((h) => l.addPoint(h.x)), l.closed = !0, l;
  }
  // Create a closed Polyline from a rectangle
  static polyFromBox(t) {
    const e = new B();
    return e.addPoint(t.leftTop), e.addPoint(t.rightTop), e.addPoint(t.rightBottom), e.addPoint(t.leftBottom), e.closed = !0, e;
  }
}
class B {
  constructor() {
    this.initIsRequired = !0, this.isClosed_ = !1;
  }
  toJSON() {
    return { points: Array.from(this).map((t) => t.toJSON()) };
  }
  static fromJSON(t) {
    return B.mkFromPoints(t.points.map((e) => u.fromJSON(e)));
  }
  RemoveStartPoint() {
    const t = this.startPoint.next;
    t.prev = null, this.startPoint = t, this.setInitIsRequired();
  }
  RemoveEndPoint() {
    const t = this.endPoint.prev;
    t.next = null, this.endPoint = t, this.setInitIsRequired();
  }
  setInitIsRequired() {
    this.initIsRequired = !0;
  }
  addPointXY(t, e) {
    this.addPoint(new u(t, e));
  }
  /** should true, by internal assumptions,  in general for convex polylines */
  isClockwise() {
    return u.getTriangleOrientation(this.startPoint.point, this.startPoint.next.point, this.startPoint.next.next.point) == L.Clockwise;
  }
  /**  adds a point to the polyline */
  addPoint(t) {
    const e = new ei();
    e.polyline = this, e.point = t.clone(), this.endPoint != null ? (this.endPoint.next = e, e.prev = this.endPoint, this.endPoint = e) : this.startPoint = this.endPoint = e, this.setInitIsRequired();
  }
  PrependPoint(t) {
    const e = ei.mkFromPoint(t);
    e.polyline = this, this.startPoint != null ? u.closeDistEps(t, this.startPoint.point) || (this.startPoint.prev = e, e.next = this.startPoint, this.startPoint = e) : (this.endPoint = e, this.startPoint = e), this.setInitIsRequired();
  }
  *[Symbol.iterator]() {
    for (let t = this.startPoint; t != null; t = t.next)
      yield t.point;
  }
  *polylinePoints() {
    for (let t = this.startPoint; t != null; t = t.next)
      yield t;
  }
  *skip(t) {
    for (let e = this.startPoint; e != null; e = e.next)
      t > 0 ? t-- : yield e;
  }
  static parallelogramOfLineSeg(t, e) {
    const i = e.sub(t).div(2);
    return Q.parallelogramByCornerSideSide(t, i, i);
  }
  static mkFromPoints(t) {
    const e = new B();
    for (const i of t)
      e.addPoint(i);
    return e;
  }
  static mkClosedFromPoints(t) {
    const e = B.mkFromPoints(t);
    return e.closed = !0, e;
  }
  calculatePbNode() {
    const t = [], e = [];
    let i = this.startPoint, s = 0;
    for (; i.next != null; ) {
      const n = B.parallelogramOfLineSeg(i.point, i.next.point);
      t.push(n), e.push({
        parallelogram: n,
        seg: this,
        leafBoxesOffset: 0,
        node: {
          low: s,
          high: s + 1,
          chord: v.mkPP(i.point, i.next.point)
        }
      }), i = i.next, s++;
    }
    if (this.isClosed_) {
      const n = B.parallelogramOfLineSeg(this.endPoint.point, this.startPoint.point);
      t.push(n), e.push({
        parallelogram: n,
        seg: this,
        leafBoxesOffset: 0,
        node: {
          low: s,
          high: s + 1,
          chord: v.mkPP(this.endPoint.point, this.startPoint.point)
        }
      });
    }
    this.pBNode = {
      parallelogram: Q.getParallelogramOfAGroup(t),
      seg: this,
      leafBoxesOffset: 0,
      node: {
        children: e
      }
    };
  }
  init() {
    this.bBox = T.rectangleOnPoint(this.startPoint.point);
    for (const t of this.skip(1))
      this.bBox.add(t.point);
    this.updateCount(), this.calculatePbNode(), this.initIsRequired = !1;
  }
  updateCount() {
    this.count_ = 0;
    for (let t = this.startPoint; t != null; t = t.next)
      this.count_++;
  }
  get count() {
    return this.initIsRequired && this.init(), this.count_;
  }
  get closed() {
    return this.isClosed_;
  }
  set closed(t) {
    this.isClosed_ = t;
  }
  value(t) {
    this.initIsRequired && this.init();
    const e = this.getAdjustedParamAndStartEndPoints(t);
    return u.convSum(e.t, e.a, e.b);
  }
  getAdjustedParamAndStartEndPoints(t) {
    let e = this.startPoint;
    for (; e.next != null; ) {
      if (t <= 1)
        return {
          a: e.point,
          b: e.next.point,
          t
        };
      e = e.next, t -= 1;
    }
    if (this.closed && t <= 1)
      return {
        a: this.endPoint.point,
        b: this.startPoint.point,
        t
      };
    throw new Error("out of the parameter domain");
  }
  derivative(t) {
    const e = this.getAdjustedParamAndStartEndPoints(t);
    return e.b.sub(e.a);
  }
  secondDerivative(t) {
    return new u(0, 0);
  }
  thirdDerivative(t) {
    return new u(0, 0);
  }
  pNodeOverICurve() {
    return this.initIsRequired && this.init(), this.pBNode;
  }
  get boundingBox() {
    return this.initIsRequired && this.init(), this.bBox;
  }
  get parStart() {
    return 0;
  }
  get parEnd() {
    return this.initIsRequired && this.init(), this.closed ? this.count_ : this.count_ - 1;
  }
  static polylineFromCurve(t) {
    const e = new B();
    e.addPoint(t.start);
    for (const i of t.segs)
      e.addPoint(i.end);
    return e.closed = t.start === t.end, e;
  }
  trim(t, e) {
    let i = this.toCurve();
    return i = i.trim(t, e), i instanceof g ? B.polylineFromCurve(i) : B.mkFromPoints([i.start, i.end]);
  }
  trimWithWrap(t, e) {
    throw new Error("Method not implemented.");
  }
  translate(t) {
    let e = this.startPoint;
    do {
      if (e.point = e.point.add(t), e === this.endPoint)
        break;
      e = e.getNext();
    } while (!0);
    this.setInitIsRequired();
  }
  scaleFromOrigin(t, e) {
    throw new Error("Method not implemented.");
  }
  get start() {
    return this.startPoint.point;
  }
  get end() {
    return this.endPoint.point;
  }
  reverse() {
    const t = new B();
    t.closed = this.closed;
    let e = this.endPoint;
    do {
      if (t.addPoint(e.point), e === this.startPoint)
        break;
      e = e.getPrev();
    } while (!0);
    return t;
  }
  offsetCurve(t, e) {
    throw new Error("Method not implemented.");
  }
  lengthPartial(t, e) {
    throw new Error("Method not implemented.");
  }
  get length() {
    throw new Error("Method not implemented.");
  }
  getParameterAtLength(t) {
    throw new Error("Method not implemented.");
  }
  transform(t) {
    const e = new B();
    for (const i of this.polylinePoints())
      e.addPoint(t.multiplyPoint(i.point));
    return e.closed = this.closed, e;
  }
  closestParameterWithinBounds(t, e, i) {
    throw new Error("Method not implemented.");
  }
  closestParameter(t) {
    let e = 0, i = Number.MAX_VALUE, s = 0, n = this.startPoint;
    for (; n.next != null; ) {
      const r = v.mkPP(n.point, n.next.point), a = r.closestParameter(t), l = r.value(a).sub(t), h = l.dot(l);
      h < i && (i = h, e = a + s), n = n.next, s++;
    }
    if (this.closed) {
      const r = v.mkPP(this.endPoint.point, this.startPoint.point), a = r.closestParameter(t), l = r.value(a).sub(t);
      l.dot(l) < i && (e = a + s);
    }
    return e;
  }
  clone() {
    const t = new B();
    t.closed = this.closed;
    let e = this.startPoint;
    do {
      if (t.addPoint(e.point), e === this.endPoint)
        break;
      e = e.getNext();
    } while (!0);
    return t;
  }
  leftDerivative(t) {
    throw new Error("Method not implemented.");
  }
  rightDerivative(t) {
    throw new Error("Method not implemented.");
  }
  curvature(t) {
    throw new Error("Method not implemented.");
  }
  curvatureDerivative(t) {
    throw new Error("Method not implemented.");
  }
  curvatureSecondDerivative(t) {
    throw new Error("Method not implemented.");
  }
  next(t) {
    var e;
    return (e = t.next) !== null && e !== void 0 ? e : this.closed ? this.startPoint : null;
  }
  prev(t) {
    var e;
    return (e = t.prev) !== null && e !== void 0 ? e : this.closed ? this.endPoint : null;
  }
  toCurve() {
    const t = new g();
    g.addLineSegment(t, this.startPoint.point, this.startPoint.next.point);
    let e = this.startPoint.next;
    for (; (e = e.next) != null; )
      g.continueWithLineSegmentP(t, e.point);
    return this.closed && g.continueWithLineSegmentP(t, this.startPoint.point), t;
  }
  RemoveCollinearVertices() {
    for (let t = this.startPoint.next; t.next != null; t = t.next)
      u.getTriangleOrientation(t.prev.point, t.point, t.next.point) === L.Collinear && (t.prev.next = t.next, t.next.prev = t.prev);
    return this.setInitIsRequired(), this;
  }
}
class Ai {
  pad(t) {
    this.width += t * 2;
  }
  /** creates a square if called with width only */
  constructor(t, e = t) {
    this.width = t, this.height = e;
  }
}
class T {
  /** this function will not work correctly for transformations that are not translations, or rotations by n*90, or a combination of those */
  transform(t) {
    return T.mkPP(t.multiplyPoint(this.leftTop), t.multiplyPoint(this.rightBottom));
  }
  translate(t) {
    return T.mkSizeCenter(this.size, this.center.add(t));
  }
  /** Returns true iff the rectangles are geometrically identical */
  equal(t) {
    return this.left_ === t.left && this.right_ === t.right && this.top_ === t.top && this.bottom_ === t.bottom;
  }
  /** Returns true iff the rectangles are distEpsilon close */
  equalEps(t) {
    return D(this.left_, t.left) && D(this.right_, t.right) && D(this.top_, t.top) && D(this.bottom_, t.bottom);
  }
  /** make a rectangle with the given size and center */
  static mkSizeCenter(t, e) {
    const i = t.width / 2, s = t.height / 2;
    return new T({
      left: e.x - i,
      right: e.x + i,
      bottom: e.y - s,
      top: e.y + s
    });
  }
  constructor(t) {
    this.left_ = t.left, this.right_ = t.right, this.top_ = t.top, this.bottom = t.bottom;
  }
  add_rect(t) {
    return this.addRec(t);
  }
  contains_point(t) {
    return this.contains(t);
  }
  contains_rect(t) {
    return this.containsRect(t);
  }
  intersection_rect(t) {
    return this.intersection(t);
  }
  intersects_rect(t) {
    return this.intersects(t);
  }
  unite(t) {
    return T.rectangleOfTwo(this, t);
  }
  contains_point_radius(t, e) {
    return this.containsWithPadding(t, e);
  }
  // returns true if r intersect this rectangle
  intersects(t) {
    return this.intersectsOnX(t) && this.intersectsOnY(t);
  }
  // intersection (possibly empty) of rectangles
  intersection(t) {
    if (!this.intersects(t)) {
      const r = T.mkEmpty();
      return r.setToEmpty(), r;
    }
    const e = Math.max(this.left, t.left), i = Math.min(this.right, t.right), s = Math.max(this.bottom, t.bottom), n = Math.min(this.top, t.top);
    return new T({ left: e, bottom: s, right: i, top: n });
  }
  // the center of the bounding box
  get center() {
    return this.leftTop.add(this.rightBottom).mul(0.5);
  }
  set center(t) {
    const e = this.leftTop.add(this.rightBottom).mul(0.5), i = t.sub(e);
    this.leftTop = this.leftTop.add(i), this.rightBottom = this.rightBottom.add(i);
  }
  intersectsOnY(t) {
    return !(t.bottom_ > this.top_ + m.distanceEpsilon || t.top_ < this.bottom_ - m.distanceEpsilon);
  }
  intersectsOnX(t) {
    return !(t.left > this.right_ + m.distanceEpsilon || t.right < this.left_ - m.distanceEpsilon);
  }
  // creates an empty rectangle
  static mkEmpty() {
    return new T({ left: 0, right: -1, bottom: 0, top: -1 });
  }
  get left() {
    return this.left_;
  }
  set left(t) {
    this.left_ = t, this.onUpdated();
  }
  get right() {
    return this.right_;
  }
  set right(t) {
    this.right_ = t, this.onUpdated();
  }
  get top() {
    return this.top_;
  }
  set top(t) {
    this.top_ = t, this.onUpdated();
  }
  get bottom() {
    return this.bottom_;
  }
  set bottom(t) {
    this.bottom_ = t, this.onUpdated();
  }
  get leftBottom() {
    return new u(this.left_, this.bottom_);
  }
  set leftBottom(t) {
    this.left_ = t.x, this.bottom = t.y;
  }
  get rightTop() {
    return new u(this.right_, this.top_);
  }
  set rightTop(t) {
    this.right_ = t.x, this.top_ = t.y;
  }
  get leftTop() {
    return new u(this.left_, this.top_);
  }
  set leftTop(t) {
    this.left_ = t.x, this.top_ = t.y;
  }
  get rightBottom() {
    return new u(this.right_, this.bottom_);
  }
  set rightBottom(t) {
    this.right_ = t.x, this.bottom = t.y;
  }
  /* eslint-disable  @typescript-eslint/no-empty-function */
  onUpdated() {
  }
  // create a box of two points
  static mkPP(t, e) {
    const i = new T({
      left: t.x,
      right: t.x,
      top: t.y,
      bottom: t.y
    });
    return i.add(e), i;
  }
  // create rectangle from a point
  static rectangleOnPoint(t) {
    return new T({ left: t.x, right: t.x, top: t.y, bottom: t.y });
  }
  static mkLeftBottomSize(t, e, i) {
    const s = t + i.width, n = e + i.height;
    return new T({ left: t, right: s, top: n, bottom: e });
  }
  // create a box on points (x0,y0), (x1,y1)
  static getRectangleOnCoords(t, e, i, s) {
    const n = new T({ left: t, bottom: e, right: t, top: e });
    return n.add(new u(i, s)), n;
  }
  // Create rectangle that is the bounding box of the given points
  static mkOnPoints(t) {
    const e = T.mkEmpty();
    for (const i of t)
      e.add(i);
    return e;
  }
  // Create rectangle that is the bounding box of the given Rectangles
  static mkOnRectangles(t) {
    const e = T.mkEmpty();
    for (const i of t)
      e.addRecSelf(i);
    return e;
  }
  // the width of the rectangle
  get width() {
    return this.right_ - this.left_;
  }
  set width(t) {
    const e = t / 2, i = (this.left_ + this.right_) / 2;
    this.left_ = i - e, this.right_ = i + e;
  }
  // returns true if the rectangle has negative width
  isEmpty() {
    return this.right < this.left;
  }
  // makes the rectangle empty
  setToEmpty() {
    this.left = 0, this.right = -1;
  }
  // height of the rectangle
  get height() {
    return this.top_ - this.bottom_;
  }
  set height(t) {
    const e = t / 2, i = (this.top_ + this.bottom_) / 2;
    this.top_ = i + e, this.bottom = i - e;
  }
  // rectangle containing both a and b
  static rectangleOfTwo(t, e) {
    const i = new T({
      left: t.left_,
      right: t.right_,
      top: t.top_,
      bottom: t.bottom_
    });
    return i.addRecSelf(e), i;
  }
  // contains with padding
  containsWithPadding(t, e) {
    return this.left_ - e - m.distanceEpsilon <= t.x && t.x <= this.right_ + e + m.distanceEpsilon && this.bottom_ - e - m.distanceEpsilon <= t.y && t.y <= this.top_ + e + m.distanceEpsilon;
  }
  // Rectangle area
  get area() {
    return (this.right_ - this.left_) * (this.top_ - this.bottom_);
  }
  // adding a point to the rectangle
  add(t) {
    this.isEmpty() ? (this.left_ = this.right_ = t.x, this.top_ = this.bottom = t.y) : (this.left_ > t.x && (this.left_ = t.x), this.top_ < t.y && (this.top_ = t.y), this.right_ < t.x && (this.right_ = t.x), this.bottom_ > t.y && (this.bottom = t.y));
  }
  // adding rectangle
  addRecSelf(t) {
    this.add(t.leftTop), this.add(t.rightBottom);
  }
  // adding rectangle
  addRec(t) {
    const e = this.clone();
    return e.add(t.leftTop), e.add(t.rightBottom), e;
  }
  /**  Returns the translated clone of the specified rectangle */
  static translate(t, e) {
    const i = t.clone();
    return i.center = t.center.add(e), i;
  }
  /**  Returns a new Rectangle which is the transform the input rectangle */
  static transform(t, e) {
    return T.mkPP(e.multiplyPoint(t.leftTop), e.multiplyPoint(t.rightBottom));
  }
  // returns true if the rectangle contains the point
  contains(t) {
    return this.containsWithPadding(t, 0);
  }
  // returns true if this rectangle compconstely contains the specified rectangle
  containsRect(t) {
    return this.contains(t.leftTop) && this.contains(t.rightBottom);
  }
  // returns true if this rectangle compconstely contains the specified rectangle
  containsRectWithPadding(t, e) {
    return this.containsWithPadding(t.leftTop, e) && this.containsWithPadding(t.rightBottom, e);
  }
  // return the length of the diagonal
  get diagonal() {
    return Math.sqrt(this.width * this.width + this.height * this.height);
  }
  // pad the rectangle horizontally by the given padding
  padWidth(t) {
    this.left -= t, this.right += t;
  }
  // pad the rectangle vertically by the given padding
  padHeight(t) {
    this.top += t, this.bottom -= t;
  }
  // pad the rectangle by the given padding
  pad(t) {
    t < -this.width / 2 && (t = -this.width / 2), t < -this.height / 2 && (t = -this.height / 2), this.padWidth(t), this.padHeight(t);
  }
  // Pad the rectangle by the given amount on each side
  padEverywhere(t) {
    this.left -= t.left, this.right += t.right, this.bottom -= t.bottom, this.top += t.top;
  }
  // Returns the intersection of two rectangles.
  static intersect(t, e) {
    return t.intersects(e) ? T.mkPP(new u(Math.max(t.left, e.left), Math.max(t.bottom, e.bottom)), new u(Math.min(t.right, e.right), Math.min(t.top, e.top))) : T.mkEmpty();
  }
  perimeter() {
    const t = new B();
    return t.addPoint(this.leftTop), t.addPoint(this.rightTop), t.addPoint(this.rightBottom), t.addPoint(this.leftBottom), t.closed = !0, t;
  }
  scaleAroundCenter(t) {
    this.width = this.width * t, this.height = this.height * t;
  }
  clone() {
    return new T({ left: this.left, right: this.right, top: this.top, bottom: this.bottom });
  }
  // gets or sets the Size
  get size() {
    return new Ai(this.width, this.height);
  }
  set size(t) {
    this.width = t.width, this.height = t.height;
  }
  // constructor with Size and center
  static creatRectangleWithSize(t, e) {
    const i = t.width / 2, s = e.x - i, n = e.x + i, r = t.height / 2, a = e.y - r, l = e.y + r;
    return new T({ left: s, right: n, top: l, bottom: a });
  }
  // adding a point with a Size
  addPointWithSize(t, e) {
    const i = t.width / 2, s = t.height / 2;
    this.add(new u(e.x - i, e.y - s)), this.add(new u(e.x + i, e.y - s)), this.add(new u(e.x - i, e.y + s)), this.add(new u(e.x + i, e.y + s));
  }
}
class St {
  constructor() {
    this.previouisBezierCoefficient = 0.5, this.nextBezierCoefficient = 0.5, this.previousTangentCoefficient = 1 / 3, this.nextTangentCoefficient = 1 / 3;
  }
  static mkSiteP(t) {
    const e = new St();
    return e.point = t, e;
  }
  static mkSiteSP(t, e) {
    const i = new St();
    return i.point = e, i.prev = t, t.next = i, i;
  }
  static mkSiteSPS(t, e, i) {
    const s = new St();
    return s.prev = t, s.point = e, s.next = i, t.next = s, i.prev = s, s;
  }
  get turn() {
    return this.next == null || this.prev == null ? 0 : u.getTriangleOrientation(this.prev.point, this.point, this.next.point);
  }
  clone() {
    const t = new St();
    return t.previouisBezierCoefficient = this.previouisBezierCoefficient, t.point = this.point, t;
  }
}
class Tt {
  // creates the polyline from corner points
  static mkFromPoints(t) {
    let e = null, i = null;
    for (const s of t)
      if (i == null)
        i = St.mkSiteP(s), e = new Tt(i);
      else {
        const n = St.mkSiteP(s);
        n.prev = i, i.next = n, i = n;
      }
    return e;
  }
  clone() {
    let t = this.headSite, e = null, i, s = null;
    for (; t != null; )
      i = t.clone(), i.prev = e, e != null ? e.next = i : s = i, t = t.next, e = i;
    return new Tt(s);
  }
  constructor(t) {
    this.headSite = t;
  }
  // the last site of the polyline
  // <
  get lastSite() {
    let t = this.headSite;
    for (; t.next != null; )
      t = t.next;
    return t;
  }
  *[Symbol.iterator]() {
    let t = this.headSite;
    for (; t != null; )
      yield t.point, t = t.next;
  }
  /** Creates a curve by using the underlying polyline*/
  createCurve() {
    const t = new g();
    let e = this.headSite, i;
    do {
      const s = g.findCorner(e);
      if (s == null)
        break;
      const n = Tt.createBezierSegOnSite(s.b);
      t.segs.length === 0 ? u.closeDistEps(e.point, n.start) || g.addLineSegment(t, e.point, n.start) : u.closeDistEps(t.end, n.start) || g.continueWithLineSegmentP(t, n.start), t.addSegment(n), e = s.b;
    } while (!0);
    return t.segs.length === 0 ? u.closeDistEps(e.point, e.next.point) ? t.segs.push(new st(e.point, e.point.add(new u(5, 5)), e.point.add(new u(-5, 5)), i.point)) : g.addLineSegment(t, e.point, e.next.point) : u.closeDistEps(t.end, e.next.point) || g.continueWithLineSegmentP(t, e.next.point), t;
  }
  static createBezierSegOnSite(t) {
    const e = t.previouisBezierCoefficient, i = t.nextBezierCoefficient, s = t.prev, n = t.next, r = s.point.mul(e).add(t.point.mul(1 - e)), a = n.point.mul(i).add(t.point.mul(1 - i)), l = r.mul(t.previousTangentCoefficient).add(t.point.mul(1 - t.previousTangentCoefficient)), h = a.mul(t.nextTangentCoefficient).add(t.point.mul(1 - t.nextTangentCoefficient));
    return st.mkBezier([r, l, h, a]);
  }
}
class Wt {
  // the matrix elements
  get Elements() {
    return this.elements;
  }
  // i,j th element
  getElem(t, e) {
    return this.elements[t][e];
  }
  setElem(t, e, i) {
    this.elements[t][e] = i;
  }
  // Divid matrix by a matrix
  static Divide(t, e) {
    return t.multiply(e.inverse());
  }
  isIdentity() {
    return D(this.elements[0][0], 1) && D(this.elements[0][1], 0) && D(this.elements[0][2], 0) && D(this.elements[1][0], 0) && D(this.elements[1][1], 1) && D(this.elements[1][2], 0);
  }
  // returns the point of the matrix offset
  offset() {
    return new u(this.getElem(0, 2), this.getElem(1, 2));
  }
  static getIdentity() {
    return new Wt(1, 0, 0, 0, 1, 0);
  }
  constructor(t, e, i, s, n, r) {
    this.elements = [
      [t, e, i],
      [s, n, r]
    ];
  }
  // Rotation matrix - rotates counterclockwise by 'angle'
  static rotation(t) {
    const e = Math.cos(t), i = Math.sin(t);
    return new Wt(e, -i, 0, i, e, 0);
  }
  static scaleAroundCenterTransformation(t, e, i) {
    const s = 1 - t, n = 1 - e;
    return new Wt(t, 0, s * i.x, 0, e, n * i.y);
  }
  // Point by matrix multiplication
  multiplyPoint(t) {
    return new u(this.getElem(0, 0) * t.x + this.getElem(0, 1) * t.y + this.getElem(0, 2), this.getElem(1, 0) * t.x + this.getElem(1, 1) * t.y + this.getElem(1, 2));
  }
  // matrix matrix multiplication
  multiply(t) {
    return t != null ? new Wt(this.getElem(0, 0) * t.getElem(0, 0) + this.getElem(0, 1) * t.getElem(1, 0), this.getElem(0, 0) * t.getElem(0, 1) + this.getElem(0, 1) * t.getElem(1, 1), this.getElem(0, 0) * t.getElem(0, 2) + this.getElem(0, 1) * t.getElem(1, 2) + this.getElem(0, 2), this.getElem(1, 0) * t.getElem(0, 0) + this.getElem(1, 1) * t.getElem(1, 0), this.getElem(1, 0) * t.getElem(0, 1) + this.getElem(1, 1) * t.getElem(1, 1), this.getElem(1, 0) * t.getElem(0, 2) + this.getElem(1, 1) * t.getElem(1, 2) + this.getElem(1, 2)) : null;
  }
  // returns the inversed matrix
  inverse() {
    const t = this.getElem(0, 0) * this.getElem(1, 1) - this.getElem(1, 0) * this.getElem(0, 1), e = this.getElem(1, 1) / t, i = -this.getElem(0, 1) / t, s = -this.getElem(1, 0) / t, n = this.getElem(0, 0) / t, r = -e * this.getElem(0, 2) - i * this.getElem(1, 2), a = -s * this.getElem(0, 2) - n * this.getElem(1, 2);
    return new Wt(e, i, r, s, n, a);
  }
}
class pt {
  static mkEllipse(t, e, i) {
    return j.mkFullEllipseNNP(t, e, i);
  }
  static createParallelogram(t, e, i) {
    const s = e / 2, n = t / 2, r = i.x, a = i.y, l = 80 * Math.PI / 180, h = s / Math.tan(l);
    return B.mkClosedFromPoints([
      new u(-n - h + r, -s + a),
      new u(n + r, -s + a),
      new u(n + r + h, s + a),
      new u(-n + r, s + a)
    ]);
  }
  static createHexagon(t, e, i) {
    const s = e / 2, n = t / 2, r = i.x, a = i.y;
    return B.mkClosedFromPoints([
      new u(-n + r, -s + a),
      new u(n + r, -s + a),
      new u(n + (s + r), 0 + a),
      new u(n + r, s + a),
      new u(-n + r, s + a),
      new u(-(n - s) + r, 0 + a)
    ]);
  }
  static createOctagon(t, e, i) {
    const s = t / 2, n = e / 2, r = new Array(8);
    r[0] = new u(s + pt.octagonPad * s, n - n * pt.octagonPad), r[3] = new u(r[0].x * -1, r[0].y), r[4] = new u(r[3].x, r[3].y * -1), r[7] = new u(r[0].x, r[0].y * -1), r[1] = new u(s - s * pt.octagonPad, n + n * pt.octagonPad), r[2] = new u(r[1].x * -1, r[1].y), r[6] = new u(r[1].x, r[1].y * -1), r[5] = new u(r[2].x, r[2].y * -1);
    for (let a = 0; a < 8; a++)
      r[a] = r[a].add(i);
    return B.mkClosedFromPoints(r);
  }
  static createInvertedHouse(t, e, i) {
    const s = pt.createHouse(t, e, i);
    return pt.rotateCurveAroundCenterByDegree(s, i, 180);
  }
  static createHouse(t, e, i) {
    const s = t / 2, n = e / 2, r = i.x, a = i.y, l = new g();
    return g.addLineSegmentCNNNN(l, r - s, a - n, r + s, a - n), g.continueWithLineSegmentNN(l, r + s, a + n), g.continueWithLineSegmentNN(l, r, a + 2 * n), g.continueWithLineSegmentNN(l, r - s, a + n), g.closeCurve(l);
  }
  static mkDiamond(t, e, i) {
    const s = t, n = e, r = i.x, a = i.y, l = new g(), h = [new u(r, a - n), new u(r + s, a), new u(r, a + n), new u(r - s, a)];
    return l.addSegs([v.mkPP(h[0], h[1]), v.mkPP(h[1], h[2]), v.mkPP(h[2], h[3]), v.mkPP(h[3], h[0])]), l;
  }
  static rotateCurveAroundCenterByDegree(t, e, i) {
    return pt.rotateCurveAroundCenterByRadian(t, e, i * Math.PI / 180);
  }
  static rotateCurveAroundCenterByRadian(t, e, i) {
    const s = Math.cos(i), n = Math.sin(i), r = new Wt(1, 0, e.x, 0, 1, e.y).multiply(new Wt(s, -n, 0, n, s, 0)).multiply(new Wt(1, 0, -e.x, 0, 1, -e.y));
    return t.transform(r);
  }
  static mkCircle(t, e) {
    return j.mkCircle(t, e);
  }
  static createRectangle(t, e, i) {
    const s = t / 2, n = e / 2, r = i.x, a = i.y, l = new g(), h = [new u(r - s, a - n), new u(r + s, a - n), new u(r + s, a + n), new u(r - s, a + n)];
    return l.addSegs([v.mkPP(h[0], h[1]), v.mkPP(h[1], h[2]), v.mkPP(h[2], h[3]), v.mkPP(h[3], h[0])]), l;
  }
  static isRoundedRect(t) {
    if (!(t instanceof g))
      return;
    const e = t.segs;
    if (e.length !== 8 && e.length !== 4)
      return;
    const i = e.length === 8;
    let s, n;
    for (let r = 0; r < 4; r++) {
      const a = i ? 2 * r + 1 : r;
      if (r === 0) {
        if (!(e[a] instanceof j))
          return;
        const l = e[a];
        s = l.aAxis.length, n = l.bAxis.length;
      } else {
        if (!(e[a] instanceof j))
          return;
        const l = e[a];
        if (s !== l.aAxis.length || n !== l.bAxis.length)
          return;
      }
    }
    return {
      radX: s,
      radY: n
    };
  }
  static mkRectangleWithRoundedCorners(t, e, i, s, n = new u(0, 0)) {
    if (i === 0 || s === 0)
      return pt.createRectangle(t, e, n);
    const r = new g(), a = t / 2;
    i > a / 2 && (i = a / 2);
    const l = e / 2;
    s > l / 2 && (s = l / 2);
    const h = n.x, c = n.y, d = a - i, f = l - s, p = c + l, P = c - l, y = h - a, C = h + a, E = new u(i, 0), N = new u(0, s);
    return d > 0 && r.addSegment(v.mkPP(new u(h - d, P), new u(h + d, P))), r.addSegment(j.mkEllipse(1.5 * Math.PI, 2 * Math.PI, E, N, h + d, c - f)), f > 0 && r.addSegment(v.mkPP(new u(C, c - f), new u(C, c + f))), r.addSegment(j.mkEllipse(0, 0.5 * Math.PI, E, N, h + d, c + f)), d > 0 && r.addSegment(v.mkPP(new u(h + d, p), new u(h - d, p))), r.addSegment(j.mkEllipse(0.5 * Math.PI, Math.PI, E, N, h - d, c + f)), f > 0 && r.addSegment(v.mkPP(new u(y, c + f), new u(y, c - f))), r.addSegment(j.mkEllipse(Math.PI, 1.5 * Math.PI, E, N, h - d, c - f)), r;
  }
}
pt.octagonPad = 1 / 4;
function Fi(o) {
  return o.parEnd - o.parStart;
}
var S;
(function(o) {
  o[o.None = 0] = "None", o[o.North = 1] = "North", o[o.East = 2] = "East", o[o.South = 4] = "South", o[o.West = 8] = "West";
})(S || (S = {}));
class b {
  // ReSharper restore InconsistentNaming
  static get DifferenceEpsilon() {
    return b.differenceEpsilon;
  }
  // Determines whether the specified Points, which are assumed to have been Round()ed,
  // are close enough to be considered equal.
  // <returns>True if the inputs are close enough to be considered equal, else false</returns>
  static EqualPP(t, e) {
    return b.Equal(t.x, e.x) && b.Equal(t.y, e.y);
  }
  // Determines whether the specified double values, which are assumed to have been Round()ed,
  // are close enough to be considered equal.
  // <returns>True if the inputs are close enough to be considered equal, else false</returns>
  static Equal(t, e) {
    return b.Compare(t, e) === 0;
  }
  // The usual Compare operation, with inputs that are assumed to have been Round()ed.
  //
  //
  // <returns>0 if the inputs are close enough to be considered equal, else -1 if lhs is
  // less than rhs, else 1.</returns>
  static Compare(t, e) {
    let i = 0;
    return t + b.DifferenceEpsilon < e ? i = -1 : e + b.DifferenceEpsilon < t && (i = 1), i;
  }
  // The usual Compare operation, with inputs that are assumed to have been Round()ed.
  // <returns>0 if the inputs are close enough to be considered equal, else -1 if lhs is
  // less than rhs, else 1.</returns>
  static ComparePP(t, e) {
    let i = b.Compare(t.x, e.x);
    return i === 0 && (i = b.Compare(t.y, e.y)), i;
  }
  // return true if less or equal holds for two values that are assumed to have been Round()ed
  static LessOrEqual(t, e) {
    const i = b.Compare(t, e);
    return i < 0 || i === 0;
  }
  static Less(t, e) {
    return b.Compare(t, e) < 0;
  }
  // static Assert_Rounded(d: number) {
  //  //  Be sure there is enough precision to round that far; anything larger than this is
  //  //  unlikely to be a graph coordinate (it's probably a line intersection way out of range).
  //  if (Math.log10(Math.abs(d)) < 14 - GeomConstants.distanceEpsilonPrecision) {
  //    /*Assert.assert(
  //      Math.abs(Point.RoundDouble(d) - d) <
  //        PointComparer.DifferenceEpsilon,
  //      'unRounded value passed',
  //    )*/
  //  }
  // }
  // static Assert_RoundedP(p: Point) {
  //  // PointComparer.Assert_Rounded(p.x)
  //  // PointComparer.Assert_Rounded(p.y)
  // }
  static GetDirections(t, e) {
    return w.DirectionFromPointToPoint(t, e);
  }
  static IsPureDirection(t, e) {
    return w.IsPureDirection(b.GetDirections(t, e));
  }
  static IsPureDirectionD(t) {
    return w.IsPureDirection(t);
  }
  static IsPureLower(t, e) {
    const i = b.GetDirections(t, e);
    return S.East === i || S.North === i;
  }
  static GetPureDirectionVV(t, e) {
    return b.GetDirections(t.point, e.point);
  }
}
b.differenceEpsilon = m.distanceEpsilon / 2;
class w {
  constructor(t) {
    this.Dir = t;
  }
  get Right() {
    return new w(w.RotateRight(this.Dir));
  }
  static RotateRight(t) {
    switch (t) {
      case S.North:
        return S.East;
      case S.East:
        return S.South;
      case S.South:
        return S.West;
      case S.West:
        return S.North;
      default:
        throw new Error();
    }
  }
  static RotateLeft(t) {
    switch (t) {
      case S.North:
        return S.West;
      case S.West:
        return S.South;
      case S.South:
        return S.East;
      case S.East:
        return S.North;
      default:
        throw new Error();
    }
  }
  static ToIndex(t) {
    switch (t) {
      case S.North:
        return 0;
      case S.East:
        return 1;
      case S.South:
        return 2;
      case S.West:
        return 3;
      default:
        throw new Error();
    }
  }
  static VectorDirection(t) {
    let e = S.None;
    return t.x > b.DifferenceEpsilon ? e = S.East : t.x < -b.DifferenceEpsilon && (e = S.West), t.y > b.DifferenceEpsilon ? e = e | S.North : t.y < -b.DifferenceEpsilon && (e = e | S.South), e;
  }
  static VectorDirectionPP(t, e) {
    let i = S.None;
    const s = e.x - t.x, n = e.y - t.y;
    return s > b.DifferenceEpsilon ? i = S.East : -s > b.DifferenceEpsilon && (i = S.West), n > b.DifferenceEpsilon ? i |= S.North : -n > b.DifferenceEpsilon && (i |= S.South), i;
  }
  static DirectionFromPointToPoint(t, e) {
    return w.VectorDirectionPP(t, e);
  }
  static OppositeDir(t) {
    switch (t) {
      case S.North:
        return S.South;
      case S.West:
        return S.East;
      case S.South:
        return S.North;
      case S.East:
        return S.West;
      default:
        return S.None;
    }
  }
  static IsPureDirection(t) {
    switch (t) {
      case S.North:
        return !0;
      case S.East:
        return !0;
      case S.South:
        return !0;
      case S.West:
        return !0;
      default:
        return !1;
    }
  }
  static IsPureDirectionPP(t, e) {
    return w.IsPureDirection(w.DirectionFromPointToPoint(t, e));
  }
  static DirectionsAreParallel(t, e) {
    return t === e || t === w.OppositeDir(e);
  }
  // Translates the CompassVector's direction into a new Point.
  ToPoint() {
    let t = 0, e = 0;
    return (this.Dir & S.East) === S.East && t++, (this.Dir & S.North) === S.North && e++, (this.Dir & S.West) === S.West && t--, (this.Dir & S.South) === S.South && e--, new u(t, e);
  }
  // Translates a direction into a Point.
  static toPoint(t) {
    return new w(t).ToPoint();
  }
  //  the negation operator
  static negate(t) {
    return new w(w.OppositeDir(t.Dir));
  }
}
class $r extends $ {
  /** clones but does not bind to the entity and does not set the parent edge*/
  clone() {
    const t = new $r(null, null);
    return t.isPositioned = this.isPositioned, t._boundingBox = this._boundingBox.clone(), t.attachmentSegmentEnd = this.attachmentSegmentEnd, t.attachmentSegmentStart = this.attachmentSegmentStart, t;
  }
  get isPositioned() {
    return this._isPositioned;
  }
  set isPositioned(t) {
    this._isPositioned = t;
  }
  constructor(t, e) {
    super(t), this._isPositioned = !1, e && (this.boundingBox = T.mkPP(new u(0, 0), new u(e.width, e.height)));
  }
  get boundingBox() {
    return this._boundingBox;
  }
  set boundingBox(t) {
    this._boundingBox = t;
  }
  setBoundingBox(t) {
    this.isPositioned = !0, this._boundingBox = t;
  }
  get width() {
    return this.boundingBox.width;
  }
  set width(t) {
    this.boundingBox.width = t;
  }
  get height() {
    return this.boundingBox.height;
  }
  set height(t) {
    this.boundingBox.height = t;
  }
  get center() {
    return this.boundingBox.center;
  }
  set center(t) {
    this.boundingBox.center = t;
  }
  translate(t) {
    this.isPositioned && (this.center = this.center.add(t));
  }
  transform(t) {
    this.isPositioned && (this.center = t.multiplyPoint(this.center));
  }
  positionCenter(t) {
    this.boundingBox.center = t, this.isPositioned = !0;
  }
}
class Zt extends $ {
  *getSmoothPolyPoints() {
    yield this.source.center, this.curve instanceof g ? yield* this.getCurvePoints(this.curve) : this.curve instanceof v ? (yield this.curve.start, yield this.curve.end) : this.curve instanceof j ? (yield this.curve.start, yield this.curve.value((this.curve.parStart + this.curve.parEnd) / 0.5), yield this.curve.end) : this.curve instanceof st && (yield this.curve.start, yield this.curve.value(0.25), yield this.curve.value(0.75), yield this.curve.end), yield this.target.center;
  }
  *getCurvePoints(t) {
    for (const e of t.segs)
      if (yield e.start, e instanceof st) {
        const i = vd(e);
        i && (yield i);
      }
    yield t.end;
  }
  static getGeom(t) {
    return $.getGeom(t);
  }
  /** clones but does not bind to the entity */
  clone() {
    const t = new Zt(null);
    return this.smoothedPolyline && (t.smoothedPolyline = this.smoothedPolyline.clone()), t.curve = this.curve.clone(), this.sourceArrowhead != null && (t.sourceArrowhead = this.sourceArrowhead.clone()), this.targetArrowhead != null && (t.targetArrowhead = this.targetArrowhead.clone()), t;
  }
  get label() {
    return this.edge != null && this.edge.label != null ? $.getGeom(this.edge.label) : null;
  }
  set label(t) {
    this.edge.label.setAttr(_e.GeomObjectIndex, t);
  }
  RaiseLayoutChangeEvent(t) {
    this.edge.raiseEvents(t);
  }
  requireRouting() {
    this.curve = null, this.smoothedPolyline = null;
  }
  translate(t) {
    if (!(t.x === 0 && t.y === 0)) {
      if (this.curve != null && this.curve.translate(t), this.smoothedPolyline != null)
        for (let e = this.smoothedPolyline.headSite, i = this.smoothedPolyline.headSite; e != null; e = e.next, i = i.next)
          e.point = i.point.add(t);
      if (this.sourceArrowhead != null && this.sourceArrowhead.tipPosition && (this.sourceArrowhead.tipPosition = this.sourceArrowhead.tipPosition.add(t)), this.targetArrowhead != null && this.targetArrowhead.tipPosition && (this.targetArrowhead.tipPosition = this.targetArrowhead.tipPosition.add(t)), this.edge.label) {
        const e = $r.getGeom(this.edge.label);
        e && e.translate(t);
      }
    }
  }
  GetMaxArrowheadLength() {
    let t = 0;
    return this.sourceArrowhead != null && (t = this.sourceArrowhead.length), this.targetArrowhead != null && this.targetArrowhead.length > t ? this.targetArrowhead.length : t;
  }
  transform(t) {
    if (this.curve != null) {
      if (this.curve = this.curve.transform(t), this.smoothedPolyline != null)
        for (let e = this.smoothedPolyline.headSite, i = this.smoothedPolyline.headSite; e != null; e = e.next, i = i.next)
          e.point = t.multiplyPoint(e.point);
      this.sourceArrowhead != null && (this.sourceArrowhead.tipPosition = t.multiplyPoint(this.sourceArrowhead.tipPosition)), this.targetArrowhead != null && (this.targetArrowhead.tipPosition = t.multiplyPoint(this.targetArrowhead.tipPosition));
    }
  }
  get edge() {
    return this.entity;
  }
  get source() {
    return $.getGeom(this.edge.source);
  }
  /** iterates over the source arrowhead corner points */
  *sourceArrowheadPoints(t) {
    if (this.sourceArrowhead == null)
      return;
    yield this.sourceArrowhead.tipPosition;
    let e = this.sourceArrowhead.tipPosition.sub(this.curve.start);
    e = e.rotate90Cw().mul(Math.tan(t * 0.5 * (Math.PI / 180))), yield e.add(this.curve.start), yield this.curve.start.sub(e);
  }
  /** iterates over the target arrowhead corner points */
  *targetArrowheadPoints(t) {
    if (this.targetArrowhead == null)
      return;
    yield this.targetArrowhead.tipPosition;
    let e = this.targetArrowhead.tipPosition.sub(this.curve.end);
    e = e.rotate90Cw().mul(Math.tan(t * 0.5 * (Math.PI / 180))), yield e.add(this.curve.end), yield this.curve.end.sub(e);
  }
  get boundingBox() {
    const t = T.mkEmpty();
    if (this.smoothedPolyline != null)
      for (const i of this.smoothedPolyline)
        t.add(i);
    this.curve != null && t.addRecSelf(this.curve.boundingBox);
    for (const i of this.sourceArrowheadPoints(25))
      t.add(i);
    for (const i of this.targetArrowheadPoints(25))
      t.add(i);
    this.label && t.addRecSelf(this.label.boundingBox);
    const e = this.lineWidth;
    return t.left -= e, t.top += e, t.right += e, t.bottom -= e, t;
  }
  isInterGraphEdge() {
    return this.edge.isInterGraphEdge();
  }
  get target() {
    return $.getGeom(this.edge.target);
  }
  constructor(t) {
    super(t), this.lineWidth = 1;
  }
  toString() {
    return this.source.toString() + "->" + this.target;
  }
  static RouteSelfEdge(t, e, i) {
    const s = t.boundingBox.width, n = t.boundingBox.height, r = t.boundingBox.center, a = new u(r.x - s / 4, r.y), l = new u(r.x - s / 4, r.y - n / 2 - e), h = new u(r.x + s / 4, r.y - n / 2 - e), c = new u(r.x + s / 4, r.y);
    return i.smoothedPolyline = Tt.mkFromPoints([a, l, h, c]), i.smoothedPolyline.createCurve();
  }
  underCollapsedGraph() {
    return this.source.underCollapsedGraph() || this.target.underCollapsedGraph();
  }
  EdgeToAncestor() {
    return this.edge.EdgeToAncestor();
  }
}
function vd(o) {
  return u.lineLineIntersection(o.b[0], o.b[1], o.b[2], o.b[3]);
}
var tr = {}, Xa;
function Cd() {
  if (Xa) return tr;
  Xa = 1, Object.defineProperty(tr, "__esModule", { value: !0 });
  const o = Wl();
  class t extends o.LinkedList {
    constructor(...i) {
      super(...i);
    }
    get top() {
      return this.head;
    }
    get size() {
      return this.length;
    }
    push(i) {
      this.prepend(i);
    }
    pop() {
      return this.removeHead();
    }
  }
  return tr.Stack = t, tr;
}
var mt = Cd(), ot;
(function(o) {
  o[o.Continue = 0] = "Continue", o[o.Stop = 1] = "Stop";
})(ot || (ot = {}));
function Id(o, t, e, i, s, n) {
  for (let a = 0; a < o.length; a++) {
    if (a === t || a === e)
      continue;
    const l = n.box0.add_rect(o[a].irect), h = l.area - n.box0.area, c = n.box1.add_rect(o[a].irect), d = c.area - n.box1.area;
    i.length * 2 < s.length ? (i.push(o[a]), n.box0 = l) : s.length * 2 < i.length ? (s.push(o[a]), n.box1 = c) : h < d ? (i.push(o[a]), n.box0 = l) : d < h ? (s.push(o[a]), n.box1 = c) : n.box0.area < n.box1.area ? (i.push(o[a]), n.box0 = l) : (s.push(o[a]), n.box1 = c);
  }
}
function wt(o) {
  if (o.length === 0)
    return null;
  if (o.length === 1)
    return o[0];
  const t = { b0: o[0].irect, seed0: 1 }, e = wd(o, t), i = [], s = [];
  i.push(o[t.seed0]), s.push(o[e]);
  const n = { box0: o[t.seed0].irect, box1: o[e].irect };
  Id(o, t.seed0, e, i, s, n);
  const r = Mh(o.length);
  return r.irect = n.box0.add_rect(n.box1), r.Left = wt(i), r.Right = wt(s), r;
}
function Qa(o, t) {
  return o.add_rect(t).area;
}
function wd(o, t) {
  let e = Qa(t.b0, o[t.seed0].irect);
  for (let s = 2; s < o.length; s++) {
    const n = Qa(t.b0, o[s].irect);
    n > e && (t.seed0 = s, e = n);
  }
  let i;
  for (let s = 0; s < o.length; s++)
    if (s !== t.seed0) {
      i = s;
      break;
    }
  e = o[t.seed0].irect.add_rect(o[i].irect).area;
  for (let s = 0; s < o.length; s++) {
    if (s === t.seed0)
      continue;
    const n = o[t.seed0].irect.add_rect(o[s].irect).area;
    n > e && (i = s, e = n);
  }
  return i;
}
function Tr(o, t) {
  if (o == null || t == null)
    return null;
  const e = Array.from(o).map((i) => Nt(i, t(i)));
  return wt(e);
}
function Mh(o) {
  const t = new ra();
  return t.Count = o, t;
}
function Nt(o, t) {
  const e = new ra();
  return e.UserData = o, e.irect = t, e.Count = 1, e;
}
function Vo(o, t, e) {
  return o.irect.intersects_rect(e) ? t(o.UserData) === ot.Continue ? o.Left != null ? Vo(o.Left, t, e) === ot.Continue && Vo(o.Right, t, e) === ot.Continue ? ot.Continue : ot.Stop : ot.Continue : ot.Stop : ot.Continue;
}
class ra {
  toString() {
    return this.IsLeaf ? this.Count.toString() + " " + this.UserData : this.Count.toString();
  }
  // false if it is an internal node and true if it is a leaf
  get IsLeaf() {
    return this.left == null;
  }
  //if left is a null then right is also a null
  //
  get Left() {
    return this.left;
  }
  set Left(t) {
    this.left != null && this.left.Parent === this && (this.left.Parent = null), this.left = t, this.left != null && (this.left.Parent = this);
  }
  get Right() {
    return this.right;
  }
  set Right(t) {
    this.right != null && this.right.Parent === this && (this.right.Parent = null), this.right = t, this.right != null && (this.right.Parent = this);
  }
  get IsLeftChild() {
    return this === this.Parent.Left;
  }
  // brings the first leaf which rectangle was intersected
  FirstIntersectedNode(t) {
    var e;
    return t.intersects_rect(this.irect) ? this.IsLeaf ? this : (e = this.Left.FirstIntersectedNode(t)) !== null && e !== void 0 ? e : this.Right.FirstIntersectedNode(t) : null;
  }
  FirstHitNodeWithPredicate(t, e) {
    var i;
    return this.irect.contains_point(t) ? this.IsLeaf ? e(t, this.UserData) === ot.Stop ? this : null : (i = this.Left.FirstHitNodeWithPredicate(t, e)) !== null && i !== void 0 ? i : this.Right.FirstHitNodeWithPredicate(t, e) : null;
  }
  FirstHitByRectWithPredicate(t, e) {
    var i;
    return this.irect.intersects_rect(t) ? this.IsLeaf ? e(this.UserData) === ot.Stop ? this : null : (i = this.Left.FirstHitByRectWithPredicate(t, e)) !== null && i !== void 0 ? i : this.Right.FirstHitByRectWithPredicate(t, e) : null;
  }
  // brings the first leaf which rectangle was hit and the delegate is happy with the object
  FirstHitNode(t) {
    var e;
    return this.irect.contains_point(t) ? this.IsLeaf ? this : (e = this.Left.FirstHitNode(t)) !== null && e !== void 0 ? e : this.Right.FirstHitNode(t) : null;
  }
  // returns all leaf nodes for which the rectangle was hit and the delegate is happy with the object
  *AllHitItems(t, e = null) {
    const i = new mt.Stack();
    for (i.push(this); i.size > 0; ) {
      const s = i.pop();
      s.irect.intersects_rect(t) && (s.IsLeaf ? (e == null || e(s.UserData)) && (yield s.UserData) : (i.push(s.left), i.push(s.right)));
    }
  }
  // returns all items for which the rectangle contains the point
  *AllHitItems_(t) {
    const e = new mt.Stack();
    for (e.push(this); e.size > 0; ) {
      const i = e.pop();
      i.irect.contains_point(t) && (i.IsLeaf ? yield i.UserData : (e.push(i.left), e.push(i.right)));
    }
  }
  // Returns all leaves whose rectangles intersect hitRectangle (or all leaves before hitTest returns false).
  VisitTree(t, e) {
    Vo(this, t, e);
  }
  //
  Clone() {
    const t = Mh(this.Count);
    return t.UserData = this.UserData, t.irect = this.irect, this.Left != null && (t.Left = this.Left.Clone()), this.Right != null && (t.Right = this.Right.Clone()), t;
  }
  // yields all leaves which rectangles intersect the given one. We suppose that leaves are all nodes having UserData not a null.
  *GetNodeItemsIntersectingRectangle(t) {
    for (const e of this.GetLeafRectangleNodesIntersectingRectangle(t))
      yield e.UserData;
  }
  // yields all leaves whose rectangles intersect the given one. We suppose that leaves are all nodes having UserData not a null.
  *GetLeafRectangleNodesIntersectingRectangle(t) {
    const e = new mt.Stack();
    for (e.push(this); e.size > 0; ) {
      const i = e.pop();
      i.irect.intersects_rect(t) && (i.IsLeaf ? yield i : (e.push(i.left), e.push(i.right)));
    }
  }
  // Walk the tree and return the data from all leaves
  *GetAllLeaves() {
    for (const t of this.GetAllLeafNodes())
      yield t.UserData;
  }
  *GetAllLeafNodes() {
    for (const t of this.EnumRectangleNodes(!0))
      yield t;
  }
  *EnumRectangleNodes(t) {
    const e = new mt.Stack();
    for (e.push(this); e.size > 0; ) {
      const i = e.pop();
      (i.IsLeaf || !t) && (yield i), i.IsLeaf || (e.push(i.left), e.push(i.right));
    }
  }
  //
  // Walk the tree from node down and apply visitor to all nodes
  TraverseHierarchy(t, e) {
    e(t), t.Left != null && this.TraverseHierarchy(t.Left, e), t.Right != null && this.TraverseHierarchy(t.Right, e);
  }
}
class ne {
  constructor(t, e) {
    hr(t, e) < 0 ? (this._first = t, this._second = e) : (this._first = e, this._second = t);
  }
  get first() {
    return this._first;
  }
  get second() {
    return this._second;
  }
  get Length() {
    return Z(this._first, this._second);
  }
  CompareTo(t) {
    const e = hr(this._first, t._first);
    return e !== 0 ? e : hr(this._second, t._second);
  }
  static equal(t, e) {
    return t._first.equal(e._first) && t._second.equal(e._second);
  }
  toString() {
    return this._first + (" " + this._second);
  }
}
let xt = class Gh {
  delete(t) {
    return this.deletexy(t.x, t.y);
  }
  clear() {
    this.mapOfSets.clear(), this.size_ = 0;
  }
  get size() {
    return this.size_;
  }
  static mk(t) {
    const e = new Gh();
    for (const i of t)
      e.add(i);
    return e;
  }
  addxy(t, e) {
    let i = this.mapOfSets.get(t);
    i == null && this.mapOfSets.set(t, i = /* @__PURE__ */ new Set()), i.has(e) || this.size_++, i.add(e);
  }
  add(t) {
    return this.addxy(t.x, t.y), this;
  }
  deletexy(t, e) {
    const i = this.mapOfSets.get(t);
    return i != null && i.delete(e) ? (this.size_--, !0) : !1;
  }
  hasxy(t, e) {
    return this.mapOfSets.has(t) && this.mapOfSets.get(t).has(e);
  }
  has(t) {
    return this.hasxy(t.x, t.y);
  }
  constructor() {
    this.size_ = 0, this.mapOfSets = /* @__PURE__ */ new Map();
  }
  forEach(t, e) {
    for (const i of this)
      t(i, i, e);
  }
  *entries() {
    for (const t of this)
      yield [t, t];
  }
  keys() {
    return this.values();
  }
  *values() {
    for (const t of this.mapOfSets)
      for (const e of t[1])
        yield new u(t[0], e);
  }
  [Symbol.iterator]() {
    return this.values();
  }
};
function Hs(o, t) {
  const e = /* @__PURE__ */ new Set();
  for (const i of o)
    t.has(i) || e.add(i);
  return e;
}
function Ed(o, t) {
  const e = new xt();
  for (const i of o)
    t.has(i) || e.add(i);
  return e;
}
function zs(o, t) {
  const e = new Set(o);
  for (const i of t)
    e.add(i);
  return e;
}
function Vi(o, t) {
  for (const e of t)
    o.push(e);
}
function Wi(o, t) {
  const e = /* @__PURE__ */ new Set();
  if (o.size < t.size)
    for (const i of o)
      t.has(i) && e.add(i);
  else
    for (const i of t)
      o.has(i) && e.add(i);
  return e;
}
function Ad(o) {
  if (o.length === 0)
    return /* @__PURE__ */ new Set();
  let t = o[0];
  for (let e = 1; e < o.length; e++)
    t = Wi(t, o[e]);
  return t;
}
function ln(o, t) {
  for (const e of t)
    o.add(e);
}
function Or(o, t) {
  if (o.size !== t.size)
    return !1;
  for (const e of o)
    if (!t.has(e))
      return !1;
  return !0;
}
function Yn(o, t) {
  const e = [];
  for (const i of o)
    for (const s of t(i))
      e.push(s);
  return e;
}
function xr(o, t, e) {
  let i = o.get(t);
  i || (i = /* @__PURE__ */ new Set(), o.set(t, i)), i.add(e);
}
function As(o, t, e) {
  let i = o.get(t);
  i || (i = new Array(), o.set(t, i)), i.push(e);
}
function Fh(o, t, e) {
  let i = o.get(t);
  i || (i = /* @__PURE__ */ new Set(), o.set(t, i)), i.add(e);
}
function Td(o, t, e) {
  Fh(o, new ne(t[0], t[1]), e);
}
function Od(o, t, e) {
  const i = o.get(t);
  i && i.delete(e);
}
function Ya(o, t, e) {
  Od(o, new ne(t[0], t[1]), e);
}
class at {
  static assert(t, e = null) {
    if (!t)
      throw e != null ? (console.log(e), new Error(e)) : new Error("condition does not hold");
  }
}
var ds;
(function(o) {
  o[o.None = 0] = "None", o[o.FromAncestor = 1] = "FromAncestor", o[o.ToAncestor = 2] = "ToAncestor";
})(ds || (ds = {}));
class Vh extends Xo {
  constructor(t, e) {
    super(), this.source = t, this.target = e, t !== e ? (t.outEdges.add(this), e.inEdges.add(this)) : t.selfEdges.add(this);
  }
  add() {
    this.source !== this.target ? (this.source.outEdges.add(this), this.target.inEdges.add(this)) : this.source.selfEdges.add(this);
  }
  remove() {
    this.source !== this.target ? (this.source.outEdges.delete(this), this.target.inEdges.delete(this)) : this.source.selfEdges.delete(this);
  }
  toString() {
    return "(" + this.source.toString() + "->" + this.target.toString() + ")";
  }
  isInterGraphEdge() {
    return this.source.parent !== this.target.parent;
  }
  EdgeToAncestor() {
    return this.source instanceof di && this.target.isDescendantOf(this.source) ? ds.FromAncestor : this.target instanceof di && this.source.isDescendantOf(this.target) ? ds.ToAncestor : ds.None;
  }
}
class xd extends Xo {
  removeOutEdge(t) {
    this.outEdges.delete(t);
  }
  removeInEdge(t) {
    this.inEdges.delete(t);
  }
  /** the unique, in the parent graph, id of the node */
  get id() {
    return this._id;
  }
  set id(t) {
    this._id = t;
  }
  toString() {
    return this.id;
  }
  constructor(t) {
    super(), this.inEdges = /* @__PURE__ */ new Set(), this.outEdges = /* @__PURE__ */ new Set(), this.selfEdges = /* @__PURE__ */ new Set(), this.id = t;
  }
  *_edges() {
    for (const t of this.inEdges)
      yield t;
    for (const t of this.outEdges)
      yield t;
    for (const t of this.selfEdges)
      yield t;
  }
  get edges() {
    return this._edges();
  }
  get outDegree() {
    return this.outEdges.size;
  }
  get inDegree() {
    return this.inEdges.size;
  }
  get selfDegree() {
    return this.selfEdges.size;
  }
  get degree() {
    return this.outDegree + this.inDegree + this.selfDegree;
  }
}
class Ld {
  constructor() {
    this.nodeMap = /* @__PURE__ */ new Map();
  }
  remove(t) {
    this.nodeMap.delete(t.id);
  }
  get size() {
    return this.nodeMap.size;
  }
  *nodes_() {
    for (const t of this.nodeMap.values())
      yield t;
  }
  *graphs_() {
    for (const t of this.nodes_())
      t instanceof di && (yield t);
  }
  findShallow(t) {
    return this.nodeMap.get(t);
  }
  get nodesShallow() {
    return this.nodes_();
  }
  get graphs() {
    return this.graphs_();
  }
  *_edges() {
    for (const t of this.nodeMap.values()) {
      for (const e of t.outEdges)
        yield e;
      for (const e of t.selfEdges)
        yield e;
    }
  }
  interGraphEdges() {
    throw new Error("not implemented");
  }
  get nodeShallowCount() {
    return this.nodeMap.size;
  }
  // caution: it is a linear by the number of nodes method
  get edgeCount() {
    let t = 0;
    for (const e of this.nodeMap.values())
      t += e.outDegree + e.selfDegree;
    return t;
  }
  /**  returns the edges of shallow nodes */
  get edges() {
    return this._edges();
  }
  addNode(t) {
    this.nodeMap.set(t.id, t);
  }
  nodeIsConsistent(t) {
    for (const e of t.outEdges)
      if (e.source !== t || e.source === e.target)
        return !1;
    for (const e of t.inEdges)
      if (e.target !== t || e.source === e.target)
        return !1;
    for (const e of t.selfEdges)
      if (e.target !== e.source || e.source !== t)
        return !1;
    return !0;
  }
  isConsistent() {
    for (const t of this.nodeMap.values())
      if (!this.nodeIsConsistent(t))
        return !1;
    return !0;
  }
}
let di = class Si extends xd {
  remove(t) {
    this.nodeCollection.remove(t);
  }
  /** Removes itself from under the parent.
   *  Also removes all the edges leading out of the graph.
   */
  removeSubgraph() {
    const t = this.parent;
    t && t.removeNode(this);
    for (const e of this.outGoingEdges())
      e.attachedAtSource ? e.node.removeOutEdge(e.edge) : e.node.removeInEdge(e.edge);
  }
  /** returns the objects that show how the edge is adjacent to a node  that is outside of the graph */
  *outGoingEdges() {
    for (const t of this.outEdges) {
      const e = t.target;
      this.isAncestor(e) || (yield { edge: t, node: e, attachedAtSource: !1 });
    }
    for (const t of this.inEdges) {
      const e = t.source;
      this.isAncestor(e) || (yield { edge: t, node: e, attachedAtSource: !0 });
    }
    for (const t of this.nodesBreadthFirst) {
      for (const e of t.outEdges) {
        const i = e.target;
        i !== this && (this.isAncestor(i) || (yield { edge: e, node: i, attachedAtSource: !1 }));
      }
      for (const e of t.inEdges) {
        const i = e.source;
        i !== this && (this.isAncestor(i) || (yield { edge: e, node: i, attachedAtSource: !0 }));
      }
    }
  }
  isAncestor(t) {
    for (const e of t.getAncestors())
      if (e === this)
        return !0;
    return !1;
  }
  /**  Iterates over all connected components of the graph and for each component
   * returns all its nodes with "this" as the parent
   */
  *getClusteredConnectedComponents() {
    const t = /* @__PURE__ */ new Set(), e = new We.Queue();
    for (const i of this.nodesBreadthFirst) {
      if (t.has(i))
        continue;
      t.add(i), e.enqueue(i);
      const s = /* @__PURE__ */ new Set();
      do {
        const n = e.dequeue();
        n.parent === this && s.add(n);
        for (const r of this.reachableFrom(n))
          t.has(r) || (t.add(r), e.enqueue(r));
      } while (e.length > 0);
      yield Array.from(s);
    }
  }
  *reachableFrom(t) {
    for (const e of t.outEdges)
      yield e.target;
    for (const e of t.inEdges)
      yield e.source;
    t instanceof Si && (yield* t.shallowNodes), t.parent != this && (yield t.parent);
  }
  hasSomeAttrOnIndex(t) {
    for (const e of this.nodesBreadthFirst)
      if (e.getAttr(t))
        return !0;
    for (const e of this.deepEdges)
      if (e.getAttr(t))
        return !0;
    return !1;
  }
  *graphs() {
    for (const t of this.nodeCollection.graphs)
      yield t;
  }
  noEmptySubgraphs() {
    for (const t of this.subgraphsBreadthFirst())
      if (t.shallowNodeCount === 0)
        return !1;
    return !0;
  }
  hasSubgraphs() {
    for (const t of this.shallowNodes)
      if (t instanceof Si)
        return !0;
    return !1;
  }
  /** iterates breadth first  */
  *subgraphsBreadthFirst() {
    for (const t of this.nodesBreadthFirst)
      t instanceof Si && (yield t);
  }
  isEmpty() {
    return this.shallowNodeCount === 0;
  }
  setEdge(t, e) {
    const i = this.nodeCollection.findShallow(t);
    if (i == null)
      return;
    const s = this.nodeCollection.findShallow(e);
    if (s != null)
      return new Vh(i, s);
  }
  /** Iterates over the nodes of the current graph but not entering the subgraphs.
   *  Yields the top subgraphs among the nodes as well
   */
  get shallowNodes() {
    return this.nodeCollection.nodesShallow;
  }
  /** Iterates over all the nodes of including the subgraphs.
   * The iteration happens in the breadth first pattern.
   */
  get nodesBreadthFirst() {
    return this.nodesBreadthFirst_();
  }
  /** iterates breadth first  */
  *nodesBreadthFirst_() {
    for (const t of this.nodeCollection.nodesShallow)
      yield t, t instanceof Si && (yield* t.nodesBreadthFirst);
  }
  constructor(t = "__graph__") {
    super(t), this.nodeCollection = new Ld();
  }
  /**
   * Finds the node with the givin id belonging to a graph or one of its subgraphs.
   */
  findNodeRecursive(t) {
    const e = this.nodeCollection.findShallow(t);
    if (e)
      return e;
    for (const i of this.shallowNodes)
      if (i instanceof Si) {
        const s = i.findNodeRecursive(t);
        if (s)
          return s;
      }
    return null;
  }
  /** Returns a node belonging to this graph having the same id.
   * If a node with the given id belongs to a subgraph than it would no be returned.
   * To find such a deeper nested node use findNodeRecursive
   */
  findNode(t) {
    return this.nodeCollection.findShallow(t);
  }
  /** iterates over the edges of the graph which adjacent to the nodes of the graph:
   * not iterating over the subgraphs
   */
  get shallowEdges() {
    return this.nodeCollection.edges;
  }
  /** iterates over the edges of the graph including subgraphs */
  get deepEdges() {
    return this.deepEdgesIt();
  }
  *deepEdgesIt() {
    for (const t of this.nodesBreadthFirst) {
      for (const e of t.outEdges)
        yield e;
      for (const e of t.selfEdges)
        yield e;
      for (const e of t.inEdges)
        this.isAncestor(e.source) || (yield e);
    }
  }
  isConsistent() {
    return this.parent ? this.parent.isConsistent() : this.eachNodeIdIsUnique() && this.nodeCollection.isConsistent();
  }
  nodeIsConsistent(t) {
    return this.nodeCollection.nodeIsConsistent(t);
  }
  /** Detouches all the node's edges and removes the node from the graph.
   * This method does not change the parent of the node.
   */
  removeNode(t) {
    for (const e of t.outEdges)
      e.target.inEdges.delete(e);
    for (const e of t.inEdges)
      e.source.outEdges.delete(e);
    this.nodeCollection.remove(t);
    for (const e of this.subgraphsBreadthFirst())
      e.removeNode(t);
  }
  /** adds a node to the graph */
  addNode(t) {
    return at.assert(this.findNodeRecursive(t.id) == null), t.parent = this, this.nodeCollection.addNode(t), t;
  }
  get shallowNodeCount() {
    return this.nodeCollection.nodeShallowCount;
  }
  get nodeCountDeep() {
    let t = this.nodeCollection.size;
    for (const e of this.shallowNodes)
      e instanceof Si && (t += e.nodeCountDeep);
    return t;
  }
  get edgeCount() {
    return this.nodeCollection.edgeCount;
  }
  // If n has an ancestor which is the graph child then return it.
  // Otherwise return null
  liftNode(t) {
    for (; t != null && t.parent !== this; )
      t = t.parent;
    return t;
  }
  /** return the number of all edges in the graph, including the subgraphs */
  get deepEdgesCount() {
    let t = 0;
    for (const e of this.nodesBreadthFirst)
      t += e.outDegree + e.selfDegree;
    return t;
  }
  eachNodeIdIsUnique() {
    const t = /* @__PURE__ */ new Set();
    for (const e of this.nodesBreadthFirst) {
      if (t.has(e.id))
        return !1;
      t.add(e.id);
    }
    return !0;
  }
  /** returns all the nodes under graph and the edges with at least one end adjacent to the graph */
  *allElements() {
    for (const t of this.allSuccessorsWidthFirst()) {
      yield t;
      for (const e of t.selfEdges)
        yield e;
      for (const e of t.outEdges)
        yield e;
      for (const e of t.inEdges)
        this.isAncestor(e.source) || (yield e);
    }
    yield* this.edges;
  }
  *allSuccessorsWidthFirst() {
    for (const t of this.shallowNodes)
      yield t;
    for (const t of this.shallowNodes)
      t instanceof Si && (yield* t.allSuccessorsWidthFirst());
  }
  *allSuccessorsDepthFirst() {
    for (const t of this.shallowNodes)
      t instanceof Si && (yield* t.allSuccessorsDepthFirst()), yield t;
  }
};
function* Rd(o) {
  const t = /* @__PURE__ */ new Set(), e = new We.Queue();
  for (const n of o.shallowNodes) {
    if (t.has(n))
      continue;
    const r = new Array();
    for (s(n, e, t); e.length > 0; ) {
      const a = e.dequeue();
      r.push(a);
      for (const l of i(a))
        s(l, e, t);
    }
    yield r;
  }
  function* i(n) {
    for (const r of n.outEdges)
      yield r.target;
    for (const r of n.inEdges)
      yield r.source;
  }
  function s(n, r, a) {
    a.has(n) || (r.enqueue(n), a.add(n));
  }
}
function Nd(o, t) {
  let e = /* @__PURE__ */ new Map();
  const i = o.nodeCountDeep;
  let s = 1 / i;
  for (const n of o.nodesBreadthFirst)
    e.set(n, s);
  for (let n = 0; n < 50; n++) {
    s = (1 - t) / i;
    const r = /* @__PURE__ */ new Map();
    for (const a of o.nodesBreadthFirst)
      r.set(a, s);
    for (const a of o.nodesBreadthFirst) {
      let l = r.get(a);
      for (const h of a.inEdges) {
        const c = h.source;
        l += t * (e.get(c) / c.outDegree);
      }
      r.set(a, l);
    }
    e = r;
  }
  return e;
}
function cr(o, t) {
  return t.has(o.source) && t.has(o.target);
}
class Jt extends $ {
  /** clones but does not bind to the entity */
  clone() {
    const t = new Jt(null);
    return this.boundaryCurve && (t.boundaryCurve = this.boundaryCurve.clone()), t;
  }
  translate(t) {
    t.x === 0 && t.y === 0 || this.boundaryCurve.translate(t);
  }
  toJSON() {
    return { boundaryCurve: this.boundaryCurve };
  }
  get node() {
    return this.entity;
  }
  get boundaryCurve() {
    return this._boundaryCurve;
  }
  set boundaryCurve(t) {
    t != null && t.boundingBox && (t.boundingBox.height < Jt.minHeight || t.boundingBox.width < Jt.minWidth) && (t = pt.mkCircle(Jt.minWidth, t.boundingBox.center)), this._boundaryCurve = t;
  }
  get id() {
    return this.node.id;
  }
  toString() {
    return this.id;
  }
  // Creates a Node instance
  static mkNode(t, e) {
    const i = new Jt(e);
    return i.boundaryCurve = t, i;
  }
  // Fields which are set by Msagl
  // return the center of the curve bounding box
  get center() {
    return this.boundaryCurve.boundingBox.center;
  }
  set center(t) {
    const e = t.sub(this.center);
    this.boundaryCurve.translate(e);
  }
  // sets the bounding curve scaled to fit the targetBounds
  fitBoundaryCurveToTarget(t) {
    if (this.boundaryCurve != null) {
      const e = pt.isRoundedRect(this.boundaryCurve);
      if (e == null) {
        const i = t.width / this.boundaryCurve.boundingBox.width, s = t.height / this.boundaryCurve.boundingBox.height;
        this.boundaryCurve = this.boundaryCurve.scaleFromOrigin(i, s), this.boundaryCurve.translate(t.center.sub(this.boundaryCurve.boundingBox.center));
      } else
        this.boundaryCurve = pt.mkRectangleWithRoundedCorners(t.width, t.height, e.radX, e.radY, t.center);
    }
  }
  static getGeom(t) {
    return t.getAttr(_e.GeomObjectIndex);
  }
  *inEdges() {
    for (const t of this.node.inEdges)
      yield $.getGeom(t);
  }
  *outEdges() {
    for (const t of this.node.outEdges)
      yield $.getGeom(t);
  }
  *selfEdges() {
    for (const t of this.node.selfEdges)
      yield $.getGeom(t);
  }
  // the bounding box of the node
  get boundingBox() {
    return this.boundaryCurve ? this.boundaryCurve.boundingBox : null;
  }
  set boundingBox(t) {
    this.boundaryCurve && (Math.abs(t.width - this.width) < 1e-4 && Math.abs(t.height - this.height) < 1e-4 ? this.center = t.center : this.fitBoundaryCurveToTarget(t));
  }
  // width of the node does not include the padding
  get width() {
    return this.boundaryCurve.boundingBox.width;
  }
  // height of the node does not including the padding
  get height() {
    return this.boundaryCurve.boundingBox.height;
  }
  transform(t) {
    this.boundaryCurve != null && (this.boundaryCurve = this.boundaryCurve.transform(t));
  }
  underCollapsedGraph() {
    const t = this.node.parent;
    if (t == null)
      return !1;
    const e = $.getGeom(t);
    return e == null ? !1 : e.isCollapsed ? !0 : e.underCollapsedGraph();
  }
  *getAncestors() {
    for (const t of this.node.getAncestors())
      yield $.getGeom(t);
  }
}
Jt.minHeight = 2;
Jt.minWidth = 3;
class lt {
  ProgressStep() {
  }
  constructor(t) {
    this.cancelToken = t;
  }
}
class Ln {
}
Ln.GoldenRatio = (1 + Math.sqrt(5)) / 2;
Ln.GoldenRatioRemainder = 2 - Ln.GoldenRatio;
class Ci extends lt {
  constructor(t, e) {
    super(null), this.desiredAspectRatio = 1.2, this.bestPacking = null, this.cachedCosts = /* @__PURE__ */ new Map(), this.rectangles = t, this.desiredAspectRatio = e;
  }
  // The width of the widest row in the packed solution
  get PackedWidth() {
    return this.bestPacking != null ? this.bestPacking.PackedWidth : 0;
  }
  // The height of the bounding box of the packed solution
  get PackedHeight() {
    return this.bestPacking != null ? this.bestPacking.PackedHeight : 0;
  }
  Pack(t, e, i) {
    const s = Ci.GetGoldenSectionStep(t, e), n = Math.max(i / 10, (e - t) / Ci.MaxSteps);
    e += n, this.bestPackingCost = Number.MAX_VALUE, this.rectangles.length === 1 ? this.PackLimit(t) : this.rectangles.length === 2 ? (this.PackLimit(t), this.PackLimit(e)) : this.rectangles.length > 2 && Ci.GoldenSectionSearch((a) => this.PackLimit(a), t, s, e, n);
    const r = this.bestPacking.getRects();
    for (let a = 0; a < this.rectangles.length; a++)
      this.rectangles[a] = r[a];
  }
  PackLimit(t) {
    let e = this.cachedCosts.get(t);
    if (e == null) {
      const i = this.createPacking(this.rectangles, t);
      i.run(), this.cachedCosts.set(t, e = Math.abs(i.PackedAspectRatio - this.desiredAspectRatio)), e < this.bestPackingCost && (this.bestPackingCost = e, this.bestPacking = i);
    }
    return e;
  }
  // recursively searches a weakly unimodal function f(x) between x1 and x3 for the minimum.  It is assumed x2 \le x1 and x2 \le x3
  // and x2-x1=a \lt b=x3-x2.  The recursion generates a fourth point x4-x1=b \gt a=x3-x4 where x4-x2=c and b=a+c and:
  // if f(x4) \lt f(x2) we search in the range [x2, x3]
  // else if f(x2) \lt f(x4) we search in the range [x1, x4]
  // else
  // f(x2)==f(x4) and we know that f is only weakly unimodal (not strongly unimodal) and we must search both branches.
  static GoldenSectionSearch(t, e, i, s, n) {
    if (Math.abs(e - s) < n)
      return t(e) < t(s) ? e : s;
    const r = Ci.GetGoldenSectionStep(i, s), a = t(i), l = t(r), h = () => Ci.GoldenSectionSearch(t, r, i, e, n), c = () => Ci.GoldenSectionSearch(t, i, r, s, n);
    if (l < a)
      return c();
    if (l > a)
      return h();
    const d = c(), f = h();
    return t(f) < t(d) ? f : d;
  }
  static GetGoldenSectionStep(t, e) {
    return t < e ? t + Ln.GoldenRatioRemainder * (e - t) : t - Ln.GoldenRatioRemainder * (t - e);
  }
}
Ci.MaxSteps = 1e3;
class Bd extends lt {
  get PackedWidth() {
    return this.packedWidth;
  }
  set PackedWidth(t) {
    this.packedWidth = t;
  }
  get PackedHeight() {
    return this.packedHeight;
  }
  set PackedHeight(t) {
    this.packedHeight = t;
  }
  // Aspect ratio of the bounding box of the packed solution
  get PackedAspectRatio() {
    return this.PackedWidth / this.PackedHeight;
  }
  getRects() {
    const t = [];
    for (const [e, i] of this.rectsToCenters)
      e.center = i, t.push(e);
    return t;
  }
}
class Lr extends Bd {
  // Constructor for packing, call Run to do the actual pack.
  // Each RectangleToPack.Rectangle is updated in place.
  // Pack rectangles tallest to shortest, left to right until wrapWidth is reached,
  // then wrap to right-most rectangle still with vertical space to fit the next rectangle
  constructor(t, e, i = !1) {
    super(null), this.rectsToCenters = /* @__PURE__ */ new Map(), this.rectanglesByDescendingHeight = i ? t : Lr.SortRectangles(t), this.wrapWidth = e;
  }
  // Sort rectangles by height
  static SortRectangles(t) {
    return t.sort((e, i) => i.height - e.height), t;
  }
  // Pack rectangles tallest to shortest, left to right until wrapWidth is reached,
  // then wrap to right-most rectangle still with vertical space to fit the next rectangle
  run() {
    this.Pack();
  }
  // Traverses the rectangleEnumerator and places rectangles at the next available slot beneath the current parent,
  // until the parent is filled or until maxRowWidth is reached.  Each successfully placed rectangle is pushed onto
  // a stack, when there is no room for the rectangle we pop the stack for a new parent and try again.
  Pack() {
    this.PackedWidth = 0, this.PackedHeight = 0;
    const t = new mt.Stack();
    let e = !1, i = 0, s = 0, n = 0;
    const r = this.rectanglesByDescendingHeight;
    for (let a = 0; e || a < r.length; ) {
      const l = r[a], h = t.length > 0 ? t.top : null;
      if (h == null || h.right + l.width <= this.wrapWidth && i + l.height <= h.top) {
        const d = new u(h ? h.right : 0, i).add(new u(l.width / 2, l.height / 2));
        l.center = d, this.rectsToCenters.set(l, d), s = Math.max(s, l.right), n = Math.max(n, l.top), t.push(l), e = !1;
      } else
        i = h.top, t.pop(), e = !0;
      e || a++;
    }
    this.PackedWidth = s, this.PackedHeight = n;
  }
}
class Dh extends Ci {
  // Constructor for packing, call Run to do the actual pack.
  // Each RectangleToPack.Rectangle is updated in place.
  // Performs a Golden Section Search on packing width for the
  // closest aspect ratio to the specified desired aspect ratio
  constructor(t, e) {
    super(Lr.SortRectangles(t), e), this.createPacking = (i, s) => new Lr(i, s, !0);
  }
  // Performs a Golden Section Search on packing width for the
  // closest aspect ratio to the specified desired aspect ratio
  run() {
    let t = Number.MAX_VALUE, e = 0, i = 0;
    for (const s of this.rectangles) {
      const n = s.width;
      i += n, t = Math.min(t, n), e = Math.max(e, n);
    }
    this.Pack(e, i, t);
  }
}
function Pn(o) {
  return new Rr(wt(o.map(([t, e]) => Nt(e, t))));
}
function Md(o, t) {
  o.UserData = t.UserData, o.Left = t.Left, o.Right = t.Right, o.Count--, o.irect = t.irect;
}
function Ja(o) {
  for (let t = o.Parent; t != null; t = t.Parent)
    t.Count--, t.irect = t.Left.irect.add_rect(t.Right.irect);
}
function Gd(o, t) {
  const e = new Array();
  for (const s of o.GetAllLeafNodes())
    s !== t && e.push(s);
  const i = wt(e);
  o.Count = i.Count, o.Left = i.Left, o.Right = i.Right, o.irect = i.Left.irect.add_rect(i.Right.irect);
}
function Fd(o) {
  for (let t = o.Parent; t != null; t = t.Parent)
    if (!kh(t))
      return t;
  return null;
}
function kh(o) {
  return 2 * o.Left.Count >= o.Right.Count && 2 * o.Right.Count >= o.Left.Count;
}
function Do(o, t, e, i) {
  return o.irect.intersects_rect(t) ? o.IsLeaf ? i(o.UserData) ? --e.bound !== 0 : !0 : Do(o.Left, t, e, i) && Do(o.Right, t, e, i) : !0;
}
class Rr {
  // Removes everything from the tree
  // <
  clear() {
    this.RootNode = null;
  }
  NumberOfIntersectedIsLessThanBound(t, e, i) {
    return Do(this._rootNode, t, { bound: e }, i);
  }
  get RootNode() {
    return this._rootNode;
  }
  set RootNode(t) {
    this._rootNode = t;
  }
  // Create a query tree for a given root node
  constructor(t) {
    this._rootNode = t;
  }
  *GetAllLeaves() {
    if (this._rootNode != null && this.Count > 0)
      for (const t of this._rootNode.GetAllLeaves())
        yield t;
  }
  // The number of data elements of the tree (number of leaf nodes)
  get Count() {
    return this._rootNode == null ? 0 : this._rootNode.Count;
  }
  Add(t, e) {
    this.AddNode(Nt(e, t));
  }
  AddNode(t) {
    this._rootNode == null ? this._rootNode = t : this.Count <= 2 ? this._rootNode = wt(Array.from(this._rootNode.GetAllLeafNodes()).concat([t])) : this.AddNodeToTreeRecursive(t, this._rootNode);
  }
  Rebuild() {
    this._rootNode = wt(Array.from(this._rootNode.GetAllLeafNodes()));
  }
  AddNodeToTreeRecursive(t, e) {
    if (e.IsLeaf)
      e.Left = Nt(e.UserData, e.irect), e.Right = t, e.Count = 2;
    else {
      e.Count++;
      let i, s;
      if (2 * e.Left.Count < e.Right.Count)
        this.AddNodeToTreeRecursive(t, e.Left), e.Left.irect = e.Left.irect.add_rect(t.irect);
      else if (2 * e.Right.Count < e.Left.Count)
        this.AddNodeToTreeRecursive(t, e.Right), e.Right.irect = e.Right.irect.add_rect(t.irect);
      else {
        i = e.Left.irect.add_rect(t.irect);
        const n = i.area - e.Left.irect.area;
        s = e.Right.irect.add_rect(t.irect);
        const r = s.area - e.Right.irect.area;
        n < r ? (this.AddNodeToTreeRecursive(t, e.Left), e.Left.irect = i) : n > r ? (this.AddNodeToTreeRecursive(t, e.Right), e.Right.irect = s) : i.area < s.area ? (this.AddNodeToTreeRecursive(t, e.Left), e.Left.irect = i) : (this.AddNodeToTreeRecursive(t, e.Right), e.Right.irect = s);
      }
    }
    e.irect = e.Left.irect.add_rect(e.Right.irect);
  }
  GetAllIntersecting(t) {
    return this._rootNode == null || this.Count === 0 ? [] : Array.from(this._rootNode.GetNodeItemsIntersectingRectangle(t));
  }
  OneIntersecting(t) {
    if (this._rootNode == null || this.Count === 0)
      return;
    const e = this._rootNode.FirstIntersectedNode(t);
    if (e != null)
      return { intersectedLeaf: e.UserData };
  }
  // Get all leaf nodes with rectangles intersecting the specified rectangular region
  GetAllLeavesIntersectingRectangle(t) {
    return this._rootNode == null || this.Count === 0 ? [] : this._rootNode.GetLeafRectangleNodesIntersectingRectangle(t);
  }
  // Does minimal work to determine if any objects of the tree intersect with the query region
  IsIntersecting(t) {
    if (this._rootNode == null || this.Count === 0)
      return !1;
    for (const e of this._rootNode.GetNodeItemsIntersectingRectangle(t))
      return !0;
    return !1;
  }
  // return true iff there is a node with the rectangle and UserData that equals to the parameter "userData"
  Contains(t, e) {
    if (this._rootNode == null)
      return !1;
    for (const i of this._rootNode.GetLeafRectangleNodesIntersectingRectangle(t))
      if (i.UserData === e)
        return !0;
    return !1;
  }
  Remove(t, e) {
    if (this._rootNode == null)
      return;
    let i;
    for (const s of this._rootNode.GetLeafRectangleNodesIntersectingRectangle(t))
      s.UserData === e && (i = s);
    if (i != null)
      return this.RootNode.Count === 1 ? this.RootNode = null : this.RemoveLeaf(i), i.UserData;
  }
  RemoveLeaf(t) {
    const e = Fd(t);
    if (e != null)
      Gd(e, t), Ja(e);
    else {
      const i = t.Parent;
      i == null ? this._rootNode = new ra() : (Md(i, t.IsLeftChild ? i.Right : i.Left), Ja(i));
    }
  }
  UnbalancedNode(t) {
    for (let e = t.Parent; e != null; e = e.Parent)
      if (!kh(e))
        return e;
    return null;
  }
}
class Vd extends T {
  constructor(t) {
    super(t), this.radX = t.radX, this.radY = t.radY, this.roundedRect_ = pt.mkRectangleWithRoundedCorners(this.width, this.height, t.radX, t.radY, this.center);
  }
  onUpdated() {
    this.isEmpty || (this.roundedRect_ = pt.mkRectangleWithRoundedCorners(this.width, this.height, this.radX, this.radY, this.center));
  }
  isOk() {
    return this.isEmpty() ? !0 : this.roundedRect_.boundingBox.equalEps(this);
  }
  setRect(t) {
    this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.isEmpty() || (this.roundedRect_ = pt.mkRectangleWithRoundedCorners(t.width, t.height, this.radX, this.radY, this.center));
  }
}
function Dd(o, t) {
  const e = t.map((n) => [n, n.boundingBox]), i = e.map((n) => n[1]), s = new Dh(i, 1.5);
  s.run();
  for (const [n, r] of e) {
    const a = r.leftBottom.sub(n.boundingBox.leftBottom);
    n.translate(a);
  }
  o.boundingBox = new T({
    left: 0,
    bottom: 0,
    right: s.PackedWidth,
    top: s.PackedHeight
  });
}
class Rt extends Jt {
  isAncestor(t) {
    return this.graph.isAncestor(t.node);
  }
  deepTranslate(t) {
    for (const e of this.nodesBreadthFirst) {
      e instanceof Rt ? e.boundingBox = e.boundingBox.translate(t) : e.translate(t);
      for (const i of e.selfEdges())
        i.translate(t);
      for (const i of e.outEdges())
        this.graph.isAncestor(i.target.node) && i.translate(t);
    }
    this.boundingBox = this.boundingBox.translate(t);
  }
  /** it is a rather shallow clone */
  clone() {
    const t = new Rt(null);
    return t.boundingBox = this.boundingBox.clone(), t.layoutSettings = this.layoutSettings, t.margins = this.margins, t.radX = this.radX, t.radY = this.radY, t;
  }
  /** Calculate bounding box from children, not updating the bounding boxes recursively. */
  calculateBoundsFromChildren() {
    const t = T.mkEmpty();
    for (const e of this.shallowNodes)
      t.addRecSelf(e.boundingBox);
    return t.padEverywhere(this.margins), t;
  }
  *allSuccessorsWidthFirst() {
    for (const t of this.graph.allSuccessorsWidthFirst())
      yield Jt.getGeom(t);
  }
  static getGeom(t) {
    return $.getGeom(t);
  }
  edgeCurveOrArrowheadsIntersectRect(t, e) {
    for (const n of t.sourceArrowheadPoints(25))
      if (e.contains(n))
        return !0;
    for (const n of t.targetArrowheadPoints(25))
      if (e.contains(n))
        return !0;
    const i = t.curve, s = e.perimeter();
    return g.intersectionOne(i, s, !1) != null || g.PointRelativeToCurveLocation(i.start, s) === F.Inside;
  }
  isEmpty() {
    return this.graph.isEmpty();
  }
  setSettingsRecursively(t) {
    this.layoutSettings = t;
    for (const e of this.nodesBreadthFirst) {
      const i = e;
      i.layoutSettings = t;
    }
  }
  get layoutSettings() {
    return this._layoutSettings;
  }
  // recursively sets the same settings for subgraphs
  set layoutSettings(t) {
    this._layoutSettings = t;
  }
  get labelSize() {
    return this._labelSize;
  }
  set labelSize(t) {
    this._labelSize = t;
  }
  get boundingBox() {
    return this.rrect ? this.rrect.clone() : null;
  }
  set boundingBox(t) {
    t ? this.rrect.setRect(t) : this.rrect.roundedRect_ = null;
  }
  transform(t) {
    if (!t.isIdentity()) {
      for (const e of this.shallowNodes)
        e.transform(t);
      for (const e of this.shallowEdges)
        e.transform(t), e.label && e.label.transform(t);
      this.boundingBox = this.rrect == null || this.rrect.isEmpty() ? this.pumpTheBoxToTheGraphWithMargins() : this.boundingBox.transform(t);
    }
  }
  /** Contrary to the deepTranslate() it also translates edges leading out of the graph */
  translate(t) {
    t.x === 0 && t.y === 0 || this.deepTranslate(t);
  }
  get nodesBreadthFirst() {
    return this.nodesBreadthFirstIter();
  }
  *nodesBreadthFirstIter() {
    for (const t of this.graph.nodesBreadthFirst)
      yield $.getGeom(t);
  }
  setEdge(t, e) {
    const i = this.graph.setEdge(t, e);
    return new Zt(i);
  }
  /** this does not change the graph bounding box */
  getPumpedGraphWithMarginsBox() {
    const t = { b: T.mkEmpty() };
    return oa(this, t), t.b.padEverywhere(this.margins), t.b;
  }
  /** sets the bounding box and the boundary curve as well */
  pumpTheBoxToTheGraphWithMargins() {
    return this.boundingBox = this.getPumpedGraphWithMarginsBox();
  }
  // Fields which are set by Msagl
  // return the center of the curve bounding box
  get center() {
    return this.boundingBox || this.boundingBox.isEmpty ? this.boundingBox.center : new u(0, 0);
  }
  set center(t) {
    const e = t.sub(this.center), i = new Wt(1, 0, e.x, 0, 1, e.y);
    this.transform(i);
  }
  get left() {
    return this.boundingBox.left;
  }
  get right() {
    return this.boundingBox.right;
  }
  get top() {
    return this.boundingBox.top;
  }
  get bottom() {
    return this.boundingBox.bottom;
  }
  CheckClusterConsistency() {
    throw new Error("Method not implemented.");
  }
  get edgeCount() {
    return this.graph.edgeCount;
  }
  get boundaryCurve() {
    return this.rrect.roundedRect_;
  }
  set boundaryCurve(t) {
    throw new Error();
  }
  get shallowNodes() {
    return this.shallowNodes_();
  }
  *shallowNodes_() {
    for (const t of this.graph.shallowNodes)
      yield $.getGeom(t);
  }
  /** iterates over the edges of the graph which adjacent to the nodes of the graph:
   * not iterating over the subgraphs
   */
  /** iterates over the edges of the graph including subgraphs */
  get deepEdges() {
    return this.deepEdgesIt();
  }
  *deepEdgesIt() {
    for (const t of this.graph.deepEdges)
      yield $.getGeom(t);
  }
  get shallowEdges() {
    return this.shallowEdgesIt();
  }
  *shallowEdgesIt() {
    for (const t of this.graph.shallowEdges)
      yield $.getGeom(t);
  }
  static mk(t, e = new Ai(0, 0)) {
    const i = new Rt(new di(t));
    return i.labelSize = e, i;
  }
  get Clusters() {
    return this.subgraphs();
  }
  /** iterates over all subgraphs  */
  *subgraphs() {
    for (const t of this.graph.subgraphsBreadthFirst())
      yield $.getGeom(t);
  }
  static mkWithGraphAndLabel(t, e) {
    const i = new Rt(t);
    return i.labelSize = e, i;
  }
  constructor(t) {
    super(t), this.margins = { left: 10, top: 10, bottom: 10, right: 10 }, this.radX = 10, this.radY = 10, this.rrect = new Vd({ left: 0, right: -1, top: 20, bottom: 0, radX: this.radX, radY: this.radY });
  }
  get deepNodeCount() {
    let t = 0;
    for (const e of this.graph.nodesBreadthFirst)
      t++;
    return t;
  }
  get subgraphsDepthFirst() {
    return this.getSubgraphsDepthFirst();
  }
  *getSubgraphsDepthFirst() {
    for (const t of this.graph.allSuccessorsDepthFirst())
      t instanceof di && (yield Rt.getGeom(t));
  }
  get uniformMargins() {
    return Math.max(this.margins.left, this.margins.right, this.margins.right, this.margins.bottom);
  }
  set uniformMargins(t) {
    this.margins.left = this.margins.right = this.margins.right = this.margins.bottom = t;
  }
  get height() {
    return this.boundingBox.height;
  }
  get width() {
    return this.boundingBox.width;
  }
  get shallowNodeCount() {
    return this.graph.shallowNodeCount;
  }
  get graph() {
    return this.entity;
  }
  liftNode(t) {
    const e = this.graph.liftNode(t.node);
    return e ? $.getGeom(e) : null;
  }
  findNode(t) {
    const e = this.graph.findNode(t);
    return e ? $.getGeom(e) : null;
  }
  addNode(t) {
    return this.graph.addNode(t.node), t;
  }
  addLabelToGraphBB(t) {
    this.labelSize && (t.top += this.labelSize.height + 2, t.width < this.labelSize.width && (t.width = this.labelSize.width));
  }
}
function oa(o, t) {
  for (const i of o.shallowEdges) {
    if (!e(i))
      continue;
    const s = i.curve.boundingBox;
    if (t.b.addRecSelf(s), i.edge.label != null) {
      const n = $.getGeom(i.edge.label);
      n && t.b.addRecSelf(n.boundingBox);
    }
  }
  for (const i of o.shallowNodes)
    "shallowEdges" in i && oa(i, t), !(i.underCollapsedGraph() || !i.boundingBox) && t.b.addRecSelf(i.boundingBox);
  o instanceof Rt && o.addLabelToGraphBB(t.b);
  function e(i) {
    if (i == null || i.curve == null || i.underCollapsedGraph())
      return !1;
    if (o instanceof Rt) {
      const s = o.entity;
      return s.isAncestor(i.source.entity) && s.isAncestor(i.target.entity);
    } else
      return !0;
  }
}
class U {
  constructor(t, e) {
    this.x = t, this.y = e;
  }
  get source() {
    return this.x;
  }
  get target() {
    return this.y;
  }
  isDiagonal() {
    return this.x === this.y;
  }
}
class Ji {
  isEmpty() {
    if (this.arrayOfMaps.length === 0)
      return !0;
    for (const t of this.arrayOfMaps)
      if (t.size > 0)
        return !1;
    return !0;
  }
  set(t, e, i) {
    let s = this.arrayOfMaps[t];
    s === void 0 && (this.arrayOfMaps[t] = s = /* @__PURE__ */ new Map()), s.set(e, i);
  }
  setPair(t, e) {
    this.set(t.x, t.y, e);
  }
  delete(t, e) {
    if (t < 0 || t >= this.arrayOfMaps.length)
      return;
    const i = this.arrayOfMaps[t];
    i !== void 0 && (i.delete(e), i.size === 0 && (this.arrayOfMaps[t] = void 0));
  }
  has(t, e) {
    if (t < 0 || t >= this.arrayOfMaps.length)
      return !1;
    const i = this.arrayOfMaps[t];
    return i === void 0 ? !1 : i.has(e);
  }
  get(t, e) {
    if (t < 0 || t >= this.arrayOfMaps.length)
      return null;
    const i = this.arrayOfMaps[t];
    return i === void 0 ? null : i.get(e);
  }
  getI(t) {
    return this.get(t.x, t.y);
  }
  /** n is the maximum of (x + 1) where (x, *) runs over the keys  */
  constructor() {
    this.arrayOfMaps = new Array();
  }
  *keys() {
    for (let t = 0; t < this.arrayOfMaps.length; t++) {
      const e = this.arrayOfMaps[t];
      if (e !== void 0)
        for (const i of e)
          yield new U(t, i[0]);
    }
  }
  *keyValues() {
    for (let t = 0; t < this.arrayOfMaps.length; t++) {
      const e = this.arrayOfMaps[t];
      if (e !== void 0)
        for (const i of e)
          yield [new U(t, i[0]), i[1]];
    }
  }
  *values() {
    for (let t = 0; t < this.arrayOfMaps.length; t++) {
      const e = this.arrayOfMaps[t];
      if (e !== void 0)
        for (const i of e)
          yield i[1];
    }
  }
  get size() {
    let t = 0;
    for (let e = 0; e < this.arrayOfMaps.length; e++) {
      const i = this.arrayOfMaps[e];
      i !== void 0 && (t += i.size);
    }
    return t;
  }
}
class er {
  get curveClips() {
    return this._curveClips;
  }
  set curveClips(t) {
    this._curveClips = t;
  }
  constructor(t) {
    this._curveClips = [], this.arrowheads = [], this.nodes = [], this.labels = [], this.rect = t, this._curveClips = [];
  }
  addCurveClip(t) {
    at.assert(!(t.curve instanceof g), "CurveClip.curve should not be a Curve!"), this._curveClips.push(t);
  }
  isEmpty() {
    return this._curveClips.length == 0 && this.arrowheads.length == 0 && this.nodes.length == 0 && this.labels.length == 0;
  }
  initCurveClips() {
    this._curveClips = [];
  }
  /** clears all arrays but does not touch this.rect */
  clear() {
    this.arrowheads = [], this.nodes = [], this.labels = [], this._curveClips = [];
  }
  /** returns the number of entities that will be rendered for a tile: each bundle is counted as one entity */
  get entityCount() {
    return this._curveClips.length + this.arrowheads.length + this.labels.length + this.nodes.length;
  }
  addElement(t) {
    if (t instanceof Jt)
      this.nodes.push(t);
    else if (t instanceof $r)
      this.labels.push(t);
    else if ("curve" in t)
      if (t.curve instanceof g)
        for (const e of t.curve.segs)
          this.addCurveClip({ edge: t.edge, curve: e, startPar: e.parStart, endPar: e.parEnd });
      else
        this.addCurveClip(t);
    else
      this.arrowheads.push(t);
  }
}
class js {
  get Parents() {
    return Array.from(this.parents.values());
  }
  get Children() {
    return Array.from(this.children.values());
  }
  get BoundaryCurve() {
    return this.boundaryCurve;
  }
  set BoundaryCurve(t) {
    this.boundaryCurve = t;
  }
  // The bounding box of the shape.
  get BoundingBox() {
    return this.BoundaryCurve.boundingBox;
  }
  // The set of Ports for this obstacle, usually RelativePorts.  In the event of overlapping
  // obstacles, this identifies the obstacle to which the port applies.
  get Ports() {
    return this.ports;
  }
  // Default constructor.
  static mkShape() {
    return new js(null);
  }
  /**  Constructor taking the curve of the shape.*/
  constructor(t = null) {
    this.parents = /* @__PURE__ */ new Set(), this.children = /* @__PURE__ */ new Set(), this.ports = /* @__PURE__ */ new Set(), this.BoundaryCurve = t;
  }
  /**  A group is a shape that has children.*/
  get IsGroup() {
    return this.children.size > 0;
  }
  *Descendants() {
    const t = new We.Queue();
    for (const e of this.Children)
      t.enqueue(e);
    for (; t.length > 0; ) {
      const e = t.dequeue();
      yield e;
      for (const i of e.Children)
        t.enqueue(i);
    }
  }
  *Ancestors() {
    const t = new We.Queue();
    for (const e of this.Parents)
      t.enqueue(e);
    for (; t.length > 0; ) {
      const e = t.dequeue();
      yield e;
      for (const i of e.Parents)
        t.enqueue(i);
    }
  }
  // Adds a parent. A shape can have several parents
  AddParent(t) {
    this.parents.add(t), t.children.add(this);
  }
  AddChild(t) {
    t.parents.add(this), this.children.add(t);
  }
  //
  RemoveChild(t) {
    this.children.delete(t), t.parents.delete(this);
  }
  //
  RemoveParent(t) {
    this.parents.delete(t), t.children.delete(this);
  }
  ToString() {
    return this.UserData ? this.UserData.toString() : "null";
  }
}
class aa {
}
class Te extends aa {
  // a curve associated with the port
  // constructor
  constructor(t, e) {
    super(), this.curve = this.curve, this.location = e.clone();
  }
  // the location of the port
  get Location() {
    return this.location;
  }
  set Location(t) {
    this.location = t;
  }
  // translate the port location by delta
  Translate(t) {
    this.location = this.location.add(t);
  }
  // the port's curve
  get Curve() {
    return this.curve;
  }
  set Curve(t) {
    this.curve = t;
  }
}
class Ki extends Te {
  static mk(t, e) {
    return new Ki(t, e, new u(0, 0));
  }
  // the delegate returning center
  get CenterDelegate() {
    return this.centerDelegate;
  }
  set CenterDelegate(t) {
    this.centerDelegate = t;
  }
  // the delegate returning center
  get CurveDelegate() {
    return this.curveDelegate;
  }
  set CurveDelegate(t) {
    this.curveDelegate = t;
  }
  //
  //        // The node where we calculate our location and Curve from
  //
  //        public Node RelativeTo { get; private set; }
  // An offset relative to the Center of the Node that we use to calculate Location
  get LocationOffset() {
    return this.locationOffset;
  }
  set LocationOffset(t) {
    this.locationOffset = t;
  }
  // Create a port relative to a specific node with an offset for the port Location from the nodes center
  constructor(t, e, i) {
    super(null, e().add(i)), this.LocationOffset = i, this.CurveDelegate = t, this.CenterDelegate = e;
  }
  //
  // // Create a port relative to the center of a specific node
  //
  // public constructor (curveDelegate: Func<ICurve>, centerDelegate: Func<Point>) :
  //        this(curveDelegate, centerDelegate, new Point()) {
  // }
  // Get the location = CenterDelegate() + LocationOffset
  get Location() {
    return this.CenterDelegate().add(this.LocationOffset);
  }
  // Get the curve from the node's BoundaryCurve
  get Curve() {
    return this.CurveDelegate();
  }
}
class go {
  constructor(t, e, i, s, n) {
    this.color = t, e !== void 0 && (this.item = e), i !== void 0 && (this.parent = i), s !== void 0 && (this.left = s), n !== void 0 && (this.right = n);
  }
  toString() {
    return this.item.toString();
  }
}
var _;
(function(o) {
  o[o.Red = 0] = "Red", o[o.Black = 1] = "Black";
})(_ || (_ = {}));
class Ee {
  [Symbol.iterator]() {
    return this.allNodes();
  }
  constructor(t) {
    this.comparer = t, this.count = 0, this.root = this.nil = new go(_.Black);
  }
  clear() {
    this.root = this.nil = new go(_.Black);
  }
  toNull(t) {
    return t !== this.nil ? t : null;
  }
  isEmpty() {
    return this.root === this.nil;
  }
  getComparer() {
    return this.comparer;
  }
  getRoot() {
    return this.root;
  }
  find(t, e = this.root) {
    let i;
    for (; e !== this.nil && (i = this.comparer(t, e.item)) !== 0; )
      e = i < 0 ? e.left : e.right;
    return this.toNull(e);
  }
  findFirst(t, e = this.root) {
    if (e === this.nil)
      return null;
    let i = null;
    for (; e !== this.nil; )
      e = t(e.item) ? (i = e).left : e.right;
    return i;
  }
  findLast(t, e = this.root) {
    if (e === this.nil)
      return null;
    let i = null;
    for (; e !== this.nil; )
      e = t(e.item) ? (i = e).right : e.left;
    return i;
  }
  treeMinimum(t = this.root) {
    for (; t.left !== this.nil; )
      t = t.left;
    return this.toNull(t);
  }
  treeMaximum(t = this.root) {
    for (; t.right !== this.nil; )
      t = t.right;
    return this.toNull(t);
  }
  next(t) {
    if (t.right !== this.nil)
      return this.treeMinimum(t.right);
    let e = t.parent;
    for (; e !== this.nil && t === e.right; )
      t = e, e = e.parent;
    return this.toNull(e);
  }
  previous(t) {
    if (t.left !== this.nil)
      return this.treeMaximum(t.left);
    let e = t.parent;
    for (; e !== this.nil && t === e.left; )
      t = e, e = e.parent;
    return this.toNull(e);
  }
  leftRotate(t) {
    const e = t.right;
    t.right = e.left, e.left !== this.nil && (e.left.parent = t), e.parent = t.parent, t.parent === this.nil ? this.root = e : t === t.parent.left ? t.parent.left = e : t.parent.right = e, e.left = t, t.parent = e;
  }
  rightRotate(t) {
    const e = t.left;
    t.left = e.right, e.right !== this.nil && (e.right.parent = t), e.parent = t.parent, t.parent === this.nil ? this.root = e : t === t.parent.right ? t.parent.right = e : t.parent.left = e, e.right = t, t.parent = e;
  }
  deleteFixup(t) {
    for (; t !== this.root && t.color === _.Black; )
      if (t === t.parent.left) {
        let e = t.parent.right;
        e.color === _.Red && (e.color = _.Black, t.parent.color = _.Red, this.leftRotate(t.parent), e = t.parent.right), e.left.color === _.Black && e.right.color === _.Black ? (e.color = _.Red, t = t.parent) : (e.right.color === _.Black && (e.left.color = _.Black, e.color = _.Red, this.rightRotate(e), e = t.parent.right), e.color = t.parent.color, t.parent.color = _.Black, e.right.color = _.Black, this.leftRotate(t.parent), t = this.root);
      } else {
        let e = t.parent.left;
        e.color === _.Red && (e.color = _.Black, t.parent.color = _.Red, this.rightRotate(t.parent), e = t.parent.left), e.right.color === _.Black && e.left.color === _.Black ? (e.color = _.Red, t = t.parent) : (e.left.color === _.Black && (e.right.color = _.Black, e.color = _.Red, this.leftRotate(e), e = t.parent.left), e.color = t.parent.color, t.parent.color = _.Black, e.left.color = _.Black, this.rightRotate(t.parent), t = this.root);
      }
    t.color = _.Black;
  }
  deleteSubTree(t) {
    let e;
    if (t.left === this.nil || t.right === this.nil)
      e = t;
    else
      for (e = t.right; e.left !== this.nil; )
        e = e.left;
    const i = e.left !== this.nil ? e.left : e.right;
    return i.parent = e.parent, e.parent === this.nil ? this.root = i : e === e.parent.left ? e.parent.left = i : e.parent.right = i, e !== t && (t.item = e.item), e.color === _.Black && this.deleteFixup(i), this.toNull(t);
  }
  deleteNodeInternal(t) {
    this.count--, this.deleteSubTree(t);
  }
  remove(t) {
    const e = this.find(t);
    return e != null ? (this.count--, this.deleteSubTree(e)) : null;
  }
  insert(t) {
    const e = this.treeInsert(t);
    return this.insertPrivate(e), this.toNull(e);
  }
  treeInsert(t) {
    let e = this.nil, i = this.root, s = 0;
    for (; i !== this.nil; )
      e = i, s = this.comparer(t, i.item), i = s < 0 ? i.left : i.right;
    const n = new go(_.Black, t, e, this.nil, this.nil);
    return e === this.nil ? this.root = n : s < 0 ? e.left = n : e.right = n, this.toNull(n);
  }
  insertPrivate(t) {
    for (this.count++, t.color = _.Red; t !== this.root && t.parent.color === _.Red; )
      if (t.parent === t.parent.parent.left) {
        const e = t.parent.parent.right;
        e.color === _.Red ? (t.parent.color = _.Black, e.color = _.Black, t.parent.parent.color = _.Red, t = t.parent.parent) : (t === t.parent.right && (t = t.parent, this.leftRotate(t)), t.parent.color = _.Black, t.parent.parent.color = _.Red, this.rightRotate(t.parent.parent));
      } else {
        const e = t.parent.parent.left;
        e.color === _.Red ? (t.parent.color = _.Black, e.color = _.Black, t.parent.parent.color = _.Red, t = t.parent.parent) : (t === t.parent.left && (t = t.parent, this.rightRotate(t)), t.parent.color = _.Black, t.parent.parent.color = _.Red, this.leftRotate(t.parent.parent));
      }
    this.root.color = _.Black;
  }
  *allNodes() {
    if (this.isEmpty())
      return;
    let t = this.treeMinimum();
    for (; t != null; )
      yield t.item, t = this.next(t);
  }
  toString() {
    let t = "{", e = 0;
    for (const i of this.allNodes())
      t += i.toString(), e !== this.count - 1 && (t += `
`), e++;
    return t + "}";
  }
}
class la {
  *[Symbol.iterator]() {
    for (let t = 1; t <= this.heapSize; t++)
      yield this.A[t];
  }
  Enqueue(t) {
    let e = this.heapSize + 1;
    this.A[e] = t, this.heapSize++;
    let i = e >> 1, s, n;
    for (; e > 1 && this.Less(s = this.A[e], n = this.A[i]); )
      this.A[i] = s, this.A[e] = n, e = i, i = e >> 1;
  }
  Dequeue() {
    if (this.heapSize < 1)
      throw new Error();
    const t = this.A[1], e = this.A[this.heapSize];
    return this.heapSize--, this.ChangeMinimum(e), t;
  }
  ChangeMinimum(t) {
    this.A[1] = t;
    let e = 1, i = 2, s = !1;
    for (; i < this.heapSize && !s; ) {
      s = !0;
      const n = this.A[i], r = this.A[i + 1];
      this.compare(n, r) < 0 ? this.compare(n, t) < 0 && (this.A[e] = n, this.A[i] = t, s = !1, e = i, i = e << 1) : this.compare(r, t) < 0 && (this.A[e] = r, this.A[i + 1] = t, s = !1, e = i + 1, i = e << 1);
    }
    if (i === this.heapSize) {
      const n = this.A[i];
      this.compare(n, t) < 0 && (this.A[e] = n, this.A[i] = t);
    }
  }
  get Count() {
    return this.heapSize;
  }
  Less(t, e) {
    return this.compare(t, e) < 0;
  }
  constructor(t) {
    this.heapSize = 0, this.A = [], this.compare = t;
  }
  GetMinimum() {
    return this.A[1];
  }
}
class Bi {
}
class tn extends Bi {
  get Site() {
    return this.Vertex.point;
  }
  constructor(t) {
    super(), this.Vertex = t;
  }
  get Polyline() {
    return this.Vertex.polyline;
  }
}
class kd extends tn {
  constructor(t) {
    super(t);
  }
}
class _d {
  constructor(t) {
    this.lineSweeper = t;
  }
  Compare(t, e) {
    switch (u.getTriangleOrientation(e.Start, e.End, this.x)) {
      case L.Collinear:
        return 0;
      case L.Clockwise:
        return 1;
      default:
        return -1;
    }
  }
  SetOperand(t) {
    this.x = this.IntersectionOfSideAndSweepLine(t);
  }
  IntersectionOfSideAndSweepLine(t) {
    const e = t.Direction.dot(this.lineSweeper.SweepDirection), i = (this.lineSweeper.Z - t.Start.dot(this.lineSweeper.SweepDirection)) / e;
    return t.Start.add(t.Direction.mul(i));
  }
}
class Wd extends Bi {
  constructor(t) {
    super(), this.site = t;
  }
  get Site() {
    return this.site;
  }
}
class _h {
  constructor(t, e) {
    this.PreviousZ = Number.NEGATIVE_INFINITY, this.z = Number.NEGATIVE_INFINITY, this.Obstacles = t ?? [], this.SweepDirection = e, this.DirectionPerp = e.rotate(-Math.PI / 2), this.EventQueue = new la((i, s) => this.Compare(i, s)), this.ObstacleSideComparer = new _d(this), this.LeftObstacleSideTree = new Ee((i, s) => this.ObstacleSideComparer.Compare(i, s)), this.RightObstacleSideTree = new Ee((i, s) => this.ObstacleSideComparer.Compare(i, s));
  }
  get EventQueue() {
    return this.eventQueue;
  }
  set EventQueue(t) {
    this.eventQueue = t;
  }
  // sweep direction rotated by 90 degrees clockwise
  get DirectionPerp() {
    return this.directionPerp;
  }
  set DirectionPerp(t) {
    this.directionPerp = t;
  }
  get Z() {
    return this.z;
  }
  set Z(t) {
    t > this.z + m.tolerance && (this.PreviousZ = this.z), this.z = t;
  }
  GetZS(t) {
    return this.SweepDirection.dot(t.Site);
  }
  GetZP(t) {
    return this.SweepDirection.dot(t);
  }
  SegmentIsNotHorizontal(t, e) {
    return Math.abs(t.sub(e).dot(this.SweepDirection)) > m.distanceEpsilon;
  }
  RemoveLeftSide(t) {
    this.ObstacleSideComparer.SetOperand(t), this.LeftObstacleSideTree.remove(t);
  }
  RemoveRightSide(t) {
    this.ObstacleSideComparer.SetOperand(t), this.RightObstacleSideTree.remove(t);
  }
  InsertLeftSide(t) {
    this.ObstacleSideComparer.SetOperand(t), this.LeftObstacleSideTree.insert(t);
  }
  InsertRightSide(t) {
    this.ObstacleSideComparer.SetOperand(t), this.RightObstacleSideTree.insert(t);
  }
  FindFirstObstacleSideToTheLeftOfPoint(t) {
    const e = this.RightObstacleSideTree.findLast((i) => u.pointToTheRightOfLineOrOnLine(t, i.Start, i.End));
    return e == null ? null : e.item;
  }
  FindFirstObstacleSideToToTheRightOfPoint(t) {
    const e = this.LeftObstacleSideTree.findFirst((i) => !u.pointToTheRightOfLineOrOnLine(t, i.Start, i.End));
    return e == null ? null : e.item;
  }
  EnqueueEvent(t) {
    this.eventQueue.Enqueue(t);
  }
  InitQueueOfEvents() {
    for (const t of this.Obstacles)
      this.EnqueueLowestPointsOnObstacles(t);
    if (this.Ports != null)
      for (const t of this.Ports.values())
        this.EnqueueEvent(new Wd(t));
  }
  EnqueueLowestPointsOnObstacles(t) {
    const e = this.GetLowestPoint(t);
    this.EnqueueEvent(new kd(e));
  }
  GetLowestPoint(t) {
    let e = t.startPoint, i = t.startPoint.next;
    for (; i != null; i = i.next)
      this.Less(i.point, e.point) && (e = i);
    return e;
  }
  // imagine that direction points up,
  // lower events have higher priorities,
  // for events at the same level events to the left have higher priority
  Compare(t, e) {
    const i = t.Site, s = e.Site;
    return this.ComparePoints(
      /* ref */
      i,
      /* ref */
      s
    );
  }
  Less(t, e) {
    return this.ComparePoints(
      /* ref */
      t,
      /* ref */
      e
    ) < 0;
  }
  ComparePoints(t, e) {
    let i = this.SweepDirection.dot(t), s = this.SweepDirection.dot(e);
    return i < s ? -1 : i > s ? 1 : (i = this.directionPerp.dot(t), s = this.directionPerp.dot(e), i < s ? -1 : i > s ? 1 : 0);
  }
}
var po = {}, Ka;
function Hd() {
  return Ka || (Ka = 1, (function(o) {
    Object.defineProperty(o, "__esModule", { value: !0 }), o.StringBuilder = o.String = o.emptyString = void 0, o.isNullOrWhiteSpace = e, o.joinString = i, o.formatString = s;
    let t = `\r
`;
    function e(a) {
      return n.isNullOrWhiteSpace(a);
    }
    function i(a, ...l) {
      return n.join(a, ...l);
    }
    function s(a, ...l) {
      return n.format(a, ...l);
    }
    o.emptyString = "";
    class n {
      static regexNumber = /{(\d+(:\w*)?)}/g;
      static regexObject = /{(\w+(:\w*)?)}/g;
      static empty = "";
      static Empty = "";
      static IsNullOrWhiteSpace(l) {
        return n.isNullOrWhiteSpace(l);
      }
      static Join(l, ...h) {
        return n.join(l, ...h);
      }
      static Format(l, ...h) {
        return n.format(l, ...h);
      }
      static isNullOrWhiteSpace(l) {
        try {
          return l == null || l == "undefined" ? !0 : l.toString().replace(/\s/g, "").length < 1;
        } catch (h) {
          return console.log(h), !1;
        }
      }
      static join(l, ...h) {
        try {
          var c = h[0];
          if (Array.isArray(c) || c instanceof Array) {
            let p = n.empty;
            for (let P = 0; P < c.length; P++) {
              var d = c[P];
              P < c.length - 1 ? p += d + l : p += d;
            }
            return p;
          }
          if (typeof c == "object") {
            let p = n.empty, P = c;
            return Object.keys(c).forEach((y) => {
              p += P[y] + l;
            }), p = p.slice(0, p.length - l.length);
          }
          var f = h;
          return n.joinString(l, ...f);
        } catch (p) {
          return console.log(p), n.empty;
        }
      }
      static format(l, ...h) {
        try {
          return l.match(n.regexNumber) ? n.formatString(n.regexNumber, l, h) : l.match(n.regexObject) ? n.formatString(n.regexObject, l, h, !0) : l;
        } catch (c) {
          return console.log(c), n.empty;
        }
      }
      static formatString(l, h, c, d = !1) {
        return h.replace(l, function(f, p) {
          var P = f.split(":");
          1 < P.length && (p = P[0].replace("{", ""), f = P[1].replace("}", ""));
          let y;
          return (y = (d ? c[0] : c)[p]) == null || y == null || f.match(/{\d+}/) || (y = n.parsePattern(f, y)) !== void 0 && y != null ? y : n.empty;
        });
      }
      static parsePattern(l, h) {
        switch (l) {
          case "L":
            return h = h.toLocaleLowerCase();
          case "U":
            return h = h.toLocaleUpperCase();
          case "d":
            if (typeof h == "string") return n.getDisplayDateFromString(h);
            if (h instanceof Date) return n.format("{0:00}.{1:00}.{2:0000}", h.getDate(), h.getMonth(), h.getFullYear());
            break;
          case "s":
            if (typeof h == "string") return n.getSortableDateFromString(h);
            if (h instanceof Date) return n.format("{0:0000}-{1:00}-{2:00}", h.getFullYear(), h.getMonth(), h.getDate());
            break;
          case "n": {
            var f = (h = typeof h != "string" ? h.toString() : h).replace(/,/g, ".");
            if (isNaN(parseFloat(f)) || f.length <= 3) break;
            f = f.split(/\D+/g);
            let p = f;
            var f = (p = 1 < f.length ? [n.joinString("", ...f.splice(0, f.length - 1)), f[f.length - 1]] : p)[0], c = f.length % 3, d = 0 < c ? f.substring(0, c) : n.empty, f = f.substring(c).match(/.{3}/g);
            return h = d + "." + n.join(".", f) + (1 < p.length ? "," + p[1] : "");
          }
          case "x":
            return this.decimalToHexString(h);
          case "X":
            return this.decimalToHexString(h, !0);
        }
        return typeof h != "number" && isNaN(h) || isNaN(+l) || n.isNullOrWhiteSpace(h) ? h : n.formatNumber(h, l);
      }
      static decimalToHexString(l, h = !1) {
        return l = parseFloat(l).toString(16), h ? l.toLocaleUpperCase() : l;
      }
      static getDisplayDateFromString(l) {
        var h = l.split("-");
        if (h.length <= 1) return l;
        let c = h[h.length - 1];
        return l = h[h.length - 2], h = h[h.length - 3], (c = (c = c.split("T")[0]).split(" ")[0]) + `.${l}.` + h;
      }
      static getSortableDateFromString(l) {
        var h = l.replace(",", "").split(".");
        if (h.length <= 1) return l;
        l = h[h.length - 1].split(" ");
        let c = n.empty, d = (1 < l.length && (c = l[l.length - 1]), h[h.length - 1].split(" ")[0] + `-${h[h.length - 2]}-` + h[h.length - 3]);
        return !n.isNullOrWhiteSpace(c) && 1 < c.length ? d += "T" + c : d += "T00:00:00", d;
      }
      static formatNumber(d, c) {
        var c = c.length, d = d.toString();
        return c <= d.length ? d : (c = c - d.length, ++c, new Array(c).join("0") + d);
      }
      static joinString(l, ...h) {
        let c = n.empty;
        for (let f = 0; f < h.length; f++) if (!(typeof h[f] == "string" && n.isNullOrWhiteSpace(h[f]) || typeof h[f] != "number" && typeof h[f] != "string")) {
          var d = "" + h[f];
          c += d;
          for (let p = f + 1; p < h.length; p++) if (!n.isNullOrWhiteSpace(h[p])) {
            c += l, f = p - 1;
            break;
          }
        }
        return c;
      }
    }
    o.String = n;
    class r {
      Values;
      constructor(l = "") {
        this.Values = [], n.isNullOrWhiteSpace(l) || (this.Values = new Array(l));
      }
      toString() {
        return this.Values.join(n.empty);
      }
      ToString() {
        return this.toString();
      }
      append(l) {
        this.Values.push(l);
      }
      Append(l) {
        this.append(l);
      }
      appendLine(l) {
        this.Values.push(t + l);
      }
      AppendLine(l) {
        this.appendLine(l);
      }
      appendFormat(l, ...h) {
        this.Values.push(n.format(l, ...h));
      }
      AppendFormat(l, ...h) {
        this.appendFormat(l, ...h);
      }
      appendLineFormat(l, ...h) {
        this.Values.push(t + n.format(l, ...h));
      }
      AppendLineFormat(l, ...h) {
        return this.appendLineFormat(l, ...h);
      }
      clear() {
        this.Values = [];
      }
      Clear() {
        this.clear();
      }
    }
    o.StringBuilder = r;
  })(po)), po;
}
var Bt = Hd();
class ce {
  static closeuv(t, e) {
    return u.closeDistEps(t.point, ce.u, 0.1) && u.closeDistEps(e.point, ce.v, 0.1);
  }
  constructor(t, e, i = 1) {
    this.LengthMultiplier = 1, this.Source = t, this.Target = e, this.Weight = i;
  }
  // edge source point
  get SourcePoint() {
    return this.Source.point;
  }
  // edge target point
  get TargetPoint() {
    return this.Target.point;
  }
  get Length() {
    return this.SourcePoint.sub(this.TargetPoint).length * this.LengthMultiplier;
  }
  toString() {
    return Bt.String.format("{0}->{1} ({2})", this.Source, this.Target, this.Weight);
  }
  ReversedClone() {
    return new ce(this.Target, this.Source);
  }
  Clone() {
    return new ce(this.Source, this.Target);
  }
}
ce.u = new u(545.833, 840.458);
ce.v = new u(606.1667261889578, 786.2917261889578);
ce.DefaultWeight = 1;
class pi extends ce {
  static constructorVV(t, e) {
    return new pi(t, e, 0);
  }
  constructor(t, e, i = 0) {
    super(t, e, i);
  }
}
class ii {
  deleteP(t) {
    return this.delete(t.x, t.y);
  }
  clear() {
    this.m.clear();
  }
  get size() {
    return this.m.size;
  }
  setxy(t, e, i) {
    this.m.set(ir(t, e), i);
  }
  set(t, e) {
    this.setxy(t.x, t.y, e);
  }
  delete(t, e) {
    return this.m.delete(ir(t, e));
  }
  hasxy(t, e) {
    return this.m.has(ir(t, e));
  }
  has(t) {
    return this.hasxy(t.x, t.y);
  }
  getxy(t, e) {
    return this.m.get(ir(t, e));
  }
  get(t) {
    return this.getxy(t.x, t.y);
  }
  constructor() {
    this.m = /* @__PURE__ */ new Map();
  }
  *keys() {
    for (const t of this.m.keys()) {
      const e = t.split(",");
      yield new u(Number(e[0]), Number(e[1]));
    }
  }
  *[Symbol.iterator]() {
    for (const [t, e] of this.m) {
      const i = t.split(",");
      yield [new u(Number(i[0]), Number(i[1])), e];
    }
  }
  *values() {
    yield* this.m.values();
  }
}
function ir(o, t) {
  return o.toString() + "," + t.toString();
}
class Ds {
  get InEdges() {
    return this._inEdges;
  }
  // this collection is sorted by the target point, in the lexicographical order
  get OutEdges() {
    return this._outEdges;
  }
  get Degree() {
    return this._inEdges.length + this.OutEdges.count;
  }
  InEdgesLength() {
    return this._inEdges.length;
  }
  addInEdge(t) {
    this._inEdges.push(t);
  }
  get IsTerminal() {
    return this._isTerminal;
  }
  set IsTerminal(t) {
    this._isTerminal = t;
  }
  get IsShortestPathTerminal() {
    return this._isShortestPathTerminal;
  }
  set IsShortestPathTerminal(t) {
    this._isShortestPathTerminal = t;
  }
  constructor(t) {
    this._inEdges = new Array(), this._outEdges = new Ee((e, i) => this.Compare(e, i)), this.point = t;
  }
  toString() {
    return this.point.toString();
  }
  // These iterate from the end of the list because Array.Remove is linear in
  // the number of items, so callers have been optimized where possible to
  // remove only the last or next-to-last edges (but in some cases such as
  // rectilinear, this optimization isn't always possible).
  RemoveOutEdge(t) {
    this.OutEdges.remove(t);
  }
  RemoveInEdge(t) {
    const e = this._inEdges.indexOf(t);
    if (e === -1)
      return;
    const i = this._inEdges.length - 1;
    e !== i && (this._inEdges[e] = this._inEdges[i]), this._inEdges.pop();
  }
  // avoiding using delegates in calling RBTree.FindFirst because of the memory allocations
  static FindFirst(t, e) {
    return Ds.FindFirst_t(t.root, t, e);
  }
  static FindFirst_t(t, e, i) {
    if (t === e.nil)
      return null;
    let s = null;
    for (; t !== e.nil; )
      t = t.item.TargetPoint.compareTo(i) >= 0 ? (s = t).left : t.right;
    return s;
  }
  get(t) {
    let e = Ds.FindFirst(this.OutEdges, t.point);
    return e != null && e.item.Target === t || (e = Ds.FindFirst(t.OutEdges, this.point), e != null && e.item.Target === this) ? e.item : null;
  }
  Compare(t, e) {
    return t.TargetPoint.compareTo(e.TargetPoint);
  }
  ClearEdges() {
    this._outEdges.clear(), this._inEdges = [];
  }
}
class Et {
  constructor() {
    this.activeVertices = /* @__PURE__ */ new Set(), this.VertexFactory = (t) => new Ds(t), this.pointToVertexMap = new ii();
  }
  *edges_() {
    for (const t of this.pointToVertexMap.values())
      for (const e of t.OutEdges)
        yield e;
  }
  get Edges() {
    return this.edges_();
  }
  ClearPrevEdgesTable() {
    for (const t of this.activeVertices)
      t.prevEdge = null;
    this.activeVertices.clear();
  }
  ShrinkLengthOfPrevEdge(t, e) {
    t.prevEdge.LengthMultiplier = e;
  }
  // needed for shortest path calculations
  PreviosVertex(t) {
    const e = t.prevEdge;
    return e ? e.Source === t ? e.Target : e.Source : null;
  }
  SetPreviousEdge(t, e) {
    this.activeVertices.add(t), t.prevEdge = e;
  }
  //  static GetVisibilityGraphForShortestPath(pathStart: Point, pathEnd: Point, obstacles: Array<Polyline>, /* out */sourceVertex: VisibilityVertex, /* out */targetVertex: VisibilityVertex): VisibilityGraph {
  //      let holes = new Array<Polyline>(VisibilityGraph.OrientHolesClockwise(obstacles));
  //      let visibilityGraph = VisibilityGraph.CalculateGraphOfBoundaries(holes);
  //      let polygons = holes.Select(() => {  }, new Polygon(holes)).ToList();
  //      TangentVisibilityGraphCalculator.AddTangentVisibilityEdgesToGraph(polygons, visibilityGraph);
  //      PointVisibilityCalculator.CalculatePointVisibilityGraph(holes, visibilityGraph, pathStart, VisibilityKind.Tangent, /* out */sourceVertex);
  //      PointVisibilityCalculator.CalculatePointVisibilityGraph(holes, visibilityGraph, pathEnd, VisibilityKind.Tangent, /* out */targetVertex);
  //      return visibilityGraph;
  //  }
  //  //  Calculates the tangent visibility graph
  //  public static FillVisibilityGraphForShortestPath(obstacles: Array<Polyline>): VisibilityGraph {
  //      let holes = new Array<Polyline>(VisibilityGraph.OrientHolesClockwise(obstacles));
  //      let visibilityGraph = VisibilityGraph.CalculateGraphOfBoundaries(holes);
  //      let polygons = holes.Select(() => {  }, new Polygon(hole)).ToList();
  //      TangentVisibilityGraphCalculator.AddTangentVisibilityEdgesToGraph(polygons, visibilityGraph);
  //      return visibilityGraph;
  //  }
  //  static CalculateGraphOfBoundaries(holes: Array<Polyline>): VisibilityGraph {
  //      let graphOfHoleBoundaries = new VisibilityGraph();
  //      for (let polyline: Polyline of holes) {
  //          graphOfHoleBoundaries.AddHole(polyline);
  //      }
  //      return graphOfHoleBoundaries;
  //  }
  AddHole(t) {
    let e = t.startPoint;
    for (; e !== t.endPoint; )
      this.AddEdgePlPl(e, e.next), e = e.next;
    this.AddEdgePlPl(t.endPoint, t.startPoint);
  }
  static *OrientHolesClockwise(t) {
    for (const e of t)
      for (let i = e.startPoint; ; i = i.next) {
        const s = u.getTriangleOrientation(i.point, i.next.point, i.next.next.point);
        if (s !== L.Collinear) {
          yield s === L.Clockwise ? e : e.reverse();
          break;
        }
      }
  }
  //  static CheckThatPolylinesAreConvex(holes: Array<Polyline>) {
  //      for (let polyline of holes) {
  //          VisibilityGraph.CheckThatPolylineIsConvex(polyline);
  //      }
  //  }
  //  static CheckThatPolylineIsConvex(polyline: Polyline) {
  //      Assert.assert(polyline.closed, "Polyline is not closed");
  //      let a: PolylinePoint = polyline.startPoint;
  //      let b: PolylinePoint = a.next;
  //      let c: PolylinePoint = b.next;
  //      let orient: TriangleOrientation = Point.getTriangleOrientation(a.point, b.point, c.point);
  //      while ((c !== polyline.endPoint)) {
  //          a = a.next;
  //          b = b.next;
  //          c = c.next;
  //          let currentOrient = Point.getTriangleOrientation(a.point, b.point, c.point);
  //          if ((currentOrient === TriangleOrientation.Collinear)) {
  //              continue
  //          }
  //          if ((orient === TriangleOrientation.Collinear)) {
  //              orient = currentOrient;
  //          }
  //          else if ((orient !== currentOrient)) {
  //              throw new InvalidOperationException();
  //          }
  //      }
  //      let o = Point.getTriangleOrientation(polyline.endPoint.Point, polyline.startPoint.Point, polyline.startPoint.Next.Point);
  //      if (((o !== TriangleOrientation.Collinear)
  //                  && (o !== orient))) {
  //          throw new InvalidOperationException();
  //      }
  //  }
  //  //  TEST || VERIFY
  //  //  Enumerate all VisibilityEdges in the VisibilityGraph.
  //  public get Edges(): Array<VisibilityEdge> {
  //      return PointToVertexMap.Values.SelectMany(() => {  }, vertex.OutEdges);
  //  }
  //  get PointToVertexMap(): Map<Point, VisibilityVertex> {
  //      return this.pointToVertexMap;
  //  }
  //  get VertexCount(): number {
  //      return this.PointToVertexMap.Count;
  //  }
  //  AddVertex(polylinePoint: PolylinePoint): VisibilityVertex {
  //      return this.AddVertex(polylinePoint.point);
  //  }
  AddVertexP(t) {
    const e = this.pointToVertexMap.get(t);
    if (e)
      return e;
    const i = this.VertexFactory(t);
    return this.pointToVertexMap.set(t, i), i;
  }
  AddVertexV(t) {
    this.pointToVertexMap.set(t.point, t);
  }
  ContainsVertex(t) {
    return this.pointToVertexMap.has(t);
  }
  static AddEdgeVV(t, e) {
    let i;
    if (i = t.get(e))
      return i;
    if (t === e)
      throw new Error("Self-edges are not allowed");
    const s = new ce(t, e);
    return t.OutEdges.insert(s), e.InEdges.push(s), s;
  }
  AddEdgePlPl(t, e) {
    this.AddEdgePP(t.point, e.point);
  }
  static AddEdge(t) {
    t.Source.OutEdges.insert(t), t.Target.addInEdge(t);
  }
  AddEdgeF(t, e, i) {
    let s = this.FindVertex(t), n = null;
    if (s != null && (n = this.FindVertex(e), n != null)) {
      const a = s.get(n);
      if (a)
        return a;
    }
    s == null ? (s = this.AddVertexP(t), n = this.AddVertexP(e)) : n == null && (n = this.AddVertexP(e));
    const r = i(s, n);
    return s.OutEdges.insert(r), n.addInEdge(r), r;
  }
  AddEdgePP(t, e) {
    return this.AddEdgeF(t, e, (i, s) => new ce(i, s));
  }
  FindVertex(t) {
    return this.pointToVertexMap.get(t);
  }
  Vertices() {
    return this.pointToVertexMap.values();
  }
  RemoveVertex(t) {
    for (const e of t.OutEdges)
      e.Target.RemoveInEdge(e);
    for (const e of t.InEdges)
      e.Source.RemoveOutEdge(e);
    this.pointToVertexMap.deleteP(t.point);
  }
  //  RemoveEdge(v1: VisibilityVertex, v2: VisibilityVertex) {
  //      let edge: VisibilityEdge;
  //      if (!v1.TryGetEdge(v2, /* out */edge)) {
  //          return;
  //      }
  //      edge.Source.RemoveOutEdge(edge);
  //      edge.Target.RemoveInEdge(edge);
  //  }
  //  RemoveEdge(p1: Point, p2: Point) {
  //      //  the order of p1 and p2 is not important.
  //      let edge: VisibilityEdge = this.FindEdge(p1, p2);
  //      if ((edge == null )) {
  //          return;
  //      }
  //      edge.Source.RemoveOutEdge(edge);
  //      edge.Target.RemoveInEdge(edge);
  //  }
  //  static FindEdge(edge: VisibilityEdge): VisibilityEdge {
  //      if (edge.Source.TryGetEdge(edge.Target, /* out */edge)) {
  //          return edge;
  //      }
  //      return null;
  //  }
  FindEdgePP(t, e) {
    const i = this.FindVertex(t);
    if (i == null)
      return null;
    const s = this.FindVertex(e);
    return s == null ? null : i.get(s);
  }
  static RemoveEdge(t) {
    t.Source.RemoveOutEdge(t), t.Target.RemoveInEdge(t);
  }
  ClearEdges() {
    for (const t of this.Vertices())
      t.ClearEdges();
  }
}
class ha {
  constructor() {
    this.Removed = !1;
  }
}
class Rs extends ha {
  get Start() {
    return this.start;
  }
  get End() {
    return this.EndVertex.point;
  }
  constructor(t, e, i) {
    super(), this.start = t, this.EndVertex = e, this.ConeSide = i;
  }
  get Direction() {
    return this.End.sub(this.Start);
  }
  toString() {
    return "BrokenConeSide: " + (this.Start + ("," + this.End));
  }
}
class mo {
  get Removed() {
    return this.removed;
  }
  set Removed(t) {
    this.removed = t;
  }
  constructor(t, e) {
    this.apex = t, this.coneSweeper = e;
  }
  get Apex() {
    return this.apex;
  }
  set Apex(t) {
    this.apex = t;
  }
  get RightSideDirection() {
    return this.coneSweeper.ConeRightSideDirection;
  }
  get LeftSideDirection() {
    return this.coneSweeper.ConeLeftSideDirection;
  }
  get RightSide() {
    return this.rightSide;
  }
  set RightSide(t) {
    this.rightSide = t, this.rightSide.Cone = this;
  }
  get LeftSide() {
    return this.leftSide;
  }
  set LeftSide(t) {
    this.leftSide = t, this.leftSide.Cone = this;
  }
}
class Za extends Bi {
  get ConeToClose() {
    return this.coneToClose;
  }
  get Site() {
    return this.site;
  }
  constructor(t, e) {
    super(), this.site = t, this.coneToClose = e;
  }
  toString() {
    return "ConeClosureEvent " + this.site;
  }
}
class ri extends ha {
  constructor(t) {
    super(), this.Cone = t;
  }
  get Start() {
    return this.Cone.Apex;
  }
  get Direction() {
    return this.Cone.LeftSideDirection;
  }
  toString() {
    return "ConeLeftSide " + this.Start + (" " + this.Direction);
  }
}
class Gi extends ha {
  constructor(t) {
    super(), this.Cone = t;
  }
  get Start() {
    return this.Cone.Apex;
  }
  get Direction() {
    return this.Cone.RightSideDirection;
  }
  toString() {
    return "ConeRightSide " + this.Start + " " + this.Direction;
  }
}
class Nr {
  SetOperand(t) {
    this.x = this.IntersectionOfSegmentAndSweepLine(t);
  }
  constructor(t) {
    this.coneSweeper = t;
  }
  Compare(t, e) {
    const i = t instanceof Rs, s = e instanceof Rs;
    return i ? s ? this.CompareBrokenSides(t, e) : this.CompareObstacleSideAndConeSide(e) : s ? this.CompareConeSideAndObstacleSide(t, e) : Nr.CompareNotIntersectingSegs(t, e);
  }
  static CompareNotIntersectingSegs(t, e) {
    switch (u.getTriangleOrientation(t.Start, e.Start, e.Start.add(e.Direction))) {
      case L.Counterclockwise:
        return -1;
      case L.Clockwise:
        return 1;
      default:
        return 0;
    }
  }
  CompareObstacleSideAndConeSide(t) {
    const e = u.getTriangleOrientation(this.x, t.Start, t.Start.add(t.Direction));
    return e === L.Counterclockwise ? -1 : e === L.Clockwise ? 1 : t instanceof ri ? -1 : 1;
  }
  CompareConeSideAndObstacleSide(t, e) {
    const i = u.getTriangleOrientation(this.x, e.start, e.End);
    return i === L.Counterclockwise ? -1 : i === L.Clockwise || t instanceof ri ? 1 : -1;
  }
  IntersectionOfSegmentAndSweepLine(t) {
    const e = t.Direction.dot(this.coneSweeper.SweepDirection), i = (this.coneSweeper.Z - t.Start.dot(this.coneSweeper.SweepDirection)) / e;
    return t.Start.add(t.Direction.mul(i));
  }
  CompareBrokenSides(t, e) {
    return t.EndVertex === e.EndVertex ? Nr.CompareNotIntersectingSegs(t.ConeSide, e.ConeSide) : u.getTriangleOrientation(this.x, e.start, e.EndVertex.point) === L.Counterclockwise ? -1 : 1;
  }
}
class hn extends Bi {
  get EndVertex() {
    return this.endVertex;
  }
  constructor(t, e, i) {
    super(), this.coneLeftSide = t, this.intersectionPoint = e, this.endVertex = i;
  }
  get Site() {
    return this.intersectionPoint;
  }
  toString() {
    return "LeftIntersectionEvent " + this.intersectionPoint;
  }
}
class ca {
  get Direction() {
    return this.End.sub(this.Start);
  }
  toString() {
    return this.Start + " " + this.End;
  }
}
class ua extends ca {
  Init(t) {
    this.StartVertex = t;
  }
  constructor(t) {
    super(), this.Init(t);
  }
  get Polyline() {
    return this.StartVertex.polyline;
  }
  get Start() {
    return this.StartVertex.point;
  }
  get End() {
    return this.EndVertex.point;
  }
}
class Ns extends ua {
  constructor(t) {
    super(t), this.end = t.nextOnPolyline.point;
  }
  get End() {
    return this.end;
  }
  get EndVertex() {
    return this.StartVertex.nextOnPolyline;
  }
}
class as extends tn {
  constructor(t) {
    super(t);
  }
}
class $a extends Bi {
  get EndVertex() {
    return this.endVertex;
  }
  set EndVertex(t) {
    this.endVertex = t;
  }
  constructor(t, e, i) {
    super(), this.coneRightSide = t, this.intersectionPoint = e, this.endVertex = i;
  }
  get Site() {
    return this.intersectionPoint;
  }
  toString() {
    return "RightIntersectionEvent " + this.intersectionPoint;
  }
}
class Bs extends ua {
  constructor(t) {
    super(t), this.end = t.prevOnPolyline.point;
  }
  get End() {
    return this.end;
  }
  get EndVertex() {
    return this.StartVertex.prevOnPolyline;
  }
}
class ls extends tn {
  constructor(t) {
    super(t);
  }
}
class Ut extends _h {
  constructor(t, e, i, s, n, r, a) {
    super(t, e), this.visibilityGraph = n, this.ConeRightSideDirection = i, this.ConeLeftSideDirection = s, this.coneSideComparer = new Nr(this), this.leftConeSides = new Ee((l, h) => this.coneSideComparer.Compare(l, h)), this.rightConeSides = new Ee((l, h) => this.coneSideComparer.Compare(l, h)), this.Ports = r, this.BorderPolyline = a, this.PortEdgesCreator = (l, h) => new pi(l, h, 0);
  }
  static Sweep(t, e, i, s, n, r) {
    new Ut(t, e, e.rotate(-i / 2), e.rotate(i / 2), s, n, r).Calculate();
  }
  Calculate() {
    for (this.InitQueueOfEvents(); this.EventQueue.Count > 0; )
      this.ProcessEvent(this.EventQueue.Dequeue());
    this.BorderPolyline != null && this.CloseRemainingCones(), this.CreatePortEdges();
  }
  CreatePortEdges() {
    if (this.portEdgesGraph != null)
      for (const t of this.portEdgesGraph.Edges)
        this.visibilityGraph.AddEdgeF(t.SourcePoint, t.TargetPoint, this.PortEdgesCreator);
  }
  CloseRemainingCones() {
    if (this.leftConeSides.count === 0)
      return;
    let t = this.BorderPolyline.startPoint, e = this.leftConeSides.count;
    do {
      const i = this.leftConeSides.treeMinimum().item.Cone;
      t = this.FindPolylineSideIntersectingConeRightSide(t, i), t = this.GetPolylinePointInsideOfConeAndRemoveCones(t, i), e--;
    } while (this.leftConeSides.count > 0 && e > 0);
  }
  GetPolylinePointInsideOfConeAndRemoveCones(t, e) {
    const i = t.nextOnPolyline, s = Ut.FindInsidePoint(t.point, i.point, e);
    return u.closeDistEps(s, t.point) ? (this.AddEdgeAndRemoveCone(e, t.point), this.AddEdgesAndRemoveRemainingConesByPoint(t.point)) : u.closeDistEps(s, i.point) ? (this.AddEdgeAndRemoveCone(e, i.point), this.AddEdgesAndRemoveRemainingConesByPoint(i.point), t = i) : (t = Ut.InsertPointIntoPolylineAfter(this.BorderPolyline, t, s), this.AddEdgeAndRemoveCone(e, t.point), this.AddEdgesAndRemoveRemainingConesByPoint(t.point)), t;
  }
  static FindInsidePoint(t, e, i) {
    return Ut.FindInsidePointBool(t, e, i.Apex, i.Apex.add(i.LeftSideDirection), i.Apex.add(i.RightSideDirection));
  }
  static FindInsidePointBool(t, e, i, s, n) {
    if (u.closeDistEps(t, e) || u.PointIsInsideCone(t, i, s, n))
      return t;
    if (u.PointIsInsideCone(e, i, s, n))
      return e;
    const r = u.middle(t, e);
    return u.pointToTheLeftOfLine(r, i, s) ? Ut.FindInsidePointBool(r, e, i, s, n) : Ut.FindInsidePointBool(t, r, i, s, n);
  }
  AddEdgesAndRemoveRemainingConesByPoint(t) {
    const e = new Array();
    for (const i of this.leftConeSides)
      if (u.PointToTheRightOfLineOrOnLine(t, i.Start, i.Start.add(i.Direction)))
        e.push(i.Cone);
      else
        break;
    for (const i of e)
      this.AddEdgeAndRemoveCone(i, t);
  }
  FindPolylineSideIntersectingConeRightSide(t, e) {
    const i = t, s = e.Apex, n = e.Apex.add(this.ConeRightSideDirection);
    let r = Ut.GetSign(t, s, n);
    for (; ; ) {
      const a = t.nextOnPolyline, l = Ut.GetSign(a, s, n);
      if (l - r > 0)
        return t;
      if (t = a, r = l, t === i)
        throw new Error("cannod decide if the polyline intersects the cone!");
    }
  }
  // #if TEST_MSAGL
  //         // ReSharper disable UnusedMember.Local
  //         static ICurve Box(Point p) {
  //             // ReSharper restore UnusedMember.Local
  //             return CurveFactory.CreateRectangle(2, 2, p);
  //         }
  //             "CA1303:Do not pass literals as localized parameters", MessageId = "System.Diagnostics.Debug.WriteLine(System.String)"
  //         )]
  //         void PrintOutRightSegTree() {
  //             System.Diagnostics.Debug.WriteLine("right segment tree");
  //             foreach(var t of rightConeSides)
  //             System.Diagnostics.Debug.WriteLine(t);
  //             System.Diagnostics.Debug.WriteLine("end of right segments");
  //         }
  // #endif
  static GetSign(t, e, i) {
    const s = u.signedDoubledTriangleArea(e, i, t.point);
    return s < 0 ? 1 : s > 0 ? -1 : 0;
  }
  // #if TEST_MSAGL && TEST_MSAGL
  //         void Showside(PolylinePoint p, Point a, Point b, PolylinePoint pn) {
  //             ShowBothTrees(new DebugCurve(100, 1, "brown", BorderPolyline), new DebugCurve(100, 2, "blue",
  //                 new LineSegment(a, b)),
  //                 new DebugCurve(100, 2, "green",
  //                     new LineSegment(
  //                         pn.point, p.point)
  //                 ));
  //         }
  // #endif
  //        void CheckThatPolylineIsLegal()
  //        {
  //            var p = BorderPolyline.startPoint;
  //            do
  //            {
  //                var pn = p.NextOnPolyline;
  //                Assert.assert(!Point.closeDistEps(p.point, pn.point));
  //                Assert.assert((pn.point - p.point)*(pn.NextOnPolyline.point - pn.point) > -GeomConstants.tolerance);
  //                p = pn;
  //            } while (p !== BorderPolyline.startPoint);
  //        }
  // #if TEST_MSAGL
  //         void ShowBoundaryPolyline() {
  //             LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(CreateBoundaryPolyDebugCurves());
  //         }
  //         Array < DebugCurve > CreateBoundaryPolyDebugCurves() {
  //             int i = 0;
  //             for (var p = BorderPolyline.startPoint; p != null; p = p.next) {
  //                 yield return new DebugCurve(new Ellipse(1, 1, p.point), i++);
  //             }
  //         }
  // #endif
  AddEdgeAndRemoveCone(t, e) {
    this.Ports != null && this.Ports.has(t.Apex) ? this.CreatePortEdge(t, e) : this.visibilityGraph.AddEdgePP(t.Apex, e), this.RemoveCone(t);
  }
  CreatePortEdge(t, e) {
    this.portEdgesGraph == null && (this.portEdgesGraph = new Et());
    const i = this.portEdgesGraph.FindVertex(t.Apex), s = i != null ? Array.from(i.InEdges).concat(Array.from(i.OutEdges.allNodes())) : null;
    if (s)
      for (const n of s) {
        const r = (n.Target === i ? n.Source : n.Target).point;
        Et.RemoveEdge(n), this.portEdgesGraph.AddEdgePP(r, e);
      }
    this.portEdgesGraph.AddEdgePP(t.Apex, e);
  }
  static InsertPointIntoPolylineAfter(t, e, i) {
    let s;
    return e.next != null ? (s = ei.mkFromPoint(i), s.prev = e, s.next = e.next, e.next.prev = s, e.next = s) : (s = ei.mkFromPoint(i), s.prev = e, e.next = s, t.endPoint = s), s.polyline = t, t.setInitIsRequired(), s;
  }
  ProcessEvent(t) {
    t instanceof tn ? this.ProcessVertexEvent(t) : t instanceof $a ? this.ProcessRightIntersectionEvent(t) : t instanceof hn ? this.ProcessLeftIntersectionEvent(t) : (t instanceof Za ? t.ConeToClose.Removed || this.RemoveCone(t.ConeToClose) : this.ProcessPortObstacleEvent(t), this.Z = this.GetZS(t));
  }
  // #if TEST_MSAGL
  //        protected override bool TreesAreCorrect() {
  //            return TreeIsCorrect(leftConeSides) && TreeIsCorrect(rightConeSides);
  //        }
  //
  //        bool TreeIsCorrect(RBTree<ConeSide> tree) {
  //            var y = Number.NEGATIVE_INFINITY;
  //            foreach (var t of tree) {
  //                var x = coneSideComparer.IntersectionOfSegmentAndSweepLine(t);
  //                var yp = x*DirectionPerp;
  //                if (yp < y - GeomConstants.distanceEpsilon)
  //                    return false;
  //                y = yp;
  //            }
  //            return true;
  //        }
  // #endif
  ProcessPortObstacleEvent(t) {
    this.Z = this.GetZS(t), this.GoOverConesSeeingVertexEvent(t), this.CreateConeOnVertex(t);
  }
  ProcessLeftIntersectionEvent(t) {
    if (t.coneLeftSide.Removed === !1)
      if (Math.abs(t.EndVertex.point.sub(t.Site).dot(this.SweepDirection)) < m.distanceEpsilon)
        this.RemoveCone(t.coneLeftSide.Cone);
      else {
        this.RemoveSegFromLeftTree(t.coneLeftSide), this.Z = this.GetZP(t.Site);
        const e = new Rs(t.Site, t.EndVertex, t.coneLeftSide);
        this.InsertToTree(this.leftConeSides, e), t.coneLeftSide.Cone.LeftSide = e, this.LookForIntersectionOfObstacleSideAndLeftConeSide(t.Site, t.EndVertex), this.TryCreateConeClosureForLeftSide(e);
      }
    else
      this.Z = this.GetZP(t.Site);
  }
  TryCreateConeClosureForLeftSide(t) {
    if (t.Cone.RightSide instanceof Gi) {
      const e = t.Cone.RightSide;
      u.getTriangleOrientation(e.Start, e.Start.add(e.Direction), t.EndVertex.point) == L.Clockwise && this.CreateConeClosureEvent(t, e);
    }
  }
  CreateConeClosureEvent(t, e) {
    const i = u.RayIntersectsRayInteriors(t.start, t.Direction, e.Start, e.Direction);
    if (i) {
      const s = new Za(i, t.Cone);
      this.EnqueueEvent(s);
    }
  }
  ProcessRightIntersectionEvent(t) {
    if (t.coneRightSide.Removed)
      this.Z = this.GetZP(t.Site);
    else {
      this.RemoveSegFromRightTree(t.coneRightSide), this.Z = this.GetZP(t.Site);
      const e = new Rs(t.Site, t.EndVertex, t.coneRightSide);
      this.InsertToTree(this.rightConeSides, e), t.coneRightSide.Cone.RightSide = e, this.LookForIntersectionOfObstacleSideAndRightConeSide(t.Site, t.EndVertex), this.TryCreateConeClosureForRightSide(e);
    }
  }
  TryCreateConeClosureForRightSide(t) {
    if (t.Cone.LeftSide instanceof ri) {
      const e = t.Cone.LeftSide;
      u.getTriangleOrientation(e.Start, e.Start.add(e.Direction), t.EndVertex.point) == L.Counterclockwise && this.CreateConeClosureEvent(t, e);
    }
  }
  RemoveConesClosedBySegment(t, e) {
    this.CloseConesCoveredBySegment(t, e, this.GetZP(t) > this.GetZP(e) ? this.leftConeSides : this.rightConeSides);
  }
  CloseConesCoveredBySegment(t, e, i) {
    let s = i.findFirst((a) => u.getTriangleOrientation(a.Start, a.Start.add(a.Direction), t) === L.Counterclockwise);
    if (s == null || !u.IntervalIntersectsRay(t, e, s.item.Start, s.item.Direction))
      return;
    const r = new Array();
    do
      r.push(s.item.Cone), s = i.next(s);
    while (s != null && u.IntervalIntersectsRay(t, e, s.item.Start, s.item.Direction) !== void 0);
    for (const a of r)
      this.RemoveCone(a);
  }
  ProcessVertexEvent(t) {
    this.Z = this.GetZS(t), this.GoOverConesSeeingVertexEvent(t), this.AddConeAndEnqueueEvents(t);
  }
  // #if TEST_MSAGL
  //         // ReSharper disable UnusedMember.Local
  //         static Ellipse EllipseOnVert(SweepEvent vertexEvent) {
  //             // ReSharper restore UnusedMember.Local
  //             return new Ellipse(5, 5, vertexEvent.Site);
  //         }
  //         // ReSharper disable UnusedMember.Local
  //         static Ellipse EllipseOnPolylinePoint(PolylinePoint pp) {
  //             // ReSharper restore UnusedMember.Local
  //             return EllipseOnPolylinePoint(pp, 5);
  //         }
  //         // ReSharper disable UnusedMember.Local
  //         static Ellipse EllipseOnPolylinePoint(PolylinePoint pp, double i)
  //         // ReSharper restore UnusedMember.Local
  //         {
  //             return new Ellipse(i, i, pp.point);
  //         }
  static Diamond(t) {
    return pt.mkDiamond(2, 2, t);
  }
  //         // ReSharper disable UnusedMember.Local
  //             "CA1303:Do not pass literals as localized parameters", MessageId = "System.Diagnostics.Debug.WriteLine(System.String)"
  //         ),
  //         void CheckConsistency() {
  //             // ReSharper restore UnusedMember.Local
  //             foreach(var s of rightConeSides) {
  //                 coneSideComparer.SetOperand(s);
  //             }
  //             foreach(var s of leftConeSides) {
  //                 coneSideComparer.SetOperand(s);
  //                 if (!rightConeSides.Contains(s.Cone.RightSide)) {
  //                     PrintOutRightSegTree();
  //                     PrintOutLeftSegTree();
  //                     ShowLeftTree();
  //                     ShowRightTree();
  //                 }
  //             }
  //         }
  //         void ShowRightTree(params ICurve[] curves) {
  //             var l = Obstacles.Select(p => new DebugCurve(100, 5, "green", p)).ToList();
  //             l.AddRange(rightConeSides.Select(s => new DebugCurve(100, 5, "blue", ExtendSegmentToZ(s))));
  //             //            foreach (VisibilityEdge edge of visibilityGraph.Edges)
  //             //                l.Add(BezierOnEdge(edge));
  //             l.AddRange(curves.Select(c => new DebugCurve(100, 5, "brown", c)));
  //             LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);
  //         }
  //         void ShowBothTrees(params DebugCurve[] curves) {
  //             var l = Obstacles.Select(p => new DebugCurve(100, 5, "green", p)).ToList();
  //             l.AddRange(leftConeSides.Select(s => new DebugCurve(ExtendSegmentToZ(s))));
  //             l.AddRange(rightConeSides.Select(s => new DebugCurve(ExtendSegmentToZ(s))));
  //             //            foreach (VisibilityEdge edge of visibilityGraph.Edges)
  //             //                l.Add(BezierOnEdge(edge));
  //             LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);
  //         }
  //         void ShowLeftTree(params ICurve[] curves) {
  //             var l = Obstacles.Select(p => new DebugCurve(100, 0.01, "green", p)).ToList();
  //             var range = new RealNumberSpan();
  //             var ellipseSize = 0.01;
  //             foreach(var s of leftConeSides) {
  //                 var curve = ExtendSegmentToZ(s);
  //                 range.AddValue(curve.start * DirectionPerp);
  //                 range.AddValue(curve.End * DirectionPerp);
  //                 l.Add(new DebugCurve(100, 0.1, "red", curve));
  //                 l.Add(new DebugCurve(200, 0.1, "black", new Ellipse(ellipseSize, ellipseSize, curve.End)));
  //                 ellipseSize += 2;
  //             }
  //             l.Add(DebugSweepLine(range));
  //             //            foreach (VisibilityEdge edge of visibilityGraph.Edges)
  //             //                l.Add(BezierOnEdge(edge));
  //             l.AddRange(curves.Select(c => new DebugCurve(100, 0.5, "brown", c)));
  //             LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);
  //         }
  //         DebugCurve DebugSweepLine(RealNumberSpan range) {
  //             var ls = new LineSegment(Z * SweepDirection + DirectionPerp * range.Min, Z * SweepDirection + DirectionPerp * range.Max);
  //             return new DebugCurve(100, 0.1, "magenta", ls);
  //         }
  // #endif
  AddConeAndEnqueueEvents(t) {
    if (t instanceof as) {
      const e = t.Vertex.nextOnPolyline;
      this.CloseConesAddConeAtLeftVertex(t, e);
    } else if (t instanceof ls) {
      const e = t.Vertex.prevOnPolyline;
      this.CloseConesAddConeAtRightVertex(t, e);
    } else
      this.CloseConesAddConeAtLeftVertex(t, t.Vertex.nextOnPolyline), this.CloseConesAddConeAtRightVertex(t, t.Vertex.prevOnPolyline);
  }
  CloseConesAddConeAtRightVertex(t, e) {
    const i = t.Vertex.nextOnPolyline.point;
    this.directionPerp.dot(t.Site.sub(i)) > m.distanceEpsilon && this.RemoveConesClosedBySegment(i, t.Vertex.point), this.directionPerp.dot(e.point.sub(t.Site)) > m.distanceEpsilon && this.RemoveConesClosedBySegment(t.Site, e.point);
    const s = t.Site, n = s.add(this.ConeLeftSideDirection), r = s.add(this.ConeRightSideDirection), a = e.point;
    this.GetZP(s.sub(i)) > m.distanceEpsilon && this.RemoveRightSide(new Bs(t.Vertex.nextOnPolyline)), this.GetZP(s.sub(e.point)) > m.distanceEpsilon && this.RemoveLeftSide(new Ns(e)), this.GetZP(a) + m.distanceEpsilon < this.GetZS(t) && this.CreateConeOnVertex(t), u.PointToTheRightOfLineOrOnLine(a, s, n) ? u.PointToTheLeftOfLineOrOnLine(a, s, r) ? this.CaseToTheLeftOfLineOrOnLineConeRp(t, e) : (this.GetZP(a.sub(s)) > m.distanceEpsilon && (this.LookForIntersectionOfObstacleSideAndLeftConeSide(t.Site, e), this.InsertRightSide(new Bs(t.Vertex))), this.EnqueueRightVertexEvent(new ls(e))) : (this.CreateConeOnVertex(t), u.PointToTheLeftOfLineOrOnLine(a.add(this.DirectionPerp), a, s) && this.EnqueueRightVertexEvent(new ls(e)));
  }
  CaseToTheLeftOfLineOrOnLineConeRp(t, e) {
    this.EnqueueRightVertexEvent(new ls(e));
    const i = new mo(t.Vertex.point, this), s = new Rs(i.Apex, e, new ri(i));
    i.LeftSide = s, i.RightSide = new Gi(i);
    const n = this.InsertToTree(this.rightConeSides, i.RightSide);
    this.LookForIntersectionWithConeRightSide(n);
    const r = this.InsertToTree(this.leftConeSides, i.LeftSide);
    this.FixConeLeftSideIntersections(s, r), this.GetZP(e.point.sub(t.Site)) > m.distanceEpsilon && this.InsertRightSide(new Bs(t.Vertex));
  }
  LookForIntersectionOfObstacleSideAndRightConeSide(t, e) {
    const i = this.GetLastNodeToTheLeftOfPointInRightSegmentTree(t);
    if (i != null && i.item instanceof Gi) {
      const s = u.IntervalIntersectsRay(t, e.point, i.item.Start, this.ConeRightSideDirection);
      s && this.SegmentIsNotHorizontal(s, e.point) && this.EnqueueEvent(this.CreateRightIntersectionEvent(i.item, s, e));
    }
  }
  CreateRightIntersectionEvent(t, e, i) {
    return new $a(t, e, i);
  }
  GetLastNodeToTheLeftOfPointInRightSegmentTree(t) {
    return this.rightConeSides.findLast((e) => Ut.PointIsToTheRightOfSegment(t, e));
  }
  LookForIntersectionOfObstacleSideAndLeftConeSide(t, e) {
    const i = this.GetFirstNodeToTheRightOfPoint(t);
    if (i == null || !(i.item instanceof ri))
      return;
    const s = i.item, n = u.IntervalIntersectsRay(t, e.point, s.Start, this.ConeLeftSideDirection);
    n && this.EnqueueEvent(new hn(s, n, e));
  }
  GetFirstNodeToTheRightOfPoint(t) {
    return this.leftConeSides.findFirst((e) => Ut.PointIsToTheLeftOfSegment(t, e));
  }
  static PointIsToTheLeftOfSegment(t, e) {
    return u.getTriangleOrientation(e.Start, e.Start.add(e.Direction), t) === L.Counterclockwise;
  }
  static PointIsToTheRightOfSegment(t, e) {
    return u.getTriangleOrientation(e.Start, e.Start.add(e.Direction), t) === L.Clockwise;
  }
  FixConeLeftSideIntersections(t, e) {
    do
      e = this.leftConeSides.next(e);
    while (e != null && u.PointToTheRightOfLineOrOnLine(t.Start, e.item.Start, e.item.Start.add(e.item.Direction)));
    if (e != null && e.item instanceof ri) {
      const i = e.item, s = u.IntervalIntersectsRay(t.start, t.End, i.Start, i.Direction);
      s && this.EnqueueEvent(new hn(i, s, t.EndVertex));
    }
  }
  InsertToTree(t, e) {
    return this.coneSideComparer.SetOperand(e), t.insert(e);
  }
  CloseConesAddConeAtLeftVertex(t, e) {
    const i = t.Vertex.prevOnPolyline.point;
    t.Site.sub(i).dot(this.directionPerp) < -m.distanceEpsilon && this.RemoveConesClosedBySegment(t.Site, i), e.point.sub(t.Site).dot(this.directionPerp) < -m.distanceEpsilon && this.RemoveConesClosedBySegment(e.point, t.Site);
    const s = t.Site, n = s.add(this.ConeLeftSideDirection), r = s.add(this.ConeRightSideDirection), a = e.point;
    this.GetZP(s.sub(i)) > m.distanceEpsilon && this.RemoveLeftSide(new Ns(t.Vertex.prevOnPolyline));
    const l = this.GetZP(a) - this.Z;
    l < -m.distanceEpsilon && this.RemoveRightSide(new Bs(e));
    const h = a.sub(t.Site);
    if (l < -m.distanceEpsilon || D(l, 0) && this.GetZP(h) > 0 && h.dot(this.directionPerp) > -m.distanceEpsilon)
      this.CreateConeOnVertex(t);
    else if (!u.PointToTheLeftOfLineOrOnLine(a, s, r))
      this.CreateConeOnVertex(t), this.EnqueueEvent(new as(e));
    else if (u.PointToTheLeftOfLineOrOnLine(a, s, n))
      this.EnqueueEvent(new as(e)), this.GetZP(h) > m.distanceEpsilon && (this.LookForIntersectionOfObstacleSideAndRightConeSide(t.Site, e), this.InsertLeftSide(new Ns(t.Vertex)));
    else {
      this.EnqueueEvent(new as(e));
      const c = new mo(t.Vertex.point, this), d = new Rs(t.Vertex.point, e, new Gi(c));
      c.RightSide = d, c.LeftSide = new ri(c), this.LookForIntersectionWithConeLeftSide(this.InsertToTree(this.leftConeSides, c.LeftSide));
      const f = this.InsertToTree(this.rightConeSides, d);
      this.FixConeRightSideIntersections(d, f), this.GetZP(h) > m.distanceEpsilon && this.InsertLeftSide(new Ns(t.Vertex));
    }
  }
  RemoveCone(t) {
    t.Removed = !0, this.RemoveSegFromLeftTree(t.LeftSide), this.RemoveSegFromRightTree(t.RightSide);
  }
  RemoveSegFromRightTree(t) {
    this.coneSideComparer.SetOperand(t);
    let e = this.rightConeSides.remove(t);
    if (t.Removed = !0, e == null) {
      const i = this.Z;
      this.Z = Math.max(this.GetZP(t.Start), this.Z - 0.01), this.coneSideComparer.SetOperand(t), e = this.rightConeSides.remove(t), this.Z = i;
    }
  }
  RemoveSegFromLeftTree(t) {
    if (t.Removed = !0, this.coneSideComparer.SetOperand(t), this.leftConeSides.remove(t) == null) {
      const i = this.Z;
      this.Z = Math.max(this.GetZP(t.Start), this.Z - 0.01), this.coneSideComparer.SetOperand(t), this.leftConeSides.remove(t), this.Z = i;
    }
  }
  FixConeRightSideIntersections(t, e) {
    do
      e = this.rightConeSides.previous(e);
    while (e != null && u.PointToTheLeftOfLineOrOnLine(t.start, e.item.Start, e.item.Start.add(e.item.Direction)));
    if (e != null) {
      let i;
      if (e.item instanceof Gi) {
        const s = e.item;
        (i = u.IntervalIntersectsRay(t.start, t.End, s.Start, s.Direction)) && this.EnqueueEvent(this.CreateRightIntersectionEvent(s, i, t.EndVertex));
      }
    }
  }
  CreateConeOnVertex(t) {
    const e = new mo(t.Site, this);
    e.LeftSide = new ri(e), e.RightSide = new Gi(e);
    const i = this.InsertToTree(this.leftConeSides, e.LeftSide), s = this.InsertToTree(this.rightConeSides, e.RightSide);
    this.LookForIntersectionWithConeRightSide(s), this.LookForIntersectionWithConeLeftSide(i);
  }
  LookForIntersectionWithConeLeftSide(t) {
    if (t.item instanceof ri) {
      const e = t.item, i = this.FindFirstObstacleSideToTheLeftOfPoint(e.Start);
      i != null && this.TryIntersectionOfConeLeftSideAndObstacleSide(e, i);
    } else {
      const e = t.item;
      t = this.leftConeSides.next(t), t != null && t.item instanceof ri && this.TryIntersectionOfConeLeftSideAndObstacleConeSide(t.item, e);
    }
  }
  LookForIntersectionWithConeRightSide(t) {
    if (t.item instanceof Gi) {
      const e = t.item, i = this.FindFirstObstacleSideToToTheRightOfPoint(e.Start);
      i != null && this.TryIntersectionOfConeRightSideAndObstacleSide(e, i);
    } else {
      const e = t.item;
      t = this.rightConeSides.previous(t), t != null && t.item instanceof Gi && this.TryIntersectionOfConeRightSideAndObstacleConeSide(t.item, e);
    }
  }
  TryIntersectionOfConeRightSideAndObstacleConeSide(t, e) {
    const i = u.IntervalIntersectsRay(e.start, e.End, t.Start, t.Direction);
    i && this.EnqueueEvent(this.CreateRightIntersectionEvent(t, i, e.EndVertex));
  }
  TryIntersectionOfConeRightSideAndObstacleSide(t, e) {
    const i = u.IntervalIntersectsRay(e.Start, e.End, t.Start, t.Direction);
    i && this.EnqueueEvent(this.CreateRightIntersectionEvent(t, i, e.EndVertex));
  }
  TryIntersectionOfConeLeftSideAndObstacleConeSide(t, e) {
    const i = u.IntervalIntersectsRay(e.start, e.End, t.Start, t.Direction);
    i && this.EnqueueEvent(new hn(t, i, e.EndVertex));
  }
  TryIntersectionOfConeLeftSideAndObstacleSide(t, e) {
    const i = u.IntervalIntersectsRay(e.Start, e.End, t.Start, t.Direction);
    i && this.EnqueueEvent(new hn(t, i, e.EndVertex));
  }
  // Show(curves: ICurve[], fn: string) {
  //   let l = Array.from(this.Obstacles).map((o) => DebugCurve.mkDebugCurveTWCI(200, 0.5, 'Blue', o))
  //   for (const s of this.rightConeSides) {
  //     l.push(DebugCurve.mkDebugCurveWCI(0.5, 'Brown', this.ExtendSegmentToZ(s)))
  //     if (s instanceof BrokenConeSide) l.push(DebugCurve.mkDebugCurveCI('Brown', LineSweeper.Diamond(s.start)))
  //     l.push(DebugCurve.mkDebugCurveWCI(0.5, 'Green', this.ExtendSegmentToZ(s.Cone.LeftSide)))
  //     if (s.Cone.LeftSide instanceof BrokenConeSide) l.push(DebugCurve.mkDebugCurveCI('Green', LineSweeper.Diamond(s.Cone.LeftSide.start)))
  //   }
  //   l.push(
  //     ...Array.from(this.visibilityGraph.Edges).map((edge) =>
  //       DebugCurve.mkDebugCurveTWCI(100, 0.1, 'Cyan', LineSegment.mkPP(edge.SourcePoint, edge.TargetPoint)),
  //     ),
  //   )
  //   l.push(...curves.map((c) => DebugCurve.mkDebugCurveCI('Red', c)))
  //   l.push(
  //     ...Array.from(this.eventQueue)
  //       .filter((e) => e instanceof RightIntersectionEvent)
  //       .map((e) => DebugCurve.mkDebugCurveCI('Black', LineSweeper.mkRightIntersDiamond(e.Site))),
  //   )
  //   SvgDebugWriter.dumpDebugCurves(fn, l)
  // }
  //         static BezierSeg BezierOnEdge(VisibilityEdge edge) {
  //             return new BezierSeg(edge.SourcePoint, 2.0 / 3.0 * edge.SourcePoint + 1.0 / 3.0 * edge.TargetPoint,
  //                 1.0 / 3.0 * edge.SourcePoint + 2.0 / 3.0 * edge.TargetPoint, edge.TargetPoint);
  //         }
  ExtendSegmentToZ(t) {
    const e = t.Direction.dot(this.SweepDirection), i = (this.Z + 40 - t.Start.dot(this.SweepDirection)) / e;
    return v.mkPP(t.Start, t.Start.add(t.Direction.mul(i)));
  }
  //         internal ICurve ExtendSegmentToZPlus1(ConeSide segment) {
  //             double den = segment.Direction * SweepDirection;
  //             Assert.assert(Math.Abs(den) > GeomConstants.distanceEpsilon);
  //             double t = (Z + 1 - segment.start * SweepDirection) / den;
  //             return new LineSegment(segment.start, segment.start + segment.Direction * t);
  //         }
  // #endif
  GoOverConesSeeingVertexEvent(t) {
    let e = this.FindFirstSegmentInTheRightTreeNotToTheLeftOfVertex(t);
    if (e == null)
      return;
    const s = e.item.Cone, n = s.LeftSide;
    if (Ut.VertexIsToTheLeftOfSegment(t, n))
      return;
    const r = [s];
    if (this.coneSideComparer.SetOperand(n), e = this.leftConeSides.find(n), e == null) {
      const a = this.Z;
      this.Z = Math.max(this.GetZP(n.Start), this.PreviousZ), this.coneSideComparer.SetOperand(n), e = this.leftConeSides.find(n), this.Z = a;
    }
    if (!(e == null && (e = this.GetRbNodeEmergency(n), e == null))) {
      for (e = this.leftConeSides.next(e); e != null && !Ut.VertexIsToTheLeftOfSegment(t, e.item); )
        r.push(e.item.Cone), e = this.leftConeSides.next(e);
      for (const a of r)
        this.AddEdgeAndRemoveCone(a, t.Site);
    }
  }
  GetRbNodeEmergency(t) {
    if (this.leftConeSides.count === 0)
      return null;
    for (let e = this.leftConeSides.treeMinimum(); e != null; e = this.leftConeSides.next(e))
      if (e.item === t)
        return e;
    return null;
  }
  // #if TEST_MSAGL
  //             MessageId = "System.Int32.ToString")]
  //         internal static GeometryGraph CreateGraphFromObstacles(Array < Polyline > obstacles) {
  //             var gg = new GeometryGraph();
  //             foreach(var ob of obstacles) {
  //                 gg.Nodes.Add(new Node(ob.ToCurve()));
  //             }
  //             return gg;
  //         }
  //             "CA1303:Do not pass literals as localized parameters", MessageId = "System.Diagnostics.Debug.WriteLine(System.String)"
  //         )]
  //         void PrintOutLeftSegTree() {
  //             System.Diagnostics.Debug.WriteLine("Left cone segments########");
  //             foreach(var t of leftConeSides) {
  //                 var x = coneSideComparer.IntersectionOfSegmentAndSweepLine(t);
  //                 System.Diagnostics.Debug.WriteLine("{0} x={1}", t, x * DirectionPerp);
  //             }
  //             System.Diagnostics.Debug.WriteLine("##########end of left cone segments");
  //         }
  // #endif
  static VertexIsToTheLeftOfSegment(t, e) {
    return u.getTriangleOrientation(e.Start, e.Start.add(e.Direction), t.Site) === L.Counterclockwise;
  }
  static VertexIsToTheRightOfSegment(t, e) {
    return u.getTriangleOrientation(e.Start, e.Start.add(e.Direction), t.Site) === L.Clockwise;
  }
  FindFirstSegmentInTheRightTreeNotToTheLeftOfVertex(t) {
    return this.rightConeSides.findFirst((e) => !Ut.VertexIsToTheRightOfSegment(t, e));
  }
  EnqueueRightVertexEvent(t) {
    this.GetZP(t.Site.sub(t.Vertex.prevOnPolyline.point)) > m.tolerance || this.EnqueueEvent(t);
  }
  invariant() {
    for (const t of this.leftConeSides)
      if (t.Removed)
        return !1;
    for (const t of this.rightConeSides)
      if (t.Removed)
        return !1;
    return !0;
  }
}
class qs extends lt {
  constructor(t, e) {
    super(null), this.coneAngle = Math.PI / 6, this.ports = new xt(), this._obstacles = Array.from(Et.OrientHolesClockwise(t)), this._visibilityGraph = e;
  }
  static mk(t, e, i, s, n) {
    const r = new qs(t, e);
    return r.Ports = s, r.BorderPolyline = n, r.ConeAngle = i, r;
  }
  get ConeAngle() {
    return this.coneAngle;
  }
  set ConeAngle(t) {
    this.coneAngle = t;
  }
  get Ports() {
    return this.ports;
  }
  set Ports(t) {
    this.ports = t;
  }
  get BorderPolyline() {
    return this.borderPolyline;
  }
  set BorderPolyline(t) {
    this.borderPolyline = t;
  }
  // If set to true then a smaller visibility graph is created.
  // An edge is added to the visibility graph only if it is found at least twice:
  // once sweeping with a direction d and the second time with -d
  get Bidirectional() {
    return this._bidirectional;
  }
  set Bidirectional(t) {
    this._bidirectional = t;
  }
  static GetTotalSteps(t) {
    return Math.floor((2 * Math.PI - t / 2) / t) + 1;
  }
  run() {
    const t = 2 * Math.PI - this.coneAngle / 2;
    if (this.Bidirectional)
      this.HandleBideractionalCase();
    else {
      let e;
      for (let i = 0; (e = this.coneAngle * i) <= t; i++)
        super.ProgressStep(), this.AddDirection(new u(Math.cos(e), Math.sin(e)), this.BorderPolyline, this._visibilityGraph);
    }
  }
  HandleBideractionalCase() {
    const t = Math.PI / this.coneAngle;
    for (let e = 0; e < t; e++) {
      const i = e * this.coneAngle, s = new Et();
      this.AddDirection(new u(Math.cos(i), Math.sin(i)), this.BorderPolyline, s);
      const n = new Et();
      this.AddDirection(new u(Math.cos(i) * -1, Math.sin(i) * -1), this.BorderPolyline, n), this.AddIntersectionOfBothDirectionSweepsToTheResult(s, n);
    }
  }
  AddIntersectionOfBothDirectionSweepsToTheResult(t, e) {
    for (const i of t.Edges)
      e.FindEdgePP(i.SourcePoint, i.TargetPoint) != null && this._visibilityGraph.AddEdgePP(i.SourcePoint, i.TargetPoint);
  }
  AddDirection(t, e, i) {
    Ut.Sweep(this._obstacles, t, this.coneAngle, i, this.Ports, e);
  }
}
class ee extends aa {
  mk(t, e) {
    const i = new ee(t);
    return i.HookSize = e, i;
  }
  constructor(t) {
    super(), this.adjustmentAngle = Math.PI / 10, this.hookSize = 9, this.curve = t, this.location = this.curve().start;
  }
  // returns a point on the boundary curve
  get Location() {
    return this.location;
  }
  // Gets the boundary curve of the port.
  get Curve() {
    return this.curve();
  }
  SetLocation(t) {
    this.location = t;
  }
  // We are trying to correct the last segment of the polyline by make it perpendicular to the Port.Curve.
  // For this purpose we trim the curve by the cone of the angle 2*adjustment angle and project the point before the last of the polyline to this curve.
  get AdjustmentAngle() {
    return this.adjustmentAngle;
  }
  set AdjustmentAngle(t) {
    this.adjustmentAngle = t;
  }
  // the size of the self-loop
  get HookSize() {
    return this.hookSize;
  }
  set HookSize(t) {
    this.hookSize = t;
  }
}
class Ve extends Ki {
  get LoosePolyline() {
    return this.loosePolyline;
  }
  set LoosePolyline(t) {
    this.loosePolyline = t;
  }
  // constructor
  constructor(t, e, i = new u(0, 0)) {
    super(t, e, i);
  }
  // constructor
  static mk(t, e) {
    return new Ve(t, e);
  }
}
class Oe extends aa {
  get Location() {
    return this.curve.value(this.parameter);
  }
  set Location(t) {
    throw new Error("Method should not be called.");
  }
  // constructor
  static mk(t, e) {
    const i = new Oe();
    return i.curve = t, i.parameter = e, i;
  }
  get Parameter() {
    return this.parameter;
  }
  set Parameter(t) {
    this.parameter = t;
  }
  get Curve() {
    return this.curve;
  }
  set Curve(t) {
    this.curve = t;
  }
}
class kt {
  constructor() {
    this.capacityOverflowCoefficient = kt.DefaultCapacityOverflowCoefficientMultiplier, this.RotateBundles = !1, this.MaxHubRadius = 50, this.MinHubRadius = 0.1, this.CreateUnderlyingPolyline = !1, this.pathLengthImportance = kt.DefaultPathLengthImportance, this.inkImportance = kt.DefaultInkImportance, this.edgeSeparation = kt.DefaultEdgeSeparation, this._edgeWidthShrinkCoeff = 1, this.useCubicBezierSegmentsInsideOfHubs = !1, this.angleThreshold = Math.PI / 180 * 45, this.hubRepulsionImportance = 100, this.bundleRepulsionImportance = 100, this.minimalRatioOfGoodCdtEdges = 0.9, this.highestQuality = !0, this.KeepOverlaps = !1, this.StopAfterShortestPaths = !1;
  }
  toJSON() {
    const t = {};
    return this.capacityOverflowCoefficient != kt.DefaultCapacityOverflowCoefficientMultiplier && (t.capacityOverflowCoefficient = this.capacityOverflowCoefficient), this.RotateBundles && (t.RotateBundles = this.RotateBundles), this.MaxHubRadius != 50 && (t.MaxHubRadius = this.MaxHubRadius), this.MinHubRadius != 0.1 && (t.MinHubRadius = this.MinHubRadius), this.CreateUnderlyingPolyline && (t.CreateUnderlyingPolyline = this.CreateUnderlyingPolyline), this.pathLengthImportance != kt.DefaultPathLengthImportance && (t.pathLengthImportance = this.pathLengthImportance), this.inkImportance != kt.DefaultInkImportance && (t.inkImportance = this.inkImportance), this.edgeSeparation != kt.DefaultEdgeSeparation && (t.edgeSeparation = this.edgeSeparation), this._edgeWidthShrinkCoeff != 1 && (t._edgeWidthShrinkCoeff = this._edgeWidthShrinkCoeff), this.useCubicBezierSegmentsInsideOfHubs && (t.useCubicBezierSegmentsInsideOfHubs = this.useCubicBezierSegmentsInsideOfHubs), this.angleThreshold != Math.PI / 180 * 45 && (t.angleThreshold = this.angleThreshold), this.hubRepulsionImportance != 100 && (t.hubRepulsionImportance = this.hubRepulsionImportance), this.bundleRepulsionImportance != 100 && (t.bundleRepulsionImportance = this.bundleRepulsionImportance), this.minimalRatioOfGoodCdtEdges != 0.9 && (t.minimalRatioOfGoodCdtEdges = this.minimalRatioOfGoodCdtEdges), this.highestQuality || (t.highestQuality = this.highestQuality), this.KeepOverlaps && (t.KeepOverlaps = this.KeepOverlaps), this.StopAfterShortestPaths && (t.StopAfterShortestPaths = this.StopAfterShortestPaths), t;
  }
  static createFromJSON(t) {
    const e = new kt();
    return t.capacityOverflowCoefficient && (e.capacityOverflowCoefficient = t.capacityOverflowCoefficient), t.RotateBundles && (e.RotateBundles = t.RotateBundles), t.MaxHubRadius && (e.MaxHubRadius = t.MaxHubRadius), t.MinHubRadius && (e.MinHubRadius = t.MinHubRadius), t.CreateUnderlyingPolyline && (e.CreateUnderlyingPolyline = t.CreateUnderlyingPolyline), t.pathLengthImportance && (e.pathLengthImportance = t.pathLengthImportance), t.inkImportance && (e.inkImportance = t.inkImportance), t.edgeSeparation && (e.edgeSeparation = t.edgeSeparation), t._edgeWidthShrinkCoeff && (e._edgeWidthShrinkCoeff = t._edgeWidthShrinkCoeff), t.useCubicBezierSegmentsInsideOfHubs && (e.useCubicBezierSegmentsInsideOfHubs = t.useCubicBezierSegmentsInsideOfHubs), t.angleThreshold && (e.angleThreshold = t.angleThreshold), t.hubRepulsionImportance && (e.hubRepulsionImportance = t.hubRepulsionImportance), t.bundleRepulsionImportance && (e.bundleRepulsionImportance = t.bundleRepulsionImportance), t.minimalRatioOfGoodCdtEdges && (e.minimalRatioOfGoodCdtEdges = t.minimalRatioOfGoodCdtEdges), t.highestQuality && (e.HighestQuality = t.highestQuality), t.KeepOverlaps && (e.KeepOverlaps = t.KeepOverlaps), t.StopAfterShortestPaths && (e.StopAfterShortestPaths = t.StopAfterShortestPaths), e;
  }
  // this number is muliplied by the overflow penalty cost and by the sum of the LengthImportanceCoefficient
  // and InkImportanceCoefficient, and added to the routing price
  get CapacityOverflowCoefficient() {
    return this.capacityOverflowCoefficient;
  }
  set CapacityOverflowCoefficient(t) {
    this.capacityOverflowCoefficient = t;
  }
  // the importance of path lengths coefficient
  get PathLengthImportance() {
    return this.pathLengthImportance;
  }
  set PathLengthImportance(t) {
    this.pathLengthImportance = t;
  }
  get InkImportance() {
    return this.inkImportance;
  }
  set InkImportance(t) {
    this.inkImportance = t;
  }
  /** Separation between the neighbor edges within a bundle */
  get EdgeSeparation() {
    return this.edgeSeparation;
  }
  set EdgeSeparation(t) {
    this.edgeSeparation = t;
  }
  get edgeWidthShrinkCoeff() {
    return this._edgeWidthShrinkCoeff;
  }
  set edgeWidthShrinkCoeff(t) {
    this._edgeWidthShrinkCoeff = t;
  }
  ActualEdgeWidth(t, e = this.edgeWidthShrinkCoeff) {
    return e * (this.edgeSeparation + t.lineWidth);
  }
  // if is set to true will be using Cubic Bezie Segments inside of hubs, otherwise will be using Biarcs
  get UseCubicBezierSegmentsInsideOfHubs() {
    return this.useCubicBezierSegmentsInsideOfHubs;
  }
  set UseCubicBezierSegmentsInsideOfHubs(t) {
    this.useCubicBezierSegmentsInsideOfHubs = t;
  }
  // 45 degrees;
  // min angle for gluing edges
  get AngleThreshold() {
    return this.angleThreshold;
  }
  set AngleThreshold(t) {
    this.angleThreshold = t;
  }
  // the importance of hub repulsion coefficient
  get HubRepulsionImportance() {
    return this.hubRepulsionImportance;
  }
  set HubRepulsionImportance(t) {
    this.hubRepulsionImportance = t;
  }
  // the importance of bundle repulsion coefficient
  get BundleRepulsionImportance() {
    return this.bundleRepulsionImportance;
  }
  set BundleRepulsionImportance(t) {
    this.bundleRepulsionImportance = t;
  }
  // minimal ration of cdt edges with satisfied capacity needed to perform bundling
  // (otherwise bundling will not be executed)
  get MinimalRatioOfGoodCdtEdges() {
    return this.minimalRatioOfGoodCdtEdges;
  }
  set MinimalRatioOfGoodCdtEdges(t) {
    this.minimalRatioOfGoodCdtEdges = t;
  }
  // speed vs quality of the drawing
  get HighestQuality() {
    return this.highestQuality;
  }
  set HighestQuality(t) {
    this.highestQuality = t;
  }
}
kt.DefaultCapacityOverflowCoefficientMultiplier = 1e3;
kt.DefaultPathLengthImportance = 500;
kt.DefaultInkImportance = 0.01;
kt.DefaultEdgeSeparation = 0.5;
class ko extends js {
  get BoundaryCurve() {
    return this.node.boundaryCurve;
  }
  set BoundaryCurve(t) {
    if (t)
      throw new Error("Cannot set BoundaryCurve directly for RelativeShape");
  }
  // Constructor taking the ID and the curve delegate for the shape.
  constructor(t) {
    super(null), this.node = t;
  }
}
class ze {
  static GetShapes(t, e) {
    const i = /* @__PURE__ */ new Map();
    for (const s of t)
      ze.ProcessAncestorDescendantCouple(s.target, s.source, i), ze.InsertEdgePortsToShapes(i, s);
    for (const s of e)
      ze.ProcessAncestorDescendantCouple(s.source, s.target, i), ze.InsertEdgePortsToShapes(i, s);
    return ze.BindShapes(i), Array.from(i.values());
  }
  static InsertEdgePortsToShapes(t, e) {
    t.get(e.target).Ports.add(e.targetPort), t.get(e.source).Ports.add(e.sourcePort);
  }
  static BindShapes(t) {
    for (const [e, i] of t) {
      if (!(e instanceof Rt))
        continue;
      const s = e;
      for (const n of Po(s)) {
        const r = t.get(n);
        r && i.AddChild(r);
      }
    }
  }
  static ProcessAncestorDescendantCouple(t, e, i) {
    let s = sr(e);
    do {
      for (const n of Po(s))
        ze.CreateShapeIfNeeeded(n, i);
      if (s === t)
        break;
      s = sr(s);
    } while (!0);
    ze.CreateShapeIfNeeeded(s, i);
  }
  static CreateShapeIfNeeeded(t, e) {
    e.has(t) || e.set(t, new ko(t));
  }
  static NumberOfActiveNodesIsUnderThreshold(t, e, i) {
    const s = /* @__PURE__ */ new Set();
    for (const n of t)
      if (ze.SetOfActiveNodesIsLargerThanThreshold(n.target, n.source, s, i))
        return !1;
    for (const n of e)
      if (ze.SetOfActiveNodesIsLargerThanThreshold(n.source, n.target, s, i))
        return !1;
    return !0;
  }
  static SetOfActiveNodesIsLargerThanThreshold(t, e, i, s) {
    let n = sr(e);
    for (; ; ) {
      for (const r of Po(n))
        if (i.add(r), i.size > s)
          return !0;
      if (n === t)
        break;
      n = sr(n);
    }
    return i.add(n), i.size > s;
  }
}
function sr(o) {
  const t = o.node.parent;
  return $.getGeom(t);
}
function* Po(o) {
  for (const t of o.graph.shallowNodes)
    yield $.getGeom(t);
}
class Xe {
  constructor(t) {
    this.stamp = 0, this.SetPivotAndAllocateHullPointsArray(t);
  }
  SetPivotAndAllocateHullPointsArray(t) {
    this.pivot = new u(0, Number.MAX_SAFE_INTEGER);
    let e = -1, i = 0;
    for (const s of t)
      s.y < this.pivot.y ? (this.pivot = s, e = i) : s.y === this.pivot.y && s.x > this.pivot.x && (this.pivot = s, e = i), i++;
    if (i >= 1) {
      this.hullPoints = new Array(i - 1), i = 0;
      for (const s of t)
        i !== e ? this.hullPoints[i++] = {
          point: s,
          deleted: !1,
          stamp: this.stamp++
        } : e = -1;
    }
  }
  get StackTopPoint() {
    return this.stack.point;
  }
  get StackSecondPoint() {
    return this.stack.next.point;
  }
  // calculates the convex hull of the given set of points
  static *CalculateConvexHull(t) {
    const e = new Xe(t);
    for (const i of e.Calculate())
      yield i;
  }
  *Calculate() {
    if (this.pivot.y !== Number.MAX_SAFE_INTEGER) {
      if (this.hullPoints.length === 0) {
        yield this.pivot;
        return;
      }
      this.SortAllPointsWithoutPivot(), this.Scan();
      for (const t of this.EnumerateStack())
        yield t;
    }
  }
  *EnumerateStack() {
    let t = this.stack;
    for (; t != null; )
      yield t.point, t = t.next;
  }
  Scan() {
    let t = 0;
    for (; this.hullPoints[t].deleted; )
      t++;
    for (this.stack = { point: this.pivot, next: null }, this.Push(t++), t < this.hullPoints.length && (this.hullPoints[t].deleted ? t++ : this.Push(t++)); t < this.hullPoints.length; )
      this.hullPoints[t].deleted ? t++ : this.LeftTurn(t) ? this.Push(t++) : this.Pop();
    for (; this.StackHasMoreThanTwoPoints() && !this.LeftTurnToPivot(); )
      this.Pop();
  }
  LeftTurnToPivot() {
    return u.getTriangleOrientation(this.StackSecondPoint, this.StackTopPoint, this.pivot) === L.Counterclockwise;
  }
  StackHasMoreThanTwoPoints() {
    return this.stack.next != null && this.stack.next.next != null;
  }
  Pop() {
    this.stack = this.stack.next;
  }
  LeftTurn(t) {
    if (this.stack.next == null)
      return !0;
    const e = u.getTriangleOrientationWithIntersectionEpsilon(this.StackSecondPoint, this.StackTopPoint, this.hullPoints[t].point);
    return e === L.Counterclockwise ? !0 : e === L.Clockwise ? !1 : this.BackSwitchOverPivot(this.hullPoints[t].point);
  }
  BackSwitchOverPivot(t) {
    return this.stack.next.next != null ? !1 : this.StackTopPoint.x > this.pivot.x + m.distanceEpsilon && t.x < this.pivot.x - m.distanceEpsilon;
  }
  Push(t) {
    this.stack = { point: this.hullPoints[t].point, next: this.stack };
  }
  SortAllPointsWithoutPivot() {
    this.hullPoints.sort(zd(this.pivot));
  }
  static createConvexHullAsClosedPolyline(t) {
    return B.mkClosedFromPoints(Array.from(Xe.CalculateConvexHull(t)));
  }
}
function zd(o) {
  return (t, e) => {
    if (t === e)
      return 0;
    if (t == null)
      return -1;
    if (e == null)
      return 1;
    switch (u.getTriangleOrientationWithIntersectionEpsilon(o, t.point, e.point)) {
      case L.Counterclockwise:
        return -1;
      case L.Clockwise:
        return 1;
      case L.Collinear:
        const i = t.point.x - o.x, s = e.point.x - o.x;
        if (i > m.distanceEpsilon && s < -m.distanceEpsilon)
          return -1;
        if (i < -m.distanceEpsilon && s > m.distanceEpsilon)
          return 1;
        const n = t.point.sub(o), r = e.point.sub(o), a = n.l1 - r.l1;
        return a < 0 ? (t.deleted = !0, -1) : a > 0 ? (e.deleted = !0, 1) : (t.stamp > e.stamp ? t.deleted = !0 : e.deleted = !0, 0);
    }
    throw new Error();
  };
}
function ae(o, t, e) {
  o.irect.intersects_rect(t.irect) && (o.Left == null ? t.Left == null ? e(o.UserData, t.UserData) : (ae(o, t.Left, e), ae(o, t.Right, e)) : t.Left != null ? (ae(o.Left, t.Left, e), ae(o.Left, t.Right, e), ae(o.Right, t.Left, e), ae(o.Right, t.Right, e)) : (ae(o.Left, t, e), ae(o.Right, t, e)));
}
function Qt(o, t, e) {
  o.irect.intersects_rect(t.irect) && (o === t ? qd(o, e) : o.Left == null ? t.Left == null ? e(o.UserData, t.UserData) : (Qt(o, t.Left, e), Qt(o, t.Right, e)) : t.Left != null ? (Qt(o.Left, t.Left, e), Qt(o.Left, t.Right, e), Qt(o.Right, t.Left, e), Qt(o.Right, t.Right, e)) : (Qt(o.Left, t, e), Qt(o.Right, t, e)));
}
function xe(o, t, e) {
  if (!o.irect.intersects_rect(t.irect))
    return !1;
  if (o === t)
    return jd(o, e);
  if (o.Left == null) {
    if (t.Left == null)
      return e(o.UserData, t.UserData);
    if (xe(o, t.Left, e) || xe(o, t.Right, e))
      return !0;
  } else if (t.Left != null) {
    if (xe(o.Left, t.Left, e) || xe(o.Left, t.Right, e) || xe(o.Right, t.Left, e) || xe(o.Right, t.Right, e))
      return !0;
  } else if (xe(o.Left, t, e) || xe(o.Right, t, e))
    return !0;
  return !1;
}
function jd(o, t) {
  return o.Left == null ? !1 : xe(o.Left, o.Left, t) || xe(o.Left, o.Right, t) || xe(o.Right, o.Right, t);
}
function qd(o, t) {
  o.Left != null && (Qt(o.Left, o.Left, t), Qt(o.Left, o.Right, t), Qt(o.Right, o.Right, t));
}
const tl = BigInt("6364136223846793005"), So = (BigInt(1) << BigInt(32)) - BigInt(1), Pi = (BigInt(1) << BigInt(64)) - BigInt(1);
class to {
  /**
   * A PRNG class. Provides two main methods:
   *
   * - `random` - Produces a "continuous" standard uniform distribution.
   * - `randint` - Produces a discrete uniform distribution.
   *
   * For more details, check the individual methods.
   *
   * @param initState The seed to initialise the state of the generator.
   * @param initSequence The seed to initialise the sequence number of the
   * generator.
   */
  // The state and sequence are stored as bigints, but anything that is
  // coercible to a bigint should be a valid seed.
  constructor(t, e) {
    this._state = BigInt(0), this._inc = (BigInt(e) << BigInt(1) | BigInt(1)) & Pi, this._random_b(), this._state = this._state + BigInt(t) & Pi, this._random_b();
  }
  /**
   * This is the source of randomness for all other random methods.
   *
   * Produces a uniformly distributed 32-bit unsigned integer as a bigint.
   *
   * Although the produced number is 32 bits; the implementation requires that
   * the state of the generator be a 64 bit unsigned integer. Since the js
   * Number datatype cannot reliably handle integers that large, we use the
   * BigInt class for the calculation.
   */
  _random_b() {
    const t = this._state;
    this._state = t * tl + this._inc & Pi;
    const e = (t >> BigInt(18) ^ t) >> BigInt(27), i = t >> BigInt(59), s = i ^ BigInt(31);
    return (e >> i | e << s) & So;
  }
  /**
   * Advances the internal state of the generator `delta` steps. Delta can be
   * negative to reverse.
   *
   * This is calculated in a very similar way to the square and multiply method
   * for taking the power of a number. As you may expect, it is calculated in
   * log(delta) time.
   */
  _advance(t) {
    t &= Pi;
    let e = BigInt(1), i = tl, s = BigInt(0), n = this._inc;
    for (; t > 0; )
      t & BigInt(1) && (e = e * i & Pi, s = s * i + n & Pi), n = (i + BigInt(1)) * n & Pi, i = i * i & Pi, t >>= BigInt(1);
    this._state = e * this._state + s & Pi;
  }
  /**
   * Produces a uniformly distributed integer, r, with 0  r < bound.
   *
   * To produce a uniformly distributed integer in the range [low, high):
   *
   * ```js
   * const i = low + rand.randint(high - low)
   * ```
   *
   * @param bound The lower bound for the number.
   */
  randint(t) {
    if (t > So)
      throw new TypeError(`Bound too large: ${t}`);
    if (t <= 0)
      throw new TypeError(`Empty sample space for r: 0  r < ${t}`);
    const e = BigInt(t), i = (So ^ e) % e;
    for (; ; ) {
      const s = this._random_b();
      if (s >= i)
        return Number(s % e);
    }
  }
  /**
   * Generates an approximately uniformly distributed number, r, with 0  r < 1.
   *
   * @returns The number r.
   */
  random() {
    return Number(this._random_b()) / Math.pow(2, 32);
  }
}
let fs;
function Us(o) {
  return fs == null && (fs = new to(0, 0)), fs.randint(o);
}
function eo(o) {
  fs = new to(o, 0);
}
function vs() {
  return fs == null && (fs = new to(0, 0)), fs.random();
}
function* Xs(o) {
  const t = new Array(o.nodeCount).fill(!1), e = new We.Queue();
  for (let i = 0; i < o.nodeCount; i++)
    if (!t[i]) {
      const s = new Array();
      for (el(i, e, t); e.length > 0; ) {
        const n = e.dequeue();
        s.push(n);
        for (const r of Ud(o, n))
          el(r, e, t);
      }
      yield s;
    }
}
function* Ud(o, t) {
  for (const e of o.outEdges[t])
    yield e.target;
  for (const e of o.inEdges[t])
    yield e.source;
}
function el(o, t, e) {
  e[o] === !1 && (t.enqueue(o), e[o] = !0);
}
function Br(o) {
  const t = new ie();
  return t.SetEdges(o, ie.vertexCount(o)), t;
}
function Wh(o) {
  const t = new ie();
  return t.SetEdges(o, ie.vertexCount(o)), t;
}
function fi(o, t) {
  const e = new ie();
  return e.SetEdges(o, t), e;
}
class ie {
  constructor() {
    this.nodeCount = 0;
  }
  *incidentEdges(t) {
    for (const e of this.outEdges[t])
      yield e;
    for (const e of this.inEdges[t])
      yield e;
  }
  static deleteFromArray(t, e) {
    const i = t.indexOf(e, 0);
    i > -1 && t.splice(i, 1);
  }
  // the method is not efficient, takes linear time
  removeEdge(t) {
    ie.deleteFromArray(this.edges, t), t.source !== t.target ? (ie.deleteFromArray(this.outEdges[t.source], t), ie.deleteFromArray(this.inEdges[t.target], t)) : ie.deleteFromArray(this.selfEdges[t.source], t);
  }
  // This method should be static be
  // finds the maximum of sources and targets, and return it incremented by 1
  static vertexCount(t) {
    let e = 0;
    for (const i of t)
      i.source >= e && (e = i.source), i.target >= e && (e = i.target);
    return ++e;
  }
  // sets edges of the graph
  SetEdges(t, e) {
    this.edges = t, this.nodeCount = e;
    const i = new Array(this.nodeCount).fill(0), s = new Array(this.nodeCount).fill(0), n = new Array(this.nodeCount).fill(0);
    this.outEdges = new Array(this.nodeCount), this.inEdges = new Array(this.nodeCount), this.selfEdges = new Array(this.nodeCount);
    for (const r of this.edges)
      r.source !== r.target ? (i[r.source]++, s[r.target]++) : n[r.source]++;
    for (let r = 0; r < this.nodeCount; r++)
      this.outEdges[r] = new Array(i[r]), i[r] = 0, this.inEdges[r] = new Array(s[r]), s[r] = 0, this.selfEdges[r] = new Array(n[r]), n[r] = 0;
    for (const r of this.edges) {
      const a = r.source, l = r.target;
      a !== l ? (this.outEdges[a][i[a]++] = r, this.inEdges[l][s[l]++] = r) : this.selfEdges[a][n[a]++] = r;
    }
  }
  inEdgesCount(t) {
    return this.inEdges[t].length;
  }
  outEdgesCount(t) {
    return this.outEdges[t].length;
  }
  selfEdgesCount(t) {
    return this.selfEdges[t].length;
  }
  addEdge(t) {
    this.edges.push(t), t.source !== t.target ? (this.outEdges[t.source].push(t), this.inEdges[t.target].push(t)) : this.selfEdges[t.source].push(t);
  }
  // We assume that the graph is connected here
  *nodesOfConnectedGraph() {
    if (this.edges.length === 0)
      return;
    const t = /* @__PURE__ */ new Set(), e = new We.Queue();
    let i = this.edges[0].source;
    for (ie.enqueue(t, e, i), yield i; e.length > 0; ) {
      i = e.dequeue();
      for (const s of this.outEdges[i]) {
        const n = s.target;
        t.has(n) || (ie.enqueue(t, e, n), yield n);
      }
      for (const s of this.inEdges[i]) {
        const n = s.source;
        t.has(n) || (ie.enqueue(t, e, n), yield n);
      }
    }
  }
  *pred(t) {
    for (const e of this.inEdges[t])
      yield e.source;
  }
  *succ(t) {
    for (const e of this.outEdges[t])
      yield e.target;
  }
  static enqueue(t, e, i) {
    e.enqueue(i), t.add(i);
  }
}
var Ft;
(function(o) {
  o[o.Increasing = 0] = "Increasing", o[o.Decreasing = 1] = "Decreasing", o[o.Extremum = 2] = "Extremum";
})(Ft || (Ft = {}));
class nr {
  // the sequence values
  get Sequence() {
    return this.f;
  }
  set Sequence(t) {
    this.f = t;
  }
  // the length of the sequence: the sequence starts from 0
  get Length() {
    return this.length;
  }
  set Length(t) {
    this.length = t;
  }
  constructor(t, e) {
    this.f = t, this.length = e;
  }
  FindMinimum() {
    let t = 0, e = this.length - 1, i = t + Math.floor((e - t) / 2);
    const s = this.f(i);
    if (s >= this.f(0) && s >= this.f(this.length - 1))
      return this.f(0) < this.f(this.length - 1) ? 0 : this.length - 1;
    for (; e - t > 1; )
      switch (i = t + Math.floor((e - t) / 2), this.BehaviourAtIndex(i)) {
        case Ft.Decreasing:
          t = i;
          break;
        case Ft.Increasing:
          e = i;
          break;
        case Ft.Extremum:
          return i;
      }
    return t === e || this.f(t) <= this.f(e) ? t : e;
  }
  BehaviourAtIndex(t) {
    const e = this.f(t);
    if (t === 0) {
      const n = this.f(1);
      return n === e ? Ft.Extremum : n > e ? Ft.Increasing : Ft.Decreasing;
    }
    if (t === this.length - 1) {
      const n = this.f(this.length - 2);
      return n === e ? Ft.Extremum : n > e ? Ft.Decreasing : Ft.Increasing;
    }
    const i = e - this.f(t - 1), s = this.f(t + 1) - e;
    return i * s <= 0 ? Ft.Extremum : i > 0 ? Ft.Increasing : Ft.Decreasing;
  }
  FindMaximum() {
    let t = 0, e = this.length - 1, i = t + Math.floor((e - t) / 2);
    const s = this.f(i);
    if (s <= this.f(0) && s <= this.f(this.length - 1))
      return this.f(0) > this.f(this.length - 1) ? 0 : this.length - 1;
    for (; e - t > 1; )
      switch (i = t + Math.floor((e - t) / 2), this.BehaviourAtIndex(i)) {
        case Ft.Decreasing:
          e = i;
          break;
        case Ft.Increasing:
          t = i;
          break;
        case Ft.Extremum:
          return i;
      }
    return t === e || this.f(t) >= this.f(e) ? t : e;
  }
}
class Xd {
  toArray() {
    const t = [];
    for (let e = 0; e < this.length; e++)
      t.push(this.f(e));
    return t;
  }
  constructor(t, e) {
    this.f = t, this.length = e;
  }
  GetAdjustedSequenceForMinimum() {
    const t = this.f(0), i = (this.f(this.length - 1) - t) / (this.length - 1);
    return (s) => Math.min(this.f(s), t + i * s);
  }
  GetAdjustedSequenceForMaximum() {
    const t = this.f(0), i = (this.f(this.length - 1) - t) / (this.length - 1);
    return (s) => Math.max(this.f(s), t + i * s);
  }
  // following Chazelle, Dobkin
  FindMinimum() {
    return this.f(0) === this.f(this.length - 1) ? new nr(this.f, this.length).FindMinimum() : new nr(this.GetAdjustedSequenceForMinimum(), this.length).FindMinimum();
  }
  FindMaximum() {
    return this.f(0) === this.f(this.length - 1) ? new nr(this.f, this.length).FindMaximum() : new nr(this.GetAdjustedSequenceForMaximum(), this.length).FindMaximum();
  }
}
class io {
  constructor(t, e) {
    this.P = t, this.Q = e;
  }
  LeftFromLineOnP(t, e, i) {
    const s = this.P.pnt(t);
    return this.upperBranchOnP ? u.pointToTheLeftOfLineOrOnLine(i, s, e) : u.pointToTheRightOfLineOrOnLine(i, s, e);
  }
  LeftFromLineOnQ(t, e, i) {
    const s = this.Q.pnt(t);
    return this.lowerBranchOnQ ? u.pointToTheLeftOfLineOrOnLine(i, s, e) : u.pointToTheRightOfLineOrOnLine(i, s, e);
  }
  PrevOnP(t) {
    return this.upperBranchOnP ? this.P.Prev(t) : this.P.Next(t);
  }
  PrevOnQ(t) {
    return this.lowerBranchOnQ ? this.Q.Prev(t) : this.Q.Next(t);
  }
  NextOnP(t) {
    return this.upperBranchOnP ? this.P.Next(t) : this.P.Prev(t);
  }
  NextOnQ(t) {
    return this.lowerBranchOnQ ? this.Q.Next(t) : this.Q.Prev(t);
  }
  MedianOnP(t, e) {
    return this.upperBranchOnP ? this.P.Median(t, e) : this.P.Median(e, t);
  }
  MedianOnQ(t, e) {
    return this.lowerBranchOnQ ? this.Q.Median(t, e) : this.Q.Median(e, t);
  }
  ModuleP(t, e) {
    return this.upperBranchOnP ? this.P.Module(e - t) : this.P.Module(t - e);
  }
  ModuleQ(t, e) {
    return this.lowerBranchOnQ ? this.Q.Module(e - t) : this.Q.Module(t - e);
  }
  // we pretend here that the branches go clockwise from p0 to p1, and from q0 to q1
  TangentBetweenBranches(t, e, i, s) {
    for (; e !== t || s !== i; ) {
      const n = e !== t ? this.MedianOnP(t, e) : t, r = s !== i ? this.MedianOnQ(i, s) : i, a = this.P.pnt(n), l = this.Q.pnt(r);
      let h = !0;
      this.ModuleP(t, e) > 1 ? this.LeftFromLineOnP(this.NextOnP(n), a, l) ? t = n : this.LeftFromLineOnP(this.PrevOnP(n), a, l) ? e = n : h = !1 : e !== t ? this.LeftFromLineOnP(e, this.P.pnt(t), l) ? t = e : this.LeftFromLineOnP(t, this.P.pnt(e), l) ? e = t : h = !1 : h = !1;
      let c = !0;
      this.ModuleQ(i, s) > 1 ? this.LeftFromLineOnQ(this.NextOnQ(r), l, a) ? i = r : this.LeftFromLineOnQ(this.PrevOnQ(r), l, a) ? s = r : c = !1 : s !== i ? this.LeftFromLineOnQ(s, this.Q.pnt(i), a) ? i = s : this.LeftFromLineOnQ(i, this.Q.pnt(s), a) ? s = i : c = !1 : c = !1, !h && !c && (t = n, e = n, i = r, s = r);
    }
    return [t, s];
  }
  // following the paper of Edelsbrunner
  FindDividingBisector(t) {
    const e = {
      pClosest: void 0,
      qClosest: void 0,
      p1: void 0,
      p2: void 0,
      q1: void 0,
      q2: void 0
    };
    this.FindClosestFeatures(e), t.bisectorPivot = u.middle(e.pClosest, e.qClosest), t.bisectorRay = e.pClosest.sub(e.qClosest).rotate(Math.PI / 2), t.p1 = e.p1, t.p2 = e.p2, t.q1 = e.q1, t.q2 = e.q2;
  }
  FindClosestPoints() {
    const t = {
      q2: void 0,
      p1: void 0,
      p2: void 0,
      q1: void 0,
      pClosest: void 0,
      qClosest: void 0
    };
    return this.FindClosestFeatures(t), { pClosest: t.pClosest, qClosest: t.qClosest };
  }
  FindClosestFeatures(t) {
    const e = {
      leftTangentPoint: void 0,
      rightTangentPoint: void 0
    };
    this.P.GetTangentPoints(e, this.Q.pp(0).point), t.p2 = e.leftTangentPoint, t.p1 = e.rightTangentPoint, t.p2 === t.p1 && (t.p2 += this.P.count), this.Q.GetTangentPoints(e, this.P.pp(0).point), t.q1 = e.leftTangentPoint, t.q2 = e.rightTangentPoint, t.q2 === t.q1 && (t.q2 += this.Q.count), this.FindClosestPoints_(t);
  }
  //chunks go clockwise from p1 to p2 and from q2 to q1
  FindClosestPoints_(t) {
    for (; this.ChunksAreLong(t.p2, t.p1, t.q2, t.q1); )
      this.ShrinkChunks(t);
    t.p1 === t.p2 ? (t.pClosest = this.P.pp(t.p2).point, t.q1 === t.q2 ? t.qClosest = this.Q.pp(t.q1).point : (t.qClosest = u.ClosestPointAtLineSegment(t.pClosest, this.Q.pp(t.q1).point, this.Q.pp(t.q2).point), u.closeDistEps(t.qClosest, this.Q.pnt(t.q1)) ? t.q2 = t.q1 : u.closeDistEps(t.qClosest, this.Q.pnt(t.q2)) && (t.q1 = t.q2))) : (t.qClosest = this.Q.pp(t.q1).point, t.pClosest = u.ClosestPointAtLineSegment(t.qClosest, this.P.pp(t.p1).point, this.P.pp(t.p2).point), u.closeDistEps(t.pClosest, this.P.pnt(t.p1)) ? t.p2 = t.p1 : u.closeDistEps(t.qClosest, this.P.pnt(t.p2)) && (t.p1 = t.p2));
  }
  ChunksAreLong(t, e, i, s) {
    const n = this.P.Module(t - e) + 1;
    if (n > 2)
      return !0;
    const r = this.Q.Module(s - i) + 1;
    return r > 2 || n === 2 && r === 2;
  }
  ShrinkChunks(t) {
    const e = t.p1 === t.p2 ? t.p1 : this.P.Median(t.p1, t.p2), i = t.q1 === t.q2 ? t.q1 : this.Q.Median(t.q2, t.q1), s = this.P.pp(e).point, n = this.Q.pp(i).point, r = {
      a1: void 0,
      a2: void 0,
      b1: void 0,
      b2: void 0
    };
    if (this.GetAnglesAtTheMedian(e, i, s, n, r), !this.InternalCut(t, e, i, r.a1, r.a2, r.b1, r.b2) && !io.OneOfChunksContainsOnlyOneVertex(t, e, i, r.a1, r.b1) && !this.OnlyOneChunkContainsExactlyTwoVertices(t, { mp: e, mq: i }, r)) {
      if (t.p2 === this.P.Next(t.p1) && t.q1 === this.Q.Next(t.q2)) {
        const a = v.minDistBetweenLineSegments(this.P.pnt(t.p1), this.P.pnt(t.p2), this.Q.pnt(t.q1), this.Q.pnt(t.q2));
        a.parab === 0 ? t.p2 = t.p1 : a.parab === 1 ? t.p1 = t.p2 : a.parcd === 0 ? t.q2 = t.q1 : a.parcd === 1 && (t.q1 = t.q2);
        return;
      }
      r.a1 <= Math.PI && r.a2 <= Math.PI && r.b1 <= Math.PI && r.b2 <= Math.PI ? r.a1 + r.b1 > Math.PI ? r.a1 >= Math.PI / 2 ? t.p1 = e : t.q1 = i : r.a2 >= Math.PI / 2 ? t.p2 = e : t.q2 = i : r.a1 > Math.PI ? t.p1 = e : r.a2 > Math.PI ? t.p2 = e : r.b1 > Math.PI ? t.q1 = i : t.q2 = i;
    }
  }
  InternalCut(t, e, i, s, n, r, a) {
    let l = !1;
    if (s >= Math.PI && n >= Math.PI) {
      const h = this.P.pp(e).point, c = this.Q.pp(i).point, d = this.P.pp(this.P.Next(e)).point, f = u.getTriangleOrientation(h, c, this.Q.pp(0).point), p = u.getTriangleOrientation(h, c, d);
      f === p ? t.p1 = this.P.Next(e) : t.p2 = this.P.Prev(e), l = !0;
    }
    if (r >= Math.PI && a >= Math.PI) {
      const h = this.P.pp(e).point, c = this.Q.pp(i).point, d = this.Q.pp(this.Q.Next(i)).point, f = u.getTriangleOrientation(h, c, this.P.pp(0).point), p = u.getTriangleOrientation(h, c, d);
      f === p ? t.q2 = this.Q.Next(i) : t.q1 = this.Q.Prev(i), l = !0;
    }
    return l;
  }
  // void ProcessLeftSideOfTrapez(ref number p1, ref number p2, ref number q2, ref number q1) {
  //   //the closest vertex is on the left side
  //   Point pn1 = P.Pnt(p1); Point pn2 = P.Pnt(p2);
  //   Point qn1 = Q.Pnt(q1); Point qn2 = Q.Pnt(q2);
  //  //SugiyamaLayoutSettings.Show(new LineSegment(pn1, pn2), new LineSegment(pn2, qn2), new LineSegment(qn2, qn1), new LineSegment(qn1, pn1));
  //   number ap1 = Point.angle(pn2, pn1, qn1);
  //   number aq1 = Point.angle(pn1, qn1, qn2);
  //   Assert.assert(ap1 + aq1 >= Math.PI);
  //   //the point is on the left side
  //   if (ap1 >= Math.PI / 2 && aq1 >= Math.PI / 2) {
  //       q2 = q1; //the vertices of the left side gives the solution
  //       p2 = p1;
  //   } else if (ap1 < Math.PI / 2) {
  //       q2 = q1;
  //       if (!Point.CanProject(qn1, pn1, pn2))
  //           p1 = p2;
  //   } else { //aq1<Pi/2
  //       p2 = p1;
  //       if (!Point.CanProject(pn1, qn1, qn2))
  //           q1 = q2;
  //   }
  //}
  GetAnglesAtTheMedian(t, e, i, s, n) {
    n.a1 = u.anglePCP(s, i, this.P.pnt(this.P.Prev(t))), n.a2 = u.anglePCP(this.P.pnt(this.P.Next(t)), i, s), n.b1 = u.anglePCP(this.Q.pnt(this.Q.Next(e)), s, i), n.b2 = u.anglePCP(i, s, this.Q.pnt(this.Q.Prev(e)));
  }
  // we know here that p1!=p2 and q1!=q2
  OnlyOneChunkContainsExactlyTwoVertices(t, e, i) {
    const s = t.p2 === this.P.Next(t.p1), n = t.q1 === this.Q.Next(t.q2);
    return s && !n ? (this.ProcessShortSide(t, e.mp, e.mq, i.a1, i.b1, i.a2, i.b2), !0) : n && !s ? (this.SwapEverything(t, e, i), this.ProcessShortSide(t, e.mp, e.mq, i.a1, i.b1, i.a2, i.b2), this.SwapEverything(t, e, i), !0) : !1;
  }
  SwapEverything(t, e, i) {
    this.SwapPq();
    let s = t.p2;
    t.p2 = t.q1, t.q1 = s, s = t.q2, t.q2 = t.p1, t.p1 = s, s = e.mq, e.mq = e.mp, e.mp = s, s = i.a2, i.a2 = i.b1, i.b1 = s, s = i.b2, i.b2 = i.a1, i.a1 = s;
  }
  ProcessShortSide(t, e, i, s, n, r, a) {
    e === t.p2 ? this.ProcessSide(t, i, s, n, a) : r <= Math.PI ? r + a >= Math.PI ? r >= Math.PI / 2 ? t.p2 = t.p1 : t.q2 = i : n >= Math.PI / 2 ? t.q1 = i : r < a && (u.canProject(this.Q.pnt(i), this.P.pp(t.p1).point, this.P.pp(t.p2).point) ? t.q1 = i : t.p1 = t.p2) : s + n <= Math.PI ? t.p1 = t.p2 : t.p2 = t.p1;
  }
  SwapPq() {
    const t = this.P;
    this.P = this.Q, this.Q = t;
  }
  ProcessSide(t, e, i, s, n) {
    const r = this.Q.pnt(e);
    i <= Math.PI ? i + s >= Math.PI ? i >= Math.PI / 2 ? t.p1 = t.p2 : t.q1 = e : n >= Math.PI / 2 ? t.q2 = e : i < n && (u.canProject(r, this.P.pp(t.p1).point, this.P.pp(t.p2).point) ? t.q2 = e : t.p2 = t.p1) : (t.p2 = t.p1, s >= Math.PI ? t.q1 = e : n >= Math.PI && (t.q2 = e));
  }
  static OneOfChunksContainsOnlyOneVertex(t, e, i, s, n) {
    return t.p1 === t.p2 ? (n >= Math.PI / 2 ? t.q1 = i : t.q2 = i, !0) : t.q1 === t.q2 ? (s >= Math.PI / 2 ? t.p1 = e : t.p2 = e, !0) : !1;
  }
  CalculateLeftTangents() {
    const t = {
      bisectorPivot: null,
      bisectorRay: null,
      p1: 0,
      p2: 0,
      q1: 0,
      q2: 0
    };
    this.FindDividingBisector(t);
    const e = this.P.FindTheFurthestVertexFromBisector(t.p1, t.p2, t.bisectorPivot, t.bisectorRay), i = this.Q.FindTheFurthestVertexFromBisector(t.q2, t.q1, t.bisectorPivot, t.bisectorRay);
    this.upperBranchOnP = !1, this.lowerBranchOnQ = !0, this.leftPLeftQ = this.TangentBetweenBranches(e, t.p1, i, t.q1), this.lowerBranchOnQ = !1, this.leftPRightQ = this.TangentBetweenBranches(e, t.p1, i, t.q2);
  }
  // bool QContains(number x ,number y) {
  //   foreach (Point p of Q.Polyline) {
  //       if (p.x === x && p.y === y)
  //           return true;
  //   }
  //   return false;
  //}
  //bool PContains(number x, number y) {
  //   foreach (Point p of P.Polyline) {
  //       if (p.x === x && p.y === y)
  //           return true;
  //   }
  //   return false;
  //}
  CalculateRightTangents() {
    const t = { bisectorPivot: null, bisectorRay: null, p1: 0, p2: 0, q1: 0, q2: 0 };
    this.FindDividingBisector(t);
    const e = this.P.FindTheFurthestVertexFromBisector(t.p1, t.p2, t.bisectorPivot, t.bisectorRay), i = this.Q.FindTheFurthestVertexFromBisector(t.q2, t.q1, t.bisectorPivot, t.bisectorRay);
    this.upperBranchOnP = !0, this.lowerBranchOnQ = !0, this.rightPLeftQ = this.TangentBetweenBranches(e, t.p2, i, t.q1), this.lowerBranchOnQ = !1, this.rightPRightQ = this.TangentBetweenBranches(e, t.p2, i, t.q2);
  }
}
class ue {
  static mkFromPoints(t) {
    return new ue(B.mkClosedFromPoints(t));
  }
  get Polyline() {
    return this.polyline;
  }
  constructor(t) {
    this.polyline = t, this.points = new Array();
    for (let e = this.polyline.startPoint; e; e = e.next)
      this.points.push(e);
  }
  Next(t) {
    return this.Module(t + 1);
  }
  Prev(t) {
    return this.Module(t - 1);
  }
  get count() {
    return this.Polyline.count;
  }
  Module(t) {
    return t < 0 ? t + this.count : t < this.count ? t : t - this.count;
  }
  pp(t) {
    return this.points[this.Module(t)];
  }
  // LineSegment ls(Point pivot, int p) {
  //    return new LineSegment(pivot, Pnt(p));
  // }
  pnt(t) {
    return this.pp(t).point;
  }
  toString() {
    return this.polyline.toString();
  }
  // the median of a chunk going clockwise from p1 to p2
  Median(t, e) {
    return e > t ? Math.floor((e + t) / 2) : this.Module(e + Math.floor((this.count + t) / 2));
  }
  // p1 and p2 represent the closest feature. Two cases are possible p1=p2, or p1 and p2 share an edge going from p1 to p2
  // Remind that the polygons are oriented clockwise
  FindTheFurthestVertexFromBisector(t, e, i, s) {
    let n = s.rotate(Math.PI / 2);
    this.polyline.startPoint.point.sub(i).dot(n) < 0 && (n = n.mul(-1)), t === e && (e = this.Next(t));
    do {
      const r = this.Median(e, t), a = this.pnt(r);
      this.pnt(this.Next(r)).sub(a).dot(n) >= 0 ? e = this.Next(r) : this.pnt(this.Prev(r)).sub(a).dot(n) >= 0 ? t = this.Prev(r) : e = r, t = r;
    } while (t !== e);
    return t;
  }
  static TestPolygonDist(t, e) {
    let i = Number.MAX_SAFE_INTEGER;
    for (let s = 0; s < t.count; s++)
      for (let n = 0; n < e.count; n++) {
        const r = v.minDistBetweenLineSegments(t.pnt(s), t.pnt(s + 1), e.pnt(n), e.pnt(n + 1));
        i = Math.min(i, r.dist);
      }
    return i;
  }
  // Distance between two polygons
  // p and q are the closest points
  // The function doesn't work if the polygons intersect each other
  static Distance(t, e) {
    const s = new io(t, e).FindClosestPoints();
    return {
      p: s.pClosest,
      q: s.qClosest,
      dist: s.pClosest.sub(s.qClosest).length
    };
  }
  // Distance between two polygons
  static DistanceOnly(t, e) {
    return ue.Distance(t, e).dist;
  }
  static PolygonIsLegalDebug(t) {
    const e = t.Polyline;
    for (let i = e.startPoint; i.next != null && i.next.next != null; i = i.next)
      if (u.getTriangleOrientation(i.point, i.next.point, i.next.next.point) === L.Collinear)
        return !1;
    return !0;
  }
  // Distance between polygon and point, assuming the point is outside of the polygon
  static DistancePoint(t, e) {
    let i = Number.MAX_VALUE;
    for (let s = 0; s < t.count; s++) {
      const n = u.distToLineSegment(e, t.points[s].point, t.points[(s + 1) % t.count].point).dist;
      i = Math.min(i, n);
    }
    return i;
  }
  GetTangentPoints(t, e) {
    const i = new Xd(this.GetSequenceDelegate(e), this.count);
    t.leftTangentPoint = i.FindMaximum(), t.rightTangentPoint = i.FindMinimum();
  }
  GetSequenceDelegate(t) {
    const e = this.pnt(0);
    return (i) => {
      const s = u.anglePCP(e, t, this.pnt(i));
      return s < Math.PI ? s : s - 2 * Math.PI;
    };
  }
}
class M {
  ObstaclesIntersectLine(t, e) {
    return this.ObstaclesIntersectICurve(v.mkPP(t, e));
  }
  static PadCorner(t, e, i, s, n) {
    const r = M.GetPaddedCorner(e, i, s, n);
    return r.numberOfPoints === -1 ? !1 : (t.addPoint(r.a), r.numberOfPoints === 2 && t.addPoint(r.b), !0);
  }
  static CurveIsClockwise(t, e) {
    return u.getTriangleOrientation(e, t.start, t.start.add(t.derivative(t.parStart))) == L.Clockwise;
  }
  static PaddedPolylineBoundaryOfNode(t, e, i = !1) {
    return M.CreatePaddedPolyline(g.polylineAroundClosedCurve(t), e, i);
  }
  /** surrounds the given polyline with the given offset, optionally randomizes the output */
  static LoosePolylineWithFewCorners(t, e, i) {
    return e < m.distanceEpsilon ? t : M.CreateLoosePolylineOnBisectors(t, e, i);
  }
  static CreateLoosePolylineOnBisectors(t, e, i) {
    const s = Array.from(M.BisectorPoints(t, e));
    i && r();
    const n = Xe.CalculateConvexHull(s);
    return B.mkClosedFromPoints(n);
    function r() {
      for (let a = 0; a < s.length; a++) {
        const l = s[a];
        s[a] = new u(l.x + (2 * vs() - 1) * i, l.y + (2 * vs() - 1) * i);
      }
    }
  }
  static CreateRectNodeOfPolyline(t) {
    return Nt(t, t.boundingBox);
  }
  CreateLooseObstacles() {
    this.tightPolylinesToLooseDistances = /* @__PURE__ */ new Map(), this.LooseObstacles = new Array();
    for (const t of this.TightObstacles) {
      const e = M.FindMaxPaddingForTightPolyline(this.RootOfTightHierarchy, t, this.LoosePadding);
      this.tightPolylinesToLooseDistances.set(t, e), this.LooseObstacles.push(M.LoosePolylineWithFewCorners(t, e, this.randomizationShift));
    }
    this.RootOfLooseHierarchy = M.CalculateHierarchy(this.LooseObstacles);
  }
  CreateTightObstacles() {
    this.RootOfTightHierarchy = this.CreateTightObstacles_(), this.OverlapsDetected = this.TightObstacles.size < this.Obstacles.length;
  }
  Calculate() {
    this.IgnoreTightPadding ? this.CreateTightObstaclesIgnoringTightPadding() : this.CreateTightObstacles(), this.IsEmpty() || this.CreateLooseObstacles();
  }
  IsEmpty() {
    return this.TightObstacles == null || this.TightObstacles.size === 0;
  }
  constructor(t, e, i, s) {
    this.randomizationShift = 0.01, this.TightObstacles = /* @__PURE__ */ new Set(), this.Obstacles = t, this.TightPadding = e, this.LoosePadding = i, this.IgnoreTightPadding = s;
  }
  ObstaclesIntersectICurve(t) {
    const e = t.boundingBox;
    return M.CurveIntersectsRectangleNode(t, e, this.RootOfTightHierarchy);
  }
  static CurveIntersectsRectangleNode(t, e, i) {
    if (!i.irect.intersects(e))
      return !1;
    if (i.UserData != null) {
      const s = i.UserData;
      return g.intersectionOne(s, t, !1) != null || M.PointIsInside(s.start, t);
    }
    return M.CurveIntersectsRectangleNode(t, e, i.Left) || M.CurveIntersectsRectangleNode(t, e, i.Right);
  }
  static PointIsInside(t, e) {
    return g.PointRelativeToCurveLocation(t, e) === F.Inside;
  }
  CreateTightObstaclesIgnoringTightPadding() {
    const t = this.Obstacles.map((s) => g.polylineAroundClosedCurve(s)), e = M.CalculateHierarchy(t), i = M.GetOverlappedPairSet(e);
    if (this.TightObstacles = /* @__PURE__ */ new Set(), i.size === 0) {
      for (const s of t) {
        const n = M.FindMaxPaddingForTightPolyline(e, s, this.TightPadding);
        this.TightObstacles.add(M.LoosePolylineWithFewCorners(s, n, this.randomizationShift));
      }
      this.RootOfTightHierarchy = M.CalculateHierarchy(Array.from(this.TightObstacles));
    } else {
      for (const s of t)
        this.TightObstacles.add(M.CreatePaddedPolyline(s, this.TightPadding));
      if (!this.IsEmpty())
        for (this.RootOfTightHierarchy = M.CalculateHierarchy(Array.from(this.TightObstacles)), this.OverlapsDetected = !1; M.GetOverlappedPairSet(this.RootOfTightHierarchy).size > 0; )
          this.RootOfTightHierarchy = M.ReplaceTightObstaclesWithConvexHulls(this.TightObstacles, Array.from(i)), this.OverlapsDetected = !0;
    }
  }
  CreateTightObstacles_() {
    if (this.Obstacles.length === 0)
      return null;
    for (const t of this.Obstacles)
      M.CalculateTightPolyline(this.TightObstacles, this.TightPadding, t);
    return M.RemovePossibleOverlapsInTightPolylinesAndCalculateHierarchy(this.TightObstacles);
  }
  static CalculateTightPolyline(t, e, i) {
    const s = M.PaddedPolylineBoundaryOfNode(i, e);
    t.add(s);
  }
  static CalculateHierarchy(t) {
    const e = t.map((i) => M.CreateRectNodeOfPolyline(i));
    return wt(e);
  }
  static RemovePossibleOverlapsInTightPolylinesAndCalculateHierarchy(t, e = null) {
    let i = M.CalculateHierarchy(Array.from(t)), s;
    for (; (s = M.GetOverlappedPairSet(i)).size > 0; )
      i = M.ReplaceTightObstaclesWithConvexHulls(t, Array.from(s), e);
    return i;
  }
  static MapToInt(t) {
    const e = /* @__PURE__ */ new Map();
    for (let i = 0; i < t.length; i++)
      e.set(t[i], i);
    return e;
  }
  static ReplaceTightObstaclesWithConvexHulls(t, e, i = null) {
    const s = /* @__PURE__ */ new Set();
    for (const h of e)
      s.add(h[0]), s.add(h[1]);
    const n = Array.from(s), r = M.MapToInt(n), a = Wh(Array.from(e).map((h) => new U(r.get(h[0]), r.get(h[1])))), l = Xs(a);
    for (const h of l) {
      const c = h.map((P) => n[P]), d = Yn(c, (P) => P), f = Xe.createConvexHullAsClosedPolyline(d), p = new Array();
      for (const P of c)
        t.delete(P), i != null && (p.push(...i.get(P)), i.delete(P));
      i?.set(f, p), t.add(f);
    }
    return M.CalculateHierarchy(Array.from(t));
  }
  static OneCurveLiesInsideOfOther(t, e) {
    return g.PointRelativeToCurveLocation(t.start, e) !== F.Outside || g.PointRelativeToCurveLocation(e.start, t) !== F.Outside;
  }
  static PolylinesIntersect(t, e) {
    return g.CurvesIntersect(t, e) || M.OneCurveLiesInsideOfOther(t, e);
  }
  static GetOverlappedPairSet(t) {
    const e = /* @__PURE__ */ new Set();
    return Qt(t, t, (i, s) => {
      M.PolylinesIntersect(i, s) && e.add([i, s]);
    }), e;
  }
  static *BisectorPoints(t, e) {
    for (let i = t.startPoint; i != null; i = i.next) {
      const s = { skip: !1 }, n = M.GetStickingVertexOnBisector(i, e, s);
      s.skip || (yield n);
    }
  }
  static GetStickingVertexOnBisector(t, e, i) {
    const s = t.polyline.prev(t).point, n = t.point, r = t.polyline.next(t).point;
    let a = n.sub(s).normalize().add(n.sub(r).normalize());
    const l = a.length;
    return l < m.tolerance ? i.skip = !0 : (i.skip = !1, a = a.div(l)), a.mul(e).add(n);
  }
  static FindMaxPaddingForTightPolyline(t, e, i) {
    let s = i;
    const n = new ue(e), r = e.boundingBox.clone();
    r.pad(2 * i);
    for (const a of Array.from(t.GetNodeItemsIntersectingRectangle(r)).filter((l) => l !== e)) {
      const l = ue.Distance(n, new ue(a)).dist;
      s = Math.min(s, l / M.LooseDistCoefficient);
    }
    return s;
  }
  static GetPaddedCorner(t, e, i, s) {
    const n = t.point, r = e.point, a = i.point;
    if (u.getTriangleOrientation(n, r, a) === L.Counterclockwise)
      return { a: void 0, b: void 0, numberOfPoints: -1 };
    let l = r.sub(n).rotate(Math.PI / 2).normalize();
    if (M.CornerIsNotTooSharp(n, r, a)) {
      l = l.mul(s);
      const P = a.sub(r).normalize().mul(s).rotate(Math.PI / 2), y = u.lineLineIntersection(n.add(l), r.add(l), r.add(P), a.add(P));
      return { a: y, b: y, numberOfPoints: 1 };
    }
    const h = r.sub(n).normalize().add(r.sub(a).normalize());
    if (h.length < m.intersectionEpsilon) {
      const P = r.add(l.mul(s));
      return { a: P, b: P, numberOfPoints: 1 };
    }
    const c = h.normalize().mul(s), d = c.rotate(Math.PI / 2), f = (s - c.dot(l)) / d.dot(l), p = d.mul(f);
    return { a: c.add(p).add(r), b: c.sub(p).add(r), numberOfPoints: 2 };
  }
  static CornerIsNotTooSharp(t, e, i) {
    const s = t.sub(e).rotate(Math.PI / 4).add(e);
    return u.getTriangleOrientation(e, s, i) === L.Counterclockwise;
  }
  static CreatePaddedPolyline(t, e, i = !1) {
    const s = new B(), n = i ? Qd(t) : t;
    if (!M.PadCorner(s, n.endPoint.prev, n.endPoint, n.startPoint, e) || !M.PadCorner(s, n.endPoint, n.startPoint, n.startPoint.next, e))
      return M.CreatePaddedPolyline(B.mkClosedFromPoints(Array.from(Xe.CalculateConvexHull(n))), e);
    for (let r = n.startPoint; r.next.next != null; r = r.next)
      if (!M.PadCorner(s, r, r.next, r.next.next, e))
        return M.CreatePaddedPolyline(B.mkClosedFromPoints(Array.from(Xe.CalculateConvexHull(n))), e);
    return s.closed = !0, s;
  }
}
M.LooseDistCoefficient = 2.1;
function Qd(o) {
  const t = new B(), e = 0.01;
  for (let i = o.startPoint; i; i = i.next) {
    const s = i.point.x + e * vs(), n = i.point.y + e * vs();
    t.addPointXY(s, n);
  }
  return t.closed = o.closed, t;
}
class da {
  get TightPolyline() {
    return this.tightPoly;
  }
  set TightPolyline(t) {
    this.tightPoly = t;
  }
  static mk(t, e, i) {
    const s = new da();
    return s.TightPolyline = t, s.LooseShape = e, s.Distance = i, s;
  }
  toString() {
    return (this.TightPolyline == null ? "null" : this.TightPolyline.toString().substring(0, 5)) + "," + (this.LooseShape == null ? "null" : this.LooseShape.toString().substring(0, 5));
  }
}
class fa {
  constructor(t, e, i, s) {
    this.loosePolylinesToNodes = /* @__PURE__ */ new Map(), this.MainShape = t, this.TightPadding = e, this.LoosePadding = i, this.ShapesToTightLooseCouples = s;
  }
  Calculate(t) {
    eo(3), this.MainShape.Children.length !== 0 && (this.CreateTightObstacles(), this.CreateTigthLooseCouples(t), this.OverlapsDetected && this.FillTheMapOfShapeToTightLooseCouples());
  }
  FillTheMapOfShapeToTightLooseCouples() {
    const t = wt(this.MainShape.Children.map((e) => Nt(e, e.BoundingBox)));
    ae(t, this.coupleHierarchy, this.TryMapShapeToTightLooseCouple.bind(this));
  }
  TryMapShapeToTightLooseCouple(t, e) {
    fa.ShapeIsInsideOfPoly(t, e.TightPolyline) && this.ShapesToTightLooseCouples.set(t, e);
  }
  // this test is valid in our situation where the tight polylines are disjoint and the shape can cross only one of them
  static ShapeIsInsideOfPoly(t, e) {
    return g.PointRelativeToCurveLocation(t.BoundaryCurve.start, e) === F.Inside;
  }
  CreateTigthLooseCouples(t) {
    const e = new Array();
    for (const i of this.tightHierarchy.GetAllLeaves()) {
      const s = M.FindMaxPaddingForTightPolyline(this.tightHierarchy, i, this.LoosePadding), n = M.LoosePolylineWithFewCorners(i, s, t), r = new js(n), a = da.mk(i, r, s), l = this.tightToShapes.get(i);
      for (const h of l)
        this.ShapesToTightLooseCouples.set(h, a);
      e.push(a);
    }
    this.coupleHierarchy = wt(e.map((i) => Nt(i, i.TightPolyline.boundingBox)));
  }
  CreateTightObstacles() {
    this.tightToShapes = /* @__PURE__ */ new Map();
    const t = new Set(this.MainShape.Children.map(this.InitialTightPolyline.bind(this))), e = t.size;
    this.tightHierarchy = M.RemovePossibleOverlapsInTightPolylinesAndCalculateHierarchy(t, this.tightToShapes), this.OverlapsDetected = e > t.size;
  }
  InitialTightPolyline(t) {
    let e = M.PaddedPolylineBoundaryOfNode(t.BoundaryCurve, this.TightPadding);
    const i = Yn(this.LoosePolylinesUnderShape(t), (n) => n).filter((n) => g.PointRelativeToCurveLocation(n, e) === F.Outside);
    if (i.length == 0)
      return this.tightToShapes && this.tightToShapes.set(e, [t]), e;
    const s = Array.from(e).concat(i);
    return e = B.mkClosedFromPoints(Xe.CalculateConvexHull(s)), this.tightToShapes && this.tightToShapes.set(e, [t]), e;
  }
  LoosePolylinesUnderShape(t) {
    return t.Children.map((e) => this.ShapesToTightLooseCouples.get(e).LooseShape.BoundaryCurve);
  }
}
class Yd {
  // value
  constructor(t, e, i) {
    this.indexToA = t, this.priority = e, this.v = i;
  }
}
class es {
  get count() {
    return this.heapSize;
  }
  ContainsElement(t) {
    return this.cache.has(t);
  }
  constructor(t = yt) {
    this.heapSize = 0, this.compare = t, this.cache = /* @__PURE__ */ new Map(), this.A = [];
  }
  SwapWithParent(t) {
    const e = this.A[t >> 1];
    this.PutAtI(t >> 1, this.A[t]), this.PutAtI(t, e);
  }
  Enqueue(t, e) {
    let i = ++this.heapSize;
    const s = new Yd(i, e, t);
    for (this.cache.set(t, s), this.A[i] = s; i > 1 && this.compare(this.A[i >> 1].priority, e) > 0; )
      this.SwapWithParent(i), i >>= 1;
  }
  IsEmpty() {
    return this.heapSize === 0;
  }
  PutAtI(t, e) {
    this.A[t] = e, e.indexToA = t;
  }
  Dequeue() {
    if (this.heapSize === 0)
      throw new Error("dequeue on an empty queue");
    const t = this.A[1].v;
    return this.MoveQueueOneStepForward(t), t;
  }
  DequeueAndGetPriority(t) {
    if (this.heapSize === 0)
      throw new Error("dequeue on an empty queue");
    const e = this.A[1].v;
    return t.priority = this.A[1].priority, this.MoveQueueOneStepForward(e), e;
  }
  MoveQueueOneStepForward(t) {
    this.cache.delete(t), this.PutAtI(1, this.A[this.heapSize]);
    let e = 1;
    for (; ; ) {
      let i = e;
      const s = e << 1;
      s <= this.heapSize && this.compare(this.A[s].priority, this.A[e].priority) < 0 && (i = s);
      const n = s + 1;
      if (n <= this.heapSize && this.compare(this.A[n].priority, this.A[i].priority) < 0 && (i = n), i !== e)
        this.SwapWithParent(i);
      else
        break;
      e = i;
    }
    this.heapSize--;
  }
  DecreasePriority(t, e) {
    const i = this.cache.get(t);
    if (!i)
      return;
    i.priority = e;
    let s = i.indexToA;
    for (; s > 1 && this.compare(this.A[s].priority, this.A[s >> 1].priority) < 0; ) {
      this.SwapWithParent(s);
      s >>= 1;
    }
  }
  *GetEnumerator() {
    for (let t = 1; t <= this.heapSize; t++)
      yield this.A[t].v;
  }
  //
  Peek(t) {
    if (this.count === 0) {
      t.priority = 0;
      return;
    }
    return t.priority = this.A[1].priority, this.A[1].v;
  }
  toString() {
    const t = new Bt.StringBuilder();
    for (const e of this.A)
      t.Append(e + ",");
    return t.ToString();
  }
}
class Rn {
  constructor(t, e, i) {
    this.upperBound = Number.POSITIVE_INFINITY, this._visGraph = i, this._visGraph.ClearPrevEdgesTable();
    for (const s of i.Vertices())
      s.Distance = Number.POSITIVE_INFINITY;
    this.source = t, this.targets = new Set(e), this.source.Distance = 0;
  }
  // Returns  a  path
  GetPath() {
    const t = new es(yt);
    for (this.source.Distance = 0, t.Enqueue(this.source, 0); !t.IsEmpty() && (this.current = t.Dequeue(), !this.targets.has(this.current)); ) {
      for (const e of this.current.OutEdges)
        this.PassableOutEdge(e) && this.ProcessNeighbor(t, e, e.Target);
      for (const e of this.current.InEdges)
        this.PassableInEdge(e) && this.ProcessNeighbor(t, e, e.Source);
    }
    return this._visGraph.PreviosVertex(this.current) == null ? null : this.CalculatePath();
  }
  PassableOutEdge(t) {
    return t.Source === this.source || this.targets.has(t.Target) || !Rn.IsForbidden(t);
  }
  PassableInEdge(t) {
    return this.targets.has(t.Source) || t.Target === this.source || !Rn.IsForbidden(t);
  }
  static IsForbidden(t) {
    return t.IsPassable != null && !t.IsPassable() || t instanceof pi;
  }
  ProcessNeighbor(t, e, i) {
    const s = e.Length, n = this.current.Distance + s;
    n >= this.upperBound || (this.targets.has(i) && (this.upperBound = n, this.closestTarget = i), i !== this.source && this._visGraph.PreviosVertex(i) == null ? (i.Distance = n, this._visGraph.SetPreviousEdge(i, e), t.Enqueue(i, n)) : n < i.Distance && (i.Distance = n, this._visGraph.SetPreviousEdge(i, e), t.DecreasePriority(i, n)));
  }
  CalculatePath() {
    if (this.closestTarget == null)
      return null;
    const t = new Array();
    let e = this.closestTarget;
    do
      t.push(e), e = this._visGraph.PreviosVertex(e);
    while (e !== this.source);
    return t.push(this.source), t.reverse();
  }
}
class Mr {
  get LengthMultiplier() {
    return this._lengthMultiplier;
  }
  set LengthMultiplier(t) {
    this._lengthMultiplier = t;
  }
  get LengthMultiplierForAStar() {
    return this._lengthMultiplierForAStar;
  }
  set LengthMultiplierForAStar(t) {
    this._lengthMultiplierForAStar = t;
  }
  constructor(t, e, i) {
    this._lengthMultiplier = 1, this._lengthMultiplierForAStar = 1, this._visGraph = t, this._source = e, this._target = i, this._source.Distance = 0;
  }
  // Returns  a  path
  GetPath(t) {
    const e = new es(yt);
    for (this._source.Distance = 0, this._target.Distance = Number.POSITIVE_INFINITY, e.Enqueue(this._source, this.H(this._source)); !e.IsEmpty(); ) {
      const i = { priority: 0 }, s = e.DequeueAndGetPriority(i);
      if (i.priority >= this._target.Distance)
        break;
      for (const n of s.OutEdges)
        if (this.PassableOutEdge(n)) {
          const r = n.Target;
          this.ProcessNeighbor(e, s, n, r);
        }
      for (const n of s.InEdges)
        if (this.PassableInEdge(n)) {
          const r = n.Source;
          this.ProcessNeighbor(e, s, n, r);
        }
    }
    return this._visGraph.PreviosVertex(this._target) == null ? null : this.CalculatePath(t);
  }
  // private AssertEdgesPassable(path: Array<VisibilityEdge>) {
  //  for (const edge of path) Assert.assert(this.PassableOutEdge(edge) || this.PassableInEdge(edge))
  // }
  PassableOutEdge(t) {
    return t.Source === this._source || t.Target === this._target || !Mr.IsForbidden(t);
  }
  PassableInEdge(t) {
    return t.Source === this._target || t.Target === this._source || !Mr.IsForbidden(t);
  }
  static IsForbidden(t) {
    return t.IsPassable != null && !t.IsPassable() || t instanceof pi;
  }
  ProcessNeighborN(t, e, i, s, n) {
    const r = i.Length + n, a = e.Distance + r;
    s !== this._source && this._visGraph.PreviosVertex(s) == null ? (s.Distance = a, this._visGraph.SetPreviousEdge(s, i), s !== this._target && t.Enqueue(s, this.H(s))) : s !== this._source && a < s.Distance && (s.Distance = a, this._visGraph.SetPreviousEdge(s, i), s !== this._target && t.DecreasePriority(s, this.H(s)));
  }
  ProcessNeighbor(t, e, i, s) {
    const n = i.Length, r = e.Distance + n;
    s !== this._source && this._visGraph.PreviosVertex(s) == null ? (s.Distance = r, this._visGraph.SetPreviousEdge(s, i), s !== this._target && t.Enqueue(s, this.H(s))) : s !== this._source && r < s.Distance && (s.Distance = r, this._visGraph.SetPreviousEdge(s, i), s !== this._target && t.DecreasePriority(s, this.H(s)));
  }
  H(t) {
    return t.Distance + t.point.sub(this._target.point).length * this.LengthMultiplierForAStar;
  }
  CalculatePath(t) {
    const e = new Array();
    let i = this._target;
    do
      e.push(i), t && this._visGraph.ShrinkLengthOfPrevEdge(i, this.LengthMultiplier), i = this._visGraph.PreviosVertex(i);
    while (i !== this._source);
    return e.push(this._source), e.reverse();
  }
}
var Ti;
(function(o) {
  o[o.Regular = 0] = "Regular", o[o.Tangent = 1] = "Tangent";
})(Ti || (Ti = {}));
class il {
  toString() {
    return Bt.String.format("{0},{1}", this.Start, this.End);
  }
  get Start() {
    return this.leftTangent.End.point;
  }
  get End() {
    return this.rightTangent.End.point;
  }
  constructor(t, e) {
    this.LeftTangent = t, this.RightTangent = e;
  }
  get LeftTangent() {
    return this.leftTangent;
  }
  set LeftTangent(t) {
    this.leftTangent = t;
  }
  get RightTangent() {
    return this.rightTangent;
  }
  set RightTangent(t) {
    this.rightTangent = t;
  }
  get RbNode() {
    return this.rbNode;
  }
  set RbNode(t) {
    this.rbNode = t;
  }
}
class sl {
  // the complimentary tangent
  get Comp() {
    return this.comp;
  }
  set Comp(t) {
    this.comp = t;
  }
  get IsHigh() {
    return !this.IsLow;
  }
  // true means that it is a low tangent to Q, false meanst that it is a high tangent to Q
  get IsLow() {
    return this.lowTangent;
  }
  set IsLow(t) {
    this.lowTangent = t;
  }
  get SeparatingPolygons() {
    return this.separatingPolygons;
  }
  set SeparatingPolygons(t) {
    this.separatingPolygons = t;
  }
  // the diagonal will be not a null only when it is active
  get Diagonal() {
    return this.diagonal;
  }
  set Diagonal(t) {
    this.diagonal = t;
  }
  get Start() {
    return this.start;
  }
  set Start(t) {
    this.start = t;
  }
  get End() {
    return this.end;
  }
  set End(t) {
    this.end = t;
  }
  constructor(t, e) {
    this.start = t, this.End = e;
  }
  toString() {
    return Bt.String.format("{0},{1}", this.Start, this.End);
  }
}
class nl {
  get PointOnTangentAndInsertedDiagonal() {
    return this.pointOnTheRay;
  }
  set PointOnTangentAndInsertedDiagonal(t) {
    this.pointOnTheRay = t;
  }
  Compare(t, e) {
    return t.Start.equal(e.Start) ? 0 : u.getTriangleOrientation(this.PointOnTangentAndInsertedDiagonal, e.Start, e.End) === L.Counterclockwise ? -1 : 1;
  }
  static BelongsToTheDiagonal(t, e, i) {
    return u.closeDistEps(t, u.ClosestPointAtLineSegment(t, e, i));
  }
  static IntersectDiagonalWithRay(t, e, i) {
    const s = e.sub(t), n = i.Start, r = i.End, a = Yi.solve(r.x - n.x, s.x * -1, t.x - n.x, r.y - n.y, s.y * -1, t.y - n.y);
    return t.add(s.mul(a.y));
  }
}
class ks {
  constructor(t) {
    this.pivot = t;
  }
  IComparer(t, e) {
    if (t === e)
      return 0;
    if (t == null)
      return -1;
    if (e == null)
      return 1;
    const i = t.Start.point.sub(this.pivot), s = e.Start.point.sub(this.pivot);
    return ks.CompareVectorsByAngleToXAxis(i, s);
  }
  static CompareVectorsByAngleToXAxis(t, e) {
    return t.y >= 0 ? e.y < 0 ? -1 : ks.CompareVectorsPointingToTheSameYHalfPlane(t, e) : e.y >= 0 ? 1 : ks.CompareVectorsPointingToTheSameYHalfPlane(t, e);
  }
  static CompareVectorsPointingToTheSameYHalfPlane(t, e) {
    const i = t.x * e.y - t.y * e.x;
    if (i > m.tolerance)
      return -1;
    if (i < -m.tolerance)
      return 1;
    if (t.x >= 0) {
      if (e.x < 0)
        return -1;
    } else if (e.x >= 0)
      return 1;
    let s = Math.abs(t.x) - Math.abs(e.x);
    return s < 0 ? -1 : s > 0 ? 1 : (s = Math.abs(t.y) - Math.abs(e.y), s < 0 ? -1 : s > 0 ? 1 : 0);
  }
}
class Hi extends lt {
  // we calculate tangents between activePolygons and between activePolygons and existingObsacles
  run() {
    this.useLeftPTangents = !0, this.CalculateAndAddEdges(), this.useLeftPTangents = !1, this.CalculateAndAddEdges();
  }
  CalculateAndAddEdges() {
    for (const t of this.addedPolygons)
      this.CalculateVisibleTangentsFromPolygon(t);
    this.ProgressStep();
  }
  CalculateVisibleTangentsFromPolygon(t) {
    this.currentPolygon = t, this.AllocateDataStructures(), this.OrganizeTangents(), this.InitActiveDiagonals(), this.Sweep();
  }
  AllocateDataStructures() {
    this.tangents = new Array(), this.diagonals = new Array(), this.activeDiagonalTree = new Ee(this.activeDiagonalComparer.Compare.bind(this.activeDiagonalComparer));
  }
  Sweep() {
    if (!(this.tangents.length < 2))
      for (let t = 1; t < this.tangents.length; t++) {
        const e = this.tangents[t];
        e.Diagonal != null ? (e.Diagonal.RbNode === this.activeDiagonalTree.treeMinimum() && this.AddVisibleEdge(e), e.IsHigh && this.RemoveDiagonalFromActiveNodes(e.Diagonal)) : e.IsLow && (this.activeDiagonalComparer.PointOnTangentAndInsertedDiagonal = e.End.point, this.InsertActiveDiagonal(new il(e, e.Comp)), e.Diagonal.RbNode === this.activeDiagonalTree.treeMinimum() && this.AddVisibleEdge(e));
      }
  }
  AddVisibleEdge(t) {
    Et.AddEdgeVV(rl(this.visibilityGraph, t.start), rl(this.visibilityGraph, t.End));
  }
  // this function will also add the first tangent to the visible edges if needed
  InitActiveDiagonals() {
    if (this.tangents.length === 0)
      return;
    const t = this.tangents[0], e = t.start.point, i = t.End.point;
    for (const s of this.diagonals)
      Hi.RayIntersectDiagonal(e, i, s) && (this.activeDiagonalComparer.PointOnTangentAndInsertedDiagonal = nl.IntersectDiagonalWithRay(e, i, s), this.InsertActiveDiagonal(s));
    if (t.Diagonal.RbNode === this.activeDiagonalTree.treeMinimum() && this.AddVisibleEdge(t), t.IsLow === !1) {
      const s = t.Diagonal;
      this.RemoveDiagonalFromActiveNodes(s);
    }
  }
  RemoveDiagonalFromActiveNodes(t) {
    const e = this.activeDiagonalTree.deleteSubTree(t.RbNode);
    e != null && e.item != null && (e.item.RbNode = e), t.LeftTangent.Diagonal = null, t.RightTangent.Diagonal = null;
  }
  InsertActiveDiagonal(t) {
    t.RbNode = this.activeDiagonalTree.insert(t), Hi.MarkDiagonalAsActiveInTangents(t);
  }
  static MarkDiagonalAsActiveInTangents(t) {
    t.LeftTangent.Diagonal = t, t.RightTangent.Diagonal = t;
  }
  static RayIntersectDiagonal(t, e, i) {
    const s = i.Start, n = i.End;
    return u.getTriangleOrientation(t, s, n) === L.Counterclockwise && u.getTriangleOrientation(t, e, s) !== L.Counterclockwise && u.getTriangleOrientation(t, e, n) !== L.Clockwise;
  }
  // compare tangents by measuring the counterclockwise angle between the tangent and the edge
  static TangentComparison(t, e) {
    return ks.CompareVectorsByAngleToXAxis(t.End.point.sub(t.start.point), e.End.point.sub(e.start.point));
  }
  *AllObstacles() {
    for (const t of this.addedPolygons)
      yield t;
    if (this.polygons)
      for (const t of this.polygons)
        yield t;
  }
  OrganizeTangents() {
    for (const t of this.AllObstacles())
      t !== this.currentPolygon && this.ProcessPolygonQ(t);
    this.tangents.sort(Hi.TangentComparison);
  }
  ProcessPolygonQ(t) {
    const e = new io(this.currentPolygon, t);
    this.useLeftPTangents ? e.CalculateLeftTangents() : e.CalculateRightTangents();
    let i = this.useLeftPTangents ? e.leftPLeftQ : e.rightPLeftQ;
    const s = new sl(this.currentPolygon.pp(i[0]), t.pp(i[1]));
    s.IsLow = !0, s.SeparatingPolygons = !this.useLeftPTangents, i = this.useLeftPTangents ? e.leftPRightQ : e.rightPRightQ;
    const n = new sl(this.currentPolygon.pp(i[0]), t.pp(i[1]));
    n.IsLow = !1, n.SeparatingPolygons = this.useLeftPTangents, s.Comp = n, n.Comp = s, this.tangents.push(s), this.tangents.push(n), this.diagonals.push(new il(s, n));
  }
  constructor(t, e, i) {
    super(null), this.polygons = [], this.activeDiagonalComparer = new nl(), this.polygons = t, this.visibilityGraph = i, this.addedPolygons = e;
  }
}
function rl(o, t) {
  return o.FindVertex(t.point);
}
class ga {
  get Pivot() {
    return this.pivot;
  }
  set Pivot(t) {
    this.pivot = t;
  }
  get IntersectionOfTheRayAndInsertedEdge() {
    return this.pointOnTheRay;
  }
  set IntersectionOfTheRayAndInsertedEdge(t) {
    this.pointOnTheRay = t;
  }
  Compare(t, e) {
    return u.getTriangleOrientation(this.IntersectionOfTheRayAndInsertedEdge, e.point, e.nextOnPolyline.point) === L.Counterclockwise ? -1 : 1;
  }
  IntersectionPointBelongsToTheInsertedEdge(t) {
    const e = t.point.sub(this.IntersectionOfTheRayAndInsertedEdge), i = t.nextOnPolyline.point.sub(this.IntersectionOfTheRayAndInsertedEdge);
    return Math.abs(e.x * i.y - i.x * e.y) < m.distanceEpsilon;
  }
  IntersectEdgeWithRayPPP(t, e, i) {
    const s = Yi.solve(e.x - t.x, -i.x, this.Pivot.x - t.x, e.y - t.y, -i.y, this.Pivot.y - t.y);
    if (!(-m.tolerance <= s.x && s.x <= 1 + m.tolerance))
      throw new Error();
    if (!s)
      throw new Error();
    return this.Pivot.add(i.mul(s.y));
  }
  IntersectEdgeWithRay(t, e) {
    return this.IntersectEdgeWithRayPPP(t.point, t.nextOnPolyline.point, e);
  }
  static constructorPP(t, e) {
    const i = new ga();
    return i.pivot = t, i.pointOnTheRay = e, i;
  }
}
class cn {
  get Start() {
    return this.start;
  }
  set Start(t) {
    this.start = t;
  }
  get End() {
    return this.end;
  }
  set End(t) {
    this.end = t;
  }
  constructor(t, e) {
    this.start = t, this.end = e;
  }
  *Sides() {
    let t = this.start;
    for (; t !== this.end; ) {
      const e = t;
      yield e, t = e.nextOnPolyline;
    }
  }
  MoveStartClockwise() {
    return this.Start !== this.End ? (this.Start = this.Start.nextOnPolyline, !0) : !1;
  }
  toString() {
    return Bt.String.format("Stem({0},{1})", this.Start, this.End);
  }
}
class Oi {
  get QVertex() {
    return this.qV;
  }
  set QVertex(t) {
    this.qV = t;
  }
  // "point" can belong to the boundary of one of the holes
  // tangent or regural visibility
  // "qVertex" : the graph vertex corresponding to the pivot
  static CalculatePointVisibilityGraph(t, e, i, s) {
    const n = e.FindVertex(i);
    if (n != null)
      return n;
    const r = new Oi(t, e, i, s);
    return r.FillGraph(), r.QVertex;
  }
  FillGraph() {
    this.ComputeHoleBoundariesPossiblyVisibleFromQ(), this.visibleBoundaries.size > 0 && (this.SortSAndInitActiveSides(), this.Sweep());
  }
  // sorts the set of potentially visible vertices around point q
  SortSAndInitActiveSides() {
    this.InitHeapAndInsertActiveSides();
    for (let t = this.heapForSorting.GetMinimum(); this.sortedListOfPolypoints.push(t.Start), t.MoveStartClockwise() ? this.heapForSorting.ChangeMinimum(t) : this.heapForSorting.Dequeue(), this.heapForSorting.Count !== 0; t = this.heapForSorting.GetMinimum())
      ;
  }
  InitHeapAndInsertActiveSides() {
    for (const t of this.GetInitialVisibleBoundaryStemsAndInsertActiveSides())
      this.heapForSorting.Enqueue(t);
  }
  // these are chuncks of the visible boundaries growing from the polyline  point just above its crossing with the horizontal ray or
  // from the visible part start
  // In the general case we have two stems from one polyline
  *GetInitialVisibleBoundaryStemsAndInsertActiveSides() {
    for (const [t, e] of this.visibleBoundaries) {
      let i = !1;
      for (const s of e.Sides()) {
        const n = s;
        if (n.point.y < this.q.y) {
          if (s.nextOnPolyline.point.y >= this.q.y) {
            const r = u.getTriangleOrientation(this.q, n.point, s.nextOnPolyline.point);
            if (r === L.Counterclockwise || r === L.Collinear) {
              i = !0, yield new cn(e.Start, s), yield new cn(s.nextOnPolyline, e.End), this.RegisterActiveSide(s);
              break;
            }
          }
        } else {
          if (n.point.y > this.q.y)
            break;
          if (s.point.x >= this.q.x) {
            i = !0, yield new cn(s, e.End), s !== e.Start && (yield new cn(e.Start, t.prev(n))), this.RegisterActiveSide(s);
            break;
          }
        }
      }
      i || (yield e);
    }
  }
  RegisterActiveSide(t) {
    this.activeEdgeComparer.IntersectionOfTheRayAndInsertedEdge = this.activeEdgeComparer.IntersectEdgeWithRay(t, new u(1, 0)), this.sideNodes.set(t, this.activeSidesTree.insert(t));
  }
  // private Polyline GetPolylineBetweenPolyPointsTest(Polyline hole, PolylinePoint p0, PolylinePoint p1) {
  //    Polyline ret = new Polyline();
  //    while (p0 !== p1) {
  //        ret.AddPoint(p0.Point);
  //        p0 = hole.Next(p0);
  //    }
  //    ret.AddPoint(p1.Point);
  //    return ret;
  // }
  constructor(t, e, i, s) {
    this.sideNodes = /* @__PURE__ */ new Map(), this.visibleBoundaries = /* @__PURE__ */ new Map(), this.sortedListOfPolypoints = new Array(), this.holes = Array.from(t), this.visibilityGraph = e, this.q = i, this.qPolylinePoint = ei.mkFromPoint(this.q), this.QVertex = this.visibilityGraph.AddVertexP(this.qPolylinePoint.point), this.visibilityKind = s;
    const n = new ks(this.q);
    this.heapForSorting = new la(n.IComparer.bind(n));
  }
  Sweep() {
    for (const t of this.sortedListOfPolypoints)
      this.SweepPolylinePoint(t);
  }
  // this code will work for convex holes
  SweepPolylinePoint(t) {
    const e = Oi.GetIncomingSide(t), i = this.GetOutgoingSide(t);
    this.activeEdgeComparer.IntersectionOfTheRayAndInsertedEdge = t.point;
    let s;
    if (s = this.sideNodes.get(e)) {
      if (s === this.activeSidesTree.treeMinimum() && this.AddEdge(t), i != null)
        s.item = i, this.sideNodes.set(i, s);
      else {
        const n = this.activeSidesTree.deleteSubTree(s);
        n != null && n.item != null && this.sideNodes.set(n.item, n);
      }
      this.sideNodes.delete(e);
    } else if (i != null) {
      let n;
      (n = this.sideNodes.get(i)) || (n = this.activeSidesTree.insert(i), this.sideNodes.set(i, n), n === this.activeSidesTree.treeMinimum() && this.AddEdge(t));
    } else
      throw new Error();
  }
  AddEdge(t) {
    (this.visibilityKind === Ti.Regular || this.visibilityKind === Ti.Tangent && Oi.LineTouchesPolygon(this.QVertex.point, t)) && this.visibilityGraph.AddEdgeF(this.QVertex.point, t.point, (e, i) => new pi(e, i));
  }
  static LineTouchesPolygon(t, e) {
    const i = e.polyline.prev(e).point, s = e.polyline.next(e).point, n = e.point;
    return u.signedDoubledTriangleArea(t, n, i) * u.signedDoubledTriangleArea(t, n, s) >= 0;
  }
  // ReSharper disable UnusedMember.Local
  /*
        DrawActiveEdgesAndVisibleGraph() {
            // ReSharper restore UnusedMember.Local
            let l = new Array<ICurve>();
            for (let pe: VisibilityEdge in this.visibilityGraph.Edges) {
                l.Add(new LineSegment(pe.SourcePoint, pe.TargetPoint));
            }
            
            for (let pe: PolylinePoint in this.activeSidesTree) {
                l.Add(new LineSegment(pe.Point, pe.NextOnPolyline.Point));
            }
            
            l.Add(new Ellipse(0.1, 0.1, this.q));
            LayoutAlgorithmSettings.Show(l.ToArray());
        }
  */
  GetOutgoingSide(t) {
    const e = this.visibleBoundaries.get(t.polyline);
    return t === e.End ? null : t;
  }
  static GetIncomingSide(t) {
    return t.prevOnPolyline;
  }
  ComputeHoleBoundariesPossiblyVisibleFromQ() {
    this.InitActiveEdgesAndActiveEdgesComparer();
    for (const t of this.holes)
      this.ComputeVisiblePartOfTheHole(t);
  }
  InitActiveEdgesAndActiveEdgesComparer() {
    this.activeEdgeComparer = new ga(), this.activeEdgeComparer.pivot = this.q, this.activeSidesTree = new Ee(this.activeEdgeComparer.Compare.bind(this.activeEdgeComparer));
  }
  ComputeVisiblePartOfTheHole(t) {
    let e, i = !0;
    for (e = t.startPoint; !this.HoleSideIsVisibleFromQ(t, e); e = t.next(e))
      i = !1;
    let s = t.next(e);
    if (i)
      for (; this.HoleSideIsVisibleFromQ(t, t.prev(e)); )
        e = t.prev(e);
    for (; this.HoleSideIsVisibleFromQ(t, s); s = t.next(s))
      ;
    this.visibleBoundaries.set(t, new cn(e, s));
  }
  HoleSideIsVisibleFromQ(t, e) {
    return u.signedDoubledTriangleArea(this.q, e.point, t.next(e).point) >= -m.squareOfDistanceEpsilon;
  }
}
class tt extends lt {
  constructor() {
    super(...arguments), this.IgnoreTightPadding = !0, this.activeRectangle = T.mkEmpty(), this.activePolygons = new Array(), this.alreadyAddedOrExcludedPolylines = /* @__PURE__ */ new Set(), this.UseEdgeLengthMultiplier = !1, this.UseInnerPolylingShortcutting = !0, this.UsePolylineEndShortcutting = !0, this.AllowedShootingStraightLines = !0, this.LookForRoundedVertices = !1;
  }
  rerouteEdge(t) {
    const e = t.smoothedPolyline ? B.mkFromPoints(t.smoothedPolyline) : B.mkFromPoints(t.getSmoothPolyPoints());
    this.pathOptimizer.run(e), t.curve = this.pathOptimizer.poly.toCurve();
  }
  static constructorANNN(t, e, i, s) {
    return tt.constructorANNNB(t, e, i, s, !1);
  }
  get Obstacles() {
    return this.obstacles_;
  }
  set Obstacles(t) {
    this.obstacles_ = t;
  }
  get EnteringAngleBound() {
    return this.enteringAngleBound_;
  }
  set EnteringAngleBound(t) {
    this.enteringAngleBound_ = t;
  }
  get SourceTightPolyline() {
    return this._sourceTightPolyline;
  }
  set SourceTightPolyline(t) {
    this._sourceTightPolyline = t;
  }
  get TargetTightPolyline() {
    return this.targetTightPolyline;
  }
  set TargetTightPolyline(t) {
    this.targetTightPolyline = t;
  }
  get TargetLoosePolyline() {
    return this.targetLoosePolyline;
  }
  set TargetLoosePolyline(t) {
    this.targetLoosePolyline = t;
  }
  get VisibilityGraph() {
    return this.visibilityGraph;
  }
  set VisibilityGraph(t) {
    this.visibilityGraph = t;
  }
  // the port of the edge start
  get SourcePort() {
    return this.sourcePort;
  }
  set SourcePort(t) {
    if (this.sourcePort = t, this.sourcePort != null)
      if (this.SourceTightPolyline = tt.GetFirstHitPolyline(this.sourcePort.Location, this.ObstacleCalculator.RootOfTightHierarchy), this.sourcePort instanceof Te)
        this.alreadyAddedOrExcludedPolylines.add(this.SourceLoosePolyline), this.StartPointOfEdgeRouting = this.SourcePort.Location;
      else {
        const e = this.sourcePort;
        this.StartPointOfEdgeRouting = this.TakeBoundaryPortOutsideOfItsLoosePolyline(e.Curve, e.Parameter, this.SourceLoosePolyline);
      }
  }
  // the port of the edge end
  get TargetPort() {
    return this.targetPort;
  }
  set TargetPort(t) {
    this.targetPort = t;
  }
  // we further pad each node but not more than LoosePadding.
  get LoosePadding() {
    return this.loosePadding;
  }
  set LoosePadding(t) {
    this.loosePadding = t, this.ObstacleCalculator != null && (this.ObstacleCalculator.LoosePadding = t);
  }
  get OffsetForPolylineRelaxing() {
    return this.TightPadding * 0.75;
  }
  get StartPointOfEdgeRouting() {
    return this.startPointOfRouting_;
  }
  set StartPointOfEdgeRouting(t) {
    this.startPointOfRouting_ = t;
  }
  ExtendVisibilityGraphToLocation(t) {
    this.VisibilityGraph == null && (this.VisibilityGraph = new Et());
    let e = null;
    if (!this.activeRectangle.contains(t)) {
      this.activeRectangle.isEmpty ? this.activeRectangle = T.mkPP(this.SourcePort.Location, t) : this.activeRectangle.add(t), e = this.GetAddedPolygonesAndMaybeExtendActiveRectangle();
      for (const i of e)
        this.VisibilityGraph.AddHole(i.Polyline);
    }
    e == null || e.length === 0 ? (this.targetVV != null && this.VisibilityGraph.RemoveVertex(this.targetVV), this.CalculateEdgeTargetVisibilityGraph(t)) : (this.RemovePointVisibilityGraphs(), new Hi(e, this.activePolygons, this.VisibilityGraph).run(), Vi(this.activePolygons, e), this.CalculateEdgeTargetVisibilityGraph(t), this.CalculateSourcePortVisibilityGraph());
  }
  RemovePointVisibilityGraphs() {
    this.targetVV != null && this.VisibilityGraph.RemoveVertex(this.targetVV), this.sourceVV != null && this.VisibilityGraph.RemoveVertex(this.sourceVV);
  }
  CalculateEdgeTargetVisibilityGraph(t) {
    this.targetVV = Oi.CalculatePointVisibilityGraph(Array.from(this.GetActivePolylines()), this.VisibilityGraph, t, Ti.Tangent);
  }
  CalculateSourcePortVisibilityGraph() {
    this.sourceVV = Oi.CalculatePointVisibilityGraph(Array.from(this.GetActivePolylines()), this.VisibilityGraph, this.StartPointOfEdgeRouting, Ti.Tangent);
  }
  TakeBoundaryPortOutsideOfItsLoosePolyline(t, e, i) {
    const s = t.value(e);
    let n = t.leftDerivative(e).normalize().add(t.rightDerivative(e).normalize()).normalize();
    u.getTriangleOrientation(tt.PointInsideOfConvexCurve(t), s, s.add(n)) == L.Counterclockwise && (n = n.mul(-1)), n = n.rotate(Math.PI / 2);
    const r = i.boundingBox.diagonal;
    let a = v.mkPP(s, s.add(n.mul(r)));
    const l = g.intersectionOne(a, i, !1).x;
    let h = n.mul(l.sub(s).length / 2);
    for (; ; ) {
      a = v.mkPP(s, l.add(h));
      let c = !1;
      for (const d of tt.IntersectionsOfLineAndRectangleNodeOverPolylineLR(a, this.ObstacleCalculator.RootOfLooseHierarchy))
        if (d.seg1 !== i) {
          h = h.div(1.5), c = !0;
          break;
        }
      if (!c)
        break;
    }
    return a.end;
  }
  static PointInsideOfConvexCurve(t) {
    return t.value(0).add(t.value(1.5)).div(2);
  }
  // Point TakeSourcePortOutsideOfLoosePolyline() {
  //    CurvePort bp = SourcePort as CurvePort;
  //    ICurve nodeBoundary = bp.Node.BoundaryCurve;
  //    Point location = bp.Location;
  //    Point tangent = (nodeBoundary.LeftDerivative(bp.Parameter).Normalize() + nodeBoundary.RightDerivative(bp.Parameter).Normalize()).Normalize();
  //    if (Point.GetTriangleOrientation(bp.Node.Center, location, location + tangent) === TriangleOrientation.Counterclockwise)
  //        tangent = -tangent;
  //    tangent = tangent.Rotate(Math.PI / 2);
  //    Number len = this.sourceLoosePolyline.BoundingBox.Diagonal;
  //    Point portLocation = bp.Location;
  //    LineSegment ls = LineSegment.mkPP(portLocation, portLocation + len * tangent);
  //    Point p = Curve.GetAllIntersections(ls, this.SourceLoosePolyline, false)[0].x;
  //    Point del = tangent * this.OffsetForPolylineRelaxing * 2;
  //    while (true) {
  //        ls = LineSegment.mkPP(portLocation, p + del);
  //        bool foundIntersectionsOutsideOfSource = false;
  //        foreach (IntersectionInfo ii in IntersectionsOfLineAndRectangleNodeOverPolyline(ls, this.obstacleCalculator.RootOfLooseHierarchy))
  //            if (ii.seg1 !== this.SourceLoosePolyline) {
  //                del /= 1.5;
  //                foundIntersectionsOutsideOfSource = true;
  //                break;
  //            }
  //        if (!foundIntersectionsOutsideOfSource)
  //            break;
  //    }
  //    return ls.End;
  // }
  *GetActivePolylines() {
    for (const t of this.activePolygons)
      yield t.Polyline;
  }
  GetAddedPolygonesAndMaybeExtendActiveRectangle() {
    const t = this.activeRectangle, e = new Array();
    let i;
    do {
      i = !1;
      for (const s of this.ObstacleCalculator.RootOfLooseHierarchy.GetNodeItemsIntersectingRectangle(this.activeRectangle))
        this.alreadyAddedOrExcludedPolylines.has(s) || (t.addRec(s.boundingBox), e.push(new ue(s)), this.alreadyAddedOrExcludedPolylines.add(s), i = !0);
      i && (this.activeRectangle = t);
    } while (i);
    return e;
  }
  PolylineSegmentIntersectsTightHierarchy(t, e) {
    return this.PolylineIntersectsPolyRectangleNodeOfTightHierarchyPPR(t, e, this.ObstacleCalculator.RootOfTightHierarchy);
  }
  PolylineIntersectsPolyRectangleNodeOfTightHierarchyPPR(t, e, i) {
    return this.PolylineIntersectsPolyRectangleNodeOfTightHierarchy(v.mkPP(t, e), i);
  }
  PolylineIntersectsPolyRectangleNodeOfTightHierarchy(t, e) {
    if (!t.boundingBox.intersects(e.irect))
      return !1;
    if (e.UserData != null) {
      for (const i of g.getAllIntersections(t, e.UserData, !1))
        if (i.seg1 !== this.SourceTightPolyline && i.seg1 !== this.TargetTightPolyline || (i.seg1 === this.SourceTightPolyline && this.SourcePort) instanceof Oe || (i.seg1 === this.TargetTightPolyline && this.TargetPort) instanceof Oe)
          return !0;
      return !1;
    }
    return this.PolylineIntersectsPolyRectangleNodeOfTightHierarchy(t, e.Left) || this.PolylineIntersectsPolyRectangleNodeOfTightHierarchy(t, e.Right);
  }
  static IntersectionsOfLineAndRectangleNodeOverPolylineLR(t, e) {
    const i = new Array();
    return tt.IntersectionsOfLineAndRectangleNodeOverPolyline(t, e, i), i;
  }
  static IntersectionsOfLineAndRectangleNodeOverPolyline(t, e, i) {
    if (e != null && t.boundingBox.intersects(e.irect)) {
      if (e.UserData != null) {
        Vi(i, g.getAllIntersections(t, e.UserData, !0));
        return;
      }
      tt.IntersectionsOfLineAndRectangleNodeOverPolyline(t, e.Left, i), tt.IntersectionsOfLineAndRectangleNodeOverPolyline(t, e.Right, i);
    }
  }
  LineCanBeAcceptedForRouting(t) {
    const e = this.SourcePort instanceof Te, i = this.TargetPort instanceof Te;
    if (!e && !this.targetIsInsideOfSourceTightPolyline && !this.InsideOfTheAllowedConeOfBoundaryPort(t.end, this.SourcePort) || !i && this.TargetPort != null && !this.sourceIsInsideOfTargetTightPolyline && !this.InsideOfTheAllowedConeOfBoundaryPort(t.start, this.TargetPort))
      return !1;
    const s = tt.IntersectionsOfLineAndRectangleNodeOverPolylineLR(t, this.ObstacleCalculator.RootOfTightHierarchy);
    for (const n of s)
      if (n.seg1 !== this.SourceTightPolyline && n.seg1 !== this.targetTightPolyline)
        return !1;
    return !0;
  }
  InsideOfTheAllowedConeOfBoundaryPort(t, e) {
    const i = e.Curve, s = M.CurveIsClockwise(i, tt.PointInsideOfConvexCurve(i)), n = e.Location, r = this.GetPointOnTheRightBoundaryPortConeSide(n, i, s, e.Parameter), a = this.GetPointOnTheLeftBoundaryPortConeSide(n, i, s, e.Parameter);
    return u.getTriangleOrientation(n, r, t) !== L.Clockwise && u.getTriangleOrientation(n, t, a) !== L.Clockwise;
  }
  GetPointOnTheRightBoundaryPortConeSide(t, e, i, s) {
    const n = i ? e.rightDerivative(s) : e.leftDerivative(s).neg();
    return t.add(n.rotate(this.EnteringAngleBound));
  }
  GetPointOnTheLeftBoundaryPortConeSide(t, e, i, s) {
    const n = i ? e.leftDerivative(s).neg() : e.rightDerivative(s);
    return t.add(n.rotate(-this.EnteringAngleBound));
  }
  // ShowPolylineAndObstacles(params curves: ICurve[]) {
  //    //  ReSharper restore UnusedMember.Local
  //    let ls: Array<DebugCurve> = this.GetDebugCurves(curves);
  //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(ls);
  // }
  // GetDebugCurves(params curves: ICurve[]): Array<DebugCurve> {
  //    let ls = this.CreateListWithObstaclesAndPolyline(curves);
  //    // ls.AddRange(this.VisibilityGraph.Edges.Select(e => new DebugCurve(100,0.1, e is TollFreeVisibilityEdge?"red":"green", LineSegment.mkPP(e.SourcePoint, e.TargetPoint))));
  //    if ((this._sourceVisibilityVertex != null)) {
  //        ls.Add(new DebugCurve("red", CurveFactory.CreateDiamond(4, 4, this._sourceVisibilityVertex.point)));
  //    }
  //    if ((this.targetVisibilityVertex != null)) {
  //        ls.Add(new DebugCurve("purple", new Ellipse(4, 4, this.targetVisibilityVertex.Point)));
  //    }
  //    let anywerePort = (<HookUpAnywhereFromInsidePort>(this.targetPort));
  //    if ((anywerePort != null)) {
  //        ls.Add(new DebugCurve("purple", anywerePort.LoosePolyline));
  //    }
  //    return ls;
  // }
  // CreateListWithObstaclesAndPolyline(params curves: ICurve[]): Array<DebugCurve> {
  //    let ls = new Array<DebugCurve>(this.ObstacleCalculator.RootOfLooseHierarchy.GetAllLeaves().select(() => {  }, new DebugCurve(100, 0.01, "green", e)));
  //    ls.AddRange(curves.Select(() => {  }, new DebugCurve(100, 0.01, "red", c)));
  //    ls.AddRange(this.ObstacleCalculator.RootOfTightHierarchy.GetAllLeaves().select(() => {  }, new DebugCurve(100, 0.01, "blue", e)));
  //    //  ls.AddRange(visibilityGraph.Edges.Select(e => (ICurve) LineSegment.mkPP(e.SourcePoint, e.TargetPoint)));
  //    if ((this._polyline != null)) {
  //        ls.Add(new DebugCurve(100, 0.03, "blue", this._polyline));
  //    }
  //    return ls;
  // }
  // smoothing the corners of the polyline
  SmoothenCorners(t) {
    let e = t.headSite, i = { b: null, c: null };
    for (; i = g.findCorner(e); )
      e = this.SmoothOneCorner(e, i.c, i.b);
  }
  SmoothOneCorner(t, e, i) {
    let r = 0.5, a, l, h;
    t.prev == null ? (h = 2, l = 1) : e.next == null ? (h = 1, l = 2) : h = l = 1;
    do
      a = g.createBezierSeg(r * h, r * l, t, i, e), i.previouisBezierCoefficient = r * h, i.nextBezierCoefficient = r * l, r /= 1.5;
    while (c() > this.loosePadding && r > 0.01);
    return r *= 1.5, r < 0.5 && r > 0.01 && (r = 0.5 * (r + r * 1.5), a = g.createBezierSeg(r * h, r * l, t, i, e), c() > this.loosePadding && (i.previouisBezierCoefficient = r * h, i.nextBezierCoefficient = r * l)), i;
    function c() {
      const d = a.closestParameter(i.point);
      return i.point.sub(a.value(d)).length;
    }
  }
  TryToRemoveInflectionsAndCollinearSegments(t) {
    let e = !0;
    const i = { s: null };
    for (; e; )
      for (e = !1, i.s = t.headSite; i.s != null && i.s.next != null; i.s = i.s.next)
        i.s.turn * i.s.next.turn < 0 && (e = this.TryToRemoveInflectionEdge(i) || e);
  }
  TryToRemoveInflectionEdge(t) {
    if (!this.ObstacleCalculator.ObstaclesIntersectLine(t.s.prev.point, t.s.next.point)) {
      const e = t.s.prev, i = t.s.next;
      return e.next = i, i.prev = e, t.s = e, !0;
    }
    if (!this.ObstacleCalculator.ObstaclesIntersectLine(t.s.prev.point, t.s.next.next.point)) {
      const e = t.s.prev, i = t.s.next.next;
      return e.next = i, i.prev = e, t.s = e, !0;
    }
    if (!this.ObstacleCalculator.ObstaclesIntersectLine(t.s.point, t.s.next.next.point)) {
      const e = t.s.next.next;
      return t.s.next = e, e.prev = t.s, !0;
    }
    return !1;
  }
  // internal Point TargetPoint {
  //    get {
  //        CurvePort tp = this.TargetPort as CurvePort;
  //        if (tp != null)
  //            return this.Target.BoundaryCurve[tp.Parameter];
  //        else
  //            return (this.TargetPort as FloatingPort).Location;
  //    }
  // }
  // internal Point SourcePoint {
  //    get {
  //        CurvePort sp = this.SourcePort as CurvePort;
  //        if (sp != null)
  //            return this.Source.BoundaryCurve[sp.Parameter];
  //        else
  //            return (this.SourcePort as FloatingPort).Location;
  //    }
  // }
  GetShortestPolyline(t, e) {
    this.CleanTheGraphForShortestPath();
    const s = new Mr(this.visibilityGraph, t, e).GetPath(this.UseEdgeLengthMultiplier);
    if (s == null)
      return null;
    let n = B.mkFromPoints(Array.from(s).map((r) => r.point)).RemoveCollinearVertices();
    return this.pathOptimizer && (this.pathOptimizer.run(n), n = this.pathOptimizer.poly), n;
  }
  // private ShowIsPassable(sourceVisVertex: VisibilityVertex, targetVisVertex: VisibilityVertex) {
  //    let dd = new Array<DebugCurve>(this.visibilityGraph.Edges.Select(() => {  }, new DebugCurve(100, 0.5, "green", LineSegment.mkPP(e.SourcePoint, e.TargetPoint))));
  //    // TODO: Warning!!!, inline IF is not supported ?
  //    ((e.IsPassable == null )
  //                || e.IsPassable());
  //    "red";
  //    if ((sourceVisVertex != null)) {
  //        dd.Add(new DebugCurve(CurveFactory.CreateDiamond(3, 3, sourceVisVertex.point)));
  //    }
  //    if ((targetVisVertex != null)) {
  //        dd.Add(new DebugCurve(CurveFactory.CreateEllipse(3, 3, targetVisVertex.point)));
  //    }
  //    if ((this.Obstacles != null)) {
  //        dd.AddRange(this.Obstacles.Select(() => {  }, new DebugCurve(o)));
  //    }
  //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(dd);
  // }
  CleanTheGraphForShortestPath() {
    this.visibilityGraph.ClearPrevEdgesTable();
  }
  // returns true if the nodes overlap or just positioned too close
  get OverlapsDetected() {
    return this.ObstacleCalculator.OverlapsDetected;
  }
  get TightHierarchy() {
    return this.ObstacleCalculator.RootOfTightHierarchy;
  }
  set TightHierarchy(t) {
    this.ObstacleCalculator.RootOfTightHierarchy = t;
  }
  get LooseHierarchy() {
    return this.ObstacleCalculator.RootOfLooseHierarchy;
  }
  set LooseHierarchy(t) {
    this.ObstacleCalculator.RootOfLooseHierarchy = t;
  }
  CalculateObstacles() {
    this.ObstacleCalculator = new M(this.Obstacles, this.TightPadding, this.LoosePadding, this.IgnoreTightPadding), this.ObstacleCalculator.Calculate();
  }
  static constructorANNNB(t, e, i, s, n) {
    const r = new tt(null);
    return r.IgnoreTightPadding = n, r.EnteringAngleBound = 80 * (Math.PI / 180), r.TightPadding = e, r.LoosePadding = i, s > 0 ? (at.assert(s > Math.PI / 180), at.assert(s <= 90 * (Math.PI / 180)), r.UseSpanner = !0, r.ExpectedProgressSteps = qs.GetTotalSteps(s)) : r.ExpectedProgressSteps = t.length, r.ConeSpannerAngle = s, r.Obstacles = t, r.CalculateObstacles(), r;
  }
  RouteEdgeToLocation(t) {
    this.TargetPort = new Te(null, t), this.TargetTightPolyline = null, this.TargetLoosePolyline = null;
    const e = new Zt(null);
    let i = v.mkPP(this.SourcePort.Location, t);
    if (this.LineCanBeAcceptedForRouting(i)) {
      this._polyline = new B(), this._polyline.addPoint(i.start), this._polyline.addPoint(i.end);
      const s = Tt.mkFromPoints(this._polyline);
      return e.curve = s.createCurve(), e;
    }
    return this.SourcePort instanceof Oe && (i = v.mkPP(this.StartPointOfEdgeRouting, t), tt.IntersectionsOfLineAndRectangleNodeOverPolylineLR(i, this.ObstacleCalculator.RootOfTightHierarchy).length == 0) ? (this._polyline = new B(), this._polyline.addPoint(this.SourcePort.Location), this._polyline.addPoint(i.start), this._polyline.addPoint(i.end), e.curve = Tt.mkFromPoints(this._polyline).createCurve(), e) : (this.ExtendVisibilityGraphToLocation(t), this._polyline = this.GetShortestPolyline(this.sourceVV, this.targetVV), this.SourcePort instanceof Oe && this._polyline.PrependPoint(this.SourcePort.Location), e.curve = Tt.mkFromPoints(this._polyline).createCurve(), e);
  }
  // routes the edge to the port
  //
  RouteEdgeToPort(t, e, i, s) {
    return this.ObstacleCalculator.IsEmpty() ? this.sourcePort != null && this.targetPort != null ? (s.smoothedPolyline = this.SmoothedPolylineFromTwoPoints(this.sourcePort.Location, this.targetPort.Location), v.mkPP(this.sourcePort.Location, this.targetPort.Location)) : null : (this.TargetPort = t, this.TargetTightPolyline = tt.GetFirstHitPolyline(t.Location, this.ObstacleCalculator.RootOfTightHierarchy), t instanceof Oe ? this.RouteEdgeToBoundaryPort(e, i, s) : this.RouteEdgeToFloatingPortOfNode(e, i, s));
  }
  SmoothedPolylineFromTwoPoints(t, e) {
    return this._polyline = new B(), this._polyline.addPoint(t), this._polyline.addPoint(e), Tt.mkFromPoints(this._polyline);
  }
  RouteEdgeToFloatingPortOfNode(t, e, i) {
    return this.sourcePort instanceof Te ? this.RouteFromFloatingPortToFloatingPort(t, e, i) : this.RouteFromBoundaryPortToFloatingPort(t, e, i);
  }
  RouteFromBoundaryPortToFloatingPort(t, e, i) {
    const s = this.SourcePort.Location, n = this.targetPort.Location;
    let r = v.mkPP(s, n);
    if (this.LineCanBeAcceptedForRouting(r))
      return i.smoothedPolyline = this.SmoothedPolylineFromTwoPoints(r.start, r.end), r;
    if (!this.targetIsInsideOfSourceTightPolyline) {
      const l = this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.SourcePort.Curve, this.SourcePort.Parameter, this.SourceLoosePolyline);
      if (r = v.mkPP(l, n), this.LineAvoidsTightHierarchyLP(r, t))
        return i.smoothedPolyline = this.SmoothedPolylineFromTwoPoints(r.start, r.end), r;
    }
    this.ExtendVisibilityGraphToLocationOfTargetFloatingPort(t), this._polyline = this.GetShortestPolyline(this.sourceVV, this.targetVV);
    const a = this.SourceTightPolyline;
    return this.targetIsInsideOfSourceTightPolyline || (this.SourceTightPolyline = null), this.SourceTightPolyline = a, this._polyline.PrependPoint(s), this.SmoothCornersAndReturnCurve(e, i);
  }
  SmoothCornersAndReturnCurve(t, e) {
    return e.smoothedPolyline = Tt.mkFromPoints(this._polyline), t && this.SmoothenCorners(e.smoothedPolyline), e.smoothedPolyline.createCurve();
  }
  RouteFromFloatingPortToFloatingPort(t, e, i) {
    return this.ExtendVisibilityGraphToLocationOfTargetFloatingPort(t), this._polyline = this.GetShortestPolyline(this.sourceVV, this.targetVV), this._polyline == null ? null : (i.smoothedPolyline = Tt.mkFromPoints(this._polyline), this.SmoothCornersAndReturnCurve(e, i));
  }
  TryShortcutPolyPoint(t) {
    return this.LineAvoidsTightHierarchyLPP(v.mkPP(t.point, t.next.next.point), this.SourceTightPolyline, this.targetTightPolyline) ? (t.next = t.next.next, t.next.prev = t, !0) : !1;
  }
  ExtendVisibilityGraphToLocationOfTargetFloatingPort(t) {
    this.VisibilityGraph == null && (this.VisibilityGraph = new Et());
    let e = null;
    const i = this.targetPort.Location;
    if (!this.activeRectangle.contains(i)) {
      this.activeRectangle.isEmpty ? this.activeRectangle = T.mkPP(this.SourcePort.Location, i) : this.activeRectangle.add(i), e = this.GetAddedPolygonesAndMaybeExtendActiveRectangle();
      for (const s of e)
        this.VisibilityGraph.AddHole(s.Polyline);
    }
    e == null ? (this.targetVV != null && this.VisibilityGraph.RemoveVertex(this.targetVV), this.CalculateEdgeTargetVisibilityGraphForFloatingPort(i, t), this.sourceVV == null && this.CalculateSourcePortVisibilityGraph()) : (this.RemovePointVisibilityGraphs(), new Hi(e, this.activePolygons, this.VisibilityGraph).run(), Vi(this.activePolygons, e), this.CalculateEdgeTargetVisibilityGraphForFloatingPort(i, t), this.CalculateSourcePortVisibilityGraph());
  }
  CalculateEdgeTargetVisibilityGraphForFloatingPort(t, e) {
    this.UseSpanner ? this.targetVV = this.AddTransientVisibilityEdgesForPort(t, e) : this.targetVV = Oi.CalculatePointVisibilityGraph(this.GetActivePolylinesWithException(e), this.VisibilityGraph, t, Ti.Tangent);
  }
  AddTransientVisibilityEdgesForPort(t, e) {
    let i = this.GetVertex(t);
    if (i != null)
      return i;
    if (i = this.visibilityGraph.AddVertexP(t), e != null)
      for (const s of e)
        this.visibilityGraph.AddEdgeF(t, s, (n, r) => new pi(n, r));
    else
      i = Oi.CalculatePointVisibilityGraph(this.GetActivePolylines(), this.VisibilityGraph, t, Ti.Tangent);
    return i;
  }
  GetVertex(t) {
    let e = this.visibilityGraph.FindVertex(t);
    return e == null && this.LookForRoundedVertices && (e = this.visibilityGraph.FindVertex(u.RoundPoint(t))), e;
  }
  *GetActivePolylinesWithException(t) {
    for (const e of this.activePolygons)
      e.Polyline !== t && (yield e.Polyline);
  }
  RouteEdgeToBoundaryPort(t, e, i) {
    return this.TargetLoosePolyline = t, this.sourcePort instanceof Te ? this.RouteFromFloatingPortToBoundaryPort(e, i) : this.RouteFromBoundaryPortToBoundaryPort(e, i);
  }
  RouteFromBoundaryPortToBoundaryPort(t, e) {
    const i = this.SourcePort.Location;
    let s;
    const n = this.targetPort.Location;
    let r = v.mkPP(i, n);
    if (this.LineCanBeAcceptedForRouting(r))
      this._polyline = new B(), this._polyline.addPoint(r.start), this._polyline.addPoint(r.end), e.smoothedPolyline = this.SmoothedPolylineFromTwoPoints(r.start, r.end), s = Tt.mkFromPoints(this._polyline).createCurve();
    else {
      const a = this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.targetPort.Curve, this.targetPort.Parameter, this.TargetLoosePolyline);
      if (r = v.mkPP(i, a), this.InsideOfTheAllowedConeOfBoundaryPort(a, this.SourcePort) && this.LineAvoidsTightHierarchyLP(r, this._sourceTightPolyline))
        this._polyline = new B(), this._polyline.addPoint(r.start), this._polyline.addPoint(r.end), this._polyline.addPoint(n), s = this.SmoothCornersAndReturnCurve(t, e);
      else if (r = v.mkPP(this.StartPointOfEdgeRouting, n), this.InsideOfTheAllowedConeOfBoundaryPort(this.StartPointOfEdgeRouting, this.TargetPort) && this.LineAvoidsTightHierarchy(r))
        this._polyline = new B(), this._polyline.addPoint(i), this._polyline.addPoint(r.start), this._polyline.addPoint(r.end), s = this.SmoothCornersAndReturnCurve(t, e);
      else {
        let l;
        if (l = v.IntersectPPPP(i, this.StartPointOfEdgeRouting, n, a))
          this._polyline = new B(), this._polyline.addPoint(i), this._polyline.addPoint(l), this._polyline.addPoint(n), s = this.SmoothCornersAndReturnCurve(t, e);
        else if (u.closeDistEps(this.StartPointOfEdgeRouting, a))
          this._polyline = new B(), this._polyline.addPoint(i), this._polyline.addPoint(a), this._polyline.addPoint(n), s = this.SmoothCornersAndReturnCurve(t, e);
        else if (this.LineAvoidsTightHierarchy(v.mkPP(this.StartPointOfEdgeRouting, a)))
          this._polyline = new B(), this._polyline.addPoint(i), this._polyline.addPoint(this.StartPointOfEdgeRouting), this._polyline.addPoint(a), this._polyline.addPoint(n), s = this.SmoothCornersAndReturnCurve(t, e);
        else {
          this.ExtendVisibilityGraphToTargetBoundaryPort(a), this._polyline = this.GetShortestPolyline(this.sourceVV, this.targetVV);
          const h = { tmpTargetTight: null }, c = this.HideSourceTargetTightsIfNeeded(h);
          this.RecoverSourceTargetTights(c, h.tmpTargetTight), this._polyline.PrependPoint(i), this._polyline.addPoint(n), s = this.SmoothCornersAndReturnCurve(t, e);
        }
      }
    }
    return s;
  }
  RecoverSourceTargetTights(t, e) {
    this.SourceTightPolyline = t, this.TargetTightPolyline = e;
  }
  HideSourceTargetTightsIfNeeded(t) {
    const e = this.SourceTightPolyline;
    return t.tmpTargetTight = this.TargetTightPolyline, this.TargetTightPolyline = null, this.SourceTightPolyline = null, e;
  }
  LineAvoidsTightHierarchy(t) {
    return tt.IntersectionsOfLineAndRectangleNodeOverPolylineLR(t, this.ObstacleCalculator.RootOfTightHierarchy).length === 0;
  }
  RouteFromFloatingPortToBoundaryPort(t, e) {
    const i = this.targetPort.Location;
    let s;
    if (this.InsideOfTheAllowedConeOfBoundaryPort(this.sourcePort.Location, this.targetPort) && (s = v.mkPP(this.SourcePort.Location, i), this.LineCanBeAcceptedForRouting(s)))
      return e.smoothedPolyline = this.SmoothedPolylineFromTwoPoints(s.start, s.end), s;
    const n = this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.TargetPort.Curve, this.TargetPort.Parameter, this.TargetLoosePolyline);
    if (s = v.mkPP(this.SourcePort.Location, n), this.LineAvoidsTightHierarchyLP(s, this._sourceTightPolyline))
      return this._polyline = B.mkFromPoints([s.start, s.end, i]), e.smoothedPolyline = Tt.mkFromPoints(this._polyline), e.smoothedPolyline.createCurve();
    this.ExtendVisibilityGraphToTargetBoundaryPort(n), this._polyline = this.GetShortestPolyline(this.sourceVV, this.targetVV), this._polyline.addPoint(i);
    const r = { smoothedPolyline: null };
    return this.SmoothCornersAndReturnCurve(t, r);
  }
  LineAvoidsTightHierarchyLP(t, e) {
    let i = !0;
    for (const s of tt.IntersectionsOfLineAndRectangleNodeOverPolylineLR(t, this.ObstacleCalculator.RootOfTightHierarchy))
      if (s.seg1 !== e) {
        i = !1;
        break;
      }
    return i;
  }
  LineAvoidsTightHierarchyLPP(t, e, i) {
    let s = !0;
    for (const n of tt.IntersectionsOfLineAndRectangleNodeOverPolylineLR(t, this.ObstacleCalculator.RootOfTightHierarchy))
      if (!(n.seg1 === e || n.seg1 === i)) {
        s = !1;
        break;
      }
    return s;
  }
  LineAvoidsTightHierarchyPPPP(t, e, i, s) {
    return this.LineAvoidsTightHierarchyLPP(v.mkPP(t, e), i, s);
  }
  ExtendVisibilityGraphToTargetBoundaryPort(t) {
    let e = null;
    if (this.VisibilityGraph == null && (this.VisibilityGraph = new Et()), !this.activeRectangle.contains(t) || !this.activeRectangle.containsRect(this.TargetLoosePolyline.boundingBox)) {
      this.activeRectangle.isEmpty ? (this.activeRectangle = this.TargetLoosePolyline.boundingBox.clone(), this.activeRectangle.add(this.SourcePort.Location), this.activeRectangle.add(this.StartPointOfEdgeRouting), this.activeRectangle.add(t)) : (this.activeRectangle.add(t), this.activeRectangle.addRec(this.TargetLoosePolyline.boundingBox)), e = this.GetAddedPolygonesAndMaybeExtendActiveRectangle();
      for (const i of e)
        this.VisibilityGraph.AddHole(i.Polyline);
    }
    e == null ? (this.targetVV != null && this.VisibilityGraph.RemoveVertex(this.targetVV), this.CalculateEdgeTargetVisibilityGraph(t)) : (this.RemovePointVisibilityGraphs(), new Hi(e, this.activePolygons, this.VisibilityGraph).run(), Vi(this.activePolygons, e), this.CalculateEdgeTargetVisibilityGraph(t), this.CalculateSourcePortVisibilityGraph());
  }
  // returns the hit object
  GetHitLoosePolyline(t) {
    return this.ObstacleCalculator.IsEmpty() || this.ObstacleCalculator.RootOfLooseHierarchy == null ? null : tt.GetFirstHitPolyline(t, this.ObstacleCalculator.RootOfLooseHierarchy);
  }
  static GetFirstHitPolyline(t, e) {
    const i = tt.GetFirstHitRectangleNode(t, e);
    return i ? i.UserData : null;
  }
  static GetFirstHitRectangleNode(t, e) {
    return e == null ? null : e.FirstHitNodeWithPredicate(t, (i, s) => g.PointRelativeToCurveLocation(i, s) !== F.Outside ? ot.Stop : ot.Continue);
  }
  //
  Clean() {
    this.TargetPort = null, this.SourcePort = null, this.SourceTightPolyline = null, this.SourceLoosePolyline = null, this.TargetLoosePolyline = null, this.targetTightPolyline = null, this.VisibilityGraph = null, this.targetVV = null, this.sourceVV = null, this.activePolygons = [], this.alreadyAddedOrExcludedPolylines.clear(), this.activeRectangle.setToEmpty();
  }
  // setting source port and the loose polyline of the port
  SetSourcePortAndSourceLoosePolyline(t, e) {
    this.SourceLoosePolyline = e, this.sourcePort = t, this.sourcePort != null && (this.SourceTightPolyline = tt.GetFirstHitPolyline(this.sourcePort.Location, this.ObstacleCalculator.RootOfTightHierarchy), this.sourcePort instanceof Te ? (this.alreadyAddedOrExcludedPolylines.add(this.SourceLoosePolyline), this.StartPointOfEdgeRouting = this.SourcePort.Location) : this.StartPointOfEdgeRouting = this.TakeBoundaryPortOutsideOfItsLoosePolyline(this.SourcePort.Curve, this.sourcePort.Parameter, this.SourceLoosePolyline));
  }
  run() {
    this.CalculateWholeTangentVisibilityGraph();
  }
  CalculateWholeTangentVisibilityGraph() {
    this.VisibilityGraph = new Et(), this.CalculateWholeVisibilityGraphOnExistingGraph();
  }
  CalculateWholeVisibilityGraphOnExistingGraph() {
    this.activePolygons = Array.from(this.AllPolygons());
    for (const e of this.ObstacleCalculator.LooseObstacles)
      this.VisibilityGraph.AddHole(e);
    let t;
    this.UseSpanner ? t = new qs(this.ObstacleCalculator.LooseObstacles, this.VisibilityGraph) : t = new Hi(new Array(), this.activePolygons, this.visibilityGraph), t.run();
  }
  RouteSplineFromPortToPortWhenTheWholeGraphIsReady(t, e, i, s) {
    const n = t instanceof Te && e instanceof Oe || t instanceof ee;
    if (n) {
      const a = t;
      t = e, e = a;
    }
    this.sourcePort = t, this.targetPort = e, this.FigureOutSourceTargetPolylinesAndActiveRectangle();
    let r = this.GetEdgeGeomByRouting(i, s);
    return r == null ? null : (this.targetVV = null, this.sourceVV = null, n && (r = r.reverse()), r);
  }
  GetEdgeGeomByRouting(t, e) {
    this.sourceIsInsideOfTargetTightPolyline = this.TargetTightPolyline == null || g.PointRelativeToCurveLocation(this.sourcePort.Location, this.TargetTightPolyline) === F.Inside;
    let i;
    if (this.sourcePort instanceof Oe) {
      const s = this.sourcePort;
      this.StartPointOfEdgeRouting = this.targetIsInsideOfSourceTightPolyline ? s.Location : this.TakeBoundaryPortOutsideOfItsLoosePolyline(s.Curve, s.Parameter, this.SourceLoosePolyline), this.CalculateSourcePortVisibilityGraph();
      const n = { smoothedPolyline: null };
      this.targetPort instanceof Oe ? i = this.RouteFromBoundaryPortToBoundaryPort(t, n) : i = this.RouteFromBoundaryPortToFloatingPort(this.targetLoosePolyline, t, n);
    } else this.targetPort instanceof Te ? (this.ExtendVisibilityGraphFromFloatingSourcePort(), i = this.RouteFromFloatingPortToFloatingPort(this.targetLoosePolyline, t, e)) : i = this.RouteFromFloatingPortToAnywherePort(this.targetPort.LoosePolyline, t, e, this.targetPort);
    return i;
  }
  RouteFromFloatingPortToAnywherePort(t, e, i, s) {
    return s.Curve.boundingBox.contains(this.sourcePort.Location) ? (this.sourceVV = this.GetVertex(this.sourcePort.Location), this._polyline = this.GetShortestPolylineToMulitpleTargets(this.sourceVV, Array.from(this.Targets(t))), this._polyline == null ? null : (this.FixLastPolylinePointForAnywherePort(s), s.HookSize > 0 && this.BuildHook(s), this.SmoothCornersAndReturnCurve(e, i))) : (i.smoothedPolyline = null, null);
  }
  BuildHook(t) {
    const e = t.Curve, i = j.mkFullEllipseNNP(t.HookSize, t.HookSize, this._polyline.end), s = g.getAllIntersections(e, i, !0);
    u.getTriangleOrientation(s[0].x, this._polyline.end, this._polyline.endPoint.prev.point) == L.Counterclockwise && s.reverse();
    const n = this._polyline.end.sub(this._polyline.endPoint.prev.point).normalize(), r = e.derivative(s[0].par0).normalize(), a = r.dot(n);
    if (Math.abs(a) < 0.2)
      this.ExtendPolyline(r, s[0], n, t);
    else {
      const l = e.derivative(s[1].par0).normalize();
      l.dot(n) < a ? this.ExtendPolyline(l, s[1], n, t) : this.ExtendPolyline(r, s[0], n, t);
    }
  }
  ExtendPolyline(t, e, i, s) {
    let n = t.rotate(Math.PI / 2);
    n.dot(i) < 0 && (n = n.neg());
    const r = e.x.add(n.mul(s.HookSize));
    let a;
    (a = u.lineLineIntersection(r, r.add(t), this._polyline.end, this._polyline.end.add(i))) && (this._polyline.addPoint(a), this._polyline.addPoint(r), this._polyline.addPoint(e.x));
  }
  FixLastPolylinePointForAnywherePort(t) {
    for (; ; ) {
      const e = this.GetLastPointInsideOfCurveOnPolyline(t.Curve);
      e.next.next = null, this._polyline.endPoint = e.next;
      let i = e.next.point.sub(e.point);
      i = i.normalize().mul(t.Curve.boundingBox.diagonal);
      const s = i.rotate(t.AdjustmentAngle * -1), n = i.rotate(t.AdjustmentAngle), r = g.intersectionOne(t.Curve, v.mkPP(e.point, e.point.add(s)), !0), a = g.intersectionOne(t.Curve, v.mkPP(e.point, e.point.add(n)), !0);
      if (r == null || a == null)
        return;
      const l = tt.GetTrimmedCurveForHookingUpAnywhere(t.Curve, e, r, a), h = l.value(l.closestParameter(e.point));
      if (!this.LineAvoidsTightHierarchyLPP(v.mkPP(e.point, h), this.SourceTightPolyline, null)) {
        const c = g.intersectionOne(t.Curve, v.mkPP(e.point, e.next.point), !1);
        if (c == null)
          return;
        this._polyline.endPoint.point = c.x;
        break;
      }
      if (this._polyline.endPoint.point = h, e.prev == null || !this.TryShortcutPolyPoint(e.prev))
        break;
    }
  }
  static GetTrimmedCurveForHookingUpAnywhere(t, e, i, s) {
    const n = u.getTriangleOrientation(s.x, i.x, e.point) === L.Clockwise, r = i.par0, a = s.par0;
    let l, h, c;
    return n ? r < a ? t.trim(r, a) : (h = t.trim(r, t.parEnd), l = t.trim(t.parStart, a), c = new g(), c.addSegs([h, l])) : a < r ? t.trim(a, r) : (h = t.trim(a, t.parEnd), l = t.trim(t.parStart, r), c = new g(), c.addSegs([h, l]));
  }
  GetLastPointInsideOfCurveOnPolyline(t) {
    for (let e = this._polyline.endPoint.prev; e != null; e = e.prev)
      if (e.prev == null || g.PointRelativeToCurveLocation(e.point, t) === F.Inside)
        return e;
    throw new Error();
  }
  GetShortestPolylineToMulitpleTargets(t, e) {
    this.CleanTheGraphForShortestPath();
    const s = new Rn(t, e, this.VisibilityGraph).GetPath();
    if (s == null)
      return null;
    const n = new B();
    for (const r of s)
      n.addPoint(r.point);
    return n.RemoveCollinearVertices();
  }
  Targets(t) {
    return Array.from(t).map((e) => this.visibilityGraph.FindVertex(e));
  }
  ExtendVisibilityGraphFromFloatingSourcePort() {
    const t = this.sourcePort;
    this.StartPointOfEdgeRouting = t.Location, this.UseSpanner ? this.sourceVV = this.AddTransientVisibilityEdgesForPort(this.sourcePort.Location, this.SourceLoosePolyline) : this.sourceVV = Oi.CalculatePointVisibilityGraph(Array.from(this.GetActivePolylines()).filter((e) => e !== this.SourceLoosePolyline), this.VisibilityGraph, this.StartPointOfEdgeRouting, Ti.Tangent);
  }
  FigureOutSourceTargetPolylinesAndActiveRectangle() {
    let t = this.sourcePort.Curve.value(this.sourcePort.Curve.parStart);
    this._sourceTightPolyline = tt.GetFirstHitPolyline(t, this.ObstacleCalculator.RootOfTightHierarchy), this.SourceLoosePolyline = tt.GetFirstHitPolyline(t, this.ObstacleCalculator.RootOfLooseHierarchy), t = this.targetPort.Curve.value(this.targetPort.Curve.parStart), this.targetTightPolyline = tt.GetFirstHitPolyline(t, this.ObstacleCalculator.RootOfTightHierarchy), this.targetLoosePolyline = tt.GetFirstHitPolyline(t, this.ObstacleCalculator.RootOfLooseHierarchy), this.activeRectangle = T.mkPP(new u(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY), new u(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY));
  }
  *AllPolygons() {
    for (const t of this.ObstacleCalculator.LooseObstacles)
      yield new ue(t);
  }
  //
  GetVisibilityGraph() {
    return this.VisibilityGraph;
  }
  // ShowObstaclesAndVisGraph() {
  //    let obs = this.ObstacleCalculator.LooseObstacles.Select(() => {  }, new DebugCurve(100, 1, "blue", o));
  //    let edges = this.visibilityGraph.Edges.Select(() => {  }, new DebugCurve(70, 1, (e instanceof  "red"), LineSegment.mkPP(e.SourcePoint, e.TargetPoint)));
  //    // TODO: Warning!!!, inline IF is not supported ?
  //    TransientVisibilityEdge;
  //    "green";
  //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(obs.Concat(edges));
  // }
  AddActivePolygons(t) {
    Vi(this.activePolygons, t);
  }
  ClearActivePolygons() {
    this.activePolygons = [];
  }
}
class vt {
  toJSON() {
    let t = "{";
    return this.tipPosition && (t += '"tipPosition": ' + this.tipPosition.toJSON()), t += "}", t;
  }
  clone() {
    const t = new vt();
    return t.length = this.length, t.width = this.width, t.tipPosition = this.tipPosition, t;
  }
  constructor() {
    this.length = vt.defaultArrowheadLength, this.width = 0, this.length = vt.defaultArrowheadLength;
  }
  // the edgeGeometry.Curve is trimmed already by the node boundaries</param>
  static calculateArrowheads(t) {
    if (t.sourceArrowhead == null && t.targetArrowhead == null)
      return !0;
    const e = vt.findTrimStartForArrowheadAtSource(t);
    if (e == null)
      return !1;
    const i = vt.findTrimEndForArrowheadAtTarget(t);
    if (i == null || e > i - m.intersectionEpsilon || g.closeIntersectionPoints(t.curve.value(e), t.curve.value(i)))
      return !1;
    const s = t.curve.trim(e, i);
    return s == null ? !1 : (t.sourceArrowhead != null && (t.sourceArrowhead.tipPosition = t.curve.start), t.targetArrowhead != null && (t.targetArrowhead.tipPosition = t.curve.end), t.curve = s, !0);
  }
  static getIntersectionsWithArrowheadCircle(t, e, i) {
    const s = j.mkFullEllipseNNP(e, e, i);
    return g.getAllIntersections(s, t, !0);
  }
  // we need to pass arrowhead length here since the original length mibh
  static findTrimEndForArrowheadAtTarget(t) {
    const e = m.distanceEpsilon * m.distanceEpsilon;
    let i = t.curve.parEnd;
    if (t.targetArrowhead == null || t.targetArrowhead.length <= m.distanceEpsilon)
      return i;
    const s = t.curve;
    let n = t.targetArrowhead.length, r, a, l = 10;
    do {
      if (l--, l === 0)
        return;
      a = vt.getIntersectionsWithArrowheadCircle(s, n, s.end), i = a.length !== 0 ? Math.max(...a.map((h) => h.par1)) : s.parEnd, r = t.curve.value(i), n /= 2;
    } while (r.sub(s.start).lengthSquared < e || a.length === 0);
    return i;
  }
  static findTrimStartForArrowheadAtSource(t) {
    if (t.sourceArrowhead == null || t.sourceArrowhead.length <= m.distanceEpsilon)
      return t.curve.parStart;
    const e = m.distanceEpsilon * m.distanceEpsilon;
    let i = t.sourceArrowhead.length, s;
    const n = t.curve;
    let r, a = 10, l;
    for (; --a > 0; ) {
      if (r = vt.getIntersectionsWithArrowheadCircle(n, i, n.start), r.length === 0)
        return n.parStart;
      if (l = Math.min(...r.map((h) => h.par1)), s = r.filter((h) => h.par1 === l)[0].x, s.sub(n.end).lengthSquared >= e)
        return l;
      i /= 2;
    }
  }
  // trim the edge curve with the node boundaries
  static trimSplineAndCalculateArrowheads(t, e, i) {
    return vt.trimSplineAndCalculateArrowheadsII(t, t.source.boundaryCurve, t.target.boundaryCurve, e, i);
  }
  // trim the edge curve with the node boundaries
  static trimSplineAndCalculateArrowheadsII(t, e, i, s, n) {
    if (t.curve = g.trimEdgeSplineWithNodeBoundaries(e, i, s, n), t.curve == null)
      return !1;
    if ((t.sourceArrowhead == null || t.sourceArrowhead.length < m.distanceEpsilon) && (t.targetArrowhead == null || t.targetArrowhead.length < m.distanceEpsilon))
      return !0;
    let r = !1;
    const a = t.sourceArrowhead != null ? t.sourceArrowhead.length : 0, l = t.targetArrowhead != null ? t.targetArrowhead.length : 0, h = t.curve.end.sub(t.curve.start).length;
    t.sourceArrowhead != null && (t.sourceArrowhead.length = Math.min(h, a)), t.targetArrowhead != null && (t.targetArrowhead.length = Math.min(h, l));
    let c = 10;
    for (; (t.sourceArrowhead != null && t.sourceArrowhead.length > m.intersectionEpsilon || t.targetArrowhead != null && t.targetArrowhead.length > m.intersectionEpsilon) && !r && (r = vt.calculateArrowheads(t), r || (t.sourceArrowhead != null && (t.sourceArrowhead.length *= 0.5), t.targetArrowhead != null && (t.targetArrowhead.length *= 0.5)), c--, c !== 0); )
      ;
    return r || (t.sourceArrowhead != null && (t.sourceArrowhead.tipPosition = s.start), t.targetArrowhead != null && (t.targetArrowhead.tipPosition = s.end)), t.sourceArrowhead != null && (t.sourceArrowhead.length = a), t.targetArrowhead != null && (t.targetArrowhead.length = l), r;
  }
  /** Creates a spline between two nodes big enough to draw arrowheads */
  static createBigEnoughSpline(t) {
    const e = t.source.center;
    let i = t.target.center;
    const s = i.sub(e), n = s.length;
    let r;
    n < 1e-3 ? (r = new u(1, 0), i = e.add(r.rotate(Math.PI / 2))) : r = s.rotate(Math.PI / 2);
    let a = 1;
    t.sourceArrowhead != null && (a += t.sourceArrowhead.length), t.targetArrowhead != null && (a += t.targetArrowhead.length), r = r.normalize().mul(1.5 * a);
    for (let l = 1; l < 1e4; l = l * 2) {
      const h = g.createBezierSegN(e, i, r, l);
      if (vt.trimSplineAndCalculateArrowheadsII(t, t.source.boundaryCurve, t.target.boundaryCurve, h, !1))
        return;
    }
    vt.createEdgeCurveWithNoTrimming(t, e, i);
  }
  // this method should never be called: it is a super emergency measure
  static createEdgeCurveWithNoTrimming(t, e, i) {
    const s = i.sub(e).normalize();
    let n = e, r = i;
    const a = t.targetArrowhead;
    a != null && (a.tipPosition = i, r = i.sub(s.mul(a.length)));
    const l = t.sourceArrowhead;
    l != null && (l.tipPosition = e, n = e.add(s.mul(l.length))), t.curve = v.mkPP(n, r);
  }
}
vt.defaultArrowheadLength = 5;
class Nn {
  constructor() {
    this.m = /* @__PURE__ */ new Map();
  }
  clear() {
    this.m.clear();
  }
  get size() {
    return this.m.size;
  }
  set(t, e) {
    this.m.set(rr(t), e);
  }
  delete(t) {
    this.m.delete(rr(t));
  }
  has(t) {
    return this.m.has(rr(t));
  }
  getPP(t, e) {
    return this.get(new ne(t, e));
  }
  get(t) {
    return this.m.get(rr(t));
  }
  *keys() {
    for (const t of this.m.keys())
      yield ol(t);
  }
  *[Symbol.iterator]() {
    for (const [t, e] of this.m)
      yield [ol(t), e];
  }
  *values() {
    yield* this.m.values();
  }
}
function ol(o) {
  const t = o.split(" "), e = t[0], i = t[1];
  let s = e.split(",");
  const n = new u(Number(s[0]), Number(s[1]));
  s = i.split(",");
  const r = new u(Number(s[0]), Number(s[1]));
  return new ne(n, r);
}
function Jd(o, t) {
  return [al(o), al(t)].sort().join(" ");
}
function rr(o) {
  return Jd(o.first, o.second);
}
function al(o) {
  return o.x.toString() + "," + o.y.toString();
}
class le {
  /**  For a given graph finds the obstacles for nodes and clusters, correctly parenting the obstacles
       according to the cluster hierarchy
       graph with edges to route and nodes/clusters to route around.
       Returns the set of obstacles with correct cluster hierarchy and ports
  */
  static GetShapes(t, e = Array.from(t.shallowEdges)) {
    const i = /* @__PURE__ */ new Map();
    Hh(t, i);
    for (const s of e) {
      let n = i.get(s.source);
      n && s.sourcePort != null && n.Ports.add(s.sourcePort), n = i.get(s.target), n && s.targetPort != null && n.Ports.add(s.targetPort);
    }
    return Array.from(i.values());
  }
  /**   Creates a shape with a RelativeFloatingPort for the node center, attaches it to the shape and all edges */
  static CreateShapeWithCenterPort(t) {
    const e = new ko(t), i = Ki.mk(() => t.boundaryCurve, () => t.center);
    e.Ports.add(i);
    for (const s of t.inEdges())
      le.FixPortAtTarget(i, s);
    for (const s of t.outEdges())
      le.FixPortAtSource(i, s);
    for (const s of t.selfEdges())
      le.FixPortAtSource(i, s), le.FixPortAtTarget(i, s);
    return e;
  }
  /**   Creates a ClusterBoundaryPort for the cluster boundary, attaches it to the shape and all edges */
  static CreateShapeWithClusterBoundaryPort(t) {
    const e = new ko(t), i = Ve.mk(() => t.boundaryCurve, () => t.center);
    e.Ports.add(i);
    let s;
    for (const n of t.inEdges())
      n.EdgeToAncestor() === ds.ToAncestor ? (s == null && (s = new ee(() => t.boundaryCurve)), n.targetPort = s) : le.FixPortAtTarget(i, n);
    for (const n of t.outEdges())
      n.EdgeToAncestor() === ds.FromAncestor ? (s == null && (s = new ee(() => t.boundaryCurve)), n.sourcePort = s) : le.FixPortAtSource(i, n);
    for (const n of t.selfEdges())
      le.FixPortAtSource(i, n), le.FixPortAtTarget(i, n);
    return e;
  }
  static FixPortAtSource(t, e) {
    e != null && e.sourcePort == null && (e.sourcePort = t);
  }
  static FixPortAtTarget(t, e) {
    e != null && e.targetPort == null && (e.targetPort = t);
  }
}
function Hh(o, t) {
  for (const e of o.shallowNodes)
    if (e instanceof Rt) {
      const i = le.CreateShapeWithClusterBoundaryPort(e);
      t.set(e, i);
      const s = e;
      if (!s.isCollapsed) {
        Hh(s, t);
        for (const n of s.shallowNodes)
          i.AddChild(t.get(n));
      }
    } else
      t.set(e, le.CreateShapeWithCenterPort(e));
}
var vi;
(function(o) {
  o[o.NotVisited = 0] = "NotVisited", o[o.InStack = 1] = "InStack", o[o.Visited = 2] = "Visited";
})(vi || (vi = {}));
let Kd = class {
  constructor(t, e) {
    this.v = t, this.i = e;
  }
};
class Zi {
  static getFeedbackSetWithConstraints(t, e) {
    throw new Error("Method not implemented.");
  }
  static push(t, e, i, s) {
    e[i] = vi.InStack, t.push(new Kd(i, s));
  }
  static getFeedbackSet(t) {
    const e = new Ji();
    if (t == null || t.nodeCount === 0)
      return [];
    const i = new Array(t.nodeCount).fill(vi.NotVisited);
    for (let s = 0; s < t.nodeCount; s++) {
      if (i[s] === vi.Visited)
        continue;
      const n = new mt.Stack();
      let r = 0;
      for (Zi.push(n, i, s, r); n.size > 0; ) {
        const a = n.pop();
        s = a.v, i[s] = vi.Visited, r = a.i;
        let l = t.outEdges[s];
        for (; r < l.length; r++) {
          const h = l[r];
          if (h.source === h.target)
            continue;
          const c = i[h.target];
          c === vi.InStack ? e.set(h.source, h.target, h) : c === vi.NotVisited && (Zi.push(n, i, s, r + 1), s = h.target, i[h.target] = vi.Visited, l = t.outEdges[s], r = -1);
        }
      }
    }
    return Array.from(e.values());
  }
}
class zi {
  constructor() {
    this.isEmpty = !0;
  }
  AddValue(t) {
    this.isEmpty ? (this.max = t, this.min = t, this.isEmpty = !1) : t < this.min ? this.min = t : t > this.max && (this.max = t);
  }
  get length() {
    return this.max - this.min;
  }
  // 0  if value is close to zero;
  // 1  if value is strictly greater than zero;
  // -1 if value is strictly lower than zero;
  static sign(t) {
    return t > m.distanceEpsilon ? 1 : t < -m.distanceEpsilon ? -1 : 0;
  }
}
class Bn {
  SetActiveState(t, e) {
    this.IsActive = t, this.VectorIndex = e, this.IsActive ? (this.Left.ActiveConstraintCount++, this.Right.ActiveConstraintCount++) : (this.Left.ActiveConstraintCount--, this.Right.ActiveConstraintCount--);
  }
  SetVectorIndex(t) {
    this.VectorIndex = t;
  }
  Reinitialize() {
    this.IsActive = !1, this.IsUnsatisfiable = !1, this.ClearDfDv();
  }
  // This is an  function, not a propset, because we only want it called by the Solver.
  UpdateGap(t) {
    this.Gap = t;
  }
  // The Constraint constructor takes the two variables and their required distance.
  // The constraints will be generated either manually or by ConstraintGenerator,
  // both of which know about the sizes when the constraints are generated (as
  // well as any necessary padding), so the sizes are accounted for at that time
  // and ProjectionSolver classes are not aware of Variable sizes.
  static constructorVVNB(t, e, i, s) {
    const n = new Bn(t);
    return n.Left = t, n.Right = e, n.Gap = i, n.IsEquality = s, n.Lagrangian = 0, n.IsActive = !1, n;
  }
  // For Solver.ComputeDfDv's DummyParentNode's constraint only.
  constructor(t) {
    this.Right = t, this.Left = t;
  }
  // Generates a string representation of the Constraint.
  // <returns>A string representation of the Constraint.</returns>
  ToString() {
    return Bt.String.format("  Cst: [{0}] [{1}] {2} {3:F5} vio {4:F5} Lm {5:F5}/{6:F5} {7}actv", this.Left, this.Right, this.IsEquality ? "==" : ">=", this.Gap, this.Violation, this.Lagrangian, this.Lagrangian * 2, this.IsActive ? "+" : this.IsUnsatisfiable ? "!" : "-");
  }
  get Violation() {
    return this.Left.ActualPos * this.Left.Scale + (this.Gap - this.Right.ActualPos * this.Right.Scale);
  }
  ClearDfDv() {
    this.Lagrangian = 0;
  }
  // Compare this Constraint to rhs by their Variables in ascending order (this === lhs, other === rhs).
  // The object being compared to.
  // <returns>-1 if this.Left/Right are "less"; +1 if this.Left/Right are "greater"; 0 if this.Left/Right
  //         and rhs.Left/Right are equal.</returns>
  CompareTo(t) {
    let e = this.Left.CompareTo(t.Left);
    return e === 0 && (e = this.Right.CompareTo(t.Right)), e === 0 && (e = yt(this.Gap, t.Gap)), e;
  }
}
class Sn {
  static constructorDCVV(t, e, i, s) {
    const n = new Sn(e);
    return n.Set(t, e, i, s), n;
  }
  // For DummyParentNode only.
  constructor(t) {
    this.ConstraintToEval = t, this.Depth = -1;
  }
  Set(t, e, i, s) {
    return this.Parent = t, this.ConstraintToEval = e, this.VariableToEval = i, this.VariableDoneEval = s, this.Depth = 0, this.ChildrenHaveBeenPushed = !1, e.Lagrangian = 0, this;
  }
  get IsLeftToRight() {
    return this.VariableToEval === this.ConstraintToEval.Right;
  }
  toString() {
    return Bt.String.format("{0} {1}{2} - {3}{4} ({5})", "", this.IsLeftToRight ? "" : "*", this.ConstraintToEval.Left.Name, this.IsLeftToRight ? "*" : "", this.ConstraintToEval.Right.Name, this.Depth);
  }
}
class Zd {
  constructor(t, e) {
    this.Constraint = t, this.IsForward = e;
  }
}
class Gr {
  constructor(t, e) {
    this.Variables = new Array(), t != null && this.AddVariable(t), this.allConstraints = e;
  }
  // Generate a string representation of the Block.
  // <returns>A string representation of the Block.</returns>
  toString() {
    return Bt.String.format("[Block: nvars = {0} refpos = {1:F5} scale = {2:F5}]", this.Variables.length, this.ReferencePos, this.Scale);
  }
  ComputeDfDv(t) {
    this.allConstraints.DfDvStack = new mt.Stack();
    const e = new Bn(t);
    this.dfDvDummyParentNode = new Sn(e);
    const i = this.GetDfDvNode(this.dfDvDummyParentNode, e, t, null);
    for (this.allConstraints.DfDvStack.push(i); ; ) {
      const s = this.allConstraints.DfDvStack.top, n = this.allConstraints.DfDvStack.length;
      if (!s.ChildrenHaveBeenPushed) {
        s.ChildrenHaveBeenPushed = !0;
        for (const r of s.VariableToEval.LeftConstraints)
          if (r.IsActive && r.Right !== s.VariableDoneEval) {
            const a = this.GetDfDvNode(s, r, r.Right, s.VariableToEval);
            r.Right.ActiveConstraintCount === 1 ? this.ProcessDfDvLeafNodeDirectly(a) : this.PushDfDvNode(a);
          }
        for (const r of s.VariableToEval.RightConstraints)
          if (r.IsActive && r.Left !== s.VariableDoneEval) {
            const a = this.GetDfDvNode(s, r, r.Left, s.VariableToEval);
            r.Left.ActiveConstraintCount === 1 ? this.ProcessDfDvLeafNodeDirectly(a) : this.PushDfDvNode(a);
          }
        if (this.allConstraints.DfDvStack.length > n)
          continue;
      }
      if (this.allConstraints.DfDvStack.pop(), this.ProcessDfDvLeafNode(s), s === i)
        break;
    }
  }
  // end ComputeDfDv()
  ProcessDfDvLeafNode(t) {
    const e = t.VariableToEval.DfDv;
    t.IsLeftToRight ? (t.ConstraintToEval.Lagrangian = t.ConstraintToEval.Lagrangian + e, t.Parent.ConstraintToEval.Lagrangian = t.Parent.ConstraintToEval.Lagrangian + t.ConstraintToEval.Lagrangian) : (t.ConstraintToEval.Lagrangian = (t.ConstraintToEval.Lagrangian + e) * -1, t.Parent.ConstraintToEval.Lagrangian = t.Parent.ConstraintToEval.Lagrangian - t.ConstraintToEval.Lagrangian), this.CheckForConstraintPathTarget(t), this.Debug_CheckForViolatedActiveConstraint(t.ConstraintToEval), this.allConstraints.RecycleDfDvNode(t);
  }
  Debug_CheckForViolatedActiveConstraint(t) {
    t.Violation > this.allConstraints.SolverParameters.GapTolerance;
  }
  // Directly evaluate a leaf node rather than defer it to stack push/pop.
  ProcessDfDvLeafNodeDirectly(t) {
    this.ProcessDfDvLeafNode(t);
  }
  GetDfDvNode(t, e, i, s) {
    const n = this.allConstraints.DfDvRecycleStack.size > 0 ? this.allConstraints.DfDvRecycleStack.pop().Set(t, e, i, s) : Sn.constructorDCVV(t, e, i, s);
    return n.Depth = n.Parent.Depth + 1, this.allConstraints.MaxConstraintTreeDepth < n.Depth && (this.allConstraints.MaxConstraintTreeDepth = n.Depth), n;
  }
  // Called by ComputeDfDv.
  PushDfDvNode(t) {
    this.PushOnDfDvStack(t);
  }
  // Called by RecurseGetConnectedVariables.
  AddVariableAndPushDfDvNode(t, e) {
    t.push(e.VariableToEval), this.PushOnDfDvStack(e);
  }
  PushOnDfDvStack(t) {
    this.allConstraints.DfDvStack.push(t);
  }
  CheckForConstraintPathTarget(t) {
    if (this.pathTargetVariable === t.VariableToEval) {
      for (; t.Parent !== this.dfDvDummyParentNode; )
        this.constraintPath.push(new Zd(t.ConstraintToEval, t.IsLeftToRight)), t = t.Parent;
      this.pathTargetVariable = null;
    }
  }
  Expand(t) {
    this.constraintPath == null && (this.constraintPath = new Array()), this.constraintPath = [], this.pathTargetVariable = t.Right, this.ComputeDfDv(t.Left);
    let e = null;
    if (this.constraintPath.length > 0) {
      for (const r of this.constraintPath)
        r.IsForward && (e == null || r.Constraint.Lagrangian < e.Lagrangian) && (r.Constraint.IsEquality || (e = r.Constraint));
      e != null && this.allConstraints.DeactivateConstraint(e);
    }
    if (this.constraintPath = [], this.pathTargetVariable = null, e == null) {
      t.IsUnsatisfiable = !0, this.allConstraints.NumberOfUnsatisfiableConstraints++;
      return;
    }
    const i = new Array();
    this.GetConnectedVariables(i, t.Right, t.Left);
    const s = t.Violation, n = i.length;
    for (let r = 0; r < n; r++)
      i[r].OffsetInBlock = i[r].OffsetInBlock + s;
    this.allConstraints.ActivateConstraint(t), t.ClearDfDv(), this.UpdateReferencePos();
  }
  // end Expand()
  Split(t) {
    if (t && this.UpdateReferencePos(), this.Variables.length < 2)
      return null;
    let e = null;
    this.ComputeDfDv(this.Variables[0]);
    let i = this.allConstraints.SolverParameters.Advanced.MinSplitLagrangianThreshold;
    const s = this.Variables.length;
    for (let n = 0; n < s; n++)
      for (const r of this.Variables[n].LeftConstraints)
        r.IsActive && !r.IsEquality && r.Lagrangian < i && (e = r, i = r.Lagrangian);
    return e == null ? null : this.SplitOnConstraint(e);
  }
  SplitOnConstraint(t) {
    this.allConstraints.DeactivateConstraint(t);
    let e = new Gr(null, this.allConstraints);
    return this.TransferConnectedVariables(e, t.Right, t.Left), e.Variables.length > 0 ? (this.UpdateReferencePos(), e.UpdateReferencePos()) : e = null, e;
  }
  // end Split()
  AddVariable(t) {
    this.Variables.push(t), t.Block = this, this.Variables.length === 1 ? (this.Scale = t.Scale, this.ReferencePos = t.ActualPos, this.sumAd = t.ActualPos * t.Weight, this.sumAb = 0, this.sumA2 = t.Weight, t.OffsetInBlock = 0) : this.AddVariableToBlockSums(t);
  }
  UpdateReferencePos() {
    this.Scale = this.Variables[0].Scale, this.sumAd = 0, this.sumAb = 0, this.sumA2 = 0;
    const t = this.Variables.length;
    for (let e = 0; e < t; e++)
      this.AddVariableToBlockSums(this.Variables[e]);
    this.UpdateReferencePosFromSums();
  }
  AddVariableToBlockSums(t) {
    const e = this.Scale / t.Scale, i = t.OffsetInBlock / t.Scale, s = e * t.Weight;
    this.sumAd += s * t.DesiredPos, this.sumAb += s * i, this.sumA2 += s * e;
  }
  UpdateReferencePosFromSums() {
    if (!(Number.isFinite(this.sumAd) && Number.isFinite(this.sumAb) && Number.isFinite(this.sumA2)))
      throw new Error("infinite numbers");
    this.ReferencePos = (this.sumAd - this.sumAb) / this.sumA2, this.UpdateVariablePositions();
  }
  UpdateVariablePositions() {
    const t = this.Scale * this.ReferencePos, e = this.Variables.length;
    for (let i = 0; i < e; i++) {
      const s = this.Variables[i];
      s.ActualPos = (t + s.OffsetInBlock) / s.Scale;
    }
  }
  GetConnectedVariables(t, e, i) {
    this.RecurseGetConnectedVariables(t, e, i);
  }
  RecurseGetConnectedVariables(t, e, i) {
    this.allConstraints.DfDvStack = new mt.Stack();
    const s = new Bn(e);
    for (this.dfDvDummyParentNode = new Sn(s), this.allConstraints.DfDvStack.push(this.GetDfDvNode(this.dfDvDummyParentNode, s, e, i)), t.push(e); this.allConstraints.DfDvStack.length > 0; ) {
      const n = this.allConstraints.DfDvStack.top, r = this.allConstraints.DfDvStack.length;
      if (!n.ChildrenHaveBeenPushed) {
        n.ChildrenHaveBeenPushed = !0;
        for (const a of n.VariableToEval.LeftConstraints)
          a.IsActive && a.Right !== n.VariableDoneEval && (a.Right.ActiveConstraintCount === 1 ? t.push(a.Right) : this.AddVariableAndPushDfDvNode(t, this.GetDfDvNode(n, a, a.Right, n.VariableToEval)));
        for (const a of n.VariableToEval.RightConstraints)
          a.IsActive && a.Left !== n.VariableDoneEval && (a.Left.ActiveConstraintCount === 1 ? t.push(a.Left) : this.AddVariableAndPushDfDvNode(t, this.GetDfDvNode(n, a, a.Left, n.VariableToEval)));
      }
      this.allConstraints.DfDvStack.length > r || this.allConstraints.RecycleDfDvNode(this.allConstraints.DfDvStack.pop());
    }
  }
  TransferConnectedVariables(t, e, i) {
    this.GetConnectedVariables(t.Variables, e, i);
    const s = t.Variables.length;
    for (let r = 0; r < s; r++)
      t.Variables[r].Block = t;
    let n = this.Variables.length - 1;
    for (let r = this.Variables.length - 1; r >= 0; r--)
      this.Variables[r].Block === t && (r < n && (this.Variables[r] = this.Variables[n]), n--);
    if (this.Variables = this.Variables.slice(0, n + 1), this.Variables.length === 0) {
      for (let r = 0; r < s; r++) {
        const a = t.Variables[r];
        this.Variables.push(a), a.Block = this;
      }
      t.Variables = [];
    }
  }
}
class $d {
  get Count() {
    return this.Vector.length;
  }
  item(t) {
    return this.Vector[t];
  }
  constructor() {
    this.Vector = new Array();
  }
  Add(t) {
    t.VectorIndex = this.Vector.length, this.Vector.push(t);
  }
  Remove(t) {
    const e = this.Vector[this.Vector.length - 1];
    this.Vector[t.VectorIndex] = e, e.VectorIndex = t.VectorIndex, this.Vector.pop();
  }
  toString() {
    return this.Vector.toString();
  }
}
class tf {
  constructor() {
    this.nextConstraintIndex = 0, this.DfDvStack = new mt.Stack(), this.DfDvRecycleStack = new mt.Stack();
  }
  get IsEmpty() {
    return this.Vector == null;
  }
  Create(t) {
    this.Vector = new Array(t), this.firstActiveConstraintIndex = t;
  }
  Add(t) {
    t.SetVectorIndex(this.nextConstraintIndex), this.Vector[this.nextConstraintIndex++] = t;
  }
  ActivateConstraint(t) {
    this.firstActiveConstraintIndex--, this.SwapConstraint(t);
  }
  DeactivateConstraint(t) {
    this.SwapConstraint(t), this.firstActiveConstraintIndex++;
  }
  SwapConstraint(t) {
    const e = this.Vector[this.firstActiveConstraintIndex];
    e.SetVectorIndex(t.VectorIndex), this.Vector[t.VectorIndex] = e, this.Vector[this.firstActiveConstraintIndex] = t, t.SetActiveState(!t.IsActive, this.firstActiveConstraintIndex);
  }
  Reinitialize() {
    if (this.Vector != null) {
      for (const t of this.Vector)
        t.Reinitialize();
      this.firstActiveConstraintIndex = this.Vector.length;
    }
  }
  RecycleDfDvNode(t) {
    this.DfDvRecycleStack.length < 1024 && this.DfDvRecycleStack.push(t);
  }
  toString() {
    return this.Vector.toString();
  }
}
class pa {
  // Constructor.
  constructor() {
    this.GapTolerance = 1e-4, this.QpscConvergenceEpsilon = 1e-5, this.QpscConvergenceQuotient = 1e-6, this.OuterProjectIterationsLimit = -1, this.InnerProjectIterationsLimit = -1, this.TimeLimit = -1, this.Advanced = new ma();
  }
  // Deep-copy the AdvancedParameters.
  Clone() {
    const t = this.MemberwiseClone();
    return t.Advanced = this.Advanced.Clone(), t;
  }
  MemberwiseClone() {
    const t = new pa();
    return t.GapTolerance = this.GapTolerance, t.QpscConvergenceEpsilon = this.QpscConvergenceEpsilon, t.QpscConvergenceQuotient = this.QpscConvergenceQuotient, t.OuterProjectIterationsLimit = this.OuterProjectIterationsLimit, t.InnerProjectIterationsLimit = this.InnerProjectIterationsLimit, t.TimeLimit = this.TimeLimit, t;
  }
}
class ma {
  // Constructor.
  constructor() {
    this.ForceQpsc = !1, this.ScaleInQpsc = !0, this.MinSplitLagrangianThreshold = -1e-7, this.UseViolationCache = !0, this.ViolationCacheMinBlocksDivisor = 10, this.ViolationCacheMinBlocksCount = 100;
  }
  // Shallow-copy the object (there is nothing requiring deep-copy).
  Clone() {
    const t = new ma();
    return t.ForceQpsc = this.ForceQpsc, t.ScaleInQpsc = this.ScaleInQpsc, t.MinSplitLagrangianThreshold = this.MinSplitLagrangianThreshold, t.UseViolationCache = this.UseViolationCache, t.ViolationCacheMinBlocksDivisor = this.ViolationCacheMinBlocksDivisor, t.ViolationCacheMinBlocksCount = this.ViolationCacheMinBlocksCount, t;
  }
}
class ef {
  constructor(t) {
    this.Variable = t, this.OrigWeight = t.Weight, this.OrigScale = t.Scale, this.OrigDesiredPos = this.Variable.DesiredPos;
  }
}
class sf {
  constructor(t, e) {
    this.Value = t, this.Column = e;
  }
}
class ge {
  constructor(t, e) {
    this.newMatrixRow = new Array(), this.previousFunctionValue = Number.MAX_VALUE, this.solverParameters = t, this.matrixQ = new Array(e).fill(0), this.vectorWiDi = new Array(e).fill(0), this.vectorQpscVars = new Array(e).fill(0), this.gradientVector = new Array(e).fill(0), this.vectorQg = new Array(e).fill(0), this.vectorPrevY = new Array(e).fill(0), this.vectorCurY = new Array(e).fill(0);
  }
  //
  // solver.SolveQpsc drives the Qpsc instance as follows:
  // Initialization:
  //    Qpsc qpsc = new Qpsc(numVariables);
  //    foreach (variable in (foreach block))
  //       qpsc.AddVariable(variable)
  //    qpsc.VariablesComplete()
  // Per iteration:
  //    if (!qpsc.PreProject()) break;
  //    solver.SplitBlocks()
  //    solver.Project()
  //    if (!qpsc.PostProject()) break;
  // Done:
  //    qpsc.ProjectComplete()
  AddVariable(t) {
    if (this.isFirstProjectCall = !0, this.vectorWiDi[t.Ordinal] = 2 * (t.Weight * t.DesiredPos) * -1, this.vectorPrevY[t.Ordinal] = t.Weight, t.Neighbors != null)
      for (const e of t.Neighbors)
        this.vectorPrevY[t.Ordinal] = this.vectorPrevY[t.Ordinal] + e.Weight, this.vectorPrevY[e.Neighbor.Ordinal] = this.vectorPrevY[e.Neighbor.Ordinal] - e.Weight;
    for (let e = 0; e < this.vectorPrevY.length; e++)
      this.vectorPrevY[e] !== 0 && (this.newMatrixRow.push(new sf(this.vectorPrevY[e] * 2, e)), this.vectorPrevY[e] = 0);
    this.matrixQ[t.Ordinal] = Array.from(this.newMatrixRow), this.newMatrixRow = [], this.vectorQpscVars[t.Ordinal] = new ef(t), t.Weight = 1;
  }
  // end AddVariable()
  VariablesComplete() {
    for (const t of this.vectorQpscVars) {
      const e = t.Variable;
      for (const i of this.matrixQ[e.Ordinal])
        i.Column === e.Ordinal && (this.solverParameters.Advanced.ScaleInQpsc && (e.Scale = 1 / Math.sqrt(Math.abs(i.Value)), Number.isFinite(e.Scale) || (e.Scale = 1), e.Scale, this.vectorWiDi[e.Ordinal] = this.vectorWiDi[e.Ordinal] * e.Scale), this.vectorCurY[e.Ordinal] = e.ActualPos, e.DesiredPos = e.ActualPos);
    }
    if (this.solverParameters.Advanced.ScaleInQpsc)
      for (let t = 0; t < this.matrixQ.length; t++) {
        const e = this.matrixQ[t];
        for (let i = 0; i < e.length; i++)
          e[i].Column === t ? e[i].Value = 1 : e[i].Value = e[i].Value * (this.vectorQpscVars[t].Variable.Scale * this.vectorQpscVars[e[i].Column].Variable.Scale);
      }
  }
  // end VariablesComplete()
  // Called by SolveQpsc before the split/project phase.  Returns false if the difference in the
  // function value on the current vs. previous iteration is sufficiently small that we're done.
  // @@PERF: Right now this is distinct matrix/vector operations.  Profiling shows most time
  // in Qpsc is taken by MatrixVectorMultiply.  We could gain a bit of performance by combining
  // some things but keep it simple unless that's needed.
  PreProject() {
    if (this.isFirstProjectCall)
      for (const s of this.vectorQpscVars)
        this.vectorCurY[s.Variable.Ordinal] = s.Variable.ActualPos;
    if (this.MatrixVectorMultiply(this.vectorCurY, this.gradientVector), this.HasConverged())
      return !1;
    ge.VectorVectorAdd(this.gradientVector, this.vectorWiDi, this.gradientVector);
    const t = ge.VectorVectorMultiply(this.gradientVector, this.gradientVector);
    let e = 0;
    if (t !== 0 && (this.MatrixVectorMultiply(this.gradientVector, this.vectorQg), e = ge.VectorVectorMultiply(this.vectorQg, this.gradientVector)), e === 0)
      return !1;
    const i = t / e;
    ge.VectorCopy(this.vectorPrevY, this.vectorCurY), ge.VectorScaledVectorSubtract(this.vectorPrevY, i, this.gradientVector, this.vectorCurY);
    for (let s = 0; s < this.vectorCurY.length; s++)
      this.vectorQpscVars[s].Variable.DesiredPos = this.vectorCurY[s];
    return !0;
  }
  // end PreProject()
  // Called by SolveQpsc after the split/project phase.
  PostProject() {
    for (const i of this.vectorQpscVars)
      this.vectorCurY[i.Variable.Ordinal] = i.Variable.ActualPos;
    ge.VectorVectorSubtract(this.vectorPrevY, this.vectorCurY, this.vectorCurY);
    const t = ge.VectorVectorMultiply(this.gradientVector, this.vectorCurY);
    let e = 0;
    if (t !== 0) {
      this.MatrixVectorMultiply(this.vectorCurY, this.vectorQg);
      const i = ge.VectorVectorMultiply(this.vectorQg, this.vectorCurY);
      e = i === 0 ? 1 : t / i, e > 1 ? e = 1 : e < 0 && (e = 0);
    }
    return ge.VectorScaledVectorSubtract(this.vectorPrevY, e, this.vectorCurY, this.vectorCurY), this.isFirstProjectCall = !1, e > 0;
  }
  // end PostProject()
  QpscComplete() {
    for (const t of this.vectorQpscVars)
      t.Variable.Weight = t.OrigWeight, t.Variable.DesiredPos = t.OrigDesiredPos, this.solverParameters.Advanced.ScaleInQpsc && (t.Variable.ActualPos = t.Variable.ActualPos * t.Variable.Scale, t.Variable.Scale = t.OrigScale);
    return this.previousFunctionValue;
  }
  HasConverged() {
    const t = this.GetFunctionValue(this.vectorCurY);
    let e = !1;
    if (!this.isFirstProjectCall) {
      const i = this.previousFunctionValue - t;
      let s = 0;
      if (i !== 0) {
        const n = this.previousFunctionValue !== 0 ? this.previousFunctionValue : t;
        s = Math.abs(i / n);
      }
      (Math.abs(i) < this.solverParameters.QpscConvergenceEpsilon || Math.abs(s) < this.solverParameters.QpscConvergenceQuotient) && (e = !0);
    }
    return this.previousFunctionValue = t, e;
  }
  GetFunctionValue(t) {
    return ge.VectorVectorMultiply(this.gradientVector, t) / 2 + ge.VectorVectorMultiply(this.vectorWiDi, t);
  }
  // Returns the dot product of two column vectors (with an "implicit transpose").
  static VectorVectorMultiply(t, e) {
    let i = 0;
    for (let s = 0; s < t.length; s++)
      i = i + t[s] * e[s];
    return i;
  }
  // Multiplies matrixQ with the column vector rhs leaving the result in column vector in result[].
  MatrixVectorMultiply(t, e) {
    let i = 0;
    for (const s of this.matrixQ) {
      let n = 0;
      for (const r of s)
        n = n + r.Value * t[r.Column];
      e[i++] = n;
    }
  }
  // Returns the addition result in result[] (which may be lhs or rhs or a different vector).
  static VectorVectorAdd(t, e, i) {
    for (let s = 0; s < t.length; s++)
      i[s] = t[s] + e[s];
  }
  // Returns the subtraction result in result[] (which may be lhs or rhs or a different vector).
  static VectorVectorSubtract(t, e, i) {
    for (let s = 0; s < t.length; s++)
      i[s] = t[s] - e[s];
  }
  // Same as VectorVectorSubtract except that rhs is multiplied by the scale value.
  static VectorScaledVectorSubtract(t, e, i, s) {
    for (let n = 0; n < t.length; n++)
      s[n] = t[n] - e * i[n];
  }
  // Copies src to dest
  static VectorCopy(t, e) {
    for (let i = 0; i < e.length; i++)
      t[i] = e[i];
  }
}
class Fr {
  constructor() {
    this.NumberOfUnsatisfiableConstraints = 0, this.OuterProjectIterations = 0, this.InnerProjectIterationsTotal = 0, this.MinInnerProjectIterations = 0, this.MaxInnerProjectIterations = 0, this.MaxConstraintTreeDepth = 0, this.GoalFunctionValue = 0, this.TimeLimitExceeded = !1, this.OuterProjectIterationsLimitExceeded = !1, this.InnerProjectIterationsLimitExceeded = !1;
  }
  // Indicates whether one or more execution limits were exceeded.
  get ExecutionLimitExceeded() {
    return this.TimeLimitExceeded || this.OuterProjectIterationsLimitExceeded || this.InnerProjectIterationsLimitExceeded;
  }
  // Shallow-copy everything, including the contained list.
  Clone() {
    const t = new Fr();
    return t.GoalFunctionValue = this.GoalFunctionValue, t.InnerProjectIterationsLimitExceeded = this.InnerProjectIterationsLimitExceeded, t.InnerProjectIterationsTotal = this.InnerProjectIterationsTotal, t.MaxConstraintTreeDepth = this.MaxConstraintTreeDepth, t.OuterProjectIterations = this.OuterProjectIterations, t.OuterProjectIterationsLimitExceeded = this.OuterProjectIterationsLimitExceeded, t.AlgorithmUsed = this.AlgorithmUsed, t.NumberOfUnsatisfiableConstraints = this.NumberOfUnsatisfiableConstraints, t.MaxInnerProjectIterations = this.MaxInnerProjectIterations, t;
  }
}
var Vr;
(function(o) {
  o[o.ProjectOnly = 0] = "ProjectOnly", o[o.QpscWithScaling = 1] = "QpscWithScaling", o[o.QpscWithoutScaling = 2] = "QpscWithoutScaling";
})(Vr || (Vr = {}));
class nf {
  constructor(t, e) {
    this.Neighbor = t, this.Weight = e;
  }
}
class rf {
  // The derivative value - essentially the weighted difference in position.
  get DfDv() {
    return 2 * (this.Weight * (this.ActualPos - this.DesiredPos)) / this.Scale;
  }
  constructor(t, e, i, s, n) {
    if (this.ActiveConstraintCount = 0, s <= 0)
      throw new Error("weight");
    if (n <= 0)
      throw new Error("scale");
    let r = i * s;
    if (!Number.isFinite(r) || Number.isNaN(r))
      throw new Error("desiredPos");
    if (r = i * n, !Number.isFinite(r) || Number.isNaN(r))
      throw new Error("desiredPos");
    this.Ordinal = t, this.UserData = e, this.DesiredPos = i, this.Weight = s, this.Scale = n, this.OffsetInBlock = 0, this.ActualPos = this.DesiredPos;
  }
  Reinitialize() {
    this.ActiveConstraintCount = 0, this.OffsetInBlock = 0, this.ActualPos = this.DesiredPos;
  }
  AddNeighbor(t, e) {
    this.Neighbors == null && (this.Neighbors = new Array()), this.Neighbors.push(new nf(t, e));
  }
  // Gets a string representation of the Variable; calls UserData.ToString as part of this.
  // <returns>A string representation of the variable.</returns>
  toString() {
    return Bt.String.format("{0} {1:F5} ({2:F5}) {3:F5} {4:F5}", this.Name, this.ActualPos, this.DesiredPos, this.Weight, this.Scale);
  }
  // Gets the string representation of UserData.
  // <returns>A string representation of Node.Object.</returns>
  get Name() {
    return this.UserData == null ? "-0-" : this.UserData.toString();
  }
  SetConstraints(t, e) {
    this.LeftConstraints = t, this.RightConstraints = e;
  }
  // Compare the Variables by their ordinals, in ascending order (this === lhs, other === rhs).
  // The object being compared to.
  // <returns>-1 if this.Ordinal is "less"; +1 if this.Ordinal is "greater"; 0 if this.Ordinal
  //         and rhs are equal.</returns>
  CompareTo(t) {
    return yt(this.Ordinal, t.Ordinal);
  }
}
class Mn {
  get IsFull() {
    return this.numConstraints === Mn.MaxConstraints;
  }
  Clear() {
    this.LowViolation = 0, this.numConstraints = 0, this.constraints || (this.constraints = new Array(Mn.MaxConstraints));
  }
  FilterBlock(t) {
    this.LowViolation = Number.MAX_VALUE;
    const e = this.numConstraints > 0;
    for (let i = this.numConstraints - 1; i >= 0; i--) {
      const s = this.constraints[i];
      if (s.Left.Block === t || s.Right.Block === t || s.IsActive || s.IsUnsatisfiable)
        i < this.numConstraints - 1 && (this.constraints[i] = this.constraints[this.numConstraints - 1]), this.numConstraints--;
      else {
        const n = s.Left.ActualPos * s.Left.Scale + (s.Gap - s.Right.ActualPos * s.Right.Scale);
        n < this.LowViolation && (this.LowViolation = n);
      }
    }
    return this.numConstraints === 0 && (this.LowViolation = 0), e;
  }
  // Find the highest constraint with a greater violation than targetViolation.
  FindIfGreater(t) {
    let e = null;
    for (let i = 0; i < this.numConstraints; i++) {
      const s = this.constraints[i], n = s.Left.ActualPos * s.Left.Scale + (s.Gap - s.Right.ActualPos * s.Right.Scale);
      n > t && (t = n, e = s);
    }
    return e;
  }
  Insert(t, e) {
    let i = 0, s = e, n = e;
    for (let r = 0; r < this.numConstraints; r++) {
      const a = this.constraints[r], l = a.Left.ActualPos * a.Left.Scale + (a.Gap - a.Right.ActualPos * a.Right.Scale);
      l < s ? (n = s, i = r, s = l) : l < n && (n = l);
    }
    this.IsFull ? (this.constraints[i] = t, this.LowViolation = n) : (this.constraints[this.numConstraints++] = t, this.IsFull && (this.LowViolation = s));
  }
}
Mn.MaxConstraints = 20;
class ll {
  constructor(t, e) {
    this.NumberOfLeftConstraints = 0, this.Constraints = t, this.NumberOfLeftConstraints = e;
  }
}
class of {
  constructor() {
    this.allBlocks = new $d(), this.allConstraints = new tf(), this.numberOfConstraints = 0, this.numberOfVariables = 0, this.equalityConstraints = new Array(), this.loadedVariablesAndConstraintLists = /* @__PURE__ */ new Map(), this.emptyConstraintList = new Array(0), this.updatedConstraints = new Array(), this.violationCache = new Mn(), this.violationCacheMinBlockCutoff = 0, this.nextVariableOrdinal = 0, this.solverParams = new pa(), this.solverSolution = new Fr();
  }
  get IsQpsc() {
    return this.hasNeighbourPairs || this.solverParams.Advanced.ForceQpsc;
  }
  // Add a Variable (for example, wrapping a node on one axis of the graph) to the Solver.
  // a tag or other user data - can be null
  // The position of the variable, such as the coordinate of a node along one axis.
  // <returns>The created variable</returns>
  AddVariableAN(t, e) {
    return this.AddVariableANNN(t, e, 1, 1);
  }
  // Add a Variable (for example, wrapping a node on one axis of the graph) to the Solver.
  // a tag or other user data - can be null
  // The position of the variable, such as the coordinate of a node along one axis.
  // The weight of the variable (makes it less likely to move if the weight is high).
  AddVariableANN(t, e, i) {
    return this.AddVariableANNN(t, e, i, 1);
  }
  // Add a Variable (for example, wrapping a node on one axis of the graph) to the Solver.
  // a tag or other user data - can be null
  // The position of the variable, such as the coordinate of a node along one axis.
  // The weight of the variable (makes it less likely to move if the weight is high).
  // The scale of the variable, for improving convergence.
  // <returns>The created variable</returns>
  AddVariableANNN(t, e, i, s) {
    if (!this.allConstraints.IsEmpty)
      throw new Error("Cannot add Variables or Constraints once Solve() has been called");
    const n = new rf(this.nextVariableOrdinal++, t, e, i, s), r = new Gr(n, this.allConstraints);
    return n.Block = r, this.allBlocks.Add(r), this.numberOfVariables++, this.loadedVariablesAndConstraintLists.set(n, new ll(new Array(), 0)), n;
  }
  // end AddVariable()
  // Must be called before Solve() if the caller has updated variable Initial positions; this
  // reconciles internals such as Block.ReferencePos.
  UpdateVariables() {
    for (const t of this.allBlocks.Vector)
      t.UpdateReferencePos();
  }
  // end UpdateVariables()
  // This enumerates all Variables created by AddVariable.
  get Variables() {
    return Yn(this.allBlocks.Vector, (t) => t.Variables);
  }
  // The number of variables added to the Solver.
  get VariableCount() {
    return this.numberOfVariables;
  }
  // This enumerates all Constraints created by AddConstraint (which in turn may have
  // been called from OverlapRemoval.ConstraintGenerator.Generate()).
  *Constraints() {
    if (this.allConstraints.IsEmpty)
      for (const t of this.loadedVariablesAndConstraintLists.keys()) {
        const e = this.loadedVariablesAndConstraintLists.get(t);
        if (e.Constraints != null) {
          const i = e.Constraints.length;
          for (let s = 0; s < i; s++) {
            const n = e.Constraints[s];
            if (t === n.Left)
              return yield, n;
          }
        }
      }
    else
      for (const t of this.allConstraints.Vector)
        yield t;
  }
  // end Constraints property
  // The number of constraints added to the Solver.
  get ConstraintCount() {
    return this.numberOfConstraints;
  }
  // Add a constraint 'left + gap' is equal to right
  AddEqualityConstraint(t, e, i) {
    return this.AddConstraintVVNB(t, e, i, !0);
  }
  // Add a constraint 'left + gap' is less than or equal to 'right'
  // The gap required between the variables.
  // <returns>The new constraint.</returns>
  AddConstraintVVNB(t, e, i, s) {
    if (!this.allConstraints.IsEmpty)
      throw new Error("Cannot add Variables or Constraints once Solve() has been called");
    if (t === e)
      throw new Error("Cannot add a constraint between a variable and itself");
    const n = this.loadedVariablesAndConstraintLists.get(t), r = this.loadedVariablesAndConstraintLists.get(e), a = Bn.constructorVVNB(t, e, i, s);
    return this.loadedVariablesAndConstraintLists.set(t, new ll(n.Constraints, n.NumberOfLeftConstraints + 1)), n.Constraints.push(a), r.Constraints.push(a), this.numberOfConstraints++, s && this.equalityConstraints.push(a), a;
  }
  // Add a constraint 'left + gap' is less than or equal to 'right'
  // The gap required between the variables.
  // <returns>The new constraint.</returns>
  AddConstraint(t, e, i) {
    return this.AddConstraintVVNB(t, e, i, !1);
  }
  // Register an update to a constraint's gap; this defers the actual update until Solve() is called.
  // The constraint to update
  // The new gap
  SetConstraintUpdate(t, e) {
    e !== t.Gap && this.updatedConstraints.push([t, e]);
  }
  // Add a pair of connected variables for goal functions of the form (x1-x2)^2.  These are
  // minimally satisfied, along with the default (x-i)^2 goal function, while also satisfying
  // all constraints.
  // The first variable
  // The second variable
  // The weight of the relationship
  AddNeighborPair(t, e, i) {
    if (i <= 0 || Number.isNaN(i) || !Number.isFinite(i))
      throw new Error("relationshipWeight");
    if (t === e)
      throw new Error();
    t.AddNeighbor(e, i), e.AddNeighbor(t, i), this.hasNeighbourPairs = !0;
  }
  // end AddNeighborPair()
  // Sets Variable.ActualPos to the positions of the Variables that minimally satisfy the constraints
  // along this axis.  This overload uses default solution parameter values.
  // <returns>A Solution object.</returns>
  Solve() {
    return this.SolvePar(null);
  }
  // Sets Variable.ActualPos to the positions of the Variables that minimally satisfy the constraints
  // along this axis.  This overload takes a parameter specification.
  // Solution-generation options.
  // <returns>The only failure condition is if there are one or more unsatisfiable constraints, such as cycles
  //         or mutually exclusive equality constraints; if these are encountered, a list of lists of these
  //         constraints is returned, where each list contains a single cycle, which may be of length one for
  //         unsatisfiable equality constraints.  Otherwise, the return value is null.</returns>
  SolvePar(t) {
    t && (this.solverParams = t.Clone()), this.solverParams.OuterProjectIterationsLimit < 0 && (this.solverParams.OuterProjectIterationsLimit = 100 * (Math.floor(Math.log2(this.numberOfVariables)) + 1)), this.solverParams.InnerProjectIterationsLimit < 0 && (this.solverParams.InnerProjectIterationsLimit = this.numberOfConstraints * 2 + 100 * (Math.max(0, Math.floor(Math.log2(this.numberOfConstraints))) + 1));
    const e = !this.allConstraints.IsEmpty;
    if (this.CheckForUpdatedConstraints(), this.solverSolution = new Fr(), this.solverSolution.MinInnerProjectIterations = Number.MAX_VALUE, this.allConstraints.MaxConstraintTreeDepth = 0, this.allConstraints.SolverParameters = this.solverParams, this.numberOfConstraints === 0) {
      if (!this.IsQpsc)
        return this.solverSolution.Clone();
    } else e || this.SetupConstraints();
    return this.allConstraints.NumberOfUnsatisfiableConstraints = 0, this.MergeEqualityConstraints(), this.IsQpsc ? this.SolveQpsc() : (this.SolveByStandaloneProject(), this.CalculateStandaloneProjectGoalFunctionValue()), this.solverSolution.MinInnerProjectIterations > this.solverSolution.MaxInnerProjectIterations && (this.solverSolution.MinInnerProjectIterations = this.solverSolution.MaxInnerProjectIterations), this.solverSolution.NumberOfUnsatisfiableConstraints = this.allConstraints.NumberOfUnsatisfiableConstraints, this.solverSolution.MaxConstraintTreeDepth = this.allConstraints.MaxConstraintTreeDepth, this.solverSolution.Clone();
  }
  // end Solve()
  CheckForUpdatedConstraints() {
    if (this.updatedConstraints.length === 0)
      return;
    let t = this.IsQpsc;
    for (const [e, i] of this.updatedConstraints) {
      const s = e;
      if (s.UpdateGap(i), !t && !s.IsEquality) {
        this.SplitOnConstraintIfActive(s);
        continue;
      }
      t = !0;
    }
    this.updatedConstraints = [], t && this.ReinitializeBlocks();
  }
  SplitOnConstraintIfActive(t) {
    if (t.IsActive) {
      const e = t.Left.Block.SplitOnConstraint(t);
      e != null && this.allBlocks.Add(e);
    }
  }
  SetupConstraints() {
    this.allConstraints.Create(this.numberOfConstraints);
    for (const t of this.loadedVariablesAndConstraintLists.keys()) {
      const e = this.loadedVariablesAndConstraintLists.get(t), i = e.Constraints;
      let s = 0, n = 0, r = 0;
      i != null && (s = i.length, n = e.NumberOfLeftConstraints, r = s - n);
      let a = this.emptyConstraintList;
      n !== 0 && (a = new Array(n));
      let l = this.emptyConstraintList;
      r !== 0 && (l = new Array(r)), t.SetConstraints(a, l);
      let h = 0, c = 0;
      for (let d = 0; d < s; d++) {
        const f = i[d];
        t === f.Left ? a[h++] = f : l[c++] = f;
      }
      for (const d of t.LeftConstraints)
        this.allConstraints.Add(d);
    }
    this.loadedVariablesAndConstraintLists.clear(), this.violationCacheMinBlockCutoff = Number.MAX_VALUE, this.solverParams.Advanced.UseViolationCache && this.solverParams.Advanced.ViolationCacheMinBlocksDivisor > 0 && (this.violationCacheMinBlockCutoff = Math.min(this.allBlocks.Count / this.solverParams.Advanced.ViolationCacheMinBlocksDivisor, this.solverParams.Advanced.ViolationCacheMinBlocksCount));
  }
  SolveByStandaloneProject() {
    for (; ; ) {
      if (!this.RunProject())
        return;
      if (!this.SplitBlocks())
        break;
    }
  }
  RunProject() {
    return this.solverSolution.OuterProjectIterations++, this.Project(), !this.CheckForLimitsExceeded();
  }
  CheckForLimitsExceeded() {
    return this.solverParams.OuterProjectIterationsLimit > 0 && this.solverSolution.OuterProjectIterations >= this.solverParams.OuterProjectIterationsLimit ? (this.solverSolution.OuterProjectIterationsLimitExceeded = !0, !0) : !!this.solverSolution.InnerProjectIterationsLimitExceeded;
  }
  CalculateStandaloneProjectGoalFunctionValue() {
    this.solverSolution.GoalFunctionValue = 0;
    const t = this.allBlocks.Count;
    for (let e = 0; e < t; e++) {
      const i = this.allBlocks.item(e), s = i.Variables.length;
      for (let n = 0; n < s; n++) {
        const r = i.Variables[n];
        this.solverSolution.GoalFunctionValue += r.Weight * (r.ActualPos * r.ActualPos), this.solverSolution.GoalFunctionValue -= 2 * (r.Weight * (r.DesiredPos * r.ActualPos));
      }
    }
  }
  // Implements the full solve_QPSC from the Ipsep_Cola and Scaling papers.
  SolveQpsc() {
    if (this.solverSolution.AlgorithmUsed = this.solverParams.Advanced.ScaleInQpsc ? Vr.QpscWithScaling : Vr.QpscWithoutScaling, !this.QpscMakeFeasible())
      return;
    const t = new ge(this.solverParams, this.numberOfVariables);
    for (const i of this.allBlocks.Vector)
      for (const s of i.Variables)
        t.AddVariable(s);
    t.VariablesComplete(), this.ReinitializeBlocks(), this.MergeEqualityConstraints();
    let e = !1;
    for (; !(!t.PreProject() && !e || (e = this.SplitBlocks(), !this.RunProject()) || !t.PostProject() && !e); )
      ;
    this.solverSolution.GoalFunctionValue = t.QpscComplete();
  }
  QpscMakeFeasible() {
    return this.RunProject();
  }
  ReinitializeBlocks() {
    const t = Array.from(this.allBlocks.Vector);
    this.allBlocks.Vector = [];
    for (const e of t)
      for (const i of e.Variables) {
        i.Reinitialize();
        const s = new Gr(i, this.allConstraints);
        this.allBlocks.Add(s);
      }
    this.allConstraints.Reinitialize(), this.violationCache.Clear();
  }
  MergeEqualityConstraints() {
    for (const t of this.equalityConstraints) {
      if (t.Left.Block === t.Right.Block) {
        Math.abs(t.Violation) > this.solverParams.GapTolerance && (t.IsUnsatisfiable = !0, this.allConstraints.NumberOfUnsatisfiableConstraints++);
        continue;
      }
      this.MergeBlocks(t);
    }
  }
  Project() {
    if (this.numberOfConstraints === 0)
      return !1;
    this.violationCache.Clear(), this.lastModifiedBlock = null;
    let t = this.allBlocks.Count > this.violationCacheMinBlockCutoff, e = 1;
    const i = { maxViolation: 0 };
    let s = this.GetMaxViolatedConstraint(i, t);
    if (!s)
      return !1;
    for (; s; ) {
      if (s.Left.Block === s.Right.Block ? (s.Left.Block.Expand(s), s.IsUnsatisfiable && this.violationCache.Clear(), this.lastModifiedBlock = s.Left.Block) : this.lastModifiedBlock = this.MergeBlocks(s), this.solverParams.InnerProjectIterationsLimit > 0 && e >= this.solverParams.InnerProjectIterationsLimit) {
        this.solverSolution.InnerProjectIterationsLimitExceeded = !0;
        break;
      }
      t = this.allBlocks.Count > this.violationCacheMinBlockCutoff, t || this.violationCache.Clear(), e++;
      const n = { maxViolation: 0 };
      s = this.GetMaxViolatedConstraint(n, t);
    }
    return this.solverSolution.InnerProjectIterationsTotal = this.solverSolution.InnerProjectIterationsTotal + e, this.solverSolution.MaxInnerProjectIterations < e && (this.solverSolution.MaxInnerProjectIterations = e), this.solverSolution.MinInnerProjectIterations > e && (this.solverSolution.MinInnerProjectIterations = e), !0;
  }
  // end Project()
  MergeBlocks(t) {
    let e = t.Left.Block, i = t.Right.Block, s = t.Left.OffsetInBlock + (t.Gap - t.Right.OffsetInBlock);
    i.Variables.length > e.Variables.length && (e = t.Right.Block, i = t.Left.Block, s = -s);
    const n = i.Variables.length;
    for (let r = 0; r < n; r++) {
      const a = i.Variables[r];
      a.OffsetInBlock += s, e.AddVariable(a);
    }
    return e.UpdateReferencePosFromSums(), this.allConstraints.ActivateConstraint(t), this.allBlocks.Remove(i), e;
  }
  // end MergeBlocks()
  SplitBlocks() {
    const t = new Array(), e = this.allBlocks.Count;
    for (let s = 0; s < e; s++) {
      const r = this.allBlocks.item(s).Split(this.IsQpsc);
      r != null && t.push(r);
    }
    const i = t.length;
    for (let s = 0; s < i; s++) {
      const n = t[s];
      this.allBlocks.Add(n);
    }
    return t.length !== 0;
  }
  // end SplitBlocks
  GetMaxViolatedConstraint(t, e) {
    t.maxViolation = this.solverParams.GapTolerance;
    const i = this.SearchViolationCache(t.maxViolation);
    return i ?? this.SearchAllConstraints(t.maxViolation, e);
  }
  // end GetMaxViolatedConstraint()
  SearchViolationCache(t) {
    let e = null;
    if (this.lastModifiedBlock == null)
      return;
    this.lastModifiedBlock.Variables.length < this.numberOfVariables + 1 && this.violationCache.FilterBlock(this.lastModifiedBlock);
    const i = this.lastModifiedBlock.Variables.length;
    for (let n = 0; n < i; n++) {
      const r = this.lastModifiedBlock.Variables[n];
      for (const a of r.LeftConstraints)
        if (!a.IsActive && !a.IsUnsatisfiable) {
          const l = a.Left.ActualPos * a.Left.Scale + (a.Gap - a.Right.ActualPos * a.Right.Scale);
          fo(l, t) && (e != null && t > this.violationCache.LowViolation && this.violationCache.Insert(e, t), t = a.Violation, e = a);
        }
      for (const a of r.RightConstraints)
        if (!a.IsActive && !a.IsUnsatisfiable && a.Left.Block !== this.lastModifiedBlock) {
          const l = a.Left.ActualPos * a.Left.Scale + (a.Gap - a.Right.ActualPos * a.Right.Scale);
          fo(l, t) && (e != null && t > this.violationCache.LowViolation && this.violationCache.Insert(e, t), t = l, e = a);
        }
    }
    const s = this.violationCache.FindIfGreater(t);
    return s != null && (e != null && t > this.violationCache.LowViolation && this.violationCache.Insert(e, t), e = s), e;
  }
  SearchAllConstraints(t, e) {
    let i = null;
    this.violationCache.Clear();
    for (const s of this.allConstraints.Vector) {
      if (s.IsActive)
        break;
      if (s.IsUnsatisfiable)
        continue;
      const n = s.Left.ActualPos * s.Left.Scale + (s.Gap - s.Right.ActualPos * s.Right.Scale);
      let r = null, a = 0;
      fo(n, t) && (t > this.violationCache.LowViolation && (r = i, a = t), t = n, i = s), e && (r == null && s !== i && (!this.violationCache.IsFull || n > this.violationCache.LowViolation) && (r = s, a = n), r != null && a > this.violationCache.LowViolation && this.violationCache.Insert(r, a));
    }
    return i;
  }
}
class Gn {
  // Constructor.
  constructor() {
    this.variables = /* @__PURE__ */ new Map(), this.fixedVars = /* @__PURE__ */ new Map(), this.FailToAdjustEpsilon = 1e-3, this.InitSolver();
  }
  // Add a node that we would like as close to position i as possible, with the requested weight.
  // Caller's unique identifier for this node
  // Desired position
  // The weight of the corresponding term in the goal function
  AddVariableWithIdealPositionNNN(t, e, i) {
    this.variables.set(t, this.solver.AddVariableANN(t, e, i));
  }
  // Add a node that we would like as close to position i as possible, with the requested weight.
  AddVariableWithIdealPositionNN(t, e) {
    this.AddVariableWithIdealPositionNNN(t, e, 1);
  }
  // Add a constraint that leftNode+gap eq|leq RightNode.
  // Caller's unique identifier for the left node
  // Caller's unique identifier for the right node
  // Required gap
  // Gap is exact rather than minimum
  AddLeftRightSeparationConstraintNNNB(t, e, i, s) {
    const n = this.GetVariable(t);
    if (n == null)
      return;
    const r = this.GetVariable(e);
    r != null && this.solver.AddConstraintVVNB(n, r, i, s);
  }
  // Add a constraint that leftNode+gap leq RightNode.
  // Caller's unique identifier for the left node
  // Caller's unique identifier for the right node
  // Required minimal gap
  AddLeftRightSeparationConstraintNNN(t, e, i) {
    this.AddLeftRightSeparationConstraintNNNB(t, e, i, !1);
  }
  // Add a goal that minimizes the distance between two nodes, i.e. weight*((id1-id2)^2).
  // Caller's unique identifier for the first node.
  // Caller's unique identifier for the second node.
  // The weight of the corresponding term in the goal function
  AddGoalTwoVariablesAreCloseNNN(t, e, i) {
    const s = this.GetVariable(t);
    if (s == null)
      return;
    const n = this.GetVariable(e);
    n != null && this.solver.AddNeighborPair(s, n, i);
  }
  //
  AddGoalTwoVariablesAreClose(t, e) {
    this.AddGoalTwoVariablesAreCloseNNN(t, e, 1);
  }
  GetVariable(t) {
    return this.variables.get(t);
  }
  // Execute the solver, filling in the Solution object and the values to be returned by GetVariableResolvedPosition.
  Solve() {
    this.SolveP(null);
  }
  // Execute the solver, filling in the Solution object and the values to be returned by GetVariableResolvedPosition.
  // Parameter object class specific to the underlying solver
  // <returns>Pass or fail</returns>
  SolveP(t) {
    const e = { executionLimitExceeded: !1 };
    this.SolvePNS(t, e);
  }
  // Execute the solver, filling in the Solution object and the values to be returned by GetVariableResolvedPosition.
  // Parameter object class specific to the underlying solver
  //         or timeout were exceeded</param>
  // <returns>Pass or fail</returns>
  SolvePNS(t, e) {
    let i;
    do {
      this.solution = null;
      let s = null;
      if (t != null && (s = t, s == null))
        throw new Error("parameters");
      this.solution = this.solver.SolvePar(s), e.executionLimitExceeded = this.solution.ExecutionLimitExceeded, i = this.AdjustConstraintsForMovedFixedVars();
    } while (i && this.solution.ExecutionLimitExceeded === !1);
    return this.solution.ExecutionLimitExceeded === !1;
  }
  //        void DumpToFile(string fileName) {
  //            var file = new StreamWriter(fileName);
  //            file.WriteLine("digraph {");
  //            foreach (var v in solver.Variables) {
  //                var s = v.Weight > 100 ? "color=\"red\"" : "";
  //                file.WriteLine(v.UserData + " [ label=" + "\"" + v.UserData +"\\n" +
  //                               v.DesiredPos + "\" " +s+ "]");
  //
  //            }
  //
  //            foreach (var cs in solver.Constraints) {
  //                file.WriteLine(cs.Left.UserData + " -> " + cs.Right.UserData + " [ label=\"" + cs.Gap + "\"]");
  //            }
  //            file.WriteLine("}");
  //            file.Close();
  //        }
  AdjustConstraintsForMovedFixedVars() {
    const t = /* @__PURE__ */ new Set();
    for (const [e, i] of this.fixedVars.entries())
      Gn.Close(i, this.GetVariableResolvedPosition(e)) || t.add(e);
    return t.size === 0 ? !1 : this.AdjustConstraintsForMovedFixedVarSet(t);
  }
  static Close(t, e) {
    return Math.abs(t - e) < 5e-4;
  }
  AdjustConstraintsForMovedFixedVarSet(t) {
    for (; t.size > 0; ) {
      let e;
      for (const i of t) {
        e = i;
        break;
      }
      if (!this.AdjustSubtreeOfFixedVar(e, t))
        return !1;
    }
    return !0;
  }
  AdjustSubtreeOfFixedVar(t, e) {
    const i = { successInAdjusting: !1 }, s = this.AdjustConstraintsOfNeighborsOfFixedVariable(t, i);
    if (!i.successInAdjusting || s.length === 0)
      return !1;
    for (const n of s)
      e.delete(n);
    return !0;
  }
  // returns the block of the fixed variable
  AdjustConstraintsOfNeighborsOfFixedVariable(t, e) {
    const i = this.variables.get(t).Block.Variables, s = new zi(), n = new zi();
    let r = 1;
    for (const a of i)
      this.fixedVars.has(a.UserData) && (s.AddValue(a.ActualPos), n.AddValue(a.DesiredPos), n.length > 0 && (r = Math.max(r, s.length / n.length)));
    return r === 1 && (r = 2), e.successInAdjusting = this.FixActiveConstraints(i, r), i.map((a) => a.UserData);
  }
  FixActiveConstraints(t, e) {
    let i = !1;
    for (const s of t)
      for (const n of s.LeftConstraints)
        n.IsActive && (n.Gap > this.FailToAdjustEpsilon && (i = !0), this.solver.SetConstraintUpdate(n, n.Gap / e));
    return i;
  }
  // Obtain the solved position for a node.
  // Caller's unique identifier for the node.
  // <returns>The node's solved position.</returns>
  GetVariableResolvedPosition(t) {
    const e = this.GetVariable(t);
    return e == null ? 0 : e.ActualPos;
  }
  //
  InitSolver() {
    this.solver = new of(), this.variables.clear();
  }
  // Add a variable with a known and unchanging position.
  // Caller's unique identifier for the node
  // Desired position.
  AddFixedVariable(t, e) {
    this.AddVariableWithIdealPositionNNN(t, e, Gn.FixedVarWeight), this.fixedVars.set(t, e);
  }
  //
  ContainsVariable(t) {
    return this.variables.has(t);
  }
  // returns the ideal position of the node that had been set at the variable construction
  GetVariableIdealPosition(t) {
    return this.variables.get(t).DesiredPos;
  }
  // Returns the solution object class specific to the underlying solver, or null if there has
  // been no call to Solve() or it threw an exception.
  get Solution() {
    return this.solution;
  }
}
Gn.FixedVarWeight = 1e9;
class af {
  constructor() {
    this.lowBound = Number.NEGATIVE_INFINITY, this.upperBound = Number.POSITIVE_INFINITY;
  }
  get Position() {
    return this.position;
  }
  set Position(t) {
    t < this.lowBound ? this.position = this.lowBound : t > this.upperBound ? this.position = this.upperBound : this.position = t;
  }
  get LowBound() {
    return this.lowBound;
  }
  set LowBound(t) {
    this.lowBound = t;
  }
  get UpperBound() {
    return this.upperBound;
  }
  set UpperBound(t) {
    this.upperBound = t;
  }
  toString() {
    return this.lowBound + (" " + (this.Position + (" " + this.upperBound)));
  }
}
class lf {
  // desired variable separation
  constructor(t) {
    this.idealPositions = /* @__PURE__ */ new Map(), this.varList = new Array(), this.constraints = /* @__PURE__ */ new Set(), this.solverShell = new Gn(), this.boundsToInt = /* @__PURE__ */ new Map(), this.varSepartion = t;
  }
  //        delegate Array<NudgerConstraint> Edges(int i);
  //
  //        delegate int End(NudgerConstraint constraint);
  //        Edges outEdgesDel;
  //        Edges inEdgesDel;
  //        End sourceDelegate;
  //        End targetDelegate;
  //        Supremum minDel;
  //        Supremum maxDel;
  SetLowBound(t, e) {
    const i = this.Var(e);
    i.LowBound = Math.max(t, i.LowBound);
  }
  Var(t) {
    return this.varList[t];
  }
  SetUpperBound(t, e) {
    const i = this.Var(t);
    i.UpperBound = Math.min(e, i.UpperBound);
  }
  Solve() {
    this.SolveByRegularSolver();
  }
  SolveByRegularSolver() {
    this.CreateVariablesForBounds();
    for (let t = 0; t < this.varList.length; t++) {
      const e = this.varList[t];
      e.IsFixed ? this.solverShell.AddFixedVariable(t, e.Position) : (this.solverShell.AddVariableWithIdealPositionNN(t, this.idealPositions.get(t)), e.LowBound !== Number.NEGATIVE_INFINITY && this.constraints.add(new U(this.GetBoundId(e.LowBound), t)), e.UpperBound !== Number.POSITIVE_INFINITY && this.constraints.add(new U(t, this.GetBoundId(e.UpperBound))));
    }
    this.CreateGraphAndRemoveCycles();
    for (const t of this.graph.edges) {
      let e = 0;
      t.x < this.varList.length && (e += this.varList[t.x].Width), t.y < this.varList.length && (e += this.varList[t.y].Width), e /= 2, this.solverShell.AddLeftRightSeparationConstraintNNN(t.x, t.y, this.varSepartion + e);
    }
    this.solverShell.Solve();
    for (let t = 0; t < this.varList.length; t++)
      this.varList[t].Position = this.solverShell.GetVariableResolvedPosition(t);
  }
  GetBoundId(t) {
    return this.boundsToInt.get(t);
  }
  CreateVariablesForBounds() {
    for (const t of this.varList)
      t.IsFixed || (t.LowBound !== Number.NEGATIVE_INFINITY && this.RegisterBoundVar(t.LowBound), t.UpperBound !== Number.POSITIVE_INFINITY && this.RegisterBoundVar(t.UpperBound));
  }
  RegisterBoundVar(t) {
    if (!this.boundsToInt.has(t)) {
      const e = this.varList.length + this.boundsToInt.size;
      this.boundsToInt.set(t, e), this.solverShell.AddFixedVariable(e, t);
    }
  }
  CreateGraphAndRemoveCycles() {
    this.graph = fi(Array.from(this.constraints), this.varList.length + this.boundsToInt.size);
    const t = Zi.getFeedbackSet(this.graph);
    if (t != null)
      for (const e of t)
        this.graph.removeEdge(e);
  }
  GetVariablePosition(t) {
    return this.varList[t].Position;
  }
  AddConstraint(t, e) {
    this.constraints.add(new U(t, e));
  }
  AddVariableNNNN(t, e, i, s) {
    this.idealPositions.set(t, i), this.AddVariableNNBN(t, e, !1, s);
  }
  AddFixedVariable(t, e) {
    this.AddVariableNNBN(t, e, !0, 0);
  }
  AddVariableNNBN(t, e, i, s) {
    const n = new af();
    n.Position = e, n.IsFixed = i, n.Width = s, this.varList.push(n);
  }
}
class q {
  clone() {
    const t = new q();
    return t.transparency = this.transparency, t.width = this.width, t.color = this.color, t.icurve = this.icurve.clone(), t.label = this.label, t.dashArray = this.dashArray, t.drawPN = this.drawPN, t;
  }
  static mkDebugCurveTWCILD(t, e, i, s, n, r, a = !1) {
    const l = new q();
    return l.transparency = t, l.width = e, l.color = i, l.icurve = s, l.label = n, l.dashArray = r, l.drawPN = a, l;
  }
  static mkDebugCurveTWCI(t, e, i, s) {
    return q.mkDebugCurveTWCILD(t, e, i, s, null, null);
  }
  static mkDebugCurveWCI(t, e, i) {
    return q.mkDebugCurveTWCI(255, t, e, i);
  }
  static mkDebugCurveCI(t, e) {
    return q.mkDebugCurveWCI(1, t, e);
  }
  static mkDebugCurveI(t) {
    return q.mkDebugCurveCI("Black", t);
  }
}
q.colors = [
  "DeepSkyBlue",
  "IndianRed",
  "Orange",
  "Gold",
  "DarkRed",
  "Plum",
  "Red",
  "Violet",
  "Indigo",
  "Yellow",
  "OrangeRed",
  "Tomato",
  "Purple",
  "SaddleBrown",
  "Green",
  "Navy",
  "Aqua",
  "Pink",
  "Bisque",
  "Black",
  "BlanchedAlmond",
  "Blue",
  "BlueViolet",
  "Brown",
  "Lime",
  "BurlyWood",
  "Chocolate",
  "Coral",
  "CornflowerBlue",
  "Cornsilk",
  "Crimson",
  "Cyan",
  "CadetBlue",
  "Chartreuse",
  "DarkBlue",
  "DarkCyan",
  "DarkGoldenrod",
  "DarkGray",
  "DarkGreen",
  "DarkKhaki",
  "DarkMagenta",
  "DarkOliveGreen",
  "DarkOrange",
  "DarkOrchid",
  "DarkSalmon",
  "DarkSeaGreen",
  "DarkSlateBlue",
  "DarkSlateGray",
  "DarkTurquoise",
  "DarkViolet",
  "DeepPink",
  "DimGray",
  "DodgerBlue",
  "Firebrick",
  "FloralWhite",
  "ForestGreen",
  "Fuchsia",
  "CodeAnalysis",
  "Gainsboro",
  "GhostWhite",
  "Goldenrod",
  "Gray",
  "GreenYellow",
  "Honeydew",
  "HotPink",
  "Ivory",
  "Lavender",
  "LavenderBlush",
  "LawnGreen",
  "LemonChiffon",
  "LightBlue",
  "LightCoral",
  "LightCyan",
  "LightGoldenrodYellow",
  "LightGray",
  "LightGreen",
  "LightPink",
  "LightSalmon",
  "LightSeaGreen",
  "LightSkyBlue",
  "LightSlateGray",
  "LightSteelBlue",
  "LightYellow",
  "LimeGreen",
  "Linen",
  "Magenta",
  "Maroon",
  "MediumAquamarine",
  "MediumBlue",
  "MediumOrchid",
  "MediumPurple",
  "MediumSeaGreen",
  "MediumSlateBlue",
  "MediumSpringGreen",
  "MediumTurquoise",
  "MediumVioletRed",
  "MidnightBlue",
  "MintCream",
  "MistyRose",
  "Moccasin",
  "NavajoWhite",
  "OldLace",
  "Olive",
  "OliveDrab",
  "Orchid",
  "PaleGoldenrod",
  "PaleGreen",
  "PaleTurquoise",
  "PaleVioletRed",
  "PapayaWhip",
  "PeachPuff",
  "Peru",
  "PowderBlue",
  "RosyBrown",
  "RoyalBlue",
  "Salmon",
  "SandyBrown",
  "SeaGreen",
  "CodeAnalysis",
  "SeaShell",
  "Sienna",
  "Silver",
  "SkyBlue",
  "SlateBlue",
  "SlateGray",
  "Snow",
  "SpringGreen",
  "SteelBlue",
  "Tan",
  "Teal",
  "Thistle",
  "Transparent",
  "Turquoise",
  "Aquamarine",
  "Azure",
  "Beige",
  "Wheat",
  "White",
  "WhiteSmoke",
  "YellowGreen",
  "Khaki",
  "AntiqueWhite"
];
class hf extends ce {
  constructor(t, e) {
    super(t, e), this.RightNeighbors = /* @__PURE__ */ new Set(), this.setOfLongestSegs = /* @__PURE__ */ new Set(), this.RightBound = Number.POSITIVE_INFINITY, this.LeftBound = Number.NEGATIVE_INFINITY, this.Direction = w.DirectionFromPointToPoint(t.point, e.point);
  }
  AddRightNeighbor(t) {
    this.RightNeighbors.add(t);
  }
  get LongestNudgedSegments() {
    return this.setOfLongestSegs;
  }
  AddLongestNudgedSegment(t) {
    this.setOfLongestSegs.add(t);
  }
  BoundFromRight(t) {
    t = Math.max(t, this.LeftBound), this.RightBound = Math.min(t, this.RightBound);
  }
  BoundFromLeft(t) {
    t = Math.min(t, this.RightBound), this.LeftBound = Math.max(t, this.LeftBound);
  }
}
class Ri {
  constructor(t) {
    this.Point = t;
  }
  *GetEnumerator() {
    let t;
    for (t = this; t != null; t = t.Next)
      yield t.Point;
  }
  get X() {
    return this.Point.x;
  }
  get Y() {
    return this.Point.y;
  }
  InsertVerts(t, e, i) {
    for (e--; t < e; e--)
      this.SetNewNext(i[e]);
  }
  InsertVertsInReverse(t, e, i) {
    for (t++; t < e; t++)
      this.SetNewNext(i[t]);
  }
  SetNewNext(t) {
    const e = new Ri(t), i = this.Next;
    this.Next = e, e.Next = i;
  }
}
class Dr {
  toString() {
    return this.Source + (" " + this.Target);
  }
  constructor(t, e) {
    this.IsFixed = !1, this.Reversed = !1, this.index = -1, this.AxisEdge = t, this.Width = e;
  }
  // It is the offset of the edge from the underlying line segment
  // [VisibilityEdge.SourcePoint, VisibilityEdge.TargetPoint] in to the direction of the VisibilityEdge.Perpendicular.
  // Offset holder is the same for the maximal parallel sequence of connected PathEdges
  get LongestNudgedSegment() {
    return this.longestNudgedSegment;
  }
  set LongestNudgedSegment(t) {
    this.longestNudgedSegment = t, this.longestNudgedSegment != null && (this.longestNudgedSegment.AddEdge(this), this.AxisEdge.AddLongestNudgedSegment(this.longestNudgedSegment));
  }
  get Source() {
    return this.Reversed ? this.AxisEdge.TargetPoint : this.AxisEdge.SourcePoint;
  }
  get Target() {
    return this.Reversed ? this.AxisEdge.SourcePoint : this.AxisEdge.TargetPoint;
  }
  static VectorsAreParallel(t, e) {
    return D(t.x * e.y - t.y * e.x, 0);
  }
  static EdgesAreParallel(t, e) {
    return Dr.VectorsAreParallel(t.AxisEdge.TargetPoint.sub(t.AxisEdge.SourcePoint), e.AxisEdge.TargetPoint.sub(e.AxisEdge.SourcePoint));
  }
  get Direction() {
    return this.Reversed ? w.OppositeDir(this.AxisEdge.Direction) : this.AxisEdge.Direction;
  }
  // not set yet
  // the index of the edge in the order
  get Index() {
    return this.index;
  }
  set Index(t) {
    this.index = t;
  }
}
class Dt {
  get PathVisibilityGraph() {
    return this.pathVisibilityGraph;
  }
  constructor(t) {
    this.pathVisibilityGraph = new Et(), this.axisEdgesToPathOrders = /* @__PURE__ */ new Map(), this.OriginalPaths = t;
  }
  GetOrder() {
    return this.FillTheVisibilityGraphByWalkingThePaths(), this.InitPathOrder(), this.OrderPaths(), this.axisEdgesToPathOrders;
  }
  FillTheVisibilityGraphByWalkingThePaths() {
    for (const t of this.OriginalPaths)
      this.FillTheVisibilityGraphByWalkingPath(t);
  }
  FillTheVisibilityGraphByWalkingPath(t) {
    const e = this.CreatePathEdgesFromPoints(s(), t.Width);
    let i = e.next();
    for (i.done || t.SetFirstEdge(i.value); (i = e.next()).done === !1; )
      t.AddEdge(i.value);
    function* s() {
      if (t.PathPoints instanceof Ri)
        for (let n = t.PathPoints; n != null; n = n.Next)
          yield n.Point;
      else
        for (const n of t.PathPoints)
          yield n;
    }
  }
  *CreatePathEdgesFromPoints(t, e) {
    let i = t.next(), s = i.value;
    for (; !(i = t.next()).done; )
      yield this.CreatePathEdge(s, i.value, e), s = i.value;
  }
  CreatePathEdge(t, e, i) {
    switch (w.DirectionFromPointToPoint(t, e)) {
      case S.East:
      case S.North:
        return new Dr(this.GetAxisEdge(t, e), i);
      case S.South:
      case S.West: {
        const n = new Dr(this.GetAxisEdge(e, t), i);
        return n.Reversed = !0, n;
      }
      default:
        throw new Error("Not a rectilinear path");
    }
  }
  GetAxisEdge(t, e) {
    return this.PathVisibilityGraph.AddEdgeF(t, e, (i, s) => new hf(i, s));
  }
  InitPathOrder() {
    for (const t of this.PathVisibilityGraph.Edges)
      this.axisEdgesToPathOrders.set(t, new Array());
    for (const t of this.OriginalPaths)
      for (const e of t.PathEdges())
        this.axisEdgesToPathOrders.get(e.AxisEdge).push(e);
  }
  OrderPaths() {
    for (const t of Dt.WalkGraphEdgesInTopologicalOrderIfPossible(this.PathVisibilityGraph))
      this.OrderPathEdgesSharingEdge(t);
  }
  OrderPathEdgesSharingEdge(t) {
    const e = this.PathOrderOfVisEdge(t);
    e.sort(Dt.CompareTwoPathEdges);
    let i = 0;
    for (const s of e)
      s.Index = i++;
  }
  static CompareTwoPathEdges(t, e) {
    if (t === e)
      return 0;
    const i = Dt.CompareInDirectionStartingFromAxisEdge(t, e, t.AxisEdge, t.AxisEdge.Direction);
    return i !== 0 ? i : -Dt.CompareInDirectionStartingFromAxisEdge(t, e, t.AxisEdge, w.OppositeDir(t.AxisEdge.Direction));
  }
  //
  // axisEdge together with the axisEdgeIsReversed parameter define direction of the movement over the paths
  static CompareInDirectionStartingFromAxisEdge(t, e, i, s) {
    for (; ; ) {
      if (t = Dt.GetNextPathEdgeInDirection(t, i, s), t == null || (e = Dt.GetNextPathEdgeInDirection(e, i, s), e == null))
        return 0;
      if (t.AxisEdge === e.AxisEdge) {
        s = Dt.FindContinuedDirection(i, s, t.AxisEdge), i = t.AxisEdge;
        const h = Dt.GetExistingOrder(t, e);
        if (h === Dt.NotOrdered)
          continue;
        return s === i.Direction ? h : -h;
      }
      const n = s === i.Direction ? i.Target : i.Source, r = Dt.OtherVertex(t.AxisEdge, n), a = Dt.OtherVertex(e.AxisEdge, n), l = Dt.ProjectionForCompare(i, s !== i.Direction);
      return yt(l(r.point), l(a.point));
    }
  }
  static FindContinuedDirection(t, e, i) {
    return t.Direction === e ? i.Source === t.Target ? i.Direction : w.OppositeDir(i.Direction) : i.Source === t.Source ? i.Direction : w.OppositeDir(i.Direction);
  }
  static OtherVertex(t, e) {
    return t.Source === e ? t.Target : t.Source;
  }
  static ProjectionForCompare(t, e) {
    return t.Direction === S.North ? e ? (i) => -i.x : (i) => i.x : e ? (i) => i.y : (i) => -i.y;
  }
  static GetNextPathEdgeInDirection(t, e, i) {
    return e.Direction === i ? t.Reversed ? t.Prev : t.Next : t.Reversed ? t.Next : t.Prev;
  }
  static GetExistingOrder(t, e) {
    const i = t.Index;
    if (i === -1)
      return Dt.NotOrdered;
    const s = e.Index;
    return yt(i, s);
  }
  PathOrderOfVisEdge(t) {
    return this.axisEdgesToPathOrders.get(t);
  }
  static InitQueueOfSources(t, e, i) {
    for (const s of i.Vertices()) {
      const n = s.InEdgesLength();
      e.set(s, n), n === 0 && t.enqueue(s);
    }
  }
  static *WalkGraphEdgesInTopologicalOrderIfPossible(t) {
    const e = new We.Queue(), i = /* @__PURE__ */ new Map();
    for (Dt.InitQueueOfSources(e, i, t); e.length > 0; ) {
      const s = e.dequeue();
      for (const n of s.OutEdges) {
        const r = i.get(n.Target);
        i.set(n.Target, r - 1), r === 1 && e.enqueue(n.Target), yield n;
      }
    }
  }
}
Dt.NotOrdered = Number.MAX_VALUE;
class cf extends Bi {
  constructor(t, e) {
    super(), this.site = e, this.AxisEdge = t;
  }
  get Site() {
    return this.site;
  }
}
class hl extends Bi {
  constructor(t, e) {
    super(), this.site = e, this.AxisEdge = t;
  }
  get Site() {
    return this.site;
  }
}
class uf {
  get Edges() {
    return this.edges;
  }
  AddEdge(t) {
    this.UpPoint = t.TargetPoint, this.edges.add(t);
  }
  constructor(t) {
    this.edges = /* @__PURE__ */ new Set(), this.Source = t;
  }
  RemoveAxis(t) {
    this.edges.delete(t);
  }
  IsEmpty() {
    return this.edges.size === 0;
  }
}
class Ii extends _h {
  //
  // edges to find the empty space around
  constructor(t, e, i, s, n) {
    super(e, new w(t).ToPoint()), this.DirectionPerp = new w(t).Right.ToPoint(), this.PathOrders = s, this.xProjection = t === S.North ? (r) => r.x : (r) => -r.y, this.edgeContainersTree = new Ee((r, a) => this.CompareAA(r, a)), this.SweepPole = w.VectorDirection(this.SweepDirection), this.AxisEdges = n, this.AxisEdgesToObstaclesTheyOriginatedFrom = i;
  }
  //   Array<Path> EdgePaths { get; set; }
  // VisibilityGraph PathVisibilityGraph { get; set; }
  // calculates the right offsets
  FindFreeSpace() {
    this.InitTheQueueOfEvents(), this.ProcessEvents();
  }
  ProcessEvents() {
    for (; this.EventQueue.Count > 0; )
      this.ProcessEvent(this.EventQueue.Dequeue());
  }
  ProcessEvent(t) {
    t instanceof tn ? this.ProcessVertexEvent(t) : (this.Z = this.GetZP(t.Site), t instanceof hl ? this.ProcessLowEdgeEvent(t) : this.ProcessHighEdgeEvent(t));
  }
  ProcessHighEdgeEvent(t) {
    const e = t.AxisEdge;
    this.RemoveEdge(e), this.ConstraintEdgeWithObstaclesAtZ(e, e.Target.point);
  }
  ProcessLowEdgeEvent(t) {
    const e = t.AxisEdge, i = this.GetOrCreateAxisEdgesContainer(e);
    i.item.AddEdge(e);
    const s = this.edgeContainersTree.previous(i);
    if (s != null)
      for (const r of s.item.edges)
        for (const a of i.item.edges)
          this.TryToAddRightNeighbor(r, a);
    const n = this.edgeContainersTree.next(i);
    if (n != null)
      for (const r of i.item.Edges)
        for (const a of n.item.edges)
          this.TryToAddRightNeighbor(r, a);
    this.ConstraintEdgeWithObstaclesAtZ(e, e.Source.point);
  }
  TryToAddRightNeighbor(t, e) {
    this.ProjectionsOfEdgesOverlap(t, e) && t.AddRightNeighbor(e);
  }
  ProjectionsOfEdgesOverlap(t, e) {
    return this.SweepPole === S.North ? !(t.TargetPoint.y < e.SourcePoint.y - m.distanceEpsilon || e.TargetPoint.y < t.SourcePoint.y - m.distanceEpsilon) : !(t.TargetPoint.x < e.SourcePoint.x - m.distanceEpsilon || e.TargetPoint.x < t.SourcePoint.x - m.distanceEpsilon);
  }
  // DebShowEdge(edge: AxisEdge, point: Point) {
  //    //  ReSharper restore UnusedMember.Local
  //    //  if (InterestingEdge(edge))
  //    this.ShowEdge(edge, point);
  // }
  // // ReSharper disable SuggestBaseTypeForParameter
  // ShowEdge(edge: AxisEdge, point: Point) {
  //    //  ReSharper restore SuggestBaseTypeForParameter
  //    let dd = this.GetObstacleBoundaries("black");
  //    let seg = new DebugCurve(1, "red", new LineSegment(edge.Source.point, edge.Target.point));
  //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(dd.Concat(new, [));
  //    seg;
  //    new DebugCurve("blue", CurveFactory.CreateEllipse(3, 3, point));
  // }
  GetObstacleBoundaries(t) {
    return this.Obstacles.map((e) => q.mkDebugCurveWCI(1, t, e));
  }
  //
  // a point on the edge on Z level
  ConstraintEdgeWithObstaclesAtZ(t, e) {
    this.ConstraintEdgeWithObstaclesAtZFromLeft(t, e), this.ConstraintEdgeWithObstaclesAtZFromRight(t, e);
  }
  ConstraintEdgeWithObstaclesAtZFromRight(t, e) {
    const i = this.GetActiveSideFromRight(e);
    if (i == null || this.NotRestricting(t, i.item.Polyline))
      return;
    const s = this.ObstacleSideComparer.IntersectionOfSideAndSweepLine(i.item);
    t.BoundFromRight(s.dot(this.DirectionPerp));
  }
  GetActiveSideFromRight(t) {
    return this.LeftObstacleSideTree.findFirst((e) => Ii.PointToTheLeftOfLineOrOnLineLocal(t, e.Start, e.End));
  }
  ConstraintEdgeWithObstaclesAtZFromLeft(t, e) {
    const i = this.GetActiveSideFromLeft(e);
    if (i == null || this.NotRestricting(t, i.item.Polyline))
      return;
    const s = this.ObstacleSideComparer.IntersectionOfSideAndSweepLine(i.item);
    t.BoundFromLeft(s.dot(this.DirectionPerp));
  }
  static PointToTheLeftOfLineOrOnLineLocal(t, e, i) {
    return u.signedDoubledTriangleArea(t, e, i) > -Ii.AreaComparisonEpsilon;
  }
  static PointToTheRightOfLineOrOnLineLocal(t, e, i) {
    return u.signedDoubledTriangleArea(e, i, t) < Ii.AreaComparisonEpsilon;
  }
  GetActiveSideFromLeft(t) {
    return this.RightObstacleSideTree.findLast((e) => Ii.PointToTheRightOfLineOrOnLineLocal(t, e.Start, e.End));
  }
  // ReSharper disable UnusedMember.Local
  // ShowPointAndEdge(point: Point, edge: AxisEdge) {
  //    //  ReSharper restore UnusedMember.Local
  //    let curves: Array<ICurve> = this.GetCurves(point, edge);
  //    LayoutAlgorithmSettings.Show(curves.ToArray());
  // }
  // // ReSharper disable UnusedMember.Local
  // ShowPointAndEdgeWithSweepline(point: Point, edge: AxisEdge) {
  //    //  ReSharper restore UnusedMember.Local
  //    let curves: Array<ICurve> = this.GetCurves(point, edge);
  //    curves.Add(new LineSegment(((this.SweepDirection * this.Z) + (10 * this.DirectionPerp)), ((this.SweepDirection * this.Z) - (10 * this.DirectionPerp))));
  //    LayoutAlgorithmSettings.Show(curves.ToArray());
  // }
  // GetCurves(point: Point, edge: AxisEdge): Array<ICurve> {
  //    let ellipse = CurveFactory.CreateEllipse(3, 3, point);
  //    let curves = new Array<ICurve>(this.Obstacles.select(() => {  }, (<ICurve>(o))));
  //    if ((edge.RightBound < Number.POSITIVE_INFINITY)) {
  //        let rightOffset: number = edge.RightBound;
  //        let del = (this.DirectionPerp * rightOffset);
  //        curves.Add(new LineSegment((edge.Source.point + del), (edge.Target.point + del)));
  //    }
  //    if ((edge.LeftBound > Number.NEGATIVE_INFINITY)) {
  //        let leftOffset: number = edge.LeftBound;
  //        let del = (this.DirectionPerp * leftOffset);
  //        curves.Add(new LineSegment((edge.Source.point + del), (edge.Target.point + del)));
  //    }
  //    curves.AddRange(from, e, in, this.PathOrders.keys, let, a=e.SourcePoint, let, b=e.TargetPoint, select, new CubicBezierSegment(a, ((a * 0.8)
  //                        + (b * 0.2)), ((a * 0.2)
  //                        + (b * 0.8)), b)).Cast();
  //    return curves;
  // }
  // GetCurvesTest(point: Point): Array<DebugCurve> {
  //    let ellipse = CurveFactory.CreateEllipse(3, 3, point);
  //    let curves = new Array<DebugCurve>(this.Obstacles.select(() => {  }, new DebugCurve(100, 1, "black", o)));
  //    curves.AddRange(from, e, in, this.edgeContainersTree, from, axisEdge, in, e, let, a=axisEdge.Source.Point, let, b=axisEdge.Target.Point, select, new DebugCurve(100, 1, "green", new LineSegment(a, b)));
  //    curves.AddRange(FreeSpaceFinder.RightNeighborsCurvesTest(this.edgeContainersTree));
  //    return curves;
  // }
  // static RightNeighborsCurvesTest(rbTree: Array<AxisEdgesContainer>): Array<DebugCurve> {
  //    for (let container of rbTree) {
  //        for (let edge of container) {
  //            for (let rn of edge.RightNeighbors) {
  //                yield;
  //                return new DebugCurve(100, 1, "brown", new LineSegment(FreeSpaceFinder.EdgeMidPoint(edge), FreeSpaceFinder.EdgeMidPoint(rn)));
  //            }
  //        }
  //    }
  // }
  static EdgeMidPoint(t) {
    return u.middle(t.SourcePoint, t.TargetPoint);
  }
  // ShowAxisEdges() {
  //    //  ReSharper restore UnusedMember.Local
  //    let dd = new Array<DebugCurve>(this.GetObstacleBoundaries("black"));
  //    let i: number = 0;
  //    for (let axisEdge of this.AxisEdges) {
  //        let color = DebugCurve.colors[i];
  //        dd.Add(new DebugCurve(200, 1, color, new LineSegment(axisEdge.Source.point, axisEdge.Target.point)));
  //        let perp: Point = new Point(0, 1);
  //        // TODO: Warning!!!, inline IF is not supported ?
  //        (axisEdge.Direction === Direction.East);
  //        new Point(-1, 0);
  //        if ((axisEdge.LeftBound !== Number.NEGATIVE_INFINITY)) {
  //            dd.Add(new DebugCurve(200, 0.5, color, new LineSegment((axisEdge.Source.point
  //                                    + (axisEdge.LeftBound * perp)), (axisEdge.Target.point
  //                                    + (axisEdge.LeftBound * perp)))));
  //        }
  //        if ((axisEdge.RightBound !== Number.POSITIVE_INFINITY)) {
  //            dd.Add(new DebugCurve(200, 0.5, color, new LineSegment((axisEdge.Source.point
  //                                    - (axisEdge.RightBound * perp)), (axisEdge.Target.point
  //                                    - (axisEdge.RightBound * perp)))));
  //        }
  //        i = ((i + 1)
  //                    % DebugCurve.colors.length);
  //    }
  //    DebugCurveCollection.WriteToFile(dd, "c:/tmp/ae");
  //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(dd);
  // }
  // // ReSharper disable UnusedMember.Local
  // ShowAtPoint(point: Point) {
  //    //  ReSharper restore UnusedMember.Local
  //    let curves = this.GetCurvesTest(point);
  //    LayoutAlgorithmSettings.ShowDebugCurves(curves.ToArray());
  // }
  GetOrCreateAxisEdgesContainer(t) {
    const e = t.Source.point, i = this.GetAxisEdgesContainerNode(e);
    return i ?? this.edgeContainersTree.insert(new uf(e));
  }
  //
  // the point has to be on the same line as the container
  GetAxisEdgesContainerNode(t) {
    const e = this.xProjection(t), i = this.edgeContainersTree.findFirst((s) => this.xProjection(s.Source) >= e - m.distanceEpsilon / 2);
    return i != null && this.xProjection(i.item.Source) <= e + m.distanceEpsilon / 2 ? i : null;
  }
  ProcessVertexEvent(t) {
    this.Z = this.GetZS(t), t instanceof as ? this.ProcessLeftVertex(t, t.Vertex.nextOnPolyline) : t instanceof ls ? this.ProcessRightVertex(t, t.Vertex.prevOnPolyline) : (this.ProcessLeftVertex(t, t.Vertex.nextOnPolyline), this.ProcessRightVertex(t, t.Vertex.prevOnPolyline));
  }
  ProcessRightVertex(t, e) {
    const i = t.Site;
    this.ProcessPrevSegmentForRightVertex(t, i);
    const s = e.point.sub(t.Site), n = s.dot(this.DirectionPerp), r = s.dot(this.SweepDirection);
    r <= m.distanceEpsilon ? n > 0 && r >= 0 ? this.EnqueueEvent(new ls(e)) : this.RestrictEdgeContainerToTheRightOfEvent(t.Vertex) : (this.InsertRightSide(new Bs(t.Vertex)), this.EnqueueEvent(new ls(e)), this.RestrictEdgeContainerToTheRightOfEvent(t.Vertex));
  }
  RestrictEdgeContainerToTheRightOfEvent(t) {
    const e = t.point, i = this.xProjection(e), s = this.edgeContainersTree.findFirst((n) => i <= this.xProjection(n.Source));
    if (s != null)
      for (const n of s.item.Edges)
        this.NotRestricting(n, t.polyline) || n.BoundFromLeft(this.DirectionPerp.dot(e));
  }
  NotRestricting(t, e) {
    return this.AxisEdgesToObstaclesTheyOriginatedFrom.get(t) === e;
  }
  ProcessPrevSegmentForRightVertex(t, e) {
    const i = t.Vertex.nextOnPolyline.point;
    e.sub(i).dot(this.SweepDirection) > m.distanceEpsilon && this.RemoveRightSide(new Bs(t.Vertex.nextOnPolyline));
  }
  RemoveEdge(t) {
    const e = this.GetAxisEdgesContainerNode(t.Source.point);
    e.item.RemoveAxis(t), e.item.IsEmpty() && this.edgeContainersTree.deleteNodeInternal(e);
  }
  ProcessLeftVertex(t, e) {
    const i = t.Site;
    this.ProcessPrevSegmentForLeftVertex(t, i);
    const s = e.point.sub(t.Site), n = s.dot(this.DirectionPerp), r = s.dot(this.SweepDirection);
    r <= m.distanceEpsilon ? n < 0 && r >= 0 && this.EnqueueEvent(new as(e)) : (this.InsertLeftSide(new Ns(t.Vertex)), this.EnqueueEvent(new as(e))), this.RestrictEdgeFromTheLeftOfEvent(t.Vertex);
  }
  RestrictEdgeFromTheLeftOfEvent(t) {
    const e = t.point, i = this.GetContainerNodeToTheLeftOfEvent(e);
    if (i != null)
      for (const s of i.item.Edges)
        this.NotRestricting(s, t.polyline) || s.BoundFromRight(e.dot(this.DirectionPerp));
  }
  GetContainerNodeToTheLeftOfEvent(t) {
    const e = this.xProjection(t);
    return this.edgeContainersTree.findLast((i) => this.xProjection(i.Source) <= e);
  }
  ProcessPrevSegmentForLeftVertex(t, e) {
    const i = t.Vertex.prevOnPolyline.point;
    e.sub(i).dot(this.SweepDirection) > m.distanceEpsilon && this.RemoveLeftSide(new Ns(t.Vertex.prevOnPolyline));
  }
  InitTheQueueOfEvents() {
    this.InitQueueOfEvents();
    for (const t of this.AxisEdges)
      this.EnqueueEventsForEdge(t);
  }
  EnqueueEventsForEdge(t) {
    this.EdgeIsParallelToSweepDir(t) && (this.EnqueueEvent(Ii.EdgeLowPointEvent(t, t.Source.point)), this.EnqueueEvent(Ii.EdgeHighPointEvent(t, t.Target.point)));
  }
  EdgeIsParallelToSweepDir(t) {
    return t.Direction === this.SweepPole || t.Direction === w.OppositeDir(this.SweepPole);
  }
  static EdgeHighPointEvent(t, e) {
    return new cf(t, e);
  }
  static EdgeLowPointEvent(t, e) {
    return new hl(t, e);
  }
  CompareAA(t, e) {
    return yt(t.Source.dot(this.DirectionPerp), e.Source.dot(this.DirectionPerp));
  }
}
Ii.AreaComparisonEpsilon = m.intersectionEpsilon;
class df extends ca {
  constructor(t) {
    super(), this.CompassDirection = S.None, this.edges = new Array(), this._isFixed = !1, this.Id = -1, this.IdealPosition = 0, this.Id = t;
  }
  get Start() {
    return this.start;
  }
  get End() {
    return this.end;
  }
  // the list of edges holding the same offset and direction
  get Edges() {
    return this.edges;
  }
  AddEdge(t) {
    if (this.Edges.length === 0) {
      let e = w.VectorDirectionPP(t.Source, t.Target);
      switch (e) {
        case S.South:
          e = S.North;
          break;
        case S.West:
          e = S.East;
          break;
      }
      this.CompassDirection = e, this.start = t.Source, this.end = t.Source;
    }
    switch (this.CompassDirection) {
      case S.North:
        this.TryPointForStartAndEndNorth(t.Source), this.TryPointForStartAndEndNorth(t.Target);
        break;
      case S.East:
        this.TryPointForStartAndEndEast(t.Source), this.TryPointForStartAndEndEast(t.Target);
        break;
    }
    this.Edges.push(t);
  }
  TryPointForStartAndEndNorth(t) {
    t.y < this.start.y ? this.start = t : t.y > this.end.y && (this.end = t);
  }
  TryPointForStartAndEndEast(t) {
    t.x < this.start.x ? this.start = t : t.x > this.end.x && (this.end = t);
  }
  // the segments constraining "this" from the right
  get IsFixed() {
    return this._isFixed;
  }
  set IsFixed(t) {
    this._isFixed = t;
  }
  // the maximal width of the edges
  get Width() {
    let t = 0;
    for (const e of this.edges)
      t = Math.max(t, e.Width);
    return t;
  }
  GetLeftBound() {
    if (!this.IsFixed) {
      let t = Number.NEGATIVE_INFINITY;
      for (const e of this.edges)
        t = Math.max(t, e.AxisEdge.LeftBound);
      return t;
    }
    return this.CompassDirection === S.North ? this.Edges[0].Source.x : -this.Edges[0].Source.y;
  }
  GetRightBound() {
    if (!this.IsFixed) {
      let t = Number.POSITIVE_INFINITY;
      for (const e of this.edges)
        t = Math.min(t, e.AxisEdge.RightBound);
      return t;
    }
    return this.Position();
  }
  Position() {
    return this.CompassDirection === S.North ? this.Edges[0].Source.x : -this.Edges[0].Source.y;
  }
}
class oi {
  //
  // no two horizontal segs overlap, but they can share an end point
  // no two vertical segs overlap, but they can share an end point
  constructor(t, e) {
    this.tree = new Ee((i, s) => yt(i.Point.x, s.Point.x)), this.VerticalPoints = e, this.HorizontalPoints = t;
  }
  SplitPoints() {
    this.VerticalPoints.length === 0 || this.HorizontalPoints.length === 0 || (this.InitEventQueue(), this.ProcessEvents());
  }
  ProcessEvents() {
    for (; !this.Queue.IsEmpty(); ) {
      const t = { priority: 0 }, e = this.Queue.DequeueAndGetPriority(t);
      this.ProcessEvent(e, t.priority);
    }
  }
  ProcessEvent(t, e) {
    D(t.Next.Point.x, t.Point.x) ? e === oi.Low(t) ? this.ProcessLowLinkedPointEvent(t) : this.ProcessHighLinkedPointEvent(t) : this.IntersectWithTree(t);
  }
  IntersectWithTree(t) {
    let e, i, s;
    const n = t.Y;
    if (t.Point.x < t.Next.Point.x ? (i = t.Point.x, e = t.Next.Point.x, s = !0) : (e = t.Point.x, i = t.Next.Point.x, s = !1), s)
      for (let r = this.tree.findFirst((a) => i <= a.Point.x); r != null && r.item.Point.x <= e; r = this.tree.next(r)) {
        const a = new u(r.item.Point.x, n);
        t = oi.TrySplitHorizontalPoint(t, a, !0), oi.TrySplitVerticalPoint(r.item, a);
      }
    else
      for (let r = this.tree.findLast((a) => a.Point.x <= e); r != null && r.item.Point.x >= i; r = this.tree.previous(r)) {
        const a = new u(r.item.Point.x, n);
        t = oi.TrySplitHorizontalPoint(t, a, !1), oi.TrySplitVerticalPoint(r.item, a);
      }
  }
  static TrySplitVerticalPoint(t, e) {
    oi.Low(t) + m.distanceEpsilon < e.y && e.y + m.distanceEpsilon < oi.High(t) && t.SetNewNext(e);
  }
  static TrySplitHorizontalPoint(t, e, i) {
    return i && t.X + m.distanceEpsilon < e.x && e.x + m.distanceEpsilon < t.Next.X || !i && t.Next.X + m.distanceEpsilon < e.x && e.x + m.distanceEpsilon < t.X ? (t.SetNewNext(e), t.Next) : t;
  }
  ProcessHighLinkedPointEvent(t) {
    this.tree.remove(t);
  }
  ProcessLowLinkedPointEvent(t) {
    this.tree.insert(t);
  }
  InitEventQueue() {
    this.Queue = new es(yt);
    for (const t of this.VerticalPoints)
      this.Queue.Enqueue(t, oi.Low(t));
    for (const t of this.HorizontalPoints)
      this.Queue.Enqueue(t, t.Point.y);
  }
  static Low(t) {
    return Math.min(t.Point.y, t.Next.Point.y);
  }
  static High(t) {
    return Math.max(t.Point.y, t.Next.Point.y);
  }
}
class Ms {
  constructor(t) {
    this.verticesToPathOffsets = new ii(), this.Paths = t;
  }
  // Avoid a situation where two paths cross each other more than once. Remove self loops.
  MergePaths() {
    this.InitVerticesToPathOffsetsAndRemoveSelfCycles();
    for (const t of this.Paths)
      this.ProcessPath(t);
  }
  ProcessPath(t) {
    const e = /* @__PURE__ */ new Map();
    let i = null;
    for (let s = t.PathPoints; s != null; s = s.Next) {
      const n = this.verticesToPathOffsets.get(s.Point);
      if (i != null) {
        if (e.size > 0)
          for (const [r, a] of n) {
            const l = e.get(r);
            l && (this.CollapseLoopingPath(r, l, a, t, s), e.delete(r));
          }
        for (const [r, a] of i)
          n.has(r) || e.set(r, a);
      }
      i = n;
    }
  }
  //        bool Correct() {
  //            foreach (var kv of verticesToPathOffsets) {
  //                Point p = kv.Key;
  //                Map<Path, LinkedPoint> pathOffs = kv.Value;
  //                foreach (var pathOff of pathOffs) {
  //                    var path = pathOff.Key;
  //                    var linkedPoint = pathOff.Value;
  //                    if (linkedPoint.Point !== p)
  //                        return false;
  //                    if (FindLinkedPointInPath(path, p) == null ) {
  //                        return false;
  //                    }
  //                }
  //            }
  //            return true;
  //        }
  CollapseLoopingPath(t, e, i, s, n) {
    const r = Ms.FindLinkedPointInPath(s, e.Point), a = Array.from(Ms.GetPointsInBetween(r, n));
    Ms.Before(e, i) ? (this.CleanDisappearedPiece(e, i, t), this.ReplacePiece(e, i, a, t)) : (this.CleanDisappearedPiece(i, e, t), this.ReplacePiece(i, e, a.reverse(), t));
  }
  static *GetPointsInBetween(t, e) {
    for (let i = t.Next; i !== e; i = i.Next)
      yield i.Point;
  }
  ReplacePiece(t, e, i, s) {
    let n = t;
    for (const r of i) {
      const a = new Ri(r);
      n.Next = a, n = a, this.verticesToPathOffsets.get(r).set(s, n);
    }
    n.Next = e;
  }
  CleanDisappearedPiece(t, e, i) {
    for (const s of Ms.GetPointsInBetween(t, e))
      this.verticesToPathOffsets.get(s).delete(i);
  }
  // checks that a is before b of the path
  // <returns>true is a is before b of the path</returns>
  static Before(t, e) {
    for (t = t.Next; t != null; t = t.Next)
      if (t === e)
        return !0;
    return !1;
  }
  static FindLinkedPointInPath(t, e) {
    for (let i = t.PathPoints; ; i = i.Next)
      if (i.Point.equal(e))
        return i;
  }
  InitVerticesToPathOffsetsAndRemoveSelfCycles() {
    for (const t of this.Paths)
      for (let e = t.PathPoints; e != null; e = e.Next) {
        let i = this.verticesToPathOffsets.get(e.Point);
        i || this.verticesToPathOffsets.set(e.Point, i = /* @__PURE__ */ new Map());
        const s = i.get(t);
        s ? (this.CleanDisappearedPiece(s, e, t), s.Next = e.Next) : i.set(t, e);
      }
  }
}
class jt {
  static RefinePaths(t, e) {
    jt.AdjustPaths(t);
    const i = jt.CreatePathsToFirstLinkedVerticesMap(t);
    jt.Refine(Array.from(i.values())), jt.CrossVerticalAndHorizontalSegs(i.values()), jt.ReconstructPathsFromLinkedVertices(i), e && new Ms(t).MergePaths();
  }
  // make sure that every two different points of paths are separated by at least 10e-6
  static AdjustPaths(t) {
    for (const e of t)
      e.PathPoints = jt.AdjustPathPoints(e.PathPoints);
  }
  static AdjustPathPoints(t) {
    if (!t || t.length === 0)
      return;
    const e = [];
    let i = u.RoundPoint(t[0]);
    e.push(i);
    for (let s = 1; s < t.length; s++) {
      const n = u.RoundPoint(t[s]);
      i.equal(n) || (i = n, e.push(i));
    }
    return e;
  }
  static CrossVerticalAndHorizontalSegs(t) {
    const e = new Array(), i = new Array();
    for (const s of t)
      for (let n = s; n.Next != null; n = n.Next)
        D(n.Point.x, n.Next.Point.x) ? i.push(n) : e.push(n);
    new oi(e, i).SplitPoints();
  }
  static ReconstructPathsFromLinkedVertices(t) {
    for (const [e, i] of t)
      e.PathPoints = i;
  }
  static Refine(t) {
    jt.RefineInDirection(S.North, t), jt.RefineInDirection(S.East, t);
  }
  // refines all segments that are parallel to "direction"
  static *groupByProj(t, e) {
    const i = /* @__PURE__ */ new Map();
    for (const s of e) {
      const n = t(s.Point);
      let r = i.get(n);
      r || (r = new Array(), i.set(n, r)), r.push(s);
    }
    for (const s of i.values())
      yield s;
  }
  static RefineInDirection(t, e) {
    const i = {
      projectionToPerp: void 0,
      projectionToDirection: void 0
    };
    jt.GetProjectionsDelegates(t, i);
    const s = Array.from(jt.GetAllLinkedVertsInDirection(i.projectionToPerp, e)), n = jt.groupByProj(i.projectionToPerp, s);
    for (const r of n)
      jt.RefineCollinearBucket(r, i.projectionToDirection);
  }
  static GetProjectionsDelegates(t, e) {
    t === S.East ? (e.projectionToDirection = (i) => i.x, e.projectionToPerp = (i) => i.y) : (e.projectionToPerp = (i) => i.x, e.projectionToDirection = (i) => i.y);
  }
  static *GetAllLinkedVertsInDirection(t, e) {
    for (const i of e)
      for (let s = i; s.Next != null; s = s.Next)
        D(t(s.Point), t(s.Next.Point)) && (yield s);
  }
  // refine vertices belonging to a bucket;
  // pathLinkedVertices belong to a line parallel to the direction of the refinement
  static RefineCollinearBucket(t, e) {
    const i = /* @__PURE__ */ new Set(), s = new Array();
    for (const a of t) {
      let l = e(a.Point);
      i.has(l) || (i.add(l), s.push([a.Point, l])), l = e(a.Next.Point), i.has(l) || (i.add(l), s.push([a.Next.Point, l]));
    }
    s.sort((a, l) => a[1] - l[1]);
    const n = s.map((a) => a[0]), r = /* @__PURE__ */ new Map();
    for (let a = 0; a < s.length; a++)
      r.set(s[a][1], a);
    for (const a of t) {
      const l = r.get(e(a.Point)), h = r.get(e(a.Next.Point));
      Math.abs(h - l) > 1 && jt.InsertPoints(a, n, l, h);
    }
  }
  static InsertPoints(t, e, i, s) {
    i < s ? t.InsertVerts(i, s, e) : t.InsertVertsInReverse(s, i, e);
  }
  static CreatePathsToFirstLinkedVerticesMap(t) {
    const e = /* @__PURE__ */ new Map();
    for (const i of t)
      e.set(i, jt.CreateLinkedVertexOfEdgePath(i));
    return e;
  }
  static CreateLinkedVertexOfEdgePath(t) {
    const e = t.PathPoints;
    let i = new Ri(e[0]);
    const s = i;
    for (let n = 1; n < e.length; n++)
      i.Next = new Ri(e[n]), i = i.Next;
    return s;
  }
}
class ss {
  // offset
  constructor(t, e) {
    this.Points = t, this.I = e;
  }
  static equal(t, e) {
    return t.I === e.I && t.Points === e.Points;
  }
  get Start() {
    return this.Points[this.I];
  }
  get End() {
    return this.Points[this.I + 1];
  }
}
class ns {
  constructor(t, e) {
    this.segTree = new Rr(null), this.crossedOutPaths = /* @__PURE__ */ new Set(), this.HierarchyOfObstacles = new Rr(e), this.Paths = t;
  }
  static RemoveStaircases(t, e) {
    new ns(t, e).Calculate();
  }
  Calculate() {
    this.InitHierarchies();
    let t;
    do {
      t = !1;
      for (const e of this.Paths.filter((i) => !this.crossedOutPaths.has(i)))
        this.ProcessPath(e) && (t = !0);
    } while (t);
  }
  ProcessPath(t) {
    const e = { pts: t.PathPoints, canHaveStaircase: !1 };
    return this.ProcessPoints(e) ? (t.PathPoints = e.pts, !0) : (e.canHaveStaircase || this.crossedOutPaths.add(t), !1);
  }
  ProcessPoints(t) {
    const e = this.FindStaircaseStart(t);
    return e < 0 ? !1 : (t.pts = this.RemoveStaircasePN(t.pts, e), !0);
  }
  FindStaircaseStart(t) {
    if (t.canHaveStaircase = !1, t.pts.length < 5)
      return -1;
    const e = [new ss(t.pts, 0), new ss(t.pts, 1), new ss(t.pts, 2), new ss(t.pts, 3)];
    let i = 0;
    for (let s = 0; ; ) {
      const n = { canHaveStaircaseAtI: !1 };
      if (this.IsStaircase(t.pts, s, e, n))
        return t.canHaveStaircase = !0, s;
      if (t.canHaveStaircase = t.canHaveStaircase || n.canHaveStaircaseAtI, s++, t.pts.length < s + 5)
        return -1;
      e[i] = new ss(t.pts, s + 3), i++, i %= 4;
    }
  }
  static GetFlippedPoint(t, e) {
    return D(t[e].y, t[e + 1].y) ? new u(t[e + 4].x, t[e].y) : new u(t[e].x, t[e + 4].y);
  }
  // ignoring crossing at a
  Crossing(t, e, i) {
    return ns.IsCrossing(v.mkPP(t, e), this.segTree, i);
  }
  // ignoring crossing at ls.Start
  static IsCrossing(t, e, i) {
    for (const s of e.GetAllIntersecting(t.boundingBox))
      if (i.findIndex((n) => n === s) === -1)
        return !0;
    return !1;
  }
  IntersectObstacleHierarchyPPP(t, e, i) {
    return this.IntersectObstacleHierarchyL(v.mkPP(t, e)) || this.IntersectObstacleHierarchyL(v.mkPP(e, i));
  }
  IntersectObstacleHierarchyL(t) {
    return this.HierarchyOfObstacles.GetAllIntersecting(t.boundingBox).some((e) => g.intersectionOne(t, e, !1) != null);
  }
  IsStaircase(t, e, i, s) {
    const n = t[e], r = t[e + 1];
    let a = t[e + 2];
    const l = t[e + 3], h = t[e + 4];
    return s.canHaveStaircaseAtI = !1, w.DirectionFromPointToPoint(n, r) !== w.DirectionFromPointToPoint(a, l) || w.DirectionFromPointToPoint(r, a) !== w.DirectionFromPointToPoint(l, h) || (a = ns.GetFlippedPoint(t, e), this.IntersectObstacleHierarchyPPP(r, a, l)) ? !1 : (s.canHaveStaircaseAtI = !0, !this.Crossing(r, a, i));
  }
  RemoveStaircasePN(t, e) {
    const i = t[e], s = t[e + 1], n = Math.abs(i.y - s.y) < m.distanceEpsilon / 2;
    return this.RemoveStaircasePNB(t, e, n);
  }
  RemoveStaircasePNB(t, e, i) {
    this.RemoveSegs(t);
    const s = new Array(t.length - 2);
    gf(t, s, e + 1);
    const n = t[e + 1], r = t[e + 3];
    return s[e + 1] = i ? new u(r.x, n.y) : new u(n.x, r.y), ff(t, e + 4, s, e + 2, s.length - e - 2), this.InsertNewSegs(s, e), s;
  }
  RemoveSegs(t) {
    for (let e = 0; e < t.length - 1; e++)
      this.RemoveSeg(new ss(t, e));
  }
  RemoveSeg(t) {
    this.segTree.Remove(ns.Rect(t), t);
  }
  InsertNewSegs(t, e) {
    this.InsSeg(t, e), this.InsSeg(t, e + 1);
  }
  InitHierarchies() {
    for (const t of this.Paths)
      this.InsertPathSegs(t);
  }
  InsertPathSegs(t) {
    this.InsertSegs(t.PathPoints);
  }
  InsertSegs(t) {
    for (let e = 0; e < t.length - 1; e++)
      this.InsSeg(t, e);
  }
  InsSeg(t, e) {
    const i = new ss(t, e);
    this.segTree.Add(ns.Rect(i), i);
  }
  static Rect(t) {
    return T.mkPP(t.Start, t.End);
  }
}
function ff(o, t, e, i, s) {
  for (; s-- > 0; )
    e[i++] = o[t++];
}
function gf(o, t, e) {
  let i = 0;
  for (; e-- > 0; )
    t[i++] = o[i++];
}
class nt {
  get HasGroups() {
    return this.HierarchyOfGroups != null && this.HierarchyOfGroups.Count > 0;
  }
  //  "nudges" paths to decrease the number of intersections and stores the results inside WidePaths of "paths"
  // paths through the graph
  // two parallel paths should be separated by this distance if it is feasible
  // polygonal convex obstacles organized  of a tree; the obstacles here are padded original obstacles
  //
  constructor(t, e, i, s) {
    this.AncestorsSets = s, this.HierarchyOfGroups = wt(Array.from(s.keys()).filter((n) => n.IsGroup).map((n) => Nt(n, n.BoundingBox))), this.Obstacles = i, this.EdgeSeparation = 2 * e, this.Paths = t, this.HierarchyOfObstacles = wt(i.map((n) => Nt(n, n.boundingBox))), this.MapPathsToTheirObstacles();
  }
  MapPathsToTheirObstacles() {
    this.PathToObstacles = /* @__PURE__ */ new Map();
    for (const t of this.Paths)
      this.MapPathToItsObstacles(t);
  }
  MapPathToItsObstacles(t) {
    if (!t.PathPoints || t.PathPoints.length === 0)
      return;
    const e = t.PathPoints, i = this.HierarchyOfObstacles.FirstHitNodeWithPredicate(e[0], nt.ObstacleTest), s = this.HierarchyOfObstacles.FirstHitNodeWithPredicate(e[e.length - 1], nt.ObstacleTest);
    i != null && s != null && this.PathToObstacles.set(t, [i.UserData, s.UserData]);
  }
  static ObstacleTest(t, e) {
    return g.PointRelativeToCurveLocation(t, e) !== F.Outside ? ot.Stop : ot.Continue;
  }
  Calculate(t, e) {
    this.NudgingDirection = t, jt.RefinePaths(this.Paths, e), this.GetPathOrdersAndPathGraph(), this.MapAxisEdgesToTheirObstacles(), this.DrawPaths();
  }
  MapAxisEdgesToTheirObstacles() {
    this.axisEdgesToObstaclesTheyOriginatedFrom = /* @__PURE__ */ new Map();
    for (const t of this.Paths)
      this.MapPathEndAxisEdgesToTheirObstacles(t);
    for (const t of this.Paths)
      this.UmmapPathInteriourFromStrangerObstacles(t);
  }
  UmmapPathInteriourFromStrangerObstacles(t) {
    const e = this.FindFirstUnmappedEdge(t);
    if (e == null)
      return;
    const i = this.FindLastUnmappedEdge(t);
    for (let s = e; s != null && s !== i; s = s.Next)
      this.axisEdgesToObstaclesTheyOriginatedFrom.delete(s.AxisEdge);
  }
  FindLastUnmappedEdge(t) {
    for (let e = t.LastEdge; e != null; e = e.Prev)
      if (e.AxisEdge.Direction !== this.NudgingDirection)
        return e;
    return null;
  }
  FindFirstUnmappedEdge(t) {
    for (let e = t.FirstEdge; e != null; e = e.Next)
      if (e.AxisEdge.Direction !== this.NudgingDirection)
        return e;
    return null;
  }
  MapPathEndAxisEdgesToTheirObstacles(t) {
    const e = this.PathToObstacles.get(t);
    e && (this.ProcessThePathStartToMapAxisEdgesToTheirObstacles(t, e[0]), this.ProcessThePathEndToMapAxisEdgesToTheirObstacles(t, e[1]));
  }
  ProcessThePathEndToMapAxisEdgesToTheirObstacles(t, e) {
    for (let i = t.LastEdge; i != null && w.DirectionsAreParallel(i.Direction, this.NudgingDirection); i = i.Prev)
      this.axisEdgesToObstaclesTheyOriginatedFrom.set(i.AxisEdge, e);
  }
  ProcessThePathStartToMapAxisEdgesToTheirObstacles(t, e) {
    for (let i = t.FirstEdge; i != null && w.DirectionsAreParallel(i.Direction, this.NudgingDirection); i = i.Next)
      this.axisEdgesToObstaclesTheyOriginatedFrom.set(i.AxisEdge, e);
  }
  GetPathOrdersAndPathGraph() {
    const t = new Dt(this.Paths);
    this.PathOrders = t.GetOrder(), this.PathVisibilityGraph = t.PathVisibilityGraph;
  }
  static GetCurvesForShow(t, e) {
    const i = new Array();
    for (const s of t) {
      const n = new B();
      for (const r of s.PathPoints)
        n.addPoint(r);
      i.push(n);
    }
    return i.concat(Array.from(e));
  }
  DrawPaths() {
    this.SetWidthsOfArrowheads(), this.CreateLongestNudgedSegments(), this.FindFreeSpaceInDirection(Array.from(this.PathVisibilityGraph.Edges)), this.MoveLongestSegsIdealPositionsInsideFeasibleIntervals(), this.PositionShiftedEdqges();
  }
  SetWidthsOfArrowheads() {
    for (const t of this.Paths)
      nt.SetWidthsOfArrowheadsForEdge(t);
  }
  static SetWidthsOfArrowheadsForEdge(t) {
    const e = t.GeomEdge;
    if (e.targetArrowhead != null) {
      const i = t.LastEdge;
      i.Width = Math.max(e.targetArrowhead.width, i.Width);
    }
    if (e.sourceArrowhead != null) {
      const i = t.FirstEdge;
      i.Width = Math.max(e.sourceArrowhead.width, i.Width);
    }
  }
  PositionShiftedEdqges() {
    this.Solver = new lf(this.EdgeSeparation);
    for (let t = 0; t < this.LongestNudgedSegs.length; t++)
      this.CreateVariablesOfLongestSegment(this.LongestNudgedSegs[t]);
    this.CreateConstraintsOfTheOrder(), this.CreateConstraintsBetweenLongestSegments(), this.Solver.SolveByRegularSolver(), this.ShiftPathEdges();
  }
  MoveLongestSegsIdealPositionsInsideFeasibleIntervals() {
    for (let t = 0; t < this.LongestNudgedSegs.length; t++) {
      const e = this.LongestNudgedSegs[t];
      nt.MoveLongestSegIdealPositionsInsideFeasibleInterval(e);
    }
  }
  static MoveLongestSegIdealPositionsInsideFeasibleInterval(t) {
    if (t.IsFixed)
      return;
    const e = t.GetLeftBound(), i = t.GetRightBound();
    t.IdealPosition < e ? t.IdealPosition = e : t.IdealPosition > i && (t.IdealPosition = i);
  }
  ShiftPathEdges() {
    for (const t of this.Paths)
      t.PathPoints = this.GetShiftedPoints(t);
  }
  GetShiftedPoints(t) {
    return nt.RemoveSwitchbacksAndMiddlePoints(this.GetShiftedPointsSimple(t));
  }
  // sometimes we have very small mistakes  of the positions that have to be fixed
  static Rectilinearise(t, e) {
    if (t.x === e.x || t.y === e.y)
      return e;
    const i = Math.abs(t.x - e.x), s = Math.abs(t.y - e.y);
    return i < s ? new u(t.x, e.y) : new u(e.x, t.y);
  }
  GetShiftedPointsSimple(t) {
    const e = [], i = t.FirstEdge;
    e.push(this.ShiftedPoint(i.Source, i.LongestNudgedSegment));
    for (const s of t.PathEdges())
      e.push(this.ShiftedEdgePositionOfTarget(s));
    return e;
  }
  ShiftedEdgePositionOfTarget(t) {
    return t.LongestNudgedSegment != null || t.Next == null ? this.ShiftedPoint(t.Target, t.LongestNudgedSegment) : this.ShiftedPoint(t.Next.Source, t.Next.LongestNudgedSegment);
  }
  ShiftedPoint(t, e) {
    if (e == null)
      return t;
    const i = this.Solver.GetVariablePosition(e.Id);
    return this.NudgingDirection === S.North ? new u(i, t.y) : new u(t.x, -i);
  }
  // static ShowPathsFromPoints(paths: Array<Path>, enumerable: Array<Polyline>) {
  //    let dd = new Array<DebugCurve>();
  //    if ((enumerable != null)) {
  //        dd=dd.concat(Nudger.GetObstacleBoundaries(enumerable, "grey"));
  //    }
  //    let i: number = 0;
  //    for (let p  of paths) {
  //        dd = dd.concat(Nudger.PathDebugCurvesFromPoints(p, DebugCurve.colors[Math.min(DebugCurve.colors.length, i++)]));
  //    }
  //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(dd);
  // }
  // static PathDebugCurvesFromPoints(path: Path, color: string): Array<DebugCurve> {
  //    const let startWidth: number = 0.01;
  //    const let endWidth: number = 3;
  //    let pts = path.PathPoints.toArray();
  //    let delta: number = ((endWidth - startWidth)
  //                / (pts.length - 1));
  //    for (let i: number = 0; (i
  //                < (pts.length - 1)); i++) {
  //        yield;
  //    }
  //    return new DebugCurve((startWidth
  //                    + (delta * i)), color, new LineSegment(pts[i], pts[(i + 1)]));
  // }
  // static ShowParamPaths(s: Point, e: Point, params paths: Path[]) {
  //    Nudger.ShowOrderedPaths(null, paths, s, e);
  // }
  // //         ReSharper disable UnusedMember.Local
  // static ShowOrderedPaths(obstacles: Array<Polyline>, paths: Array<Path>, s: Point, e: Point) {
  //    //            ReSharper restore UnusedMember.Local
  //    let colors: string[] = [
  //            "red",
  //            "green",
  //            "blue",
  //            "violet",
  //            "rose",
  //            "black"];
  //    const let startWidth: number = 0.001;
  //    const let endWidth: number = 0.1;
  //    let dd = new Array<DebugCurve>();
  //    if ((obstacles != null)) {
  //        dd.AddRange(Nudger.GetObstacleBoundaries(obstacles, "grey"));
  //    }
  //    let i: number = 0;
  //    for (let path  of paths) {
  //        dd.AddRange(Nudger.GetTestPathAsDebugCurve(startWidth, endWidth, colors[Math.min((colors.length - 1), i++)], path));
  //    }
  //    let ell = new DebugCurve(1, "black", new Ellipse(0.01, 0.01, s));
  //    dd.Add(ell);
  //    dd.Add(new DebugCurve(1, "black", new Ellipse(0.02, 0.02, e)));
  //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(dd.concat(Nudger.GetObstacleBoundaries(obstacles, "lightblue")));
  // }
  // static GetTestPathAsDebugCurve(startWidth: number, endWidth: number, color: string, path: Path): Array<DebugCurve> {
  //    if ((path.PathEdges.Count() > 0)) {
  //        let count: number = path.PathEdges.Count();
  //        let deltaW: number = ((endWidth - startWidth)
  //                    / (count - 1));
  //        // TODO: Warning!!!, inline IF is not supported ?
  //        (count > 1);
  //        1;
  //        // if count ==1 the value of deltaW does not matter
  //        let i: number = 0;
  //        for (let e  of path.PathEdges) {
  //            yield;
  //        }
  //        return new DebugCurve(150, (startWidth
  //                        + (deltaW
  //                        * (i + 1))), color, new LineSegment(e.Source, e.Target));
  //    }
  //    else {
  //        let count: number = path.PathPoints.count();
  //        let pts = path.PathPoints.toArray();
  //        let deltaW = ((endWidth - startWidth)
  //                    / (count - 1));
  //        // TODO: Warning!!!, inline IF is not supported ?
  //        (count > 1);
  //        1;
  //        // if count ==1 the value of deltaW does not matter
  //        for (let i: number = 0; (i
  //                    < (count - 1)); i++) {
  //            yield;
  //        }
  //        return new DebugCurve(150, (startWidth
  //                        + (deltaW * i)), color, new LineSegment(pts[i], pts[(i + 1)]));
  //    }
  // }
  // static GetTestEdgePathAsDebugCurves(startWidth: number, endWidth: number, color: string, path: Path): Array<DebugCurve> {
  //    let count: number = path.PathPoints.count();
  //    let deltaW: number = ((endWidth - startWidth)
  //                / (count - 1));
  //    // TODO: Warning!!!, inline IF is not supported ?
  //    (count > 1);
  //    1;
  //    // if count ==1 the value of deltaW does not matter
  //    let points = path.PathPoints.toArray();
  //    for (let i: number = 0; (i
  //                < (points.length - 1)); i++) {
  //        yield;
  //    }
  //    return new DebugCurve(125, (startWidth
  //                    + (deltaW * i)), color, new LineSegment(points[i], points[(i + 1)]));
  // }
  // static GetEdgePathFromPathEdgesAsDebugCurves(startWidth: number, endWidth: number, color: string, path: Path): Array<DebugCurve> {
  //    let points = path.PathPoints.toArray();
  //    let count: number = points.length;
  //    let deltaW: number = ((endWidth - startWidth)
  //                / (count - 1));
  //    // TODO: Warning!!!, inline IF is not supported ?
  //    (count > 1);
  //    1;
  //    // if count ==1 the value of deltaW does not matter
  //    for (let i: number = 0; (i
  //                < (points.length - 1)); i++) {
  //        yield;
  //    }
  //    return new DebugCurve(120, (startWidth
  //                    + (deltaW * i)), color, new LineSegment(points[i], points[(i + 1)]));
  // }
  // // ReSharper disable UnusedMember.Local
  // static ShowEdgePaths(obstacles: Array<Polyline>, edgePaths: Array<Path>) {
  //    //  ReSharper restore UnusedMember.Local
  //    let debCurves: Array<DebugCurve> = Nudger.GetDebCurvesOfPaths(obstacles, edgePaths);
  //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(debCurves);
  // }
  // static GetDebCurvesOfPaths(enumerable: Array<Polyline>, edgePaths: Array<Path>): Array<DebugCurve> {
  //    let debCurves = Nudger.GetObstacleBoundaries(enumerable, "black");
  //    let i: number = 0;
  //    for (let edgePath  of edgePaths) {
  //        debCurves.AddRange(Nudger.GetTestEdgePathAsDebugCurves(0.2, 4, DebugCurve.colors[((i + 1)
  //                            % DebugCurve.colors.length)], edgePath));
  //    }
  //    return debCurves;
  // }
  // static ShowPathsInLoop(enumerable: Array<Polyline>, edgePaths: Array<Path>, point: Point) {
  //    for (let edgePath  of edgePaths.where(() => {  }, (((path.PathPoints.First() - point).Length < 1)
  //                    || ((path.PathPoints.Last() - point).Length < 1)))) {
  //        let debCurves = Nudger.GetObstacleBoundaries(enumerable, "black");
  //        debCurves.AddRange(Nudger.GetTestEdgePathAsDebugCurves(0.1, 4, "red", edgePath));
  //        LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(debCurves);
  //    }
  // }
  // // ReSharper disable UnusedMember.Local
  // ShowLongSegsWithIdealPositions(dir: Direction) {
  //    //  ReSharper restore UnusedMember.Local
  //    let debCurves = Nudger.GetObstacleBoundaries(this.Obstacles, "black");
  //    let i: number = 0;
  //    debCurves.AddRange(this.LongestNudgedSegs.Select(() => {  }, Nudger.DebugCurveOfLongSeg(ls, DebugCurve.colors[i++, Percent, DebugCurve.colors.length], dir)));
  //    DebugCurveCollection.WriteToFile(debCurves, "c:/tmp/longSegs");
  //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(debCurves);
  // }
  // static DebugCurveOfLongSeg(ls: LongestNudgedSegment, s: string, dir: Direction): DebugCurve {
  //    return new DebugCurve(1, s, Nudger.LineSegOfLongestSeg(ls, dir));
  // }
  static LineSegOfLongestSeg(t, e) {
    const i = e === S.East ? (n) => n.x : (n) => n.y, s = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
    for (const n of t.Edges)
      nt.UpdateMinMaxWithPoint(s, i, n.Source), nt.UpdateMinMaxWithPoint(s, i, n.Target);
    return e === S.East ? new v(s.min, -t.IdealPosition, s.max, -t.IdealPosition) : new v(t.IdealPosition, s.min, t.IdealPosition, s.max);
  }
  static UpdateMinMaxWithPoint(t, e, i) {
    const s = e(i);
    t.min > s && (t.min = s), t.max < s && (t.max = s);
  }
  // ShowPathsDebug(edgePaths: Array<Path>) {
  //    let debCurves = Nudger.GetObstacleBoundaries(this.Obstacles, "black");
  //    let i: number = 0;
  //    for (let edgePath  of edgePaths) {
  //        debCurves.AddRange(Nudger.GetEdgePathFromPathEdgesAsDebugCurves(0.01, 0.4, DebugCurve.colors[((i + 1)
  //                            % DebugCurve.colors.length)], edgePath));
  //    }
  //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(debCurves);
  // }
  // static PathDebugCurves(path: Path, color: string): Array<DebugCurve> {
  //    let d = path.PathEdges.Select(() => {  }, new DebugCurve(70, 0.5, color, new LineSegment(e.Source, e.Target)));
  //    return d.Concat(Nudger.MarkPathVerts(path));
  // }
  // private static MarkPathVerts(path: Path): Array<DebugCurve> {
  //    let first: boolean = true;
  //    let p = new Point();
  //    for (let p0  of path.PathPoints) {
  //        if (first) {
  //            yield;
  //            return new DebugCurve(200, 1, "violet", CurveFactory.CreateDiamond(5, 5, p0));
  //            first = false;
  //        }
  //        else {
  //            yield;
  //        }
  //        return new DebugCurve(100, 0.5, "brown", CurveFactory.CreateEllipse(1.5, 1.5, p0));
  //        p = p0;
  //    }
  //    yield;
  //    return new DebugCurve(200, 1, "green", CurveFactory.CreateDiamond(3, 3, p));
  // }
  // static PathDebugCurvesFromPoint(path: Path): Array<DebugCurve> {
  //    let l = new Array<Point>(path.PathPoints);
  //    for (let i: number = 0; (i
  //                < (l.Count - 1)); i++) {
  //        yield;
  //    }
  //    return new DebugCurve(4, "red", new LineSegment(l[i], l[(i + 1)]));
  // }
  //
  // ReSharper disable UnusedMember.Local
  //        void ShowEdgesOfEdgePath(Path path){
  // ReSharper restore UnusedMember.Local
  //            string[] colors = {"red", "brown", "purple"};
  //            const double w0 = 1;
  //            const double w1 = 3;
  //            double dw = (w1 - w0)/path.OrientedSubpaths.Count;
  //            int i = 0;
  //            var dc = new Array<DebugCurve>();
  //            foreach (var s  of path.OrientedSubpaths){
  //                dc.AddRange(SubpathDebugCurves(w0 + dw*i, colors[Math.Min(i++, colors.Length - 1)], s));
  //            }
  //            LayoutAlgorithmSettings.ShowDebugCurves(dc.ToArray());
  //        }
  //
  //        static Array<DebugCurve> SubpathDebugCurves(double w, string color, OrientedSubpath subpath){
  //            return subpath.LinkedPath.Select(e => new DebugCurve(w, color, new LineSegment(e.Source.Point, e.Target.Point)));
  //        }
  // static GetObstacleBoundaries(obstacles: Array<Polyline>, color: string): Array<DebugCurve> {
  //    let debugCurves = new Array<DebugCurve>();
  //    if ((obstacles != null)) {
  //        debugCurves.AddRange(obstacles.select(() => {  }, new DebugCurve(50, 0.3, color, poly)));
  //    }
  //    return debugCurves;
  // }
  CreateConstraintsBetweenLongestSegments() {
    for (const t of this.LongestNudgedSegs)
      this.CreateConstraintsBetweenLongestSegmentsForSegment(t);
  }
  CreateConstraintsBetweenLongestSegmentsForSegment(t) {
    const e = /* @__PURE__ */ new Set();
    for (const i of t.Edges) {
      const s = i.AxisEdge;
      if (s != null)
        for (const n of s.RightNeighbors)
          for (const r of n.LongestNudgedSegments)
            e.add(r);
    }
    for (const i of e)
      this.ConstraintTwoLongestSegs(t, i);
  }
  CreateConstraintsOfTheOrder() {
    for (const t of this.PathOrders)
      nt.ParallelToDirection(t[0], this.NudgingDirection) && this.CreateConstraintsOfThePathOrder(t[1]);
  }
  static ParallelToDirection(t, e) {
    switch (e) {
      case S.North:
      case S.South:
        return D(t.SourcePoint.x, t.TargetPoint.x);
      default:
        return D(t.SourcePoint.y, t.TargetPoint.y);
    }
  }
  CreateConstraintsOfThePathOrder(t) {
    let e = null;
    for (const i of t.filter((s) => s.LongestNudgedSegment != null))
      e != null && this.ConstraintTwoLongestSegs(e.LongestNudgedSegment, i.LongestNudgedSegment), e = i;
  }
  ConstraintTwoLongestSegs(t, e) {
    (!t.IsFixed || !e.IsFixed) && this.Solver.AddConstraint(t.Id, e.Id);
  }
  CreateVariablesOfLongestSegment(t) {
    if (t.IsFixed)
      this.Solver.AddFixedVariable(t.Id, nt.SegmentPosition(t, this.NudgingDirection));
    else {
      const e = t.GetLeftBound(), i = t.GetRightBound();
      e >= i ? (this.Solver.AddFixedVariable(t.Id, nt.SegmentPosition(t, this.NudgingDirection)), t.IsFixed = !0) : (this.Solver.AddVariableNNNN(t.Id, nt.SegmentPosition(t, this.NudgingDirection), t.IdealPosition, t.Width), e !== Number.NEGATIVE_INFINITY && this.Solver.SetLowBound(e, t.Id), i !== Number.POSITIVE_INFINITY && this.Solver.SetUpperBound(t.Id, i));
    }
  }
  static SegmentPosition(t, e) {
    return e === S.North ? t.Start.x : -t.Start.y;
  }
  FindFreeSpaceInDirection(t) {
    this.BoundAxisEdgesByRectsKnownInAdvance(), new Ii(this.NudgingDirection, this.Obstacles, this.axisEdgesToObstaclesTheyOriginatedFrom, this.PathOrders, t).FindFreeSpace();
  }
  BoundAxisEdgesByRectsKnownInAdvance() {
    for (const t of this.Paths)
      this.HasGroups && this.BoundPathByMinCommonAncestors(t), this.BoundAxisEdgesAdjacentToSourceAndTargetOnEdge(t);
  }
  BoundPathByMinCommonAncestors(t) {
    for (const e of this.GetMinCommonAncestors(t.GeomEdge)) {
      const i = e.BoundingBox;
      for (const s of t.PathEdges()) {
        const n = s.AxisEdge;
        n.Direction === this.NudgingDirection && this.BoundAxisEdgeByRect(i, n);
      }
    }
  }
  GetMinCommonAncestors(t) {
    this.PortToShapes == null && (this.PortToShapes = nt.MapPortsToShapes(this.AncestorsSets.keys()));
    const e = pf(this.AncestorsForPort(t.sourcePort), this.AncestorsForPort(t.targetPort));
    return Array.from(e).filter((i) => !i.Children.some((s) => e.has(s)));
  }
  AncestorsForPort(t) {
    const e = this.PortToShapes.get(t);
    return e ? this.AncestorsSets.get(e) : new Set(this.HierarchyOfGroups.AllHitItems(T.mkPP(t.Location, t.Location), null));
  }
  BoundAxisEdgeAdjacentToObstaclePort(t, e) {
    t.Curve == null ? this.BoundAxisByPoint(t.Location, e) : t.Curve.boundingBox.contains(t.Location) && this.BoundAxisEdgeByRect(t.Curve.boundingBox, e);
  }
  BoundAxisByPoint(t, e) {
    e != null && e.Direction === this.NudgingDirection && (this.NudgingDirection === S.North ? (e.BoundFromLeft(t.x), e.BoundFromRight(t.x)) : (e.BoundFromLeft(-t.y), e.BoundFromRight(-t.y)));
  }
  BoundAxisEdgesAdjacentToSourceAndTargetOnEdge(t) {
    this.BoundAxisEdgeAdjacentToObstaclePort(t.GeomEdge.sourcePort, t.FirstEdge.AxisEdge), this.BoundAxisEdgeAdjacentToObstaclePort(t.GeomEdge.targetPort, t.LastEdge.AxisEdge);
  }
  BoundAxisEdgeByRect(t, e) {
    e != null && e.Direction === this.NudgingDirection && (this.NudgingDirection === S.North ? (e.BoundFromLeft(t.left), e.BoundFromRight(t.right)) : (e.BoundFromLeft(t.top * -1), e.BoundFromRight(t.bottom * -1)));
  }
  CreateLongestNudgedSegments() {
    const t = this.NudgingDirection === S.East ? (e) => -e.y : (e) => e.x;
    this.LongestNudgedSegs = new Array();
    for (let e = 0; e < this.Paths.length; e++)
      this.CreateLongestNudgedSegmentsForPath(this.Paths[e], t);
  }
  CreateLongestNudgedSegmentsForPath(t, e) {
    this.GoOverPathAndCreateLongSegs(t), nt.CalculateIdealPositionsForLongestSegs(t, e);
  }
  static CalculateIdealPositionsForLongestSegs(t, e) {
    let i = null, s = null, n = e(t.Start);
    for (const r of t.PathEdges())
      if (r.LongestNudgedSegment != null) {
        if (i = r.LongestNudgedSegment, s != null) {
          let a;
          nt.SetIdealPositionForSeg(s, a = e(s.start), n, e(i.Start)), n = a, s = null;
        }
      } else i != null && (s = i, i = null);
    s != null ? nt.SetIdealPositionForSeg(s, e(s.Start), n, e(t.End)) : i != null && (i.IdealPosition = e(i.Start));
  }
  static SetIdealPositionForSeg(t, e, i, s) {
    const n = Math.max(i, s), r = Math.min(i, s);
    r + m.distanceEpsilon < e ? e < n ? t.IdealPosition = 0.5 * (n + r) : t.IdealPosition = n : t.IdealPosition = r;
  }
  GoOverPathAndCreateLongSegs(t) {
    let e = null;
    const i = w.OppositeDir(this.NudgingDirection);
    for (const s of t.PathEdges()) {
      const n = s.Direction;
      n === this.NudgingDirection || n === i ? (e == null ? (s.LongestNudgedSegment = e = new df(this.LongestNudgedSegs.length), this.LongestNudgedSegs.push(e)) : s.LongestNudgedSegment = e, s.IsFixed && (e.IsFixed = !0)) : (s.LongestNudgedSegment = null, e = null);
    }
  }
  static BuildPolylineForPath(t) {
    const e = { points: t.PathPoints.map((i) => i.clone()) };
    return nt.ExtendPolylineToPorts(e, t), e.points;
  }
  static ExtendPolylineToPorts(t, e) {
    nt.ExtendPolylineToSourcePort(t, e.GeomEdge.sourcePort.Location), nt.ExtendPolylineToTargetPort(t, e.GeomEdge.targetPort.Location), t.points.length < 2 && (t.points = new Array(2), t.points[0] = e.GeomEdge.sourcePort.Location, t.points[1] = e.GeomEdge.targetPort.Location);
  }
  static ExtendPolylineToTargetPort(t, e) {
    const i = t.points.length - 1, s = w.VectorDirectionPP(t.points[i - 1], t.points[i]);
    if (nt.ProjectionsAreClose(t.points[i - 1], s, e)) {
      t.points = t.points.slice(0, i);
      return;
    }
    const n = t.points[i];
    s === S.East || s === S.West ? t.points[i] = new u(e.x, n.y) : t.points[i] = new u(n.x, e.y);
  }
  static ProjectionsAreClose(t, e, i) {
    return e === S.East || e === S.West ? D(t.x, i.x) : D(t.y, i.y);
  }
  static ExtendPolylineToSourcePort(t, e) {
    const i = w.VectorDirectionPP(t.points[0], t.points[1]);
    if (nt.ProjectionsAreClose(t.points[1], i, e)) {
      t.points = t.points.slice(1);
      return;
    }
    const s = t.points[0];
    i === S.East || i === S.West ? t.points[0] = new u(e.x, s.y) : t.points[0] = new u(s.x, e.y);
  }
  static RemoveSwitchbacksAndMiddlePoints(t) {
    const e = [];
    let i = t[0];
    e.push(i);
    let s = t[1], n = w.VectorDirectionPP(i, s), r = 1;
    for (; ++r < t.length; ) {
      const a = w.VectorDirectionPP(s, t[r]);
      a === n || w.OppositeDir(a) === n || a === S.None || (u.closeDistEps(i, s) || e.push(i = nt.Rectilinearise(i, s)), n = a), s = t[r];
    }
    return u.closeDistEps(i, s) || e.push(nt.Rectilinearise(i, s)), e;
  }
  // this function defines the final path coordinates
  // the set of paths, point sequences
  // the radius of the arc inscribed into the path corners
  // an enumeration of padded obstacles
  //
  //
  // <returns>the mapping of the path to its modified path</returns>
  static NudgePaths(t, e, i, s, n) {
    if (t.length === 0)
      return;
    const r = new nt(t, e, i, s);
    r.Calculate(S.North, !0), r.Calculate(S.East, !1), r.Calculate(S.North, !1), n && r.RemoveStaircases();
    for (const a of t)
      a.GeomEdge.curve = B.mkFromPoints(nt.BuildPolylineForPath(a));
  }
  RemoveStaircases() {
    ns.RemoveStaircases(this.Paths, this.HierarchyOfObstacles);
  }
  static MapPortsToShapes(t) {
    const e = /* @__PURE__ */ new Map();
    for (const i of t)
      for (const s of i.Ports)
        e.set(s, i);
    return e;
  }
  // ShowPathsDebug(edgePaths: Iterable<Path>, fn: string) {
  //  const debCurves = GetObstacleBoundaries(this.Obstacles, 'black')
  //  const i = 0
  //  for (const edgePath of edgePaths) {
  //    for (const c of Nudger.GetEdgePathFromPathEdgesAsDebugCurves(
  //      0.1,
  //      1.0,
  //      DebugCurve.colors[(i + 1) % DebugCurve.colors.length],
  //      edgePath,
  //    )) {
  //      debCurves.push(c)
  //    }
  //  }
  //  SvgDebugWriter.dumpDebugCurves(fn, debCurves)
  // }
  static *GetEdgePathFromPathEdgesAsDebugCurves(t, e, i, s) {
    const n = s.ArrayOfPathPoints(), r = n.length, a = r > 1 ? (e - t) / (r - 1) : 1;
    for (let l = 0; l < n.length - 1; l++)
      yield q.mkDebugCurveTWCI(200, t + a * l, i, v.mkPP(n[l], n[l + 1]));
  }
}
function pf(o, t) {
  const e = /* @__PURE__ */ new Set();
  if (o.size < t.size)
    for (const i of o)
      t.has(i) && e.add(i);
  else
    for (const i of t)
      o.has(i) && e.add(i);
  return e;
}
class mf {
  constructor(t, e) {
    this.Crossings = [], this.Location = t, this.Crossings = e;
  }
}
class yn {
  Count() {
    return this.ListOfPointsAndCrossings.length;
  }
  constructor() {
    this.ListOfPointsAndCrossings = [], this.index = 0, this.ListOfPointsAndCrossings = new Array();
  }
  Add(t, e) {
    this.ListOfPointsAndCrossings.push(new mf(t, e));
  }
  Pop() {
    return this.ListOfPointsAndCrossings[this.index++];
  }
  CurrentIsBeforeOrAt(t) {
    return this.index >= this.ListOfPointsAndCrossings.length ? !1 : b.ComparePP(this.ListOfPointsAndCrossings[this.index].Location, t) <= 0;
  }
  get First() {
    return this.ListOfPointsAndCrossings[0];
  }
  get Last() {
    return this.ListOfPointsAndCrossings[this.ListOfPointsAndCrossings.length - 1];
  }
  Reset() {
    this.index = 0;
  }
  MergeFrom(t) {
    if (this.Reset(), t == null)
      return;
    const e = this.ListOfPointsAndCrossings.length;
    let i = 0;
    const s = t.ListOfPointsAndCrossings.length;
    let n = 0;
    const r = new Array(this.ListOfPointsAndCrossings.length);
    for (; i < e || n < s; ) {
      if (i >= e) {
        r.push(t.ListOfPointsAndCrossings[n++]);
        continue;
      }
      if (n >= s) {
        r.push(this.ListOfPointsAndCrossings[i++]);
        continue;
      }
      const a = this.ListOfPointsAndCrossings[i], l = t.ListOfPointsAndCrossings[n], h = b.ComparePP(a.Location, l.Location);
      h === 0 ? (r.push(a), ++i, ++n) : h === -1 ? (r.push(a), ++i) : (r.push(l), ++n);
    }
    this.ListOfPointsAndCrossings = r;
  }
  Trim(t, e) {
    this.Reset(), !(this.ListOfPointsAndCrossings == null || this.ListOfPointsAndCrossings.length === 0) && (this.ListOfPointsAndCrossings = this.ListOfPointsAndCrossings.filter((i) => b.ComparePP(i.Location, t) >= 0 && b.ComparePP(i.Location, e) <= 0));
  }
  // For a single vertex point, split its Array of crossings in both directions into an array in each (opposite)
  // direction.  CLR Array iteration is much faster than Array.
  static ToCrossingArray(t, e) {
    let i = 0;
    const s = t.length;
    for (let a = 0; a < s; a++)
      t[a].DirectionToInside === e && i++;
    if (i === 0)
      return null;
    const n = new Array(i);
    let r = 0;
    for (let a = 0; a < s; a++)
      t[a].DirectionToInside === e && (n[r++] = t[a]);
    return n;
  }
  ToString() {
    return Bt.String.format("{0} [{1}]", this.ListOfPointsAndCrossings.length, this.index);
  }
}
class O {
  // Determine the direction of an edge.
  static EdgeDirectionVE(t) {
    return O.EdgeDirectionVV(t.Source, t.Target);
  }
  static EdgeDirectionVV(t, e) {
    return b.GetDirections(t.point, e.point);
  }
  static GetEdgeEnd(t, e) {
    const i = O.EdgeDirectionVE(t);
    return e === i ? t.Target : t.Source;
  }
  static FindAdjacentVertex(t, e) {
    for (const i of t.InEdges)
      if (b.GetDirections(t.point, i.SourcePoint) === e)
        return i.Source;
    for (const i of t.OutEdges)
      if (b.GetDirections(t.point, i.TargetPoint) === e)
        return i.Target;
    return null;
  }
  static FindAdjacentEdge(t, e) {
    for (const i of t.InEdges)
      if (b.GetDirections(i.SourcePoint, t.point) === e)
        return i;
    for (const i of t.OutEdges)
      if (b.GetDirections(t.point, i.TargetPoint) === e)
        return i;
    return null;
  }
  static FindBendPointBetween(t, e, i) {
    return O.IsVerticalD(i) ? new u(e.x, t.y) : new u(t.x, e.y);
  }
  static SegmentIntersectionPPP(t, e, i) {
    const s = b.GetDirections(t, e);
    return O.IsVerticalD(s) ? new u(t.x, i.y) : new u(i.x, t.y);
  }
  static SegmentIntersectionSP(t, e) {
    return O.SegmentIntersectionPPP(t.Start, t.End, e);
  }
  static SegmentsIntersection(t, e) {
    return O.IntervalsIntersect(t.Start, t.End, e.Start, e.End);
  }
  static SegmentsIntersectLL(t, e) {
    return O.IntervalsIntersect(t.start, t.end, e.start, e.end);
  }
  static IntervalsOverlapSS(t, e) {
    return O.IntervalsOverlapPPPP(t.Start, t.End, e.Start, e.End);
  }
  static IntervalsOverlapPPPP(t, e, i, s) {
    return O.IntervalsAreCollinear(t, e, i, s) && b.ComparePP(t, s) !== b.ComparePP(e, i);
  }
  static IntervalsAreCollinear(t, e, i, s) {
    const n = O.IsVerticalPP(t, e);
    return O.IsVerticalPP(i, s) === n ? n ? b.Equal(t.x, i.x) : b.Equal(t.y, i.y) : !1;
  }
  static IntervalsAreSame(t, e, i, s) {
    return b.EqualPP(t, i) && b.EqualPP(e, s);
  }
  static IntervalsIntersect(t, e, i, s) {
    const n = O.SegmentIntersectionPPP(t, e, i);
    return O.PointIsOnSegmentPPP(t, e, n) && O.PointIsOnSegmentPPP(i, s, n) ? n : void 0;
  }
  static SegmentIntersectionEP(t, e) {
    return O.SegmentIntersectionPPP(t.SourcePoint, t.TargetPoint, e);
  }
  static PointIsOnSegmentPPP(t, e, i) {
    return b.EqualPP(t, i) || b.EqualPP(e, i) || b.GetDirections(t, i) === b.GetDirections(i, e);
  }
  static PointIsOnSegmentSP(t, e) {
    return O.PointIsOnSegmentPPP(t.Start, t.End, e);
  }
  static IsVerticalD(t) {
    return (t & (S.North | S.South)) !== 0;
  }
  static IsVerticalE(t) {
    return O.IsVerticalD(b.GetDirections(t.SourcePoint, t.TargetPoint));
  }
  static IsVerticalPP(t, e) {
    return O.IsVerticalD(b.GetDirections(t, e));
  }
  static IsVertical(t) {
    return O.IsVerticalD(b.GetDirections(t.start, t.end));
  }
  static IsAscending(t) {
    return (t & (S.North | S.East)) !== 0;
  }
  static Slope(t, e, i) {
    const s = e.sub(t);
    return s.dot(i.PerpDirectionAsPoint) / s.dot(i.DirectionAsPoint);
  }
  static SortAscending(t, e) {
    const i = b.GetDirections(t, e);
    return S.None === i || O.IsAscending(i) ? [t, e] : [e, t];
  }
  static RectangleBorderIntersect(t, e, i) {
    switch (i) {
      case S.North:
      case S.South:
        return new u(e.x, O.GetRectangleBound(t, i));
      case S.East:
      case S.West:
        return new u(O.GetRectangleBound(t, i), e.y);
      default:
        throw new Error();
    }
  }
  static GetRectangleBound(t, e) {
    switch (e) {
      case S.North:
        return t.top;
      case S.South:
        return t.bottom;
      case S.East:
        return t.right;
      case S.West:
        return t.left;
      default:
        throw new Error();
    }
  }
  static RectangleInteriorsIntersect(t, e) {
    return b.Compare(t.bottom, e.top) < 0 && b.Compare(e.bottom, t.top) < 0 && b.Compare(t.left, e.right) < 0 && b.Compare(e.left, t.right) < 0;
  }
  static PointIsInRectangleInterior(t, e) {
    return b.Compare(t.y, e.top) < 0 && b.Compare(e.bottom, t.y) < 0 && b.Compare(t.x, e.right) < 0 && b.Compare(e.left, t.x) < 0;
  }
}
class Pt {
  get Dir() {
    return this.dir;
  }
  set Dir(t) {
    this.dir = t;
  }
  // Use the internal static xxxInstance properties to get an instance.
  constructor(t) {
    this.Dir = t, this.DirectionAsPoint = w.toPoint(this.Dir), this.PerpDirection = S.North === t ? S.East : S.North, this.PerpDirectionAsPoint = w.toPoint(this.PerpDirection), this.OppositeDirection = w.OppositeDir(t);
  }
  get IsHorizontal() {
    return S.East === this.Dir;
  }
  get IsVertical() {
    return S.North === this.Dir;
  }
  // Compare in perpendicular direction first, then parallel direction.
  Compare(t, e) {
    const i = this.ComparePerpCoord(t, e);
    return i !== 0 ? i : this.CompareScanCoord(t, e);
  }
  CompareScanCoord(t, e) {
    return b.Compare(t.sub(e).dot(this.DirectionAsPoint), 0);
  }
  ComparePerpCoord(t, e) {
    return b.Compare(t.sub(e).dot(this.PerpDirectionAsPoint), 0);
  }
  IsFlatS(t) {
    return this.IsFlatPP(t.Start, t.End);
  }
  IsFlatPP(t, e) {
    return b.Equal(e.sub(t).dot(this.PerpDirectionAsPoint), 0);
  }
  IsPerpendicularS(t) {
    return this.IsPerpendicularPP(t.Start, t.End);
  }
  IsPerpendicularPP(t, e) {
    return b.Equal(e.sub(t).dot(this.DirectionAsPoint), 0);
  }
  Coord(t) {
    return t.dot(this.DirectionAsPoint);
  }
  Min(t, e) {
    return this.Compare(t, e) <= 0 ? t : e;
  }
  Max(t, e) {
    return this.Compare(t, e) >= 0 ? t : e;
  }
  get PerpendicularInstance() {
    return this.IsHorizontal ? Pt.VerticalInstance : Pt.HorizontalInstance;
  }
  static GetInstance(t) {
    return O.IsVerticalD(t) ? Pt.VerticalInstance : Pt.HorizontalInstance;
  }
  ToString() {
    return this.Dir.toString();
  }
}
Pt.HorizontalInstance = new Pt(S.East);
Pt.VerticalInstance = new Pt(S.North);
class W extends ca {
  static mk(t, e) {
    return new W(
      t,
      e,
      W.NormalWeight,
      /* gbcList:*/
      null
    );
  }
  constructor(t, e, i, s) {
    super(), this.Update(t, e), this.Weight = i, this.GroupBoundaryPointAndCrossingsList = s;
  }
  get Start() {
    return this.startPoint;
  }
  get End() {
    return this.endPoint;
  }
  get IsVertical() {
    return W.IsVerticalSegment(this.Start, this.End);
  }
  get ScanDirection() {
    return this.IsVertical ? Pt.VerticalInstance : Pt.HorizontalInstance;
  }
  // For overlaps, we will need to create a VisibilityVertex at the junction of overlapped/nonoverlapped
  // segments, but we don't want to create this for non-overlapped situations.
  get IsOverlapped() {
    return W.OverlappedWeight === this.Weight;
  }
  get IsReflection() {
    return W.ReflectionWeight === this.Weight;
  }
  static IsVerticalSegment(t, e) {
    return t.x === e.x;
  }
  MergeGroupBoundaryCrossingList(t) {
    t != null && (this.GroupBoundaryPointAndCrossingsList == null && (this.GroupBoundaryPointAndCrossingsList = new yn()), this.GroupBoundaryPointAndCrossingsList.MergeFrom(t));
  }
  TrimGroupBoundaryCrossingList() {
    this.GroupBoundaryPointAndCrossingsList != null && this.GroupBoundaryPointAndCrossingsList.Trim(this.Start, this.End);
  }
  // ctor
  Update(t, e) {
    this.startPoint = t, this.endPoint = e;
  }
  SetInitialVisibilityVertex(t) {
    this.LowestVisibilityVertex = t, this.HighestVisibilityVertex = t;
  }
  AppendVisibilityVertex(t, e) {
    if (this.HighestVisibilityVertex == null)
      this.AddGroupCrossingsBeforeHighestVisibilityVertex(t, e) || this.SetInitialVisibilityVertex(e);
    else {
      if (b.IsPureLower(e.point, this.HighestVisibilityVertex.point))
        return;
      this.AddGroupCrossingsBeforeHighestVisibilityVertex(t, e) || this.AppendHighestVisibilityVertex(e);
    }
  }
  AddVisibilityEdge(t, e) {
    const i = new ce(t, e, this.Weight);
    return Et.AddEdge(i), i;
  }
  AppendHighestVisibilityVertex(t) {
    b.EqualPP(this.HighestVisibilityVertex.point, t.point) || (this.AddVisibilityEdge(this.HighestVisibilityVertex, t), this.HighestVisibilityVertex = t);
  }
  LoadStartOverlapVertexIfNeeded(t) {
    if (this.NeedStartOverlapVertex) {
      const e = t.FindVertex(this.Start);
      this.AppendVisibilityVertex(t, e ?? t.AddVertexP(this.Start));
    }
  }
  LoadEndOverlapVertexIfNeeded(t) {
    if (this.NeedEndOverlapVertex) {
      const e = t.FindVertex(this.End);
      this.AppendVisibilityVertex(t, e ?? t.AddVertexP(this.End));
    }
  }
  OnSegmentIntersectorBegin(t) {
    this.AppendGroupCrossingsThroughPoint(t, this.Start) || this.LoadStartOverlapVertexIfNeeded(t);
  }
  OnSegmentIntersectorEnd(t) {
    this.AppendGroupCrossingsThroughPoint(t, this.End), this.GroupBoundaryPointAndCrossingsList = null, (this.HighestVisibilityVertex == null || b.IsPureLower(this.HighestVisibilityVertex.point, this.End)) && this.LoadEndOverlapVertexIfNeeded(t);
  }
  // If we have collinear segments, then we may be able to just update the previous one
  // instead of growing the ScanSegmentTree.
  // - For multiple collinear OpenVertexEvents, neighbors to the high side have not yet
  //   been seen, so a segment is created that spans the lowest and highest neighbors.
  //   A subsequent collinear OpenVertexEvent will be to the high side and will add a
  //   subsegment of that segment, so we subsume it into LastAddedSegment.
  // - For multiple collinear CloseVertexEvents, closing neighbors to the high side are
  //   still open, so a segment is created from the lowest neighbor to the next-highest
  //   collinear obstacle to be closed.  When that next-highest CloseVertexEvent is
  //   encountered, it will extend LastAddedSegment.
  // - For multiple collinear mixed Open and Close events, we'll do all Opens first,
  //   followed by all closes (per EventQueue opening), so we may add multiple discrete
  //   segments, which ScanSegmentTree will merge.
  static Subsume(t, e, i, s, n, r, a, l) {
    return l.extendStart = !0, l.extendEnd = !0, t.seg == null || !O.IntervalsOverlapPPPP(t.seg.Start, t.seg.End, e, i) ? !1 : t.seg.Weight !== s ? t.seg.Start === e && t.seg.End === i ? (t.seg.Weight = Math.min(t.seg.Weight, s), !0) : !1 : (l.extendStart = r.CompareScanCoord(e, t.seg.Start) === -1, l.extendEnd = r.CompareScanCoord(i, t.seg.End) === 1, (l.extendStart || l.extendEnd) && (a.Remove(t.seg), t.seg.startPoint = r.Min(t.seg.Start, e), t.seg.endPoint = r.Max(t.seg.End, i), t.seg = a.InsertUnique(t.seg).item, t.seg.MergeGroupBoundaryCrossingList(n)), !0);
  }
  IntersectsSegment(t) {
    return O.SegmentsIntersection(this, t) !== void 0;
  }
  toString() {
    return "[" + this.Start + " -> " + this.End + (this.IsOverlapped ? " olap" : " free") + "]";
  }
  ContainsPoint(t) {
    return b.EqualPP(this.Start, t) || b.EqualPP(this.End, t) || b.GetDirections(this.Start, t) === b.GetDirections(t, this.End);
  }
  get HasSparsePerpendicularCoords() {
    return this.sparsePerpendicularCoords == null ? !1 : this.sparsePerpendicularCoords.size > 0;
  }
  CreatePointFromPerpCoord(t) {
    return this.IsVertical ? new u(this.Start.x, t) : new u(t, this.Start.y);
  }
  AddSparseVertexCoord(t) {
    this.sparsePerpendicularCoords == null && (this.sparsePerpendicularCoords = /* @__PURE__ */ new Set()), this.sparsePerpendicularCoords.add(t);
  }
  AddSparseEndpoint(t) {
    return this.sparsePerpendicularCoords.has(t) ? !1 : (this.sparsePerpendicularCoords.add(t), !0);
  }
  CreateSparseVerticesAndEdges(t) {
    var e;
    if (this.sparsePerpendicularCoords != null) {
      this.AppendGroupCrossingsThroughPoint(t, this.Start);
      for (const i of Array.from(this.sparsePerpendicularCoords.values()).sort(yt)) {
        const s = this.CreatePointFromPerpCoord(i);
        this.AppendVisibilityVertex(t, (e = t.FindVertex(s)) !== null && e !== void 0 ? e : t.AddVertexP(s));
      }
      this.AppendGroupCrossingsThroughPoint(t, this.End), this.GroupBoundaryPointAndCrossingsList = null, this.sparsePerpendicularCoords.clear(), this.sparsePerpendicularCoords = null;
    }
  }
  HasVisibility() {
    return this.LowestVisibilityVertex != null;
  }
  AddGroupCrossingsBeforeHighestVisibilityVertex(t, e) {
    return this.AppendGroupCrossingsThroughPoint(t, e.point) ? (b.IsPureLower(this.HighestVisibilityVertex.point, e.point) && (this.AddVisibilityEdge(this.HighestVisibilityVertex, e), this.HighestVisibilityVertex = e), !0) : !1;
  }
  AppendGroupCrossingsThroughPoint(t, e) {
    var i;
    if (this.GroupBoundaryPointAndCrossingsList == null)
      return !1;
    let s = !1;
    for (; this.GroupBoundaryPointAndCrossingsList.CurrentIsBeforeOrAt(e); ) {
      const n = this.GroupBoundaryPointAndCrossingsList.Pop();
      let r = null, a = null;
      b.ComparePP(n.Location, this.Start) > 0 && (r = yn.ToCrossingArray(n.Crossings, this.ScanDirection.OppositeDirection)), b.ComparePP(n.Location, this.End) < 0 && (a = yn.ToCrossingArray(n.Crossings, this.ScanDirection.Dir)), s = !0;
      const l = (i = t.FindVertex(n.Location)) !== null && i !== void 0 ? i : t.AddVertexP(n.Location);
      t.AddVertexP(n.Location), r != null || a != null ? (this.AddLowCrossings(t, l, r), this.AddHighCrossings(t, l, a)) : this.LowestVisibilityVertex == null ? this.SetInitialVisibilityVertex(l) : this.AppendHighestVisibilityVertex(l);
    }
    return s;
  }
  static GetCrossingInteriorVertex(t, e, i) {
    var s;
    const n = i.GetInteriorVertexPoint(e.point);
    return (s = t.FindVertex(n)) !== null && s !== void 0 ? s : t.AddVertexP(n);
  }
  AddCrossingEdge(t, e, i, s) {
    let n = null;
    this.HighestVisibilityVertex != null && (b.EqualPP(this.HighestVisibilityVertex.point, i.point) ? n = t.FindEdgePP(e.point, i.point) : this.AppendHighestVisibilityVertex(e)), n == null && (n = this.AddVisibilityEdge(e, i));
    const r = s.map((l) => l.Group.InputShape), a = n.IsPassable;
    a == null ? n.IsPassable = () => {
      for (const l of r)
        if (l.IsTransparent)
          return !0;
      return !1;
    } : n.IsPassable = () => {
      for (const l of r)
        if (l.IsTransparent || a())
          return !0;
      return !1;
    }, this.LowestVisibilityVertex == null && this.SetInitialVisibilityVertex(e), this.HighestVisibilityVertex = i;
  }
  AddLowCrossings(t, e, i) {
    if (i != null) {
      const s = W.GetCrossingInteriorVertex(t, e, i[0]);
      this.AddCrossingEdge(t, s, e, i);
    }
  }
  AddHighCrossings(t, e, i) {
    if (i != null) {
      const s = W.GetCrossingInteriorVertex(t, e, i[0]);
      this.AddCrossingEdge(t, e, s, i);
    }
  }
}
W.NormalWeight = ce.DefaultWeight;
W.ReflectionWeight = 5;
W.OverlappedWeight = 500;
class cl {
  // A class that records an entry from a specific direction for a vertex.
  // Vertex that this VertexEntry enters
  // The previous VertexEntry along this path; null for a path source
  // Length of the path up to this vertex
  // Number of bends in the path up to this vertex
  // Cost of the path up to this vertex
  constructor(t, e, i, s, n) {
    this.IsClosed = !1, this.Vertex = t, this.Direction = e != null ? w.DirectionFromPointToPoint(e.Vertex.point, t.point) : S.None, this.ResetEntry(e, i, s, n);
  }
  ResetEntry(t, e, i, s) {
    this.PreviousEntry = t, this.Length = e, this.NumberOfBends = i, this.Cost = s;
  }
  // The vertex that this VertexEntry is entered from
  get PreviousVertex() {
    return this.PreviousEntry == null ? null : this.PreviousEntry.Vertex;
  }
  toString() {
    return this.Vertex.point + (" " + (this.Direction + (" " + (this.IsClosed + (" " + this.Cost)))));
  }
}
class yo {
  constructor() {
    this.Clear();
  }
  Set(t, e) {
    this.Vertex = t, this.Weight = e;
  }
  Clear() {
    this.Vertex = null, this.Weight = Number.NaN;
  }
}
class K {
  // The cost of the path calculation
  CombinedCost(t, e) {
    return this.LengthImportance * t + this.BendsImportance * e;
  }
  TotalCostFromSourceToVertex(t, e) {
    return this.CombinedCost(t, e) + this.sourceCostAdjustment;
  }
  constructor() {
    this.nextNeighbors = [new yo(), new yo(), new yo()], this.LengthImportance = 1, this.BendsImportance = 1;
  }
  InitPath(t, e, i) {
    if (e === i || !this.InitEntryDirectionsAtTarget(i))
      return !1;
    this.Target = i, this.Source = e;
    const s = this.TotalCostFromSourceToVertex(0, 0) + this.HeuristicDistanceFromVertexToTarget(e.point, S.None);
    return s >= this.upperBoundOnCost ? !1 : (this.queue = new es(yt), this.visitedVertices = [e], t == null ? this.EnqueueInitialVerticesFromSource(s) : this.EnqueueInitialVerticesFromSourceEntries(t), this.queue.count > 0);
  }
  InitEntryDirectionsAtTarget(t) {
    this.EntryDirectionsToTarget = S.None;
    for (const e of t.OutEdges)
      this.EntryDirectionsToTarget = this.EntryDirectionsToTarget | w.DirectionFromPointToPoint(e.TargetPoint, t.point);
    for (const e of t.InEdges)
      this.EntryDirectionsToTarget = this.EntryDirectionsToTarget | w.DirectionFromPointToPoint(e.SourcePoint, t.point);
    return this.EntryDirectionsToTarget !== S.None;
  }
  static IsInDirs(t, e) {
    return t === (t & e);
  }
  MultistageAdjustedCostBound(t) {
    return Number.isFinite(t) ? t + this.BendsImportance : t;
  }
  // estimation from below for the distance
  HeuristicDistanceFromVertexToTarget(t, e) {
    const i = this.Target.point.sub(t);
    if (D(i.x, 0) && D(i.y, 0))
      return this.targetCostAdjustment;
    const s = w.VectorDirection(i);
    let n;
    return e === S.None ? (e = S.East | (S.North | (S.West | S.South)), n = this.GetNumberOfBends(e, s)) : n = this.GetNumberOfBends(e, s), this.CombinedCost(K.ManhattanDistance(t, this.Target.point), n) + this.targetCostAdjustment;
  }
  GetNumberOfBends(t, e) {
    return w.IsPureDirection(e) ? this.GetNumberOfBendsForPureDirection(t, e) : K.GetBendsForNotPureDirection(e, t, this.EntryDirectionsToTarget);
  }
  GetNumberOfBendsForPureDirection(t, e) {
    return (e & t) === e ? K.IsInDirs(e, this.EntryDirectionsToTarget) ? 0 : K.IsInDirs(K.Left(e), this.EntryDirectionsToTarget) || K.IsInDirs(K.Right(e), this.EntryDirectionsToTarget) ? 2 : 4 : this.GetNumberOfBendsForPureDirection(K.AddOneTurn[t], e) + 1;
  }
  static GetBendsForNotPureDirection(t, e, i) {
    const s = t & e;
    if (s === S.None)
      return K.GetBendsForNotPureDirection(t, K.AddOneTurn[e], i) + 1;
    const n = t & i;
    return n === S.None ? K.GetBendsForNotPureDirection(t, e, K.AddOneTurn[i]) + 1 : (s | n) === t ? 1 : 2;
  }
  static Left(t) {
    switch (t) {
      case S.None:
        return S.None;
      case S.North:
        return S.West;
      case S.East:
        return S.North;
      case S.South:
        return S.East;
      case S.West:
        return S.South;
      default:
        throw new Error("direction");
    }
  }
  static Right(t) {
    switch (t) {
      case S.None:
        return S.None;
      case S.North:
        return S.East;
      case S.East:
        return S.South;
      case S.South:
        return S.West;
      case S.West:
        return S.North;
      default:
        throw new Error("direction");
    }
  }
  static RestorePathV(t) {
    return K.RestorePath(t, null);
  }
  static RestorePath(t, e) {
    if (t.entry == null)
      return [];
    const i = new Array();
    let s = !1, n = S.None;
    for (; ; ) {
      n === t.entry.Direction ? s = !0 : (s = !1, i.push(t.entry.Vertex.point), n = t.entry.Direction);
      const r = t.entry.PreviousEntry;
      if (r == null || t.entry.Vertex === e)
        break;
      t.entry = r;
    }
    return s && i.push(t.entry.Vertex.point), i.reverse(), i;
  }
  QueueReversedEntryToNeighborVertexIfNeeded(t, e, i) {
    const s = { numberOfBends: 0, length: 0 }, n = e.PreviousVertex, r = K.GetLengthAndNumberOfBendsToNeighborVertex(t, n, i, s);
    if (this.CombinedCost(s.length, s.numberOfBends) < this.CombinedCost(e.Length, e.NumberOfBends) || t.Vertex.Degree === 1) {
      const a = this.TotalCostFromSourceToVertex(s.length, s.numberOfBends) + this.HeuristicDistanceFromVertexToTarget(n.point, r);
      this.EnqueueEntry(t, n, s.length, s.numberOfBends, a);
    }
  }
  UpdateEntryToNeighborVertexIfNeeded(t, e, i) {
    const s = {
      numberOfBends: 0,
      length: 0
    }, n = K.GetLengthAndNumberOfBendsToNeighborVertex(t, e.Vertex, i, s);
    if (this.CombinedCost(s.length, s.numberOfBends) < this.CombinedCost(e.Length, e.NumberOfBends)) {
      const r = this.TotalCostFromSourceToVertex(s.length, s.numberOfBends) + this.HeuristicDistanceFromVertexToTarget(e.Vertex.point, n);
      e.ResetEntry(t, s.length, s.numberOfBends, r), this.queue.DecreasePriority(e, r);
    }
  }
  CreateAndEnqueueEntryToNeighborVertex(t, e, i) {
    const s = { numberOfBends: 0, length: 0 }, n = K.GetLengthAndNumberOfBendsToNeighborVertex(t, e, i, s), r = this.TotalCostFromSourceToVertex(s.length, s.numberOfBends) + this.HeuristicDistanceFromVertexToTarget(e.point, n);
    r < this.upperBoundOnCost && (e.VertexEntries == null && this.visitedVertices.push(e), this.EnqueueEntry(t, e, s.length, s.numberOfBends, r));
  }
  EnqueueEntry(t, e, i, s, n) {
    const r = new cl(e, t, i, s, n);
    e.SetVertexEntry(r), this.queue.Enqueue(r, r.Cost);
  }
  static GetLengthAndNumberOfBendsToNeighborVertex(t, e, i, s) {
    s.length = t.Length + K.ManhattanDistance(t.Vertex.point, e.point) * i;
    const n = w.DirectionFromPointToPoint(t.Vertex.point, e.point);
    return s.numberOfBends = t.NumberOfBends, t.Direction !== S.None && n !== t.Direction && s.numberOfBends++, n;
  }
  static ManhattanDistance(t, e) {
    return Math.abs(e.x - t.x) + Math.abs(e.y - t.y);
  }
  GetPathWithCost(t, e, i, s, n, r, a) {
    if (this.upperBoundOnCost = a, this.sourceCostAdjustment = i, this.targetCostAdjustment = r, !this.InitPath(t, e, n))
      return null;
    for (; this.queue.count > 0; ) {
      const l = this.queue.Dequeue(), h = l.Vertex;
      if (h === this.Target) {
        if (s == null)
          return this.Cleanup(), l;
        if (l.Direction, this.EntryDirectionsToTarget === S.None) {
          let d = 0;
          for (const f of this.Target.VertexEntries)
            s[d++] = f;
          return this.Cleanup(), null;
        }
        this.upperBoundOnCost = Math.min(this.MultistageAdjustedCostBound(l.Cost), this.upperBoundOnCost);
        continue;
      }
      l.IsClosed = !0;
      for (const d of this.nextNeighbors)
        d.Clear();
      const c = K.Right(l.Direction);
      this.ExtendPathAlongInEdges(l, h.InEdges, c), this.ExtendPathAlongOutEdges(l, h.OutEdges, c);
      for (const d of this.nextNeighbors)
        d.Vertex != null && this.ExtendPathToNeighborVertex(l, d.Vertex, d.Weight);
    }
    if (s != null && this.Target.VertexEntries != null)
      for (let l = 0; l < this.Target.VertexEntries.length; l++)
        s[l] = this.Target.VertexEntries[l];
    return this.Cleanup(), null;
  }
  ExtendPathAlongInEdges(t, e, i) {
    for (const s of e)
      this.ExtendPathAlongEdge(t, s, !0, i);
  }
  ExtendPathAlongOutEdges(t, e, i) {
    let s = e.isEmpty() ? null : e.treeMinimum();
    for (; s != null; s = e.next(s))
      this.ExtendPathAlongEdge(t, s.item, !1, i);
  }
  ExtendPathAlongEdge(t, e, i, s) {
    if (!K.IsPassable(e))
      return;
    const n = i ? e.Source : e.Target;
    if (n === t.PreviousVertex) {
      if (t.Vertex.Degree > 1 || t.Vertex !== this.Source)
        return;
      this.ExtendPathToNeighborVertex(t, n, e.Weight);
      return;
    }
    const r = w.DirectionFromPointToPoint(t.Vertex.point, n.point);
    let a = this.nextNeighbors[2];
    r !== t.Direction && (a = this.nextNeighbors[r === s ? 1 : 0]), a.Set(n, e.Weight);
  }
  EnqueueInitialVerticesFromSource(t) {
    const e = new cl(this.Source, null, 0, 0, t);
    e.IsClosed = !0;
    for (const i of this.Source.OutEdges)
      K.IsPassable(i) && this.ExtendPathToNeighborVertex(e, i.Target, i.Weight);
    for (const i of this.Source.InEdges)
      K.IsPassable(i) && this.ExtendPathToNeighborVertex(e, i.Source, i.Weight);
  }
  EnqueueInitialVerticesFromSourceEntries(t) {
    for (const e of t)
      e != null && this.queue.Enqueue(e, e.Cost);
  }
  ExtendPathToNeighborVertex(t, e, i) {
    const s = w.DirectionFromPointToPoint(t.Vertex.point, e.point), n = e.VertexEntries != null ? e.VertexEntries[w.ToIndex(s)] : null;
    n == null ? this.CreateAndEnqueueReversedEntryToNeighborVertex(t, e, i) || this.CreateAndEnqueueEntryToNeighborVertex(t, e, i) : n.IsClosed || this.UpdateEntryToNeighborVertexIfNeeded(t, n, i);
  }
  CreateAndEnqueueReversedEntryToNeighborVertex(t, e, i) {
    if (t.Vertex.VertexEntries != null) {
      const s = w.DirectionFromPointToPoint(e.point, t.Vertex.point), n = t.Vertex.VertexEntries[w.ToIndex(s)];
      if (n != null)
        return this.QueueReversedEntryToNeighborVertexIfNeeded(t, n, i), !0;
    }
    return !1;
  }
  static IsPassable(t) {
    return t.IsPassable == null || t.IsPassable();
  }
  Cleanup() {
    for (const t of this.visitedVertices)
      t.RemoveVertexEntries();
    this.visitedVertices = [], this.queue = null;
  }
}
K.DefaultBendPenaltyAsAPercentageOfDistance = 4;
K.AddOneTurn = [
  S.None,
  S.North | S.East | S.West,
  S.North | S.East | S.South,
  15,
  S.East | S.South | S.West,
  15,
  15,
  15,
  13,
  15,
  15,
  15,
  15,
  15,
  15,
  15
  //15
];
class bn {
  constructor(t) {
    this.bendPenaltyAsAPercentageOfDistance = K.DefaultBendPenaltyAsAPercentageOfDistance, this.currentPassTargetEntries = new Array(4), this.bendPenaltyAsAPercentageOfDistance = t;
  }
  // Get the lowest-cost path from one of one or more sources to one of one or more targets, without waypoints.
  // One or more source vertices
  // One or more target vertices
  // <returns>A single enumeration of path points.</returns>
  GetPath(t, e) {
    const i = { entry: this.GetPathStage(null, t, null, e) };
    return K.RestorePathV(i);
  }
  // Route a single stage of a possibly multi-stage (due to waypoints) path.
  // The VertexEntry array that was in the source vertex if it was the target of a prior stage.
  // The enumeration of source vertices; must be only one if sourceVertexEntries is non-null.
  // The enumeration of target vertex entries; must be only one if targetVertexEntries is non-null.
  // The VertexEntry array that is in the target at the end of the stage.
  GetPathStage(t, e, i, s) {
    const n = new K(), r = {
      bestEntry: null,
      // This contains the best (lowest) path cost after normalizing origins to the center of the sources
      // and targets.  This is used to avoid selecting a vertex pair whose path has more bends than another pair of
      // vertices, but the bend penalty didn't total enough to offset the additional length between the "better" pair.
      // This also plays the role of an upper bound on the path length; if a path cost is greater than adjustedMinCost
      // then we stop exploring it, which saves considerable time after low-cost paths have been found.
      bestCost: Number.MAX_VALUE / W.OverlappedWeight
    };
    let a = Number.POSITIVE_INFINITY;
    const l = bn.Barycenter(e), h = bn.Barycenter(s), c = K.ManhattanDistance(l, h);
    n.BendsImportance = Math.max(1e-3, c * (this.bendPenaltyAsAPercentageOfDistance * 0.01));
    const d = n.LengthImportance, f = i != null ? this.currentPassTargetEntries : null, p = [];
    for (const C of e)
      for (const E of s)
        p.push([C, E]);
    p.sort(([C, E], [N, I]) => P(C, E) - P(N, I));
    for (const [C, E] of p) {
      if (u.closeDistEps(C.point, E.point))
        continue;
      const N = y(C, l) * d, I = y(E, h) * d;
      let x = r.bestCost;
      if (i != null) {
        for (let X = 0; X < f.length; X++)
          f[X] = null;
        x = n.MultistageAdjustedCostBound(r.bestCost);
      }
      const V = n.GetPathWithCost(t, C, N, f, E, I, x);
      if (f != null) {
        bn.UpdateTargetEntriesForEachDirection(i, f, r);
        continue;
      }
      if (V == null)
        continue;
      const G = V.Cost / P(C, E);
      (V.Cost < r.bestCost || D(V.Cost, r.bestCost) && G < a) && (r.bestCost = V.Cost, r.bestEntry = V, a = V.Cost / P(C, E));
    }
    return r.bestEntry;
    function P(C, E) {
      return K.ManhattanDistance(C.point, E.point);
    }
    function y(C, E) {
      return K.ManhattanDistance(C.point, E);
    }
  }
  static UpdateTargetEntriesForEachDirection(t, e, i) {
    for (let s = 0; s < e.length; s++) {
      const n = e[s];
      n != null && (t[s] == null || n.Cost < t[s].Cost) && (t[s] = n, n.Cost < i.bestCost && (i.bestCost = n.Cost, i.bestEntry = n));
    }
  }
  static Barycenter(t) {
    let e = new u(0, 0);
    for (const i of t)
      e = e.add(i.point);
    return e.div(t.length);
  }
}
class Pf {
  get PathPoints() {
    return this._pathPoints;
  }
  set PathPoints(t) {
    this._pathPoints = t;
  }
  get Width() {
    return this.GeomEdge.lineWidth;
  }
  // constructor
  constructor(t) {
    this.GeomEdge = t;
  }
  get End() {
    return this.LastEdge.Target;
  }
  get Start() {
    return this.FirstEdge.Source;
  }
  ArrayOfPathPoints() {
    return this._pathPoints instanceof Ri ? Array.from(ul(this._pathPoints)) : this._pathPoints;
  }
  *PathEdges() {
    for (let t = this.FirstEdge; t != null; t = t.Next)
      yield t;
  }
  AddEdge(t) {
    t.Path = this, this.LastEdge.Next = t, t.Prev = this.LastEdge, this.LastEdge = t;
  }
  SetFirstEdge(t) {
    this.FirstEdge = t, this.LastEdge = t, t.Path = this;
  }
  //
  toString() {
    const t = new Bt.StringBuilder();
    this.PathPoints instanceof Ri && t.Append("L");
    for (const e of ul(this.PathPoints))
      t.Append(e.toString());
    return t.ToString();
  }
}
function* ul(o) {
  if (o instanceof Ri)
    for (let t = o; t != null; t = t.Next)
      yield t.Point;
  else
    for (const t of o)
      yield t;
}
class zh extends ua {
  get Obstacle() {
    return this.obstacle;
  }
  set Obstacle(t) {
    this.obstacle = t;
  }
  constructor(t, e, i, s) {
    super(e), this.Slope = 0, this.SlopeInverse = 0, this.Obstacle = t, this.endVertex = s ? e.nextOnPolyline : e.prevOnPolyline, i.IsPerpendicularPP(e.point, this.endVertex.point) || (this.Slope = O.Slope(e.point, this.endVertex.point, i), this.SlopeInverse = 1 / this.Slope);
  }
  get EndVertex() {
    return this.endVertex;
  }
}
class Qe extends zh {
  constructor(t, e, i) {
    super(t, e, i, i.IsHorizontal);
  }
}
class vn extends zh {
  constructor(t, e, i) {
    super(t, e, i, i.IsVertical);
  }
}
class Ot {
  get PaddedPolyline() {
    return this._PaddedPolyline;
  }
  set PaddedPolyline(t) {
    this._PaddedPolyline = t;
  }
  get looseVisibilityPolyline() {
    return this._looseVisibilityPolyline == null && (this._looseVisibilityPolyline = Ot.CreateLoosePolyline(this.VisibilityPolyline)), this._looseVisibilityPolyline;
  }
  set looseVisibilityPolyline(t) {
    this._looseVisibilityPolyline = t;
  }
  GetPortChanges(t) {
    return t.addedPorts = Hs(this.InputShape.Ports, this.Ports), t.removedPorts = Hs(this.Ports, this.InputShape.Ports), t.addedPorts.size === 0 && t.removedPorts.size === 0 ? !1 : (this.Ports = new Set(this.InputShape.Ports), !0);
  }
  get IsInConvexHull() {
    return this.ConvexHull != null;
  }
  get IsGroup() {
    return this.InputShape != null && this.InputShape.IsGroup;
  }
  get VisibilityBoundingBox() {
    return this.VisibilityPolyline.boundingBox;
  }
  get VisibilityPolyline() {
    return this.ConvexHull != null ? this.ConvexHull.Polyline : this.PaddedPolyline;
  }
  static CreateSentinel(t, e, i, s) {
    const n = Ot.mk(t, e, s);
    return n.CreateInitialSides(n.PaddedPolyline.startPoint, i), n;
  }
  CreateInitialSides(t, e) {
    this.ActiveLowSide = new Qe(this, t, e), this.ActiveHighSide = new vn(this, t, e), e.IsFlatS(this.ActiveHighSide) && (this.ActiveHighSide = new vn(this, this.ActiveHighSide.EndVertex, e));
  }
  constructor(t, e) {
    t != null && (this.PaddedPolyline = M.PaddedPolylineBoundaryOfNode(t.BoundaryCurve, e), Ot.RoundVerticesAndSimplify(this.PaddedPolyline), this.IsRectangle = this.IsPolylineRectangle(), this.InputShape = t, this.Ports = new Set(this.InputShape.Ports));
  }
  static mk(t, e, i) {
    const s = new Ot(null, 0);
    return s.PaddedPolyline = B.mkClosedFromPoints([u.RoundPoint(t), u.RoundPoint(e)]), s.Ordinal = i, s;
  }
  IsPolylineRectangle() {
    if (this.PaddedPolyline.count !== 4)
      return !1;
    let t = this.PaddedPolyline.startPoint, e = t.nextOnPolyline, i = w.VectorDirectionPP(t.point, e.point);
    if (!w.IsPureDirection(i))
      return !1;
    do {
      t = e, e = t.nextOnPolyline;
      const s = w.DirectionFromPointToPoint(t.point, e.point);
      if (s !== w.RotateRight(i))
        return !1;
      i = s;
    } while (t !== this.PaddedPolyline.startPoint);
    return !0;
  }
  static RoundVerticesAndSimplify(t) {
    let e = t.startPoint;
    do
      e.point = u.RoundPoint(e.point), e = e.nextOnPolyline;
    while (e !== t.startPoint);
    Ot.RemoveCloseAndCollinearVerticesInPlace(t), t.setInitIsRequired();
  }
  // A single convex hull is shared by all obstacles contained by it and we only want one occurrence of that
  // convex hull's polyline in the visibility graph generation.
  get IsPrimaryObstacle() {
    return this.ConvexHull == null || this === this.ConvexHull.PrimaryObstacle;
  }
  static RemoveCloseAndCollinearVerticesInPlace(t) {
    const e = m.intersectionEpsilon * 10;
    for (let i = t.startPoint.next; i != null; i = i.next)
      u.close(i.prev.point, i.point, e) && (i.next == null ? t.RemoveEndPoint() : (i.prev.next = i.next, i.next.prev = i.prev));
    return u.close(t.start, t.end, e) && t.RemoveStartPoint(), t = t.RemoveCollinearVertices(), t.endPoint.prev != null && t.endPoint.prev !== t.startPoint && u.getTriangleOrientation(t.endPoint.prev.point, t.end, t.start) === L.Collinear && t.RemoveEndPoint(), t.startPoint.next != null && t.endPoint.prev !== t.startPoint && u.getTriangleOrientation(t.end, t.start, t.startPoint.next.point) === L.Collinear && t.RemoveStartPoint(), t.setInitIsRequired(), t;
  }
  get isOverlapped() {
    return this.clump !== void 0 && this.clump.length > 0;
  }
  get IsSentinel() {
    return this.InputShape == null;
  }
  IsInSameClump(t) {
    return this.isOverlapped && this.clump === t.clump;
  }
  Close() {
    this.ActiveLowSide = null, this.ActiveHighSide = null;
  }
  SetConvexHull(t) {
    this.clump = null, this.IsRectangle = !1, this.ConvexHull = t, this.looseVisibilityPolyline = null;
  }
  static CreateLoosePolyline(t) {
    const e = M.CreatePaddedPolyline(t, m.intersectionEpsilon * 10);
    return Ot.RoundVerticesAndSimplify(e), e;
  }
  get IsTransparentAncestor() {
    return this.InputShape == null ? !1 : this.InputShape.IsTransparent;
  }
  set IsTransparentAncestor(t) {
    this.InputShape.IsTransparent = t;
  }
}
Ot.FirstSentinelOrdinal = 1;
Ot.FirstNonSentinelOrdinal = 10;
class Sf {
  get Obstacle() {
    return this.ObstaclePort.Obstacle;
  }
  get InitialWeight() {
    return this.IsOverlapped ? W.OverlappedWeight : W.NormalWeight;
  }
  get IsCollinearWithPort() {
    return w.IsPureDirection(b.GetDirections(this.VisibilityBorderIntersect, this.ObstaclePort.Location));
  }
  get IsVertical() {
    return O.IsVertical(this.MaxVisibilitySegment);
  }
  // If the port has entrances that are collinear, don't do the optimization for non-collinear ones.
  get WantVisibilityIntersection() {
    return !this.IsOverlapped && this.CanExtend && (!this.ObstaclePort.HasCollinearEntrances || this.IsCollinearWithPort);
  }
  get CanExtend() {
    return b.GetDirections(this.MaxVisibilitySegment.start, this.MaxVisibilitySegment.end) !== S.None;
  }
  constructor(t, e, i, s) {
    this.IsOverlapped = !1, this.unpaddedToPaddedBorderWeight = W.NormalWeight, this.ObstaclePort = t, this.UnpaddedBorderIntersect = e, this.OutwardDirection = i;
    const n = v.mkPP(this.UnpaddedBorderIntersect, O.RectangleBorderIntersect(t.Obstacle.VisibilityBoundingBox, this.UnpaddedBorderIntersect, i)), r = g.getAllIntersections(n, t.Obstacle.VisibilityPolyline, !0);
    this.VisibilityBorderIntersect = u.RoundPoint(r[0].x);
    const a = { pacList: null };
    this.MaxVisibilitySegment = s.CreateMaxVisibilitySegment(this.VisibilityBorderIntersect, this.OutwardDirection, a), this.pointAndCrossingsList = a.pacList, (this.Obstacle.isOverlapped || this.Obstacle.IsGroup && !this.Obstacle.IsInConvexHull) && (this.IsOverlapped = s.IntersectionIsInsideAnotherObstacle(null, this.Obstacle, this.VisibilityBorderIntersect, Pt.GetInstance(this.OutwardDirection)), (!this.Obstacle.IsGroup || this.IsOverlapped || this.InteriorEdgeCrossesObstacle(s)) && (this.unpaddedToPaddedBorderWeight = W.OverlappedWeight)), this.Obstacle.IsInConvexHull && this.unpaddedToPaddedBorderWeight === W.NormalWeight && this.SetUnpaddedToPaddedBorderWeightFromHullSiblingOverlaps(s);
  }
  SetUnpaddedToPaddedBorderWeightFromHullSiblingOverlaps(t) {
    (this.Obstacle.IsGroup ? this.InteriorEdgeCrossesObstacle(t) : this.InteriorEdgeCrossesConvexHullSiblings()) && (this.unpaddedToPaddedBorderWeight = W.OverlappedWeight);
  }
  InteriorEdgeCrossesObstacle(t) {
    const e = T.mkPP(this.UnpaddedBorderIntersect, this.VisibilityBorderIntersect);
    return this.InteriorEdgeCrossesObstacleRFI(e, (i) => i.VisibilityPolyline, Array.from(t.Root.GetLeafRectangleNodesIntersectingRectangle(e)).filter((i) => !i.UserData.IsGroup && i.UserData !== this.Obstacle).map((i) => i.UserData));
  }
  InteriorEdgeCrossesConvexHullSiblings() {
    const t = T.mkPP(this.UnpaddedBorderIntersect, this.VisibilityBorderIntersect);
    return this.InteriorEdgeCrossesObstacleRFI(t, (e) => e.PaddedPolyline, this.Obstacle.ConvexHull.Obstacles.filter((e) => e !== this.Obstacle));
  }
  InteriorEdgeCrossesObstacleRFI(t, e, i) {
    let s = null;
    for (const n of i) {
      const r = e(n);
      if (!O.RectangleInteriorsIntersect(t, r.boundingBox))
        continue;
      if (s = s ?? v.mkPP(this.UnpaddedBorderIntersect, this.VisibilityBorderIntersect), g.intersectionOne(
        s,
        r,
        /* liftIntersection:*/
        !1
      ) != null || F.Outside !== g.PointRelativeToCurveLocation(this.UnpaddedBorderIntersect, r))
        return !0;
    }
    return !1;
  }
  get HasGroupCrossings() {
    return this.pointAndCrossingsList != null && this.pointAndCrossingsList.Count() > 0;
  }
  HasGroupCrossingBeforePoint(t) {
    if (!this.HasGroupCrossings)
      return !1;
    const e = O.IsAscending(this.OutwardDirection) ? this.pointAndCrossingsList.First : this.pointAndCrossingsList.Last;
    return b.GetDirections(this.MaxVisibilitySegment.start, e.Location) === b.GetDirections(e.Location, t);
  }
  AddToAdjacentVertex(t, e, i, s) {
    let n = t.VisGraph.FindVertex(this.VisibilityBorderIntersect);
    if (n != null) {
      this.ExtendEdgeChain(t, n, n, i, s);
      return;
    }
    this.OutwardDirection === b.GetDirections(e.point, this.VisibilityBorderIntersect) ? (this.VisibilityBorderIntersect = e.point, n = e) : (n = t.FindOrAddVertex(this.VisibilityBorderIntersect), t.FindOrAddEdge(n, e, this.InitialWeight)), this.ExtendEdgeChain(t, n, e, i, s);
  }
  ExtendEdgeChain(t, e, i, s, n) {
    t.ExtendEdgeChainVRLPB(i, s, this.MaxVisibilitySegment, this.pointAndCrossingsList, this.IsOverlapped);
    const r = t.FindOrAddVertex(this.UnpaddedBorderIntersect);
    t.FindOrAddEdge(r, e, this.unpaddedToPaddedBorderWeight), n && t.ConnectVertexToTargetVertex(this.ObstaclePort.CenterVertex, r, this.OutwardDirection, this.InitialWeight);
  }
  toString() {
    return Bt.String.format("{0} {1}~{2} {3}", this.ObstaclePort.Location, this.UnpaddedBorderIntersect, this.VisibilityBorderIntersect, this.OutwardDirection);
  }
}
class yf {
  constructor(t, e) {
    this.HasCollinearEntrances = !1, this.VisibilityRectangle = T.mkEmpty(), this.Port = t, this.Obstacle = e, this.PortEntrances = new Array(), this.Location = u.RoundPoint(this.Port.Location);
  }
  CreatePortEntrance(t, e, i) {
    const s = new Sf(this, t, e, i);
    this.PortEntrances.push(s), this.VisibilityRectangle.add(s.MaxVisibilitySegment.end), this.HasCollinearEntrances = this.HasCollinearEntrances || s.IsCollinearWithPort;
  }
  ClearVisibility() {
    this.PortEntrances = [];
  }
  AddToGraph(t, e) {
    e && (this.CenterVertex = t.FindOrAddVertex(this.Location));
  }
  RemoveFromGraph() {
    this.CenterVertex = null;
  }
  // PortManager will recreate the Port if it detects this (this.Location has already been rounded).
  get LocationHasChanged() {
    return !u.closeDistEps(this.Location, u.RoundPoint(this.Port.Location));
  }
  // The curve associated with the port.
  get PortCurve() {
    return this.Port.Curve;
  }
  // The (unrounded) location of the port.
  get PortLocation() {
    return this.Port.Location;
  }
  toString() {
    return this.Port + this.Obstacle.toString();
  }
}
class bf {
  get Point() {
    return this.Vertex.point;
  }
  get InitialWeight() {
    return this.IsOverlapped ? W.OverlappedWeight : W.NormalWeight;
  }
  get IsOutOfBounds() {
    return S.None !== this.OutOfBoundsDirectionFromGraph;
  }
  // Called if we must create the vertex.
  constructor(t, e) {
    this.maxVisibilitySegmentsAndCrossings = new Array(4), this.OutOfBoundsDirectionFromGraph = S.None, this.GetVertex(t, e);
  }
  GetVertex(t, e) {
    this.Vertex = t.FindOrAddVertex(e);
  }
  // Adds an edge from this.Vertex to a (possibly new) vertex at an intersection with an
  // existing Edge that adjoins the point.  We take 'dir' as an input parameter for edge
  // extension because we may be on the edge so can't calculate the direction.
  AddEdgeToAdjacentEdge(t, e, i, s) {
    const n = O.SegmentIntersectionEP(e, this.Point);
    let r = t.VisGraph.FindVertex(n);
    return r != null ? this.AddToAdjacentVertex(t, r, i, s) : r = t.AddEdgeToTargetEdge(this.Vertex, e, n), this.ExtendEdgeChain(t, r, i, s), r;
  }
  AddToAdjacentVertex(t, e, i, s) {
    b.EqualPP(this.Point, e.point) || t.FindOrAddEdge(this.Vertex, e, this.InitialWeight), this.ExtendEdgeChain(t, e, i, s);
  }
  ExtendEdgeChain(t, e, i, s) {
    let n = this.IsOverlapped;
    n && (n = t.ObstacleTree.PointIsInsideAnObstaclePD(e.point, i));
    const r = this.GetSegmentAndCrossings(this.IsOverlapped ? e : this.Vertex, i, t);
    t.ExtendEdgeChainVRLPB(e, s, r[0], r[1], n);
  }
  GetSegmentAndCrossings(t, e, i) {
    const s = w.ToIndex(e);
    let n = this.maxVisibilitySegmentsAndCrossings[s];
    if (n == null) {
      const r = { pacList: null };
      n = [i.ObstacleTree.CreateMaxVisibilitySegment(t.point, e, r), r.pacList], this.maxVisibilitySegmentsAndCrossings[s] = n;
    } else
      b.GetDirections(t.point, n[0].start) === e && (n[0].start = t.point);
    return n;
  }
  MaxVisibilityInDirectionForNonOverlappedFreePoint(t, e) {
    return this.GetSegmentAndCrossings(this.Vertex, t, e)[0].end;
  }
  AddOobEdgesFromGraphCorner(t, e) {
    const i = b.GetDirections(e, this.Vertex.point), s = t.VisGraph.FindVertex(e);
    t.ConnectVertexToTargetVertex(s, this.Vertex, i & (S.North | S.South), W.NormalWeight), t.ConnectVertexToTargetVertex(s, this.Vertex, i & (S.East | S.West), W.NormalWeight);
  }
  RemoveFromGraph() {
    this.Vertex = null;
  }
  toString() {
    return this.Vertex.toString();
  }
}
class Pa {
  constructor(t, e) {
    this.BoundaryWidth = m.distanceEpsilon, this.Group = t, this.DirectionToInside = e;
  }
  GetInteriorVertexPoint(t) {
    return u.RoundPoint(t.add(w.toPoint(this.DirectionToInside).mul(this.BoundaryWidth)));
  }
  toString() {
    return Bt.String.format("{0} {1}", this.DirectionToInside, this.Group);
  }
}
Pa.BoundaryWidth = m.distanceEpsilon;
class bo extends Bi {
  constructor(t) {
    super(), this.site = t;
  }
  get Site() {
    return this.site;
  }
}
class so extends tn {
  constructor(t, e) {
    super(e), this.Obstacle = t;
  }
}
class ur extends so {
  constructor(t, e) {
    super(t, e);
  }
}
class vf {
  AddPendingPerpendicularCoord(t) {
    this.pendingPerpCoords == null && (this.pendingPerpCoords = new Array()), this.pendingPerpCoords.push(t);
  }
  // Restores state between intersection passes.
  ResetForIntersections() {
    this.CurrentSegment = this.FirstSegment;
  }
  // Indicates whether ScanSegments in this item are horizontally or vertically oriented.
  get IsHorizontal() {
    return !this.FirstSegment.IsVertical;
  }
  // Ctor, taking the parallel (constant) coordinate.
  // the parallel (constant) coordinate
  constructor(t) {
    this.Coord = t;
  }
  // Move along the linked list until we hit the ScanSegment that contains the point.
  TraverseToSegmentContainingPoint(t) {
    if (this.CurrentSegment.ContainsPoint(t))
      return !0;
    const e = this.IsHorizontal ? t.y : t.x;
    if (!b.Equal(this.Coord, e)) {
      for (; this.MoveNext(); )
        ;
      return !1;
    }
    for (; ; ) {
      if ((this.CurrentSegment.NextSegment == null || b.GetDirections(this.CurrentSegment.End, t) == b.GetDirections(t, this.CurrentSegment.NextSegment.Start)) && u.closeIntersections(this.CurrentSegment.End, t))
        return this.CurrentSegment.Update(this.CurrentSegment.Start, t), !0;
      if (!this.MoveNext())
        return !1;
      if (this.CurrentSegment.ContainsPoint(t))
        return !0;
      if (b.IsPureLower(t, this.CurrentSegment.Start))
        return this.CurrentSegment.Update(t, this.CurrentSegment.End), !0;
    }
  }
  MoveNext() {
    return this.CurrentSegment = this.CurrentSegment.NextSegment, this.HasCurrent;
  }
  get HasCurrent() {
    return this.CurrentSegment != null;
  }
  // Returns true if the point is the end of the current segment and there is an adjoining NextSegment.
  PointIsCurrentEndAndNextStart(t) {
    return t.equal(this.CurrentSegment.End) && this.CurrentSegment.NextSegment != null && t.equal(this.CurrentSegment.NextSegment.Start);
  }
  // Set Current to the ScanSegment containing the perpendicular coordinate, then add that coordinate to its
  // sparse-vector coordinate list.
  AddPerpendicularCoord(t) {
    const e = this.IsHorizontal ? new u(t, this.Coord) : new u(this.Coord, t);
    this.TraverseToSegmentContainingPoint(e), this.CurrentSegment.AddSparseVertexCoord(t);
  }
  toString() {
    return this.FirstSegment == null ? "-0- " + this.Coord : this.IsHorizontal ? "(H) Y === " + this.Coord : "(V) X === ";
  }
  AppendScanSegment(t) {
    this.FirstSegment == null ? this.FirstSegment = t : this.CurrentSegment.NextSegment = t, this.CurrentSegment = t;
  }
  AddPendingPerpendicularCoordsToScanSegments() {
    if (this.pendingPerpCoords != null) {
      this.ResetForIntersections();
      for (const t of this.pendingPerpCoords)
        this.AddPerpendicularCoord(t);
    }
  }
}
class dl {
  constructor(t, e) {
    this.CurrentSlotIndex = 0, this.vector = [], this.IsHorizontal = e;
    const i = Array.from(t).sort((s, n) => s > n ? 1 : s < n ? -1 : 0);
    for (const s of i)
      this.vector.push(new vf(s));
  }
  get Length() {
    return this.vector.length;
  }
  // The item at the index of the scan segment vector we're appending to on the ScanSegment-generation sweep.
  get CurrentSlot() {
    return this.vector[this.CurrentSlotIndex];
  }
  // The indexed item in the vector.
  Item(t) {
    return this.vector[t];
  }
  // Appends a ScanSegment to the linked list in the "Current" slot.
  CreateScanSegment(t, e, i, s) {
    this.CurrentSlot.AppendScanSegment(new W(t, e, i, s));
  }
  ScanSegmentsCompleteForCurrentSlot() {
    this.CurrentSlotIndex++;
  }
  ScanSegmentsComplete() {
    for (const t of this.vector)
      t.AddPendingPerpendicularCoordsToScanSegments();
  }
  // Returns an enumeration of the vector of ScanSegmentVectorItems.
  Items() {
    return this.vector;
  }
  // Reset vector state between passes.
  ResetForIntersections() {
    for (const t of this.vector)
      t.ResetForIntersections();
  }
  // Search the vector for the nearest slot in the specified direction.
  FindNearest(t, e) {
    let i = 0, s = this.vector.length - 1;
    if (t <= this.vector[i].Coord)
      return i;
    if (t >= this.vector[s].Coord)
      return s;
    for (; s - i > 2; ) {
      const n = i + (s - i >> 1), r = this.vector[n];
      if (t < r.Coord) {
        s = n;
        continue;
      }
      if (t > r.Coord) {
        i = n;
        continue;
      }
      return n;
    }
    for (i++; i <= s; i++) {
      const n = this.vector[i];
      if (t < n.Coord)
        return e > 0 ? i : i - 1;
      if (t === n.Coord)
        break;
    }
    return i;
  }
  CreateSparseVerticesAndEdges(t) {
    for (const e of this.vector) {
      e.ResetForIntersections();
      for (let i = e.FirstSegment; i != null; i = i.NextSegment)
        i.CreateSparseVerticesAndEdges(t);
    }
  }
  // Get the coordinate that remains constant along a segment in this vector.
  GetParallelCoord(t) {
    return this.IsHorizontal ? t.y : t.x;
  }
  // Get the coordinate that changes along a segment in this vector (and is thus the parallel
  // coord of an intersecting segment).
  GetPerpendicularCoord(t) {
    return this.IsHorizontal ? t.x : t.y;
  }
  ConnectAdjoiningSegmentEndpoints() {
    for (const t of this.vector) {
      t.ResetForIntersections();
      let e = t.FirstSegment;
      for (let i = e.NextSegment; i != null; i = i.NextSegment) {
        if (i.HasSparsePerpendicularCoords && e.HasSparsePerpendicularCoords && i.Start === e.End) {
          const s = this.GetPerpendicularCoord(i.Start);
          e.AddSparseEndpoint(s), i.AddSparseEndpoint(s);
        }
        e = i;
      }
    }
  }
  toString() {
    return (this.IsHorizontal ? "(H) count" : "(V) count === ") + this.vector.length;
  }
}
class Cs extends Bi {
  // Called by StoreLookaheadSite only.
  constructor(t, e, i) {
    super(), this.InitialObstacle = t, this.ReflectingObstacle = e, this.site = i;
  }
  // Called by LowReflectionEvent or HighReflectionEvent ctors, which are called out of
  // AddReflectionEvent, which in turn is called by LoadLookaheadIntersections.
  // In this case we know the eventObstacle and initialObstacle are the same obstacle (the
  // one that the reflected ray bounced off of, to generate the Left/HighReflectionEvent).
  static mk(t, e, i) {
    const s = new Cs(t.ReflectingObstacle, e, i);
    return s.PreviousSite = t, s;
  }
  // If true, we have a staircase situation.
  IsStaircaseStep(t) {
    return this.InitialObstacle === t;
  }
  get Site() {
    return this.site;
  }
}
class fl {
  constructor() {
    this.eventTree = new la((t, e) => this.Compare(t, e));
  }
  Reset(t) {
    this.scanDirection = t;
  }
  Enqueue(t) {
    this.eventTree.Enqueue(t);
  }
  Dequeue() {
    return this.eventTree.Dequeue();
  }
  get Count() {
    return this.eventTree.Count;
  }
  Compare(t, e) {
    if (t === e)
      return 0;
    if (t == null)
      return -1;
    if (e == null)
      return 1;
    let i = this.scanDirection.ComparePerpCoord(t.Site, e.Site);
    if (i)
      return i;
    const s = t instanceof Cs ? 0 : 1, n = e instanceof Cs ? 0 : 1;
    return i = s - n, i || this.scanDirection.CompareScanCoord(t.Site, e.Site);
  }
}
class jh {
  constructor() {
    this.pointCrossingMap = new ii(), this.pointList = new Array();
  }
  AddIntersection(t, e, i) {
    let s = this.pointCrossingMap.get(t);
    s || (s = new Array(), this.pointCrossingMap.set(t, s));
    const n = s.length;
    for (let a = 0; a < n; a++) {
      const l = s[a];
      if (l.Group === e)
        return l;
    }
    const r = new Pa(e, i);
    return s.push(r), r;
  }
  Clear() {
    this.pointCrossingMap.clear();
  }
  GetOrderedListBetween(t, e) {
    if (this.pointCrossingMap.size === 0)
      return null;
    if (b.ComparePP(t, e) > 0) {
      const n = t;
      t = e, e = n;
    }
    this.pointList = [];
    for (const n of this.pointCrossingMap.keys())
      b.ComparePP(n, t) >= 0 && b.ComparePP(n, e) <= 0 && this.pointList.push(n);
    this.pointList.sort((n, r) => n.compareTo(r));
    const i = new yn(), s = this.pointList.length;
    for (let n = 0; n < s; n++) {
      const r = this.pointList[n];
      i.Add(r, this.pointCrossingMap.get(r));
    }
    return i;
  }
  toString() {
    return Bt.String.format("{0}", this.pointCrossingMap.size);
  }
}
class gl extends Cs {
  constructor(t, e, i) {
    super(t.ReflectingObstacle, e.Obstacle, i), this.Side = e;
  }
}
class Cf {
  constructor(t) {
    this.staleSites = new Array(), this.scanDirection = t, this.eventTree = new Ee((e, i) => this.CompareBB(e, i)), this.findFirstPred = (e) => this.CompareToFindFirstPoint(e.Site) >= 0;
  }
  Add(t) {
    this.eventTree.insert(t);
  }
  // Buffer up the events that are known to be stale - that is, will never queued as events because the
  // event-load intersection is the same as the site.
  MarkStaleSite(t) {
    this.staleSites.push(t);
  }
  RemoveStaleSites() {
    const t = this.staleSites.length;
    if (t > 0) {
      for (let e = 0; e < t; e++)
        this.RemoveExact(this.staleSites[e]);
      this.staleSites = [];
    }
  }
  RemoveSitesForFlatBottom(t, e) {
    for (let i = this.FindFirstInRange(t, e); i != null; i = this.FindNextInRange(i, e))
      this.MarkStaleSite(i.item);
    this.RemoveStaleSites();
  }
  Find(t) {
    return this.FindFirstInRange(t, t);
  }
  RemoveExact(t) {
    const e = this.eventTree.find(t);
    return e != null && e.item.Site === t.Site ? (this.eventTree.deleteNodeInternal(e), !0) : !1;
  }
  FindFirstInRange(t, e) {
    this.findFirstPoint = t;
    const i = this.eventTree.findFirst(this.findFirstPred);
    return i != null && this.Compare(i.item.Site, e) <= 0 ? i : null;
  }
  CompareToFindFirstPoint(t) {
    return this.Compare(t, this.findFirstPoint);
  }
  FindNextInRange(t, e) {
    const i = this.eventTree.next(t);
    return i != null && this.Compare(i.item.Site, e) <= 0 ? i : null;
  }
  // For ordering Points in the lookahead list.  We just care about the coordinate that changes
  // parallel to the scanline, so for vertical sweep (sweeping up from bottom, scanning
  // horizontally) then order points by X only, else by Y only.
  CompareBB(t, e) {
    return this.scanDirection.CompareScanCoord(t.Site, e.Site);
  }
  Compare(t, e) {
    return this.scanDirection.CompareScanCoord(t, e);
  }
}
class pl extends so {
  constructor(t, e) {
    super(t, e);
  }
}
class ml extends so {
  constructor(t, e) {
    super(t, e);
  }
}
class Pl extends so {
  constructor(t, e) {
    super(t, e);
  }
}
class Sl extends Cs {
  constructor(t, e, i) {
    super(t.ReflectingObstacle, e.obstacle, i), this.Side = e;
  }
}
class yl {
  // Dereferences the node if non-null to return the side Item.
  get LowNeighborSide() {
    return this.LowNeighbor == null ? null : this.LowNeighbor.item;
  }
  // Dereferences the node if non-null to return the side Item.
  get HighNeighborSide() {
    return this.HighNeighbor == null ? null : this.HighNeighbor.item;
  }
  Clear() {
    this.LowNeighbor = null, this.LowOverlapEnd = null, this.GroupSideInterveningBeforeLowNeighbor = null, this.HighNeighbor = null, this.HighOverlapEnd = null, this.GroupSideInterveningBeforeHighNeighbor = null;
  }
  SetSides(t, e, i, s) {
    if (O.IsAscending(t)) {
      this.HighNeighbor = e, this.HighOverlapEnd = i, this.GroupSideInterveningBeforeHighNeighbor = s;
      return;
    }
    this.LowNeighbor = e, this.LowOverlapEnd = i, this.GroupSideInterveningBeforeLowNeighbor = s;
  }
}
class ti {
  has(t) {
    return this.hasxy(t.x, t.y);
  }
  remove(t) {
    if (!(t.x < 0 || t.x >= this.arrayOfSets.length))
      return this.arrayOfSets[t.x].delete(t.y);
  }
  hasxy(t, e) {
    if (t < 0 || t >= this.arrayOfSets.length)
      return !1;
    const i = this.arrayOfSets[t];
    return i !== void 0 && i.has(e);
  }
  constructor() {
    this.arrayOfSets = new Array();
  }
  static mk(t) {
    const e = new ti();
    for (const i of t)
      e.add(i);
    return e;
  }
  *values() {
    for (let t = 0; t < this.arrayOfSets.length; t++) {
      const e = this.arrayOfSets[t];
      if (e)
        for (const i of e.values())
          yield new U(t, i);
    }
  }
  add(t) {
    let e = this.arrayOfSets[t.x];
    e == null && (this.arrayOfSets[t.x] = e = /* @__PURE__ */ new Set()), e.add(t.y);
  }
  addNN(t, e) {
    let i = this.arrayOfSets[t];
    i == null && (this.arrayOfSets[t] = i = /* @__PURE__ */ new Set()), i.add(e);
  }
  clear() {
    for (const t of this.arrayOfSets)
      t && t.clear();
  }
}
class bl {
  constructor(t, e) {
    this.Polyline = t, this.Obstacles = Array.from(e), this.PrimaryObstacle = this.Obstacles[0], Ot.RoundVerticesAndSimplify(this.Polyline);
  }
}
class Qs {
  // Most of the original contents of this file have been subsumed into ObstacleTree and TransientGraphUtility.
  static MungeClosestIntersectionInfo(t, e, i) {
    const s = e.seg1.boundingBox, n = u.RoundPoint(e.x).clone();
    return i ? new u(Qs.MungeIntersect(t.x, n.x, s.left, s.right), n.y) : new u(n.x, Qs.MungeIntersect(t.y, n.y, s.bottom, s.top));
  }
  // Make sure that we intersect the object space.
  static MungeIntersect(t, e, i, s) {
    if (t < e) {
      const n = Math.min(i, s);
      e < n && (e = n);
    } else if (t > e) {
      const n = Math.max(i, s);
      e > n && (e = n);
    }
    return u.RoundDouble(e);
  }
}
class ct {
  constructor() {
    this.CurrentGroupBoundaryCrossingMap = new jh(), this.overlapPairs = new ti(), this.hasOverlaps = !1, this.lookupIntPair = new U(-1, -1);
  }
  get GraphBox() {
    return this.Root.irect;
  }
  //Create the tree hierarchy from the enumeration.
  Init(t, e, i) {
    this.CreateObstacleListAndOrdinals(t), this.AncestorSets = e, this.CreateRoot(), this.shapeIdToObstacleMap = i;
  }
  CreateObstacleListAndOrdinals(t) {
    this.allObstacles = Array.from(t);
    let e = Ot.FirstNonSentinelOrdinal;
    for (const i of this.allObstacles)
      i.Ordinal = e++;
  }
  OrdinalToObstacle(t) {
    return this.allObstacles[t - Ot.FirstNonSentinelOrdinal];
  }
  // Create the root with overlapping non-rectangular obstacles converted to their convex hulls, for more reliable calculations.
  CreateRoot() {
    this.Root = ct.CalculateHierarchy(this.GetAllObstacles()), this.OverlapsExist() && (this.AccreteClumps(), this.AccreteConvexHulls(), this.GrowGroupsToAccommodateOverlaps(), this.Root = ct.CalculateHierarchy(this.GetAllObstacles().filter((t) => t.IsPrimaryObstacle)));
  }
  OverlapsExist() {
    return this.Root == null ? !1 : (Qt(this.Root, this.Root, (t, e) => this.CheckForInitialOverlaps(t, e)), this.hasOverlaps);
  }
  OverlapPairAlreadyFound(t, e) {
    return this.lookupIntPair.x = e.Ordinal, this.lookupIntPair.y = t.Ordinal, this.overlapPairs.has(this.lookupIntPair);
  }
  CheckForInitialOverlaps(t, e) {
    if (this.hasOverlaps)
      return;
    const i = { bIsInsideA: !1, aIsInsideB: !1 };
    if (ct.ObstaclesIntersect(t, e, i)) {
      this.hasOverlaps = !0;
      return;
    }
    !i.aIsInsideB && !i.bIsInsideA || t.IsGroup && e.IsGroup || t.IsGroup && i.bIsInsideA || e.IsGroup && i.aIsInsideB || (this.hasOverlaps = !0);
  }
  AccreteClumps() {
    this.AccumulateObstaclesForClumps(), this.CreateClumps();
  }
  AccreteConvexHulls() {
    for (; ; )
      if (this.AccumulateObstaclesForConvexHulls(), !this.CreateConvexHulls())
        return;
  }
  static CalculateHierarchy(t) {
    const e = Array.from(t).map((i) => Nt(i, i.VisibilityBoundingBox));
    return wt(e);
  }
  AccumulateObstaclesForClumps() {
    this.overlapPairs.clear();
    const t = ct.CalculateHierarchy(this.GetAllObstacles().filter((e) => !e.IsGroup && e.IsRectangle));
    t != null && ae(t, t, (e, i) => this.EvaluateOverlappedPairForClump(e, i));
  }
  EvaluateOverlappedPairForClump(t, e) {
    if (t === e || this.OverlapPairAlreadyFound(t, e))
      return;
    const i = { bIsInsideA: !1, aIsInsideB: !1 };
    !ct.ObstaclesIntersect(t, e, i) && !i.aIsInsideB && !i.bIsInsideA || this.overlapPairs.add(new U(t.Ordinal, e.Ordinal));
  }
  AccumulateObstaclesForConvexHulls() {
    this.overlapPairs.clear();
    const t = ct.CalculateHierarchy(this.GetAllObstacles().filter((e) => e.IsPrimaryObstacle && !e.IsGroup));
    t != null && ae(t, t, (e, i) => this.EvaluateOverlappedPairForConvexHull(e, i));
  }
  EvaluateOverlappedPairForConvexHull(t, e) {
    if (t === e || this.OverlapPairAlreadyFound(t, e))
      return;
    const i = { bIsInsideA: !1, aIsInsideB: !1 };
    !ct.ObstaclesIntersect(t, e, i) && !i.aIsInsideB && !i.bIsInsideA || !t.IsInConvexHull && !e.IsInConvexHull && t.IsRectangle && e.IsRectangle || (this.overlapPairs.add(new U(t.Ordinal, e.Ordinal)), this.AddClumpToConvexHull(t), this.AddClumpToConvexHull(e), this.AddConvexHullToConvexHull(t), this.AddConvexHullToConvexHull(e));
  }
  GrowGroupsToAccommodateOverlaps() {
    for (; ; )
      if (this.AccumulateObstaclesForGroupOverlaps(), !this.GrowGroupsToResolveOverlaps())
        return;
  }
  AccumulateObstaclesForGroupOverlaps() {
    const t = ct.CalculateHierarchy(this.GetAllObstacles().filter((i) => i.IsGroup)), e = ct.CalculateHierarchy(this.GetAllObstacles().filter((i) => i.IsPrimaryObstacle));
    t == null || e == null || ae(t, e, (i, s) => this.EvaluateOverlappedPairForGroup(i, s));
  }
  EvaluateOverlappedPairForGroup(t, e) {
    if (t === e || this.OverlapPairAlreadyFound(t, e))
      return;
    const i = { bIsInsideA: !1, aIsInsideB: !1 }, s = ct.ObstaclesIntersect(t, e, i);
    if (!(!s && !i.aIsInsideB && !i.bIsInsideA)) {
      if (t.IsRectangle && e.IsRectangle) {
        e.IsGroup || (i.aIsInsideB || ct.FirstRectangleContainsACornerOfTheOther(e.VisibilityBoundingBox, t.VisibilityBoundingBox)) && (e.OverlapsGroupCorner = !0);
        return;
      }
      !s && (e.IsGroup || i.bIsInsideA) || this.overlapPairs.add(new U(t.Ordinal, e.Ordinal));
    }
  }
  static FirstRectangleContainsACornerOfTheOther(t, e) {
    return t.contains(e.leftBottom) || t.contains(e.leftTop) || t.contains(e.rightTop) || t.contains(e.rightBottom);
  }
  static FirstPolylineStartIsInsideSecondPolyline(t, e) {
    return g.PointRelativeToCurveLocation(t.start, e) !== F.Outside;
  }
  AddClumpToConvexHull(t) {
    if (t.isOverlapped) {
      for (const e of t.clump.filter((i) => i.Ordinal !== t.Ordinal))
        this.overlapPairs.add(new U(t.Ordinal, e.Ordinal));
      t.clump = [];
    }
  }
  AddConvexHullToConvexHull(t) {
    if (t.IsInConvexHull) {
      for (const e of t.ConvexHull.Obstacles.filter((i) => i.Ordinal !== t.Ordinal))
        this.overlapPairs.add(new U(t.Ordinal, e.Ordinal));
      t.ConvexHull.Obstacles = [];
    }
  }
  CreateClumps() {
    const t = Br(Array.from(this.overlapPairs.values())), e = Xs(t);
    for (const i of e) {
      if (i.length === 1)
        continue;
      const s = i.map((n) => this.OrdinalToObstacle(n));
      for (const n of s)
        n.clump = s;
    }
  }
  CreateConvexHulls() {
    let t = !1;
    const e = Br(Array.from(this.overlapPairs.values())), i = Xs(e);
    for (const s of i) {
      if (s.length === 1)
        continue;
      t = !0;
      const n = s.map(this.OrdinalToObstacle), r = Yn(n, (l) => l.VisibilityPolyline), a = new bl(Xe.createConvexHullAsClosedPolyline(r), n);
      for (const l of n)
        l.SetConvexHull(a);
    }
    return t;
  }
  GrowGroupsToResolveOverlaps() {
    let t = !1;
    for (const e of this.overlapPairs.values()) {
      t = !0;
      const i = this.OrdinalToObstacle(e.x), s = this.OrdinalToObstacle(e.y);
      ct.ResolveGroupAndGroupOverlap(i, s) || ct.ResolveGroupAndObstacleOverlap(i, s);
    }
    return this.overlapPairs.clear(), t;
  }
  static ResolveGroupAndGroupOverlap(t, e) {
    return e.IsGroup ? (t.VisibilityPolyline.boundingBox.area > e.VisibilityPolyline.boundingBox.area ? ct.ResolveGroupAndObstacleOverlap(t, e) : ct.ResolveGroupAndObstacleOverlap(e, t), !0) : !1;
  }
  static ResolveGroupAndObstacleOverlap(t, e) {
    let i = e.looseVisibilityPolyline;
    ct.GrowGroupAroundLoosePolyline(t, i);
    const s = { bIsInsideA: !1, aIsInsideB: !1 };
    for (; ct.ObstaclesIntersect(e, t, s) || !s.aIsInsideB; )
      i = Ot.CreateLoosePolyline(i), ct.GrowGroupAroundLoosePolyline(t, i);
  }
  static GrowGroupAroundLoosePolyline(t, e) {
    const i = Array.from(t.VisibilityPolyline).concat(Array.from(e));
    t.SetConvexHull(new bl(Xe.createConvexHullAsClosedPolyline(i), [t]));
  }
  static ObstaclesIntersect(t, e, i) {
    return g.CurvesIntersect(t.VisibilityPolyline, e.VisibilityPolyline) ? (i.aIsInsideB = !1, i.bIsInsideA = !1, !0) : (i.aIsInsideB = ct.FirstPolylineStartIsInsideSecondPolyline(t.VisibilityPolyline, e.VisibilityPolyline), i.bIsInsideA = !i.aIsInsideB && ct.FirstPolylineStartIsInsideSecondPolyline(e.VisibilityPolyline, t.VisibilityPolyline), t.IsRectangle && e.IsRectangle ? !1 : ct.ObstaclesAreCloseEnoughToBeConsideredTouching(t, e, i.aIsInsideB, i.bIsInsideA) ? (i.aIsInsideB = !1, i.bIsInsideA = !1, !0) : !1);
  }
  static ObstaclesAreCloseEnoughToBeConsideredTouching(t, e, i, s) {
    if (!i && !s)
      return g.CurvesIntersect(t.looseVisibilityPolyline, e.VisibilityPolyline);
    const n = i ? t.looseVisibilityPolyline : e.looseVisibilityPolyline, r = i ? e.VisibilityPolyline : t.VisibilityPolyline;
    for (const a of n)
      if (g.PointRelativeToCurveLocation(a, r) === F.Outside) {
        const l = g.ClosestPoint(r, a);
        if (!u.closeIntersections(a, l))
          return !0;
      }
    return !1;
  }
  //Add ancestors that are spatial parents - they may not be in the hierarchy, but we need to be
  //able to cross their boundaries if we're routing between obstacles on different sides of them.
  AdjustSpatialAncestors() {
    if (this.SpatialAncestorsAdjusted)
      return !1;
    for (const e of this.GetAllGroups()) {
      const i = e.VisibilityBoundingBox;
      for (const s of this.Root.GetNodeItemsIntersectingRectangle(i))
        if (s !== e && g.ClosedCurveInteriorsIntersect(s.VisibilityPolyline, e.VisibilityPolyline)) {
          if (s.IsInConvexHull)
            for (const n of s.ConvexHull.Obstacles)
              this.AncestorSets.get(n.InputShape).add(e.InputShape);
          this.AncestorSets.get(s.InputShape).add(e.InputShape);
        }
    }
    let t = new Array();
    for (const e of this.Root.GetAllLeaves()) {
      const i = e.VisibilityBoundingBox;
      t = t.concat(Array.from(this.AncestorSets.get(e.InputShape)).filter((s) => !i.intersects(this.shapeIdToObstacleMap.get(s).VisibilityBoundingBox)));
      for (const s of t)
        this.AncestorSets.get(e.InputShape).delete(s);
      t = [];
    }
    return this.SpatialAncestorsAdjusted = !0, !0;
  }
  GetAllGroups() {
    return this.GetAllObstacles().filter((t) => t.IsGroup);
  }
  //Clear the internal state.
  Clear() {
    this.Root = null, this.AncestorSets = null;
  }
  // Create a LineSegment that contains the max visibility from startPoint in the desired direction.
  CreateMaxVisibilitySegment(t, e, i) {
    const s = O.RectangleBorderIntersect(this.GraphBox, t, e);
    if (b.GetDirections(t, s) === S.None)
      return i.pacList = null, v.mkPP(t, t);
    const n = this.RestrictSegmentWithObstacles(t, s);
    return i.pacList = this.CurrentGroupBoundaryCrossingMap.GetOrderedListBetween(n.start, n.end), n;
  }
  // Convenience functions that call through to RectangleNode.
  GetAllObstacles() {
    return this.allObstacles;
  }
  // Returns a list of all primary obstacles - secondary obstacles inside a convex hull are not needed in the VisibilityGraphGenerator.
  GetAllPrimaryObstacles() {
    return this.Root.GetAllLeaves();
  }
  // Hit-testing.
  IntersectionIsInsideAnotherObstacle(t, e, i, s) {
    return this.insideHitTestIgnoreObstacle1 = e, this.insideHitTestIgnoreObstacle2 = t, this.insideHitTestScanDirection = s, this.Root.FirstHitNodeWithPredicate(i, this.InsideObstacleHitTest.bind(this)) != null;
  }
  PointIsInsideAnObstaclePD(t, e) {
    return this.PointIsInsideAnObstacle(t, Pt.GetInstance(e));
  }
  PointIsInsideAnObstacle(t, e) {
    return this.insideHitTestIgnoreObstacle1 = null, this.insideHitTestIgnoreObstacle2 = null, this.insideHitTestScanDirection = e, this.Root.FirstHitNodeWithPredicate(t, this.InsideObstacleHitTest.bind(this)) != null;
  }
  InsideObstacleHitTest(t, e) {
    if (e === this.insideHitTestIgnoreObstacle1 || e === this.insideHitTestIgnoreObstacle2 || e.IsGroup || !O.PointIsInRectangleInterior(t, e.VisibilityBoundingBox))
      return ot.Continue;
    const i = O.RectangleBorderIntersect(e.VisibilityBoundingBox, t, this.insideHitTestScanDirection.dir).add(this.insideHitTestScanDirection.DirectionAsPoint), s = O.RectangleBorderIntersect(e.VisibilityBoundingBox, t, this.insideHitTestScanDirection.OppositeDirection).sub(this.insideHitTestScanDirection.DirectionAsPoint), n = v.mkPP(s, i), r = g.getAllIntersections(n, e.VisibilityPolyline, !0);
    if (r.length === 2) {
      const a = u.RoundPoint(r[0].x), l = u.RoundPoint(r[1].x);
      if (!b.EqualPP(t, a) && !b.EqualPP(t, l) && t.compareTo(a) !== t.compareTo(l) && !D(Math.floor(r[0].par1), Math.floor(r[1].par1)))
        return ot.Stop;
    }
    return ot.Continue;
  }
  SegmentCrossesAnObstacle(t, e) {
    this.stopAtGroups = !0, this.wantGroupCrossings = !1;
    const i = this.RestrictSegmentPrivate(t, e);
    return !b.EqualPP(i.end, e);
  }
  SegmentCrossesANonGroupObstacle(t, e) {
    this.stopAtGroups = !1, this.wantGroupCrossings = !1;
    const i = this.RestrictSegmentPrivate(t, e);
    return !b.EqualPP(i.end, e);
  }
  // TEST_MSAGL
  RestrictSegmentWithObstacles(t, e) {
    return this.stopAtGroups = !1, this.wantGroupCrossings = !0, this.RestrictSegmentPrivate(t, e);
  }
  RestrictSegmentPrivate(t, e) {
    return this.GetRestrictedIntersectionTestSegment(t, e), this.currentRestrictedRay = v.mkPP(t, e), this.restrictedRayLengthSquared = t.sub(e).lengthSquared, this.CurrentGroupBoundaryCrossingMap.Clear(), this.RecurseRestrictRayWithObstacles(this.Root), this.currentRestrictedRay;
  }
  GetRestrictedIntersectionTestSegment(t, e) {
    const i = b.GetDirections(t, e), s = S.West === i ? this.GraphBox.right : S.East === i ? this.GraphBox.left : t.x, n = S.West === i ? this.GraphBox.left : S.East === i ? this.GraphBox.right : e.x, r = S.South === i ? this.GraphBox.top * 2 : S.North === i ? this.GraphBox.bottom : t.y, a = S.South === i ? this.GraphBox.bottom : S.North === i ? this.GraphBox.top : t.y;
    this.restrictedIntersectionTestSegment = v.mkPP(new u(s, r), new u(n, a));
  }
  RecurseRestrictRayWithObstacles(t) {
    if (!O.RectangleInteriorsIntersect(this.currentRestrictedRay.boundingBox, t.irect))
      return;
    const e = t.UserData;
    if (e != null) {
      const i = g.getAllIntersections(this.restrictedIntersectionTestSegment, e.VisibilityPolyline, !0);
      if (!e.IsGroup || this.stopAtGroups) {
        this.LookForCloserNonGroupIntersectionToRestrictRay(i);
        return;
      }
      this.wantGroupCrossings && this.AddGroupIntersectionsToRestrictedRay(e, i);
      return;
    }
    this.RecurseRestrictRayWithObstacles(t.Left), this.RecurseRestrictRayWithObstacles(t.Right);
  }
  LookForCloserNonGroupIntersectionToRestrictRay(t) {
    let e = 0, i = null, s = this.restrictedRayLengthSquared;
    const n = b.GetDirections(this.restrictedIntersectionTestSegment.start, this.restrictedIntersectionTestSegment.end);
    for (const r of t) {
      const a = u.RoundPoint(r.x), l = b.GetDirections(this.currentRestrictedRay.start, a);
      if (l === w.OppositeDir(n))
        continue;
      if (e++, S.None === l) {
        s = 0, i = r;
        continue;
      }
      const h = a.sub(this.currentRestrictedRay.start).lengthSquared;
      if (h < s) {
        if (r.x.sub(this.currentRestrictedRay.start).lengthSquared < m.squareOfDistanceEpsilon)
          continue;
        s = h, i = r;
      }
    }
    if (i != null) {
      if (e === 1) {
        const r = u.RoundPoint(i.x);
        if (u.closeIntersections(r, this.currentRestrictedRay.start) || u.closeIntersections(r, this.currentRestrictedRay.end))
          return;
      }
      this.restrictedRayLengthSquared = s, this.currentRestrictedRay.end = Qs.MungeClosestIntersectionInfo(this.currentRestrictedRay.start, i, !O.IsVerticalPP(this.currentRestrictedRay.start, this.currentRestrictedRay.end));
    }
  }
  AddGroupIntersectionsToRestrictedRay(t, e) {
    for (const i of e) {
      const s = u.RoundPoint(i.x);
      if (s.sub(this.currentRestrictedRay.start).lengthSquared > this.restrictedRayLengthSquared)
        continue;
      const r = b.GetDirections(this.currentRestrictedRay.start, this.currentRestrictedRay.end), a = i.seg1, l = w.VectorDirection(a.derivative(i.par1));
      let h = r;
      (l & w.RotateRight(r)) !== 0 && (h = w.OppositeDir(h)), this.CurrentGroupBoundaryCrossingMap.AddIntersection(s, t, h);
    }
  }
}
class If {
  constructor(t, e) {
    this.scanDirection = t, this.SideTree = new Ee((i, s) => this.Compare(i, s)), this.linePositionAtLastInsertOrRemove = e;
  }
  Insert(t, e) {
    return this.linePositionAtLastInsertOrRemove = e, this.SideTree.insert(t);
  }
  get Count() {
    return this.SideTree.count;
  }
  Remove(t, e) {
    this.linePositionAtLastInsertOrRemove = e, this.SideTree.remove(t);
  }
  Find(t) {
    return this.scanDirection.ComparePerpCoord(this.linePositionAtLastInsertOrRemove, t.Start) === -1 ? null : this.SideTree.find(t);
  }
  NextLowB(t) {
    return this.NextLowR(this.Find(t));
  }
  NextLowR(t) {
    return this.SideTree.previous(t);
  }
  NextHighB(t) {
    return this.NextHighR(this.Find(t));
  }
  NextHighR(t) {
    return this.SideTree.next(t);
  }
  Next(t, e) {
    return O.IsAscending(t) ? this.SideTree.next(e) : this.SideTree.previous(e);
  }
  Lowest() {
    return this.SideTree.treeMinimum();
  }
  // For ordering lines along the scanline at segment starts/ends.
  Compare(t, e) {
    if (t.Obstacle === e.Obstacle)
      return t === e ? 0 : t instanceof Qe ? -1 : 1;
    const i = ut.ScanLineIntersectSidePBS(this.linePositionAtLastInsertOrRemove, t, this.scanDirection), s = ut.ScanLineIntersectSidePBS(this.linePositionAtLastInsertOrRemove, e, this.scanDirection);
    let n = i.compareTo(s);
    if (n === 0) {
      const r = t instanceof Qe, a = e instanceof Qe;
      n = dd(r, a), n === 0 && (n = yt(t.Obstacle.Ordinal, e.Obstacle.Ordinal));
    }
    return n;
  }
}
class or {
  constructor(t) {
    this.lookupSegment = W.mk(new u(0, 0), new u(0, 1)), this.ScanDirection = t, this.segmentTree = new Ee((e, i) => this.Compare(e, i)), this.findIntersectorPred = (e) => this.CompareIntersector(e), this.findPointPred = (e) => this.CompareToPoint(e);
  }
  get Segments() {
    return this.segmentTree.allNodes();
  }
  // If the seg is already in the tree it returns that instance, else it inserts the new
  // seg and returns that.
  InsertUnique(t) {
    this.AssertValidSegmentForInsertion(t);
    const e = this.segmentTree.find(t);
    return e ?? this.segmentTree.insert(t);
  }
  AssertValidSegmentForInsertion(t) {
  }
  Remove(t) {
    this.segmentTree.remove(t);
  }
  Find(t, e) {
    this.lookupSegment.Update(t, e);
    const i = this.segmentTree.find(this.lookupSegment);
    return i != null && b.EqualPP(i.item.End, e) ? i.item : null;
  }
  // Find the lowest perpendicular scanseg that intersects the segment endpoints.
  FindLowestIntersector(t, e) {
    const i = this.FindLowestIntersectorNode(t, e);
    return i != null ? i.item : null;
  }
  FindLowestIntersectorNode(t, e) {
    this.lookupSegment.Update(t, t);
    let i = this.segmentTree.findLast(this.findIntersectorPred);
    if (b.EqualPP(t, e))
      i != null && this.ScanDirection.Compare(i.item.End, t) < 0 && (i = null);
    else
      for (this.lookupSegment.Update(t, e); i != null && !i.item.IntersectsSegment(this.lookupSegment); ) {
        if (this.ScanDirection.Compare(i.item.Start, e) > 0)
          return null;
        i = this.segmentTree.next(i);
      }
    return i;
  }
  // Find the highest perpendicular scanseg that intersects the segment endpoints.
  FindHighestIntersector(t, e) {
    this.lookupSegment.Update(e, e);
    let i = this.segmentTree.findLast(this.findIntersectorPred);
    if (b.EqualPP(t, e))
      i != null && this.ScanDirection.Compare(i.item.End, t) < 0 && (i = null);
    else
      for (this.lookupSegment.Update(t, e); i != null && !i.item.IntersectsSegment(this.lookupSegment); ) {
        if (this.ScanDirection.Compare(i.item.End, t) < 0)
          return null;
        i = this.segmentTree.previous(i);
      }
    return i != null ? i.item : null;
  }
  CompareIntersector(t) {
    return this.ScanDirection.Compare(t.Start, this.lookupSegment.Start) <= 0;
  }
  FindSegmentContainingPoint(t, e) {
    return this.FindSegmentOverlappingPoints(t, t, e);
  }
  FindSegmentOverlappingPoints(t, e, i) {
    this.lookupSegment.Update(t, e);
    const s = this.segmentTree.findFirst(this.findPointPred);
    if (s != null) {
      const n = s.item;
      if (this.ScanDirection.Compare(n.Start, e) <= 0)
        return n;
    }
    return null;
  }
  CompareToPoint(t) {
    return this.ScanDirection.Compare(t.End, this.lookupSegment.Start) >= 0;
  }
  MergeAndRemoveNextNode(t, e) {
    return this.ScanDirection.Compare(t.End, e.item.End) === -1 && t.Update(t.Start, e.item.End), t.MergeGroupBoundaryCrossingList(e.item.GroupBoundaryPointAndCrossingsList), this.segmentTree.deleteNodeInternal(e), this.segmentTree.find(t);
  }
  MergeSegments() {
    if (this.segmentTree.count < 2)
      return;
    let t = this.segmentTree.treeMinimum(), e = this.segmentTree.next(t);
    for (; e != null; e = this.segmentTree.next(t))
      switch (this.ScanDirection.Compare(e.item.Start, t.item.End)) {
        case 1:
          t = e;
          break;
        case 0:
          e.item.IsOverlapped === t.item.IsOverlapped ? t = this.MergeAndRemoveNextNode(t.item, e) : (t.item.NeedEndOverlapVertex = !0, e.item.NeedStartOverlapVertex = !0, t = e);
          break;
        default:
          if (t.item.IsOverlapped !== e.item.IsOverlapped) {
            if (t.item.IsOverlapped)
              t.item.Start === e.item.Start ? t = this.MergeAndRemoveNextNode(e.item, t) : (t.item.Update(t.item.Start, e.item.Start), t = e);
            else if (t.item.End === e.item.End)
              t = this.MergeAndRemoveNextNode(t.item, e);
            else {
              const s = e.item, n = t.item;
              this.segmentTree.deleteNodeInternal(e), s.Update(n.End, s.End), this.segmentTree.insert(s), s.TrimGroupBoundaryCrossingList(), t = this.segmentTree.find(n);
            }
            break;
          }
          t = this.MergeAndRemoveNextNode(t.item, e);
          break;
      }
  }
  // For ordering the line segments inserted by the ScanLine. Assuming vertical sweep (sweeping up from
  // bottom, scanning horizontally) then order ScanSegments first by lowest Y coord, then by lowest X coord.
  Compare(t, e) {
    if (t === e)
      return 0;
    if (t == null)
      return -1;
    if (e == null)
      return 1;
    let i = this.ScanDirection.Compare(t.Start, e.Start);
    return i === 0 && (i = this.ScanDirection.Compare(t.End, e.End) * -1), i;
  }
}
class wf extends Ds {
  constructor(t) {
    super(t);
  }
  SetVertexEntry(t) {
    this.VertexEntries == null && (this.VertexEntries = new Array(4)), this.VertexEntries[w.ToIndex(t.Direction)] = t;
  }
  RemoveVertexEntries() {
    this.VertexEntries = null;
  }
}
class ut {
  constructor(t) {
    this.ObstacleTree = new ct(), this.CurrentGroupBoundaryCrossingMap = new jh(), this.LowNeighborSides = new yl(), this.HighNeighborSides = new yl(), this.ScanDirection = Pt.HorizontalInstance, this.eventQueue = new fl(), this.HorizontalScanSegments = new or(Pt.HorizontalInstance), this.VerticalScanSegments = new or(Pt.VerticalInstance), this.wantReflections = t;
  }
  get ParallelScanSegments() {
    return this.ScanDirection.IsHorizontal ? this.HorizontalScanSegments : this.VerticalScanSegments;
  }
  get PerpendicularScanSegments() {
    return this.ScanDirection.IsHorizontal ? this.VerticalScanSegments : this.HorizontalScanSegments;
  }
  static NewVisibilityGraph() {
    const t = new Et();
    return t.VertexFactory = (e) => new wf(e), t;
  }
  // Generate the visibility graph along which edges will be routed.
  GenerateVisibilityGraph() {
    if (this.ObstacleTree.Root == null)
      return;
    this.InitializeEventQueue(Pt.HorizontalInstance);
    let t = Ot.FirstSentinelOrdinal, e = new u(this.ObstacleTree.GraphBox.left - ut.SentinelOffset, this.ObstacleTree.GraphBox.bottom - ut.SentinelOffset), i = new u(this.ObstacleTree.GraphBox.left - ut.SentinelOffset, this.ObstacleTree.GraphBox.top + ut.SentinelOffset), s = Ot.CreateSentinel(e, i, this.ScanDirection, t++);
    this.scanLine.Insert(s.ActiveHighSide, this.ObstacleTree.GraphBox.leftBottom), e = new u(this.ObstacleTree.GraphBox.right + ut.SentinelOffset, this.ObstacleTree.GraphBox.bottom - ut.SentinelOffset), i = new u(this.ObstacleTree.GraphBox.right + ut.SentinelOffset, this.ObstacleTree.GraphBox.top + ut.SentinelOffset), s = Ot.CreateSentinel(e, i, this.ScanDirection, t++), this.scanLine.Insert(s.ActiveLowSide, this.ObstacleTree.GraphBox.leftBottom), this.ProcessEvents(), this.InitializeEventQueue(Pt.VerticalInstance), e = new u(this.ObstacleTree.GraphBox.left - ut.SentinelOffset, this.ObstacleTree.GraphBox.bottom - ut.SentinelOffset), i = new u(this.ObstacleTree.GraphBox.right + ut.SentinelOffset, this.ObstacleTree.GraphBox.bottom - ut.SentinelOffset), s = Ot.CreateSentinel(e, i, this.ScanDirection, t++), this.scanLine.Insert(s.ActiveHighSide, this.ObstacleTree.GraphBox.leftBottom), e = new u(this.ObstacleTree.GraphBox.left - ut.SentinelOffset, this.ObstacleTree.GraphBox.top + ut.SentinelOffset), i = new u(this.ObstacleTree.GraphBox.right + ut.SentinelOffset, this.ObstacleTree.GraphBox.top + ut.SentinelOffset), s = Ot.CreateSentinel(e, i, this.ScanDirection, t), this.scanLine.Insert(s.ActiveLowSide, this.ObstacleTree.GraphBox.leftBottom), this.ProcessEvents();
  }
  // // ReSharper disable InconsistentNaming
  // protected static Debug_AssertGraphIsRectilinear(graph: VisibilityGraph, this.ObstacleTree: this.ObstacleTree) {
  //    this.#if TEST_MSAGL
  //    if (graph.Edges.Any(edge => !PointComparer.IsPureDirection(PointComparer.GetDirections(edge.SourcePoint, edge.TargetPoint))))
  //    {
  //        StaticGraphUtility.Assert(false, "Generated VisibilityGraph contains non-rectilinear lines", this.ObstacleTree, graph);
  //        return;
  //    }
  //    this.#endif
  // }
  static ScanLineIntersectSidePBS(t, e, i) {
    const s = e.Direction;
    let n = e.Start.x, r = e.Start.y;
    return i.IsHorizontal ? (n += s.x / s.y * (t.y - e.Start.y), n = Qs.MungeIntersect(t.x, n, e.Start.x, e.End.x), r = t.y) : (n = t.x, r += s.y / s.x * (t.x - e.Start.x), r = Qs.MungeIntersect(t.y, r, e.Start.y, e.End.y)), new u(n, r);
  }
  GetOpenVertex(t) {
    let e = t.startPoint, i = this.TraversePolylineForEvents(e), s = this.PointCompare(i.point, e.point);
    for (; ; i = this.TraversePolylineForEvents(i)) {
      const n = this.PointCompare(i.point, e.point);
      if (n <= 0)
        e = i;
      else if (n > 0 && s <= 0)
        break;
      s = n;
    }
    return e;
  }
  TraversePolylineForEvents(t) {
    return this.ScanDirection.IsHorizontal ? t.nextOnPolyline : t.prevOnPolyline;
  }
  InitializeEventQueue(t) {
    this.ScanDirection = t, this.eventQueue.Reset(this.ScanDirection), this.EnqueueBottomVertexEvents(), this.scanLine = new If(this.ScanDirection, this.ObstacleTree.GraphBox.leftBottom), this.lookaheadScan = new Cf(this.ScanDirection);
  }
  EnqueueBottomVertexEvents() {
    for (const t of this.ObstacleTree.GetAllPrimaryObstacles()) {
      const e = this.GetOpenVertex(t.VisibilityPolyline);
      this.eventQueue.Enqueue(new ur(t, e));
    }
  }
  // end EnqueueBottomVertexEvents
  IsFlat(t) {
    return this.ScanDirection.IsFlatS(t);
  }
  IsPerpendicular(t) {
    return this.ScanDirection.IsPerpendicularS(t);
  }
  // Params are event site (vertex point) and the obstacle side adjacent to that site.
  ScanLineIntersectSide(t, e) {
    return ut.ScanLineIntersectSidePBS(t, e, this.ScanDirection);
  }
  SideReflectsUpward(t) {
    return t instanceof Qe ? this.ScanDirection.Coord(t.End) > this.ScanDirection.Coord(t.Start) : this.ScanDirection.Coord(t.End) < this.ScanDirection.Coord(t.Start);
  }
  SideReflectsDownward(t) {
    return t instanceof Qe ? this.ScanDirection.Coord(t.End) < this.ScanDirection.Coord(t.Start) : this.ScanDirection.Coord(t.End) > this.ScanDirection.Coord(t.Start);
  }
  // Calculate reflections from the lines, depending on line side (Low vs. High) and slope.
  // Because the low neighbor intersection is on a high side of its obstacle
  // and vice-versa, then the "side" of a lowNbor is a highSide, and vice versa.
  StoreLookaheadSite(t, e, i, s) {
    if (this.wantReflections && !this.IsPerpendicular(e)) {
      if (!s && !O.PointIsInRectangleInterior(i, e.Obstacle.VisibilityBoundingBox))
        return;
      this.SideReflectsUpward(e) && this.lookaheadScan.Find(i) == null && this.lookaheadScan.Add(new Cs(t, e.Obstacle, i));
    }
  }
  // Load any lookahead scan ray intersections with a side we've just added.
  LoadReflectionEvents(t) {
    this.LoadReflectionEventsBB(t, t);
  }
  // sideWithRange is either the same as sideToQueue, if that side is being loaded by an
  // OpenVertexEvent, or is a different side that is just closing.
  LoadReflectionEventsBB(t, e) {
    if (t == null || this.SideReflectsUpward(t) || this.IsPerpendicular(t))
      return;
    const i = T.mkPP(t.Start, t.End), s = T.mkPP(e.Start, e.End);
    if (this.ScanDirection.IsHorizontal ? !i.intersectsOnX(s) : !i.intersectsOnY(s))
      return;
    const n = T.intersect(i, s), r = n.leftBottom, a = n.rightTop;
    let l = this.lookaheadScan.FindFirstInRange(r, a);
    for (; l != null; ) {
      const h = ut.ScanLineIntersectSidePBS(l.item.Site, t, this.ScanDirection.PerpendicularInstance);
      this.ScanDirection.ComparePerpCoord(h, l.item.Site) > 0 ? this.AddReflectionEvent(l.item, t, h) : l.item.ReflectingObstacle !== t.Obstacle && this.lookaheadScan.MarkStaleSite(l.item), l = this.lookaheadScan.FindNextInRange(l, a);
    }
    this.lookaheadScan.RemoveStaleSites();
  }
  // Determine whether the event is valid and do some common processing.
  AddPerpendicularReflectionSegment(t, e, i) {
    if (this.lookaheadScan.RemoveExact(t.PreviousSite)) {
      if (e == null)
        return !1;
      if (t.PreviousSite.IsStaircaseStep(t.ReflectingObstacle)) {
        if (!O.PointIsInRectangleInterior(t.Site, t.ReflectingObstacle.VisibilityBoundingBox) || !this.InsertPerpendicularReflectionSegment(t.PreviousSite.Site, t.Site))
          return !1;
        if (i != null && t.IsStaircaseStep(i.Obstacle))
          return this.ScanLineCrossesObstacle(t.Site, i.Obstacle);
      }
    }
    return !1;
  }
  AddParallelReflectionSegment(t, e, i, s) {
    {
      const n = this.ScanLineIntersectSide(s.Site, e ?? i), r = e != null ? n : s.Site, a = e != null ? s.Site : n;
      return e == null ? e = this.scanLine.NextLowB(i).item : i = this.scanLine.NextHighB(e).item, this.InsertParallelReflectionSegment(r, a, t, e, i, s);
    }
  }
  AddReflectionEvent(t, e, i) {
    const s = e;
    s != null ? this.eventQueue.Enqueue(new Sl(t, s, i)) : this.eventQueue.Enqueue(new gl(t, e, i));
  }
  AddSideToScanLine(t, e) {
    const i = this.scanLine.Insert(t, e);
    return this.LoadReflectionEvents(t), i;
  }
  RemoveSideFromScanLine(t, e) {
    this.scanLine.Remove(t.item, e);
  }
  PointCompare(t, e) {
    return this.ScanDirection.Compare(t, e);
  }
  Clear() {
    this.ObstacleTree.Clear(), this.eventQueue = new fl(), this.HorizontalScanSegments = new or(Pt.HorizontalInstance), this.VerticalScanSegments = new or(Pt.VerticalInstance), this.VisibilityGraph = null;
  }
  ProcessEvents() {
    for (; this.eventQueue.Count > 0; ) {
      const t = this.eventQueue.Dequeue();
      t instanceof ur ? this.ProcessEventO(t) : t instanceof pl ? this.ProcessEventLB(t) : t instanceof ml ? this.ProcessEventHB(t) : t instanceof Pl ? this.ProcessEventCV(t) : t instanceof Sl ? this.ProcessEventLR(t) : t instanceof gl ? this.ProcessEventHR(t) : this.ProcessCustomEvent(t), this.LowNeighborSides.Clear(), this.HighNeighborSides.Clear();
    }
  }
  ProcessCustomEvent(t) {
  }
  ScanLineCrossesObstacle(t, e) {
    return this.ScanDirection.ComparePerpCoord(t, e.VisibilityBoundingBox.leftBottom) > 0 && this.ScanDirection.ComparePerpCoord(t, e.VisibilityBoundingBox.rightTop) < 0;
  }
  FindInitialNeighborSides(t, e) {
    e.lowNborSideNode = this.scanLine.NextLowR(t), e.highNborSideNode = this.scanLine.NextHighR(t);
  }
  // As described in the doc, we stop at the first neighbor of the appropriate side type that we touch
  // the border of, even if that's just skimming along the extreme vertex of it, because those will
  // continue the chain of open/close+addSegment, and we don't want to follow the full length of the
  // segment each time if there are a lot of collinear obstacle open/close events.
  FindNeighborsBRR(t, e, i) {
    this.LowNeighborSides.Clear(), this.HighNeighborSides.Clear(), this.FindNeighbors(t, e, this.LowNeighborSides), this.FindNeighbors(t, i, this.HighNeighborSides);
  }
  FindNeighbors(t, e, i) {
    const s = t instanceof ur ? e.item.Start : e.item.End, n = { lowNborSideNode: null, highNborSideNode: null };
    this.FindInitialNeighborSides(e, n), this.SkipToNeighbor(this.ScanDirection.OppositeDirection, e.item, s, n.lowNborSideNode, i), this.SkipToNeighbor(this.ScanDirection.Dir, e.item, s, n.highNborSideNode, i);
  }
  SkipToNeighbor(t, e, i, s, n) {
    let r = null, a = null;
    for (; ; s = this.scanLine.Next(t, s))
      if (s.item.Obstacle !== e.Obstacle) {
        if (s.item.Obstacle.IsGroup) {
          this.ProcessGroupSideEncounteredOnTraversalToNeighbor(s, i, t) && a == null && (a = s.item);
          continue;
        }
        if (s.item instanceof vn === O.IsAscending(t)) {
          this.ScanLineCrossesObstacle(i, s.item.Obstacle) && (r = s, a = null);
          continue;
        }
        break;
      }
    n.SetSides(t, s, r, a);
  }
  // end this.ProcessEvent(CloseVertexEvent)
  ProcessGroupSideEncounteredOnTraversalToNeighbor(t, e, i) {
    if (!this.ScanLineCrossesObstacle(e, t.item.Obstacle))
      return !1;
    const s = t.item instanceof Qe === O.IsAscending(i) ? i : w.OppositeDir(i), n = this.ScanLineIntersectSide(e, t.item);
    return this.CurrentGroupBoundaryCrossingMap.AddIntersection(n, t.item.Obstacle, s), !0;
  }
  FindNeighborsAndProcessVertexEvent(t, e, i) {
    this.CurrentGroupBoundaryCrossingMap.Clear(), this.FindNeighborsBRR(i, t, e), this.ProcessVertexEvent(t, e, i), this.CurrentGroupBoundaryCrossingMap.Clear();
  }
  ProcessEventO(t) {
    var e, i;
    const s = t.Obstacle;
    s.CreateInitialSides(t.Vertex, this.ScanDirection), this.AddSideToScanLine(s.ActiveLowSide, t.Site);
    const n = this.AddSideToScanLine(s.ActiveHighSide, t.Site), r = this.scanLine.Find(s.ActiveLowSide);
    this.FindNeighborsAndProcessVertexEvent(r, n, t);
    const a = (e = this.LowNeighborSides.GroupSideInterveningBeforeLowNeighbor) !== null && e !== void 0 ? e : this.LowNeighborSides.LowNeighborSide;
    this.SideReflectsUpward(a) && this.LoadReflectionEvents(s.ActiveLowSide);
    const l = (i = this.HighNeighborSides.GroupSideInterveningBeforeHighNeighbor) !== null && i !== void 0 ? i : this.HighNeighborSides.HighNeighborSide;
    if (this.SideReflectsUpward(l) && this.LoadReflectionEvents(s.ActiveHighSide), s.ActiveHighSide.Start !== s.ActiveLowSide.Start) {
      const h = new vn(s, t.Vertex, this.ScanDirection);
      this.lookaheadScan.RemoveSitesForFlatBottom(h.Start, h.End);
    }
    this.EnqueueLowBendVertexEvent(s.ActiveLowSide), this.EnqueueHighBendOrCloseVertexEvent(s.ActiveHighSide);
  }
  // end this.ProcessEvent(OpenVertexEvent)
  ProcessEventLB(t) {
    const e = t.Obstacle, i = new Qe(e, t.Vertex, this.ScanDirection);
    this.ScanDirection.ComparePerpCoord(i.End, i.Start) > 0 && (this.RemoveSideFromScanLine(this.scanLine.Find(e.ActiveLowSide), t.Site), this.AddSideToScanLine(i, t.Site), e.ActiveLowSide = i, this.EnqueueLowBendVertexEvent(i));
  }
  // end this.ProcessEvent(LowBendVertexEvent)
  EnqueueLowBendVertexEvent(t) {
    this.eventQueue.Enqueue(new pl(t.Obstacle, t.EndVertex));
  }
  ProcessEventHB(t) {
    const e = t.Obstacle, i = new vn(e, t.Vertex, this.ScanDirection);
    this.RemoveSideFromScanLine(this.scanLine.Find(e.ActiveHighSide), t.Site);
    const s = this.AddSideToScanLine(i, t.Site);
    if (e.ActiveHighSide = i, this.EnqueueHighBendOrCloseVertexEvent(e.ActiveHighSide), this.wantReflections && this.ScanDirection.IsHorizontal && i.Start.x === e.VisibilityBoundingBox.right && this.SideReflectsUpward(i)) {
      const n = this.scanLine.NextHighR(s);
      n.item instanceof Qe && this.SideReflectsDownward(n.item) && (!e.isOverlapped || !this.ObstacleTree.PointIsInsideAnObstacle(i.Start, this.ScanDirection)) && (this.StoreLookaheadSite(n.item.Obstacle, i, i.Start, !0), this.LoadReflectionEvents(n.item));
    }
  }
  EnqueueHighBendOrCloseVertexEvent(t) {
    const e = t.Obstacle, i = this.ScanDirection.IsHorizontal ? t.EndVertex.prevOnPolyline : t.EndVertex.nextOnPolyline;
    this.ScanDirection.ComparePerpCoord(i.point, t.End) > 0 ? this.eventQueue.Enqueue(new ml(e, t.EndVertex)) : this.eventQueue.Enqueue(new Pl(e, t.EndVertex));
  }
  // end this.ProcessEvent(HighBendVertexEvent)
  CreateCloseEventSegmentsAndFindNeighbors(t) {
    const e = t.Obstacle;
    let i = this.scanLine.Find(e.ActiveLowSide), s = this.scanLine.Find(e.ActiveHighSide);
    if (this.scanLine.Compare(e.ActiveLowSide, e.ActiveHighSide) === 1) {
      const n = i;
      i = s, s = n;
    }
    if (this.FindNeighborsAndProcessVertexEvent(i, s, t), this.wantReflections && e.isOverlapped)
      for (let n = this.scanLine.NextHighR(i); n.item !== s.item; n = this.scanLine.NextHighR(n))
        this.LoadReflectionEvents(n.item);
    this.scanLine.Remove(e.ActiveLowSide, t.Site), this.scanLine.Remove(e.ActiveHighSide, t.Site);
  }
  ProcessEventCV(t) {
    this.CreateCloseEventSegmentsAndFindNeighbors(t);
    const e = this.LowNeighborSides.LowNeighbor.item, i = this.HighNeighborSides.HighNeighbor.item, s = t.Obstacle;
    this.LoadReflectionEvents(e), this.LoadReflectionEvents(i), s.Close();
  }
  ProcessEventLR(t) {
    const e = t.Side.Obstacle, i = this.scanLine.NextLowB(t.Side).item;
    this.AddPerpendicularReflectionSegment(t, t.Side, i) && this.AddParallelReflectionSegment(e, i, null, t) && this.LoadReflectionEvents(e.ActiveLowSide);
  }
  // end this.ProcessEvent(LowReflectionEvent)
  ProcessEventHR(t) {
    const e = t.Side.Obstacle, i = this.scanLine.NextHighB(t.Side).item;
    this.AddPerpendicularReflectionSegment(t, t.Side, i) && this.AddParallelReflectionSegment(e, null, i, t) && this.LoadReflectionEvents(e.ActiveHighSide);
  }
  // end this.ProcessEvent(HighReflectionEvent)
  MakeInBoundsLocation(t) {
    const e = Math.max(t.x, this.ObstacleTree.GraphBox.left), i = Math.max(t.y, this.ObstacleTree.GraphBox.bottom);
    return new u(Math.min(e, this.ObstacleTree.GraphBox.right), Math.min(i, this.ObstacleTree.GraphBox.top));
  }
  IsInBoundsV(t) {
    return this.IsInBoundsP(t.point);
  }
  IsInBoundsP(t) {
    return b.EqualPP(t, this.MakeInBoundsLocation(t));
  }
}
ut.SentinelOffset = 1;
class Se extends ut {
  constructor() {
    super(
      /* wantReflections:*/
      !1
    ), this.horizontalVertexPoints = new xt(), this.verticalVertexPoints = new xt(), this.boundingBoxSteinerPoints = new xt(), this.xCoordAccumulator = /* @__PURE__ */ new Set(), this.yCoordAccumulator = /* @__PURE__ */ new Set(), this.horizontalCoordMap = /* @__PURE__ */ new Map(), this.verticalCoordMap = /* @__PURE__ */ new Map();
  }
  Clear() {
    super.Clear(), this.Cleanup();
  }
  Cleanup() {
    this.horizontalVertexPoints.clear(), this.verticalVertexPoints.clear(), this.boundingBoxSteinerPoints.clear(), this.xCoordAccumulator.clear(), this.yCoordAccumulator.clear(), this.horizontalCoordMap.clear(), this.verticalCoordMap.clear();
  }
  // Generate the visibility graph along which edges will be routed.
  GenerateVisibilityGraph() {
    this.AccumulateVertexCoords(), this.CreateSegmentVectorsAndPopulateCoordinateMaps(), this.RunScanLineToCreateSegmentsAndBoundingBoxSteinerPoints(), this.GenerateSparseIntersectionsFromVertexPoints(), this.CreateScanSegmentTrees(), this.Cleanup();
  }
  AccumulateVertexCoords() {
    for (const t of this.ObstacleTree.GetAllObstacles())
      this.xCoordAccumulator.add(t.VisibilityBoundingBox.left), this.xCoordAccumulator.add(t.VisibilityBoundingBox.right), this.yCoordAccumulator.add(t.VisibilityBoundingBox.top), this.yCoordAccumulator.add(t.VisibilityBoundingBox.bottom);
  }
  CreateSegmentVectorsAndPopulateCoordinateMaps() {
    this.horizontalScanSegmentVector = new dl(this.yCoordAccumulator, !0), this.verticalScanSegmentVector = new dl(this.xCoordAccumulator, !1);
    for (let t = 0; t < this.horizontalScanSegmentVector.Length; t++)
      this.horizontalCoordMap.set(this.horizontalScanSegmentVector.Item(t).Coord, t);
    for (let t = 0; t < this.verticalScanSegmentVector.Length; t++)
      this.verticalCoordMap.set(this.verticalScanSegmentVector.Item(t).Coord, t);
  }
  RunScanLineToCreateSegmentsAndBoundingBoxSteinerPoints() {
    super.GenerateVisibilityGraph(), this.horizontalScanSegmentVector.ScanSegmentsComplete(), this.verticalScanSegmentVector.ScanSegmentsComplete(), this.xCoordAccumulator.clear(), this.yCoordAccumulator.clear();
  }
  InitializeEventQueue(t) {
    super.InitializeEventQueue(t), this.SetVectorsAndCoordMaps(t), this.AddAxisCoordinateEvents(t);
  }
  AddAxisCoordinateEvents(t) {
    if (t.IsHorizontal) {
      for (const e of this.yCoordAccumulator)
        this.eventQueue.Enqueue(new bo(new u(this.ObstacleTree.GraphBox.left - Se.SentinelOffset, e)));
      return;
    }
    for (const e of this.xCoordAccumulator)
      this.eventQueue.Enqueue(new bo(new u(e, this.ObstacleTree.GraphBox.bottom - Se.SentinelOffset)));
  }
  ProcessCustomEvent(t) {
    this.ProcessAxisCoordinate(t) || this.ProcessCustomEvent(t);
  }
  ProcessAxisCoordinate(t) {
    return t instanceof bo ? (this.CreateScanSegmentsOnAxisCoordinate(t.Site), !0) : !1;
  }
  InsertPerpendicularReflectionSegment(t, e) {
    return !1;
  }
  InsertParallelReflectionSegment(t, e, i, s, n, r) {
    return !1;
  }
  ProcessVertexEvent(t, e, i) {
    const s = this.ScanDirection.IsHorizontal ? this.horizontalVertexPoints : this.verticalVertexPoints;
    s.add(i.Site);
    const n = this.LowNeighborSides.LowNeighbor.item, r = this.HighNeighborSides.HighNeighbor.item, a = this.ScanDirection.Dir, l = this.ScanDirection.OppositeDirection, h = this.ScanLineIntersectSide(i.Site, n), c = this.ScanLineIntersectSide(i.Site, r);
    if (this.ObstacleTree.GraphBox.contains(h)) {
      const f = O.RectangleBorderIntersect(n.Obstacle.VisibilityBoundingBox, h, a);
      b.IsPureLower(f, i.Site) && this.boundingBoxSteinerPoints.add(f);
    }
    if (this.ObstacleTree.GraphBox.contains(c)) {
      const f = O.RectangleBorderIntersect(r.Obstacle.VisibilityBoundingBox, c, l);
      b.IsPureLower(i.Site, f) && this.boundingBoxSteinerPoints.add(f);
    }
    const d = { lowCorner: void 0, highCorner: void 0 };
    Se.GetBoundingCorners(t.item.Obstacle.VisibilityBoundingBox, i instanceof ur, this.ScanDirection.IsHorizontal, d), (b.IsPureLower(h, d.lowCorner) || n.Obstacle.IsInSameClump(i.Obstacle)) && s.add(d.lowCorner), (b.IsPureLower(d.highCorner, c) || r.Obstacle.IsInSameClump(i.Obstacle)) && s.add(d.highCorner);
  }
  static GetBoundingCorners(t, e, i, s) {
    if (e) {
      s.lowCorner = t.leftBottom, s.highCorner = i ? t.rightBottom : t.leftTop;
      return;
    }
    s.lowCorner = i ? t.leftTop : t.rightBottom, s.highCorner = t.rightTop;
  }
  CreateScanSegmentsOnAxisCoordinate(t) {
    this.CurrentGroupBoundaryCrossingMap.Clear();
    const e = this.scanLine.Lowest();
    let i = this.scanLine.NextHighR(e), s = 0, n = t, r = !1;
    for (; i != null; i = this.scanLine.NextHighR(i)) {
      if (this.SkipSide(n, i.item))
        continue;
      if (i.item.Obstacle.IsGroup) {
        (s === 0 || r) && this.HandleGroupCrossing(t, i.item);
        continue;
      }
      if (i.item instanceof Qe) {
        if (s > 0) {
          s++;
          continue;
        }
        n = this.CreateScanSegment(n, i.item, W.NormalWeight), this.CurrentGroupBoundaryCrossingMap.Clear(), s = 1, r = i.item.Obstacle.isOverlapped;
        continue;
      }
      s++, !(s > 0) && (n = i.item.Obstacle.isOverlapped || i.item.Obstacle.OverlapsGroupCorner ? this.CreateScanSegment(n, i.item, W.OverlappedWeight) : this.ScanLineIntersectSide(n, i.item), this.CurrentGroupBoundaryCrossingMap.Clear(), r = !1);
    }
    const a = this.ScanDirection.IsHorizontal ? new u(this.ObstacleTree.GraphBox.right + Se.SentinelOffset, n.y) : new u(n.x, this.ObstacleTree.GraphBox.top + Se.SentinelOffset);
    this.parallelSegmentVector.CreateScanSegment(n, a, W.NormalWeight, this.CurrentGroupBoundaryCrossingMap.GetOrderedListBetween(n, a)), this.parallelSegmentVector.ScanSegmentsCompleteForCurrentSlot();
  }
  HandleGroupCrossing(t, e) {
    if (!this.ScanLineCrossesObstacle(t, e.Obstacle))
      return;
    const i = e instanceof Qe ? this.ScanDirection.Dir : this.ScanDirection.OppositeDirection, s = this.ScanLineIntersectSide(t, e), n = this.CurrentGroupBoundaryCrossingMap.AddIntersection(s, e.Obstacle, i);
    this.AddPerpendicularCoordForGroupCrossing(s);
    const r = n.GetInteriorVertexPoint(s);
    this.AddPerpendicularCoordForGroupCrossing(r);
  }
  AddPerpendicularCoordForGroupCrossing(t) {
    const e = this.FindPerpendicularSlot(t, 0);
    e !== -1 && this.perpendicularSegmentVector.Item(e).AddPendingPerpendicularCoord(this.parallelSegmentVector.CurrentSlot.Coord);
  }
  SkipSide(t, e) {
    if (e.Obstacle.IsSentinel)
      return !0;
    const i = e.Obstacle.VisibilityBoundingBox;
    return this.ScanDirection.IsHorizontal ? t.y === i.bottom || t.y === i.top : t.x === i.left || t.x === i.right;
  }
  CreateScanSegment(t, e, i) {
    const s = this.ScanLineIntersectSide(t, e);
    return t !== s && this.parallelSegmentVector.CreateScanSegment(t, s, i, this.CurrentGroupBoundaryCrossingMap.GetOrderedListBetween(t, s)), s;
  }
  GenerateSparseIntersectionsFromVertexPoints() {
    this.VisibilityGraph = Se.NewVisibilityGraph(), this.GenerateSparseIntersectionsAlongHorizontalAxis(), this.GenerateSparseIntersectionsAlongVerticalAxis(), this.ConnectAdjoiningScanSegments(), this.horizontalScanSegmentVector.CreateSparseVerticesAndEdges(this.VisibilityGraph), this.verticalScanSegmentVector.CreateSparseVerticesAndEdges(this.VisibilityGraph);
  }
  GenerateSparseIntersectionsAlongHorizontalAxis() {
    this.currentAxisPointComparer = hr;
    const t = Array.from(this.horizontalVertexPoints.values()).sort(this.currentAxisPointComparer), e = Array.from(this.boundingBoxSteinerPoints.values()).sort(this.currentAxisPointComparer);
    this.ScanDirection = Pt.HorizontalInstance, this.SetVectorsAndCoordMaps(this.ScanDirection), this.GenerateSparseIntersections(t, e);
  }
  GenerateSparseIntersectionsAlongVerticalAxis() {
    this.currentAxisPointComparer = (i, s) => i.compareTo(s);
    const t = Array.from(this.verticalVertexPoints.values()).sort(this.currentAxisPointComparer), e = Array.from(this.boundingBoxSteinerPoints.values()).sort(this.currentAxisPointComparer);
    this.ScanDirection = Pt.VerticalInstance, this.SetVectorsAndCoordMaps(this.ScanDirection), this.GenerateSparseIntersections(t, e);
  }
  SetVectorsAndCoordMaps(t) {
    t.IsHorizontal ? (this.parallelSegmentVector = this.horizontalScanSegmentVector, this.perpendicularSegmentVector = this.verticalScanSegmentVector, this.perpendicularCoordMap = this.verticalCoordMap) : (this.parallelSegmentVector = this.verticalScanSegmentVector, this.perpendicularSegmentVector = this.horizontalScanSegmentVector, this.perpendicularCoordMap = this.horizontalCoordMap);
  }
  ConnectAdjoiningScanSegments() {
    this.horizontalScanSegmentVector.ConnectAdjoiningSegmentEndpoints(), this.verticalScanSegmentVector.ConnectAdjoiningSegmentEndpoints();
  }
  GenerateSparseIntersections(t, e) {
    this.perpendicularSegmentVector.ResetForIntersections(), this.parallelSegmentVector.ResetForIntersections();
    let i = 1;
    const s = { j: 0 };
    for (const n of this.parallelSegmentVector.Items())
      for (; !(!n.CurrentSegment.ContainsPoint(t[i]) && (!this.AddSteinerPointsToInterveningSegments(t[i], e, s, n) || !n.TraverseToSegmentContainingPoint(t[i]))); ) {
        if (this.AddPointsToCurrentSegmentIntersections(e, s, n), this.GenerateIntersectionsFromVertexPointForCurrentSegment(t[i], n), n.PointIsCurrentEndAndNextStart(t[i])) {
          n.MoveNext();
          continue;
        }
        if (++i >= t.length)
          return;
      }
  }
  AddSteinerPointsToInterveningSegments(t, e, i, s) {
    for (; i.j < e.length && this.currentAxisPointComparer(e[i.j], t) === -1; ) {
      if (!s.TraverseToSegmentContainingPoint(e[i.j]))
        return !1;
      this.AddPointsToCurrentSegmentIntersections(e, i, s);
    }
    return !0;
  }
  AddPointsToCurrentSegmentIntersections(t, e, i) {
    for (; e.j < t.length && i.CurrentSegment.ContainsPoint(t[e.j]); e.j++) {
      const s = this.FindPerpendicularSlot(t[e.j], 0);
      this.AddSlotToSegmentIntersections(i, s);
    }
  }
  GenerateIntersectionsFromVertexPointForCurrentSegment(t, e) {
    const i = this.FindPerpendicularSlot(e.CurrentSegment.Start, 1), s = this.FindPerpendicularSlot(e.CurrentSegment.End, -1), n = this.FindPerpendicularSlot(t, 0);
    i >= s || (this.AddSlotToSegmentIntersections(e, i), this.AddSlotToSegmentIntersections(e, s), n > i && n < s && (this.AddSlotToSegmentIntersections(e, n), this.AddBinaryDivisionSlotsToSegmentIntersections(e, i, n, s)));
  }
  // These are called when the site may not be in the vector.
  FindPerpendicularSlot(t, e) {
    return Se.FindIntersectingSlot(this.perpendicularSegmentVector, this.perpendicularCoordMap, t, e);
  }
  static FindIntersectingSlot(t, e, i, s) {
    const n = t.GetParallelCoord(i), r = e.get(n);
    return r !== void 0 ? r : s === 0 ? -1 : t.FindNearest(n, s);
  }
  AddSlotToSegmentIntersections(t, e) {
    const i = this.perpendicularSegmentVector.Item(e);
    t.CurrentSegment.AddSparseVertexCoord(i.Coord), i.AddPerpendicularCoord(t.Coord);
  }
  AddBinaryDivisionSlotsToSegmentIntersections(t, e, i, s) {
    let n = 0, r = this.perpendicularSegmentVector.Length - 1;
    for (; r - n > 1; ) {
      const a = n + Math.floor((r - n) / 2);
      if (i <= a) {
        r = a, i < r && r <= s && this.AddSlotToSegmentIntersections(t, r);
        continue;
      }
      n = a, i > n && n >= e && this.AddSlotToSegmentIntersections(t, n);
    }
  }
  // Create the ScanSegmentTrees that functions as indexes for port-visibility splicing.
  CreateScanSegmentTrees() {
    Se.CreateScanSegmentTree(this.horizontalScanSegmentVector, this.HorizontalScanSegments), Se.CreateScanSegmentTree(this.verticalScanSegmentVector, this.VerticalScanSegments);
  }
  static CreateScanSegmentTree(t, e) {
    for (const i of t.Items())
      for (let s = i.FirstSegment; s != null; s = s.NextSegment)
        s.HasVisibility() && e.InsertUnique(s);
  }
}
class me {
  get ObstacleTree() {
    return this.GraphGenerator.ObstacleTree;
  }
  get VisGraph() {
    return this.GraphGenerator.VisibilityGraph;
  }
  get IsSparseVg() {
    return this.GraphGenerator instanceof Se;
  }
  constructor(t) {
    this.AddedVertices = new Array(), this.AddedEdges = new Array(), this.edgesToRestore = new Array(), this.LimitPortVisibilitySpliceToEndpointBoundingBox = !1, this.GraphGenerator = t;
  }
  AddVertex(t) {
    const e = this.VisGraph.AddVertexP(t);
    return this.AddedVertices.push(e), e;
  }
  FindOrAddVertex(t) {
    const e = this.VisGraph.FindVertex(t);
    return e ?? this.AddVertex(t);
  }
  FindOrAddEdgeVV(t, e) {
    return this.FindOrAddEdge(t, e, W.NormalWeight);
  }
  FindOrAddEdge(t, e, i) {
    const s = b.GetPureDirectionVV(t, e), n = {
      bracketSource: void 0,
      bracketTarget: void 0,
      splitVertex: void 0
    };
    me.GetBrackets(t, e, s, n);
    let r = this.VisGraph.FindEdgePP(n.bracketSource.point, n.bracketTarget.point);
    return r = r != null ? this.SplitEdge(r, n.splitVertex) : this.CreateEdge(n.bracketSource, n.bracketTarget, i), r;
  }
  static GetBrackets(t, e, i, s) {
    if (s.splitVertex = e, !me.FindBracketingVertices(t, e.point, i, s)) {
      const n = {
        bracketSource: null,
        bracketTarget: null
      };
      me.FindBracketingVertices(e, t.point, w.OppositeDir(i), n) && (s.bracketSource = n.bracketTarget, s.splitVertex = t), s.bracketTarget = n.bracketSource;
    }
  }
  static FindBracketingVertices(t, e, i, s) {
    for (s.bracketSource = t; s.bracketTarget = O.FindAdjacentVertex(s.bracketSource, i), s.bracketTarget != null; ) {
      if (u.closeDistEps(s.bracketTarget.point, e))
        return !0;
      if (i !== b.GetDirections(s.bracketTarget.point, e))
        break;
      s.bracketSource = s.bracketTarget;
    }
    return s.bracketTarget != null;
  }
  // DEVTRACE
  // ReSharper restore InconsistentNaming
  CreateEdge(t, e, i) {
    let s = t, n = e;
    b.IsPureLower(s.point, n.point) || (s = e, n = t);
    const r = new pi(s, n, i);
    return Et.AddEdge(r), this.AddedEdges.push(r), r;
  }
  RemoveFromGraph() {
    this.RemoveAddedVertices(), this.RemoveAddedEdges(), this.RestoreRemovedEdges();
  }
  RemoveAddedVertices() {
    for (const t of this.AddedVertices)
      this.VisGraph.FindVertex(t.point) != null && this.VisGraph.RemoveVertex(t);
    this.AddedVertices = [];
  }
  RemoveAddedEdges() {
    for (const t of this.AddedEdges)
      this.VisGraph.FindVertex(t.SourcePoint) != null && Et.RemoveEdge(t);
    this.AddedEdges = [];
  }
  RestoreRemovedEdges() {
    for (const t of this.edgesToRestore)
      Et.AddEdge(t);
    this.edgesToRestore = [];
  }
  FindNextEdge(t, e) {
    return O.FindAdjacentEdge(t, e);
  }
  FindPerpendicularOrContainingEdge(t, e, i) {
    for (; ; ) {
      const s = O.FindAdjacentVertex(t, e);
      if (s == null)
        break;
      const n = b.GetDirections(s.point, i);
      if ((w.OppositeDir(e) & n) !== 0)
        return this.VisGraph.FindEdgePP(t.point, s.point);
      t = s;
    }
    return null;
  }
  FindNearestPerpendicularOrContainingEdge(t, e, i) {
    let s;
    e & b.GetDirections(t.point, i);
    let n = t;
    const r = s;
    for (; S.None !== r; ) {
      const l = O.FindAdjacentVertex(n, s);
      if (l == null || (w.OppositeDir(s) & b.GetDirections(l.point, i)) !== 0)
        break;
      n = l, e & b.GetDirections(n.point, i);
    }
    let a;
    for (; a = this.FindPerpendicularOrContainingEdge(n, e, i), !(a != null || n === t); )
      n = O.FindAdjacentVertex(n, w.OppositeDir(s));
    return a;
  }
  ConnectVertexToTargetVertex(t, e, i, s) {
    if (u.closeDistEps(t.point, e.point))
      return;
    const n = b.GetDirections(t.point, e.point);
    if (b.IsPureDirectionD(n)) {
      this.FindOrAddEdgeVV(t, e);
      return;
    }
    const r = O.FindBendPointBetween(t.point, e.point, i), a = this.FindOrAddVertex(r);
    this.FindOrAddEdge(t, a, s), this.FindOrAddEdge(a, e, s);
  }
  AddEdgeToTargetEdge(t, e, i) {
    let s = this.VisGraph.FindVertex(i);
    return s == null && (s = this.AddVertex(i), this.SplitEdge(e, s)), this.FindOrAddEdgeVV(t, s), s;
  }
  SplitEdge(t, e) {
    return t == null ? null : u.closeDistEps(t.Source.point, e.point) || u.closeDistEps(t.Target.point, e.point) ? t : (t instanceof pi || this.edgesToRestore.push(t), Et.RemoveEdge(t), (this.IsSparseVg || t.Weight === W.OverlappedWeight) && e.Degree > 0 ? (this.FindOrAddEdge(e, t.Source, t.Weight), this.FindOrAddEdge(e, t.Target, t.Weight)) : (this.CreateEdge(e, t.Target, t.Weight), this.CreateEdge(t.Source, e, t.Weight)));
  }
  ExtendEdgeChainVRLPB(t, e, i, s, n) {
    const r = b.GetDirections(i.start, i.end);
    if (r === S.None)
      return;
    const a = O.GetRectangleBound(e, r), l = O.IsVerticalD(r) ? u.RoundPoint(new u(t.point.x, a)) : u.RoundPoint(new u(a, t.point.y));
    if (u.closeDistEps(l, t.point) || b.GetDirections(t.point, l) !== r)
      return;
    let h = i;
    b.GetDirections(l, h.end) === r && (h = v.mkPP(h.start, l)), this.ExtendEdgeChain(t, r, h, i, s, n);
  }
  ExtendEdgeChain(t, e, i, s, n, r) {
    if (b.GetDirections(t.point, i.end) !== e)
      return;
    let l = w.RotateLeft(e), h = O.FindAdjacentVertex(t, l);
    if (h == null && (l = w.OppositeDir(l), h = O.FindAdjacentVertex(t, l), h == null))
      return;
    const c = w.OppositeDir(l), d = { spliceTarget: null };
    this.ExtendSpliceWorker(h, e, c, i, s, r, d) && this.ExtendSpliceWorker(d.spliceTarget, e, l, i, s, r, d), this.SpliceGroupBoundaryCrossings(n, t, i);
  }
  SpliceGroupBoundaryCrossings(t, e, i) {
    if (t == null || t.Count() === 0)
      return;
    t.Reset();
    let s = i.start, n = i.end, r = b.GetDirections(s, n);
    O.IsAscending(r) || (s = i.end, n = i.start, r = w.OppositeDir(r)), e = me.TraverseToFirstVertexAtOrAbove(e, s, w.OppositeDir(r));
    for (let a = e; a != null; a = O.FindAdjacentVertex(a, r)) {
      const l = b.ComparePP(a.point, n) >= 0;
      for (; t.CurrentIsBeforeOrAt(a.point); ) {
        const h = t.Pop();
        b.ComparePP(h.Location, e.point) > 0 && b.ComparePP(h.Location, n) <= 0 && this.SpliceGroupBoundaryCrossing(a, h, w.OppositeDir(r)), b.ComparePP(h.Location, e.point) >= 0 && b.ComparePP(h.Location, n) < 0 && this.SpliceGroupBoundaryCrossing(a, h, r);
      }
      if (l)
        break;
    }
  }
  static TraverseToFirstVertexAtOrAbove(t, e, i) {
    let s = t;
    const n = w.OppositeDir(i);
    for (; ; ) {
      const r = O.FindAdjacentVertex(s, i);
      if (r == null || b.GetDirections(r.point, e) === n)
        break;
      s = r;
    }
    return s;
  }
  SpliceGroupBoundaryCrossing(t, e, i) {
    var s, n;
    const r = yn.ToCrossingArray(e.Crossings, i);
    if (r != null) {
      const a = (s = this.VisGraph.FindVertex(e.Location)) !== null && s !== void 0 ? s : this.AddVertex(e.Location);
      t.point.equal(a.point) || this.FindOrAddEdgeVV(t, a);
      const l = r[0].GetInteriorVertexPoint(e.Location), h = (n = this.VisGraph.FindVertex(l)) !== null && n !== void 0 ? n : this.AddVertex(l), c = this.FindOrAddEdgeVV(a, h), d = r.map((f) => f.Group.InputShape);
      c.IsPassable = () => d.some((f) => f.IsTransparent);
    }
  }
  // The return value is whether we should try a second pass if this is called on the first pass,
  // using spliceTarget to wrap up dead-ends on the target side.
  ExtendSpliceWorker(t, e, i, s, n, r, a) {
    let l = O.FindAdjacentVertex(t, i);
    a.spliceTarget = O.FindAdjacentVertex(l, i);
    const h = { spliceSource: t };
    for (; me.GetNextSpliceSource(h, i, e); ) {
      const c = O.FindBendPointBetween(l.point, h.spliceSource.point, w.OppositeDir(i));
      if (me.IsPointPastSegmentEnd(n, c))
        break;
      if (a.spliceTarget = me.GetSpliceTarget(h, i, c), a.spliceTarget == null) {
        if (this.IsSkippableSpliceSourceWithNullSpliceTarget(h.spliceSource, e))
          continue;
        if (this.ObstacleTree.SegmentCrossesAnObstacle(h.spliceSource.point, c))
          return !1;
      }
      let d = this.VisGraph.FindVertex(c);
      if (d != null) {
        if (a.spliceTarget == null || this.VisGraph.FindEdgePP(l.point, c) != null)
          return a.spliceTarget == null && this.FindOrAddEdge(l, d, r ? W.OverlappedWeight : W.NormalWeight), !1;
      } else
        d = this.AddVertex(c);
      if (this.FindOrAddEdge(l, d, r ? W.OverlappedWeight : W.NormalWeight), this.FindOrAddEdge(h.spliceSource, d, r ? W.OverlappedWeight : W.NormalWeight), r && (r = this.SeeIfSpliceIsStillOverlapped(e, d)), l = d, (e & b.GetDirections(c, s.end)) === 0) {
        a.spliceTarget = null;
        break;
      }
    }
    return a.spliceTarget != null;
  }
  static GetNextSpliceSource(t, e, i) {
    let s = O.FindAdjacentVertex(t.spliceSource, i);
    if (s == null)
      for (s = t.spliceSource; ; ) {
        if (s = O.FindAdjacentVertex(s, w.OppositeDir(e)), s == null)
          return !1;
        const n = O.FindAdjacentVertex(s, i);
        if (n != null) {
          s = n;
          break;
        }
      }
    return t.spliceSource = s, !0;
  }
  static GetSpliceTarget(t, e, i) {
    const s = b.GetDirections(t.spliceSource.point, i);
    let n = s, r = t.spliceSource;
    for (; n === s && (t.spliceSource = r, r = O.FindAdjacentVertex(t.spliceSource, e), r != null); ) {
      if (u.closeDistEps(r.point, i)) {
        r = O.FindAdjacentVertex(r, e);
        break;
      }
      n = b.GetDirections(r.point, i);
    }
    return r;
  }
  SeeIfSpliceIsStillOverlapped(t, e) {
    let i = this.FindNextEdge(e, w.RotateLeft(t)), s = i == null ? !1 : W.NormalWeight === i.Weight;
    return s || (i = this.FindNextEdge(e, w.RotateRight(t)), s = i == null ? !1 : W.NormalWeight === i.Weight), !s || this.ObstacleTree.PointIsInsideAnObstaclePD(e.point, t);
  }
  IsSkippableSpliceSourceWithNullSpliceTarget(t, e) {
    if (me.IsSkippableSpliceSourceEdgeWithNullTarget(O.FindAdjacentEdge(t, e)))
      return !0;
    const i = O.FindAdjacentEdge(t, w.OppositeDir(e));
    return me.IsSkippableSpliceSourceEdgeWithNullTarget(i) || me.IsReflectionEdge(i);
  }
  static IsSkippableSpliceSourceEdgeWithNullTarget(t) {
    return t != null && t.IsPassable != null && D(t.Length, Pa.BoundaryWidth);
  }
  static IsReflectionEdge(t) {
    return t != null && t.Weight === W.ReflectionWeight;
  }
  static IsPointPastSegmentEnd(t, e) {
    return b.GetDirections(t.start, t.end) === b.GetDirections(t.end, e);
  }
  toString() {
    return Bt.String.format("{0} {1}", this.AddedVertices.length, this.edgesToRestore.length);
  }
}
class Cn {
  // Extension of port visibility splices into the visibility graph.
  get LimitPortVisibilitySpliceToEndpointBoundingBox() {
    return this.TransUtil.LimitPortVisibilitySpliceToEndpointBoundingBox;
  }
  set LimitPortVisibilitySpliceToEndpointBoundingBox(t) {
    this.TransUtil.LimitPortVisibilitySpliceToEndpointBoundingBox = t;
  }
  // Typing shortcuts
  get VisGraph() {
    return this.graphGenerator.VisibilityGraph;
  }
  get HScanSegments() {
    return this.graphGenerator.HorizontalScanSegments;
  }
  get VScanSegments() {
    return this.graphGenerator.VerticalScanSegments;
  }
  get ObstacleTree() {
    return this.graphGenerator.ObstacleTree;
  }
  get AncestorSets() {
    return this.ObstacleTree.AncestorSets;
  }
  constructor(t) {
    this.obstaclePortMap = /* @__PURE__ */ new Map(), this.freePointMap = new ii(), this.freePointLocationsUsedByRouteEdges = new xt(), this.RouteToCenterOfObstacles = !1, this.obstaclePortsInGraph = new Array(), this.freePointsInGraph = /* @__PURE__ */ new Set(), this.activeAncestors = new Array(), this.TransUtil = new me(t), this.graphGenerator = t;
  }
  Clear() {
    this.TransUtil.RemoveFromGraph(), this.obstaclePortMap.clear();
  }
  CreateObstaclePorts(t) {
    for (const e of t.Ports)
      this.CreateObstaclePort(t, e);
  }
  CreateObstaclePort(t, e) {
    if (e.Curve == null)
      return null;
    const i = u.RoundPoint(e.Location);
    if (F.Outside === g.PointRelativeToCurveLocation(i, t.InputShape.BoundaryCurve) || t.InputShape.BoundaryCurve !== e.Curve && F.Outside === g.PointRelativeToCurveLocation(i, e.Curve))
      return null;
    const s = new yf(e, t);
    return this.obstaclePortMap.set(e, s), s;
  }
  FindVertices(t) {
    const e = new Array(), i = this.obstaclePortMap.get(t);
    if (i)
      if (this.RouteToCenterOfObstacles)
        e.push(i.CenterVertex);
      else
        for (const s of i.PortEntrances) {
          const n = this.VisGraph.FindVertex(s.UnpaddedBorderIntersect);
          n != null && e.push(n);
        }
    else
      e.push(this.VisGraph.FindVertex(u.RoundPoint(t.Location)));
    return e;
  }
  RemoveObstaclePorts(t) {
    for (const e of t.Ports)
      this.RemoveObstaclePort(e);
  }
  RemoveObstaclePort(t) {
    this.obstaclePortMap.delete(t);
  }
  // Add path control points - source, target, and any waypoints.
  AddControlPointsToGraph(t, e) {
    this.GetPortSpliceLimitRectangle(t), this.activeAncestors = [];
    const i = { oport: null }, s = { oport: null }, n = this.FindAncestorsAndObstaclePort(t.sourcePort, i), r = this.FindAncestorsAndObstaclePort(t.targetPort, s);
    if (this.AncestorSets.size > 0 && i.oport != null && s.oport != null) {
      const a = Hs(r, n), l = Hs(n, r);
      this.ActivateAncestors(l, a, e);
    }
    this.AddPortToGraph(t.sourcePort, i.oport), this.AddPortToGraph(t.targetPort, s.oport);
  }
  ConnectOobWaypointToEndpointVisibilityAtGraphBoundary(t, e) {
    if (t == null || !t.IsOutOfBounds)
      return;
    const i = this.FindVertices(e);
    let s = t.OutOfBoundsDirectionFromGraph & (S.North | S.South);
    this.ConnectToGraphAtPointsCollinearWithVertices(t, s, i), s = t.OutOfBoundsDirectionFromGraph & (S.East | S.West), this.ConnectToGraphAtPointsCollinearWithVertices(t, s, i);
  }
  ConnectToGraphAtPointsCollinearWithVertices(t, e, i) {
    if (S.None === e)
      return;
    const s = w.OppositeDir(e);
    for (const n of i) {
      const r = this.InBoundsGraphBoxIntersect(n.point, e), a = this.VisGraph.FindVertex(r);
      a != null && this.TransUtil.ConnectVertexToTargetVertex(t.Vertex, a, s, W.NormalWeight);
    }
  }
  SetAllAncestorsActive(t, e) {
    if (this.AncestorSets.size === 0)
      return !1;
    this.ObstacleTree.AdjustSpatialAncestors(), this.ClearActiveAncestors();
    const i = { oport: null }, s = { oport: null }, n = this.FindAncestorsAndObstaclePort(t.sourcePort, s), r = this.FindAncestorsAndObstaclePort(t.targetPort, i);
    return this.AncestorSets.size > 0 && n != null && r != null ? (this.ActivateAncestors(n, r, e), !0) : !1;
  }
  SetAllGroupsActive() {
    this.ClearActiveAncestors();
    for (const t of this.ObstacleTree.GetAllGroups())
      t.IsTransparentAncestor = !0, this.activeAncestors.push(t);
  }
  FindAncestorsAndObstaclePort(t, e) {
    return e.oport = this.FindObstaclePort(t), this.AncestorSets.size === 0 ? null : e.oport != null ? this.AncestorSets.get(e.oport.Obstacle.InputShape) : new Set(Array.from(this.ObstacleTree.Root.AllHitItems(T.mkPP(t.Location, t.Location), (i) => i.IsGroup)).map((i) => i.InputShape));
  }
  ActivateAncestors(t, e, i) {
    for (const s of zs(t, e)) {
      const n = i.get(s);
      n.IsTransparentAncestor = !0, this.activeAncestors.push(n);
    }
  }
  ClearActiveAncestors() {
    for (const t of this.activeAncestors)
      t.IsTransparentAncestor = !1;
    this.activeAncestors = [];
  }
  RemoveControlPointsFromGraph() {
    this.ClearActiveAncestors(), this.RemoveObstaclePortsFromGraph(), this.RemoveFreePointsFromGraph(), this.TransUtil.RemoveFromGraph(), this.portSpliceLimitRectangle = T.mkEmpty();
  }
  RemoveObstaclePortsFromGraph() {
    for (const t of this.obstaclePortsInGraph)
      t.RemoveFromGraph();
    this.obstaclePortsInGraph = [];
  }
  RemoveFreePointsFromGraph() {
    for (const t of this.freePointsInGraph)
      t.RemoveFromGraph();
    this.freePointsInGraph.clear();
  }
  RemoveStaleFreePoints() {
    if (this.freePointMap.size > this.freePointLocationsUsedByRouteEdges.size) {
      const t = Array.from(this.freePointMap).filter((e) => !this.freePointLocationsUsedByRouteEdges.has(e[0]));
      for (const e of t)
        this.freePointMap.deleteP(e[0]);
    }
  }
  ClearVisibility() {
    this.freePointMap.clear();
    for (const t of this.obstaclePortMap.values())
      t.ClearVisibility();
  }
  BeginRouteEdges() {
    this.RemoveControlPointsFromGraph(), this.freePointLocationsUsedByRouteEdges.clear();
  }
  EndRouteEdges() {
    this.RemoveStaleFreePoints();
  }
  FindObstaclePort(t) {
    let e = this.obstaclePortMap.get(t);
    if (e) {
      const i = {
        removedPorts: null,
        addedPorts: null
      };
      if (e.Obstacle.GetPortChanges(i)) {
        for (const s of i.addedPorts)
          this.CreateObstaclePort(e.Obstacle, s);
        for (const s of i.removedPorts)
          this.RemoveObstaclePort(s);
        e = this.obstaclePortMap.get(t);
      }
    }
    return e;
  }
  AddPortToGraph(t, e) {
    if (e != null) {
      this.AddObstaclePortToGraph(e);
      return;
    }
    this.AddFreePointToGraph(t.Location);
  }
  AddObstaclePortToGraph(t) {
    if (!(t.LocationHasChanged && (this.RemoveObstaclePort(t.Port), t = this.CreateObstaclePort(t.Obstacle, t.Port), t == null))) {
      t.AddToGraph(this.TransUtil, this.RouteToCenterOfObstacles), this.obstaclePortsInGraph.push(t), this.CreateObstaclePortEntrancesIfNeeded(t);
      for (const e of t.PortEntrances)
        this.AddObstaclePortEntranceToGraph(e);
    }
  }
  CreateObstaclePortEntrancesIfNeeded(t) {
    t.PortEntrances.length > 0 || this.CreateObstaclePortEntrancesFromPoints(t);
  }
  GetPortVisibilityIntersection(t) {
    const e = this.FindObstaclePort(t.sourcePort), i = this.FindObstaclePort(t.targetPort);
    if (e == null || i == null || e.Obstacle.IsInConvexHull || i.Obstacle.IsInConvexHull || (this.CreateObstaclePortEntrancesIfNeeded(e), this.CreateObstaclePortEntrancesIfNeeded(i), !e.VisibilityRectangle.intersects(i.VisibilityRectangle)))
      return null;
    for (const s of e.PortEntrances)
      if (s.WantVisibilityIntersection)
        for (const n of i.PortEntrances) {
          if (!n.WantVisibilityIntersection)
            continue;
          const r = s.IsVertical === n.IsVertical ? Cn.GetPathPointsFromOverlappingCollinearVisibility(s, n) : Cn.GetPathPointsFromIntersectingVisibility(s, n);
          if (r != null)
            return r;
        }
    return null;
  }
  static GetPathPointsFromOverlappingCollinearVisibility(t, e) {
    return !O.IntervalsAreSame(t.MaxVisibilitySegment.start, t.MaxVisibilitySegment.end, e.MaxVisibilitySegment.end, e.MaxVisibilitySegment.start) || t.HasGroupCrossings || e.HasGroupCrossings || u.closeDistEps(t.UnpaddedBorderIntersect, e.UnpaddedBorderIntersect) ? null : [t.UnpaddedBorderIntersect, e.UnpaddedBorderIntersect];
  }
  static GetPathPointsFromIntersectingVisibility(t, e) {
    const i = O.SegmentsIntersectLL(t.MaxVisibilitySegment, e.MaxVisibilitySegment);
    return !i || t.HasGroupCrossingBeforePoint(i) || e.HasGroupCrossingBeforePoint(i) ? null : [t.UnpaddedBorderIntersect, i, e.UnpaddedBorderIntersect];
  }
  CreateObstaclePortEntrancesFromPoints(t) {
    const e = this.graphGenerator.ObstacleTree.GraphBox, i = T.mkPP(u.RoundPoint(t.PortCurve.boundingBox.leftBottom), u.RoundPoint(t.PortCurve.boundingBox.rightTop)), s = u.RoundPoint(t.PortLocation);
    let n = !1;
    const r = { xx0: null, xx1: null };
    if (!b.Equal(s.y, i.top) && !b.Equal(s.y, i.bottom)) {
      n = !0;
      const a = new v(e.left, s.y, e.right, s.y);
      this.GetBorderIntersections(s, a, t.PortCurve, r);
      let l = new u(Math.min(r.xx0.x, r.xx1.x), s.y);
      l.x < i.left && (l = new u(i.left, l.y));
      let h = new u(Math.max(r.xx0.x, r.xx1.x), s.y);
      h.x > i.right && (h = new u(i.right, h.y)), this.CreatePortEntrancesAtBorderIntersections(i, t, s, l, h);
    }
    if (!b.Equal(s.x, i.left) && !b.Equal(s.x, i.right)) {
      n = !0;
      const a = new v(s.x, e.bottom, s.x, e.top);
      this.GetBorderIntersections(s, a, t.PortCurve, r);
      let l = new u(s.x, Math.min(r.xx0.y, r.xx1.y));
      l.y < e.bottom && (l = new u(l.x, e.bottom));
      let h = new u(s.x, Math.max(r.xx0.y, r.xx1.y));
      h.y > e.top && (h = new u(h.x, e.top)), this.CreatePortEntrancesAtBorderIntersections(i, t, s, l, h);
    }
    n || this.CreateEntrancesForCornerPort(i, t, s);
  }
  GetBorderIntersections(t, e, i, s) {
    const n = g.getAllIntersections(e, i, !0);
    s.xx0 = u.RoundPoint(n[0].x), s.xx1 = u.RoundPoint(n[1].x);
  }
  CreatePortEntrancesAtBorderIntersections(t, e, i, s, n) {
    const r = b.GetDirections(s, n);
    b.EqualPP(s, i) || this.CreatePortEntrance(t, e, n, r), b.EqualPP(n, i) || this.CreatePortEntrance(t, e, s, w.OppositeDir(r));
  }
  static GetDerivative(t, e) {
    const i = t.PortCurve.closestParameter(e);
    let s = t.PortCurve.derivative(i);
    const n = (t.PortCurve.parStart + t.PortCurve.parEnd) / 2;
    return M.CurveIsClockwise(t.PortCurve, t.PortCurve.value(n)) || (s = s.mul(-1)), s;
  }
  CreatePortEntrance(t, e, i, s) {
    e.CreatePortEntrance(i, s, this.ObstacleTree);
    const n = Pt.GetInstance(s);
    let r = O.GetRectangleBound(t, s) - n.Coord(i);
    if (r < 0 && (r = -r), r > m.intersectionEpsilon) {
      const a = w.VectorDirection(Cn.GetDerivative(e, i));
      let l;
      s | w.OppositeDir(s), S.None !== (s & a) && (l = w.OppositeDir(l)), e.CreatePortEntrance(i, l, this.ObstacleTree);
    }
  }
  CreateEntrancesForCornerPort(t, e, i) {
    let s = S.North;
    b.EqualPP(i, t.leftBottom) ? s = S.South : b.EqualPP(i, t.leftTop) ? s = S.West : b.EqualPP(i, t.rightTop) ? s = S.North : b.EqualPP(i, t.rightBottom) && (s = S.East), e.CreatePortEntrance(i, s, this.ObstacleTree), e.CreatePortEntrance(i, w.RotateRight(s), this.ObstacleTree);
  }
  AddObstaclePortEntranceToGraph(t) {
    const e = this.VisGraph.FindVertex(t.VisibilityBorderIntersect);
    if (e) {
      t.ExtendEdgeChain(this.TransUtil, e, e, this.portSpliceLimitRectangle, this.RouteToCenterOfObstacles);
      return;
    }
    const i = { targetVertex: null }, s = t.IsOverlapped ? W.OverlappedWeight : W.NormalWeight;
    this.FindorCreateNearestPerpEdgePPDNT(t.MaxVisibilitySegment.end, t.VisibilityBorderIntersect, t.OutwardDirection, s, i) != null && t.AddToAdjacentVertex(this.TransUtil, i.targetVertex, this.portSpliceLimitRectangle, this.RouteToCenterOfObstacles);
  }
  InBoundsGraphBoxIntersect(t, e) {
    return O.RectangleBorderIntersect(this.graphGenerator.ObstacleTree.GraphBox, t, e);
  }
  FindorCreateNearestPerpEdgePPDN(t, e, i, s) {
    const n = { targetVertex: null };
    return this.FindorCreateNearestPerpEdgePPDNT(t, e, i, s, n);
  }
  FindorCreateNearestPerpEdgePPDNT(t, e, i, s, n) {
    const r = O.SortAscending(t, e), a = r[0], l = r[1], h = O.IsVerticalD(i) ? this.HScanSegments : this.VScanSegments, c = O.IsAscending(i) ? h.FindLowestIntersector(a, l) : h.FindHighestIntersector(a, l);
    if (c == null)
      return n.targetVertex = null, null;
    const d = O.SegmentIntersectionSP(c, a);
    return this.FindOrCreateNearestPerpEdgeFromNearestPerpSegment(O.IsAscending(i) ? a : l, c, d, s, n);
  }
  FindOrCreateNearestPerpEdgeFromNearestPerpSegment(t, e, i, s, n) {
    var r;
    const a = {
      segsegVertex: this.VisGraph.FindVertex(i),
      targetVertex: null
    };
    if (a.segsegVertex == null) {
      const d = this.FindOrCreateSegmentIntersectionVertexAndAssociatedEdge(t, i, e, s, a);
      if (d != null)
        return d;
    } else if (b.EqualPP(t, i))
      return n.targetVertex = a.segsegVertex, this.TransUtil.FindNextEdge(n.targetVertex, w.OppositeDir(e.ScanDirection.Dir));
    const l = b.GetDirections(i, t);
    let h = b.GetDirections(a.segsegVertex.point, t);
    if (l === h) {
      const d = { bracketTarget: null, bracketSource: null };
      return me.FindBracketingVertices(a.segsegVertex, t, l, d), (r = this.TransUtil.FindNextEdge(d.bracketSource, w.RotateLeft(l))) !== null && r !== void 0 ? r : this.TransUtil.FindNextEdge(d.bracketSource, w.RotateRight(l));
    }
    h &= ~l;
    const c = this.TransUtil.FindNearestPerpendicularOrContainingEdge(a.segsegVertex, h, t);
    return c == null ? (n.targetVertex = this.TransUtil.AddVertex(i), this.TransUtil.FindOrAddEdge(n.targetVertex, e.HighestVisibilityVertex, e.Weight)) : (a.segsegVertex = O.GetEdgeEnd(c, w.OppositeDir(h)), i = O.SegmentIntersectionPPP(t, i, a.segsegVertex.point), b.EqualPP(a.segsegVertex.point, i) ? (n.targetVertex = a.segsegVertex, this.TransUtil.FindNextEdge(a.segsegVertex, h)) : (n.targetVertex = this.TransUtil.FindOrAddVertex(i), this.TransUtil.FindOrAddEdge(a.segsegVertex, n.targetVertex, s)));
  }
  FindOrCreateSegmentIntersectionVertexAndAssociatedEdge(t, e, i, s, n) {
    const a = (i.IsVertical ? this.HScanSegments : this.VScanSegments).FindHighestIntersector(i.Start, e);
    if (a == null)
      return n.segsegVertex = null, n.targetVertex = this.TransUtil.AddVertex(e), this.TransUtil.FindOrAddEdge(n.targetVertex, i.LowestVisibilityVertex, i.Weight);
    const l = O.SegmentsIntersection(i, a);
    if (n.segsegVertex = this.VisGraph.FindVertex(l), !n.segsegVertex) {
      n.segsegVertex = this.TransUtil.AddVertex(l);
      const h = this.AddEdgeToClosestSegmentEnd(i, n.segsegVertex, i.Weight);
      if (this.AddEdgeToClosestSegmentEnd(a, n.segsegVertex, a.Weight), b.EqualPP(n.segsegVertex.point, e))
        return n.targetVertex = n.segsegVertex, h;
    }
    return b.EqualPP(t, e) ? (n.targetVertex = this.TransUtil.FindOrAddVertex(e), this.TransUtil.FindOrAddEdge(n.segsegVertex, n.targetVertex, s)) : (n.targetVertex = null, null);
  }
  AddEdgeToClosestSegmentEnd(t, e, i) {
    return b.IsPureLower(t.HighestVisibilityVertex.point, e.point) ? this.TransUtil.FindOrAddEdge(t.HighestVisibilityVertex, e, i) : b.IsPureLower(e.point, t.LowestVisibilityVertex.point) ? this.TransUtil.FindOrAddEdge(e, t.LowestVisibilityVertex, i) : this.TransUtil.FindOrAddEdgeVV(t.LowestVisibilityVertex, e);
  }
  GetPortSpliceLimitRectangle(t) {
    if (!this.LimitPortVisibilitySpliceToEndpointBoundingBox) {
      this.portSpliceLimitRectangle = this.graphGenerator.ObstacleTree.GraphBox;
      return;
    }
    this.portSpliceLimitRectangle = this.GetPortRectangle(t.sourcePort), this.portSpliceLimitRectangle.addRecSelf(this.GetPortRectangle(t.targetPort));
  }
  GetPortRectangle(t) {
    const e = this.obstaclePortMap.get(t);
    return e ? e.Obstacle.VisibilityBoundingBox.clone() : T.mkOnPoints([u.RoundPoint(t.Location)]);
  }
  AddToLimitRectangle(t) {
    this.graphGenerator.IsInBoundsP(t) && this.portSpliceLimitRectangle.add(t);
  }
  FindOrCreateFreePoint(t) {
    let e = this.freePointMap.get(t);
    return e ? e.GetVertex(this.TransUtil, t) : (e = new bf(this.TransUtil, t), this.freePointMap.set(t, e)), this.freePointsInGraph.add(e), this.freePointLocationsUsedByRouteEdges.add(t), e;
  }
  // This is private because it depends on LimitRectangle
  AddFreePointToGraph(t) {
    t = u.RoundPoint(t);
    const e = this.VisGraph.FindVertex(t), i = this.FindOrCreateFreePoint(t);
    if (e != null)
      return i;
    if (!this.graphGenerator.IsInBoundsP(t))
      return this.CreateOutOfBoundsFreePoint(i), i;
    i.IsOverlapped = this.ObstacleTree.PointIsInsideAnObstacle(i.Point, this.HScanSegments.ScanDirection), this.VScanSegments.FindSegmentContainingPoint(t, !0);
    let s = S.South;
    for (let n = 0; n < 4; n++)
      this.ConnectFreePointToLateralEdge(i, s), s = w.RotateLeft(s);
    return i;
  }
  CreateOutOfBoundsFreePoint(t) {
    const e = t.Point, i = this.graphGenerator.MakeInBoundsLocation(e), s = b.GetDirections(i, e);
    if (t.OutOfBoundsDirectionFromGraph = s, !b.IsPureDirectionD(s)) {
      t.AddOobEdgesFromGraphCorner(this.TransUtil, i);
      return;
    }
    let n = this.VisGraph.FindVertex(i);
    const r = w.OppositeDir(s);
    if (n != null)
      t.AddToAdjacentVertex(this.TransUtil, n, r, this.portSpliceLimitRectangle);
    else {
      const h = this.FindorCreateNearestPerpEdgePPDN(e, i, s, W.NormalWeight);
      h != null && (n = t.AddEdgeToAdjacentEdge(this.TransUtil, h, r, this.portSpliceLimitRectangle));
    }
    const a = O.FindAdjacentVertex(n, w.RotateLeft(r));
    a != null && this.TransUtil.ConnectVertexToTargetVertex(t.Vertex, a, r, W.NormalWeight);
    const l = O.FindAdjacentVertex(n, w.RotateRight(r));
    l != null && this.TransUtil.ConnectVertexToTargetVertex(t.Vertex, l, r, W.NormalWeight);
  }
  ConnectFreePointToLateralEdge(t, e) {
    const i = t.IsOverlapped ? this.InBoundsGraphBoxIntersect(t.Point, e) : t.MaxVisibilityInDirectionForNonOverlappedFreePoint(e, this.TransUtil), s = this.FindorCreateNearestPerpEdgePPDN(i, t.Point, e, t.InitialWeight);
    s != null && t.AddEdgeToAdjacentEdge(this.TransUtil, s, e, this.portSpliceLimitRectangle);
  }
}
class bt extends lt {
  // If true, route to obstacle centers.  Initially false for greater accuracy with the current
  // MultiSourceMultiTarget approach.
  get RouteToCenterOfObstacles() {
    return this.PortManager.RouteToCenterOfObstacles;
  }
  set RouteToCenterOfObstacles(t) {
    this.PortManager.RouteToCenterOfObstacles = t;
  }
  // If true, limits the extension of port visibility splices into the visibility graph to the rectangle defined by
  // the path endpoints.
  get LimitPortVisibilitySpliceToEndpointBoundingBox() {
    return this.PortManager.LimitPortVisibilitySpliceToEndpointBoundingBox;
  }
  set LimitPortVisibilitySpliceToEndpointBoundingBox(t) {
    this.PortManager.LimitPortVisibilitySpliceToEndpointBoundingBox = t;
  }
  // Add an GeomEdge to route
  AddEdgeGeometryToRoute(t) {
    u.closeDistEps(u.RoundPoint(t.sourcePort.Location), u.RoundPoint(t.targetPort.Location)) ? this.selfEdges.push(t) : this.EdgesToRoute.push(t);
  }
  // Array all edge routing specifications that are currently active.  We want to hide access to the
  // Array itself so people don't add or remove items directly.
  get EdgeGeometriesToRoute() {
    return this.EdgesToRoute;
  }
  // Remove all EdgeGeometries to route
  RemoveAllEdgeGeometriesToRoute() {
    this.EdgesToRoute = [];
  }
  // If true, this router uses a sparse visibility graph, which saves memory for large graphs but
  // may choose suboptimal paths.  Set on constructor.
  get UseSparseVisibilityGraph() {
    return this.GraphGenerator instanceof Se;
  }
  get Obstacles() {
    return Array.from(this.ShapeToObstacleMap.values()).map((t) => t.InputShape);
  }
  // The collection of padded obstacle boundary polylines around the input shapes to route around.
  get PaddedObstacles() {
    return Array.from(this.ShapeToObstacleMap.values()).map((t) => t.PaddedPolyline);
  }
  // Add obstacles to the router.
  AddObstacles(t) {
    this.AddShapes(t), this.RebuildTreeAndGraph();
  }
  AddShapes(t) {
    for (const e of t)
      this.AddObstacleWithoutRebuild(e);
  }
  // Add a single obstacle to the router.
  AddObstacle(t) {
    this.AddObstacleWithoutRebuild(t), this.RebuildTreeAndGraph();
  }
  // For each Shapes, update its position and reroute as necessary.
  UpdateObstacles(t) {
    for (const e of t)
      this.UpdateObstacleWithoutRebuild(e);
    this.RebuildTreeAndGraph();
  }
  // For each Shapes, update its position and reroute as necessary.
  UpdateObstacle(t) {
    this.UpdateObstacleWithoutRebuild(t), this.RebuildTreeAndGraph();
  }
  // Remove obstacles from the router.
  RemoveObstacles(t) {
    for (const e of t)
      this.RemoveObstacleWithoutRebuild(e);
    this.RebuildTreeAndGraph();
  }
  // Removes an obstacle from the router.
  // <returns>All EdgeGeometries affected by the re-routing and re-nudging in order to avoid the new obstacle.</returns>
  RemoveObstacle(t) {
    this.RemoveObstacleWithoutRebuild(t), this.RebuildTreeAndGraph();
  }
  // utilities
  AddObstacleWithoutRebuild(t) {
    if (t.BoundaryCurve == null)
      throw new Error("Shape must have a BoundaryCurve");
    this.CreatePaddedObstacle(t);
  }
  UpdateObstacleWithoutRebuild(t) {
    if (t.BoundaryCurve == null)
      throw new Error("Shape must have a BoundaryCurve");
    this.PortManager.RemoveObstaclePorts(this.ShapeToObstacleMap.get(t)), this.CreatePaddedObstacle(t);
  }
  CreatePaddedObstacle(t) {
    const e = new Ot(t, this.Padding);
    this.ShapeToObstacleMap.set(t, e), this.PortManager.CreateObstaclePorts(e);
  }
  RemoveObstacleWithoutRebuild(t) {
    const e = this.ShapeToObstacleMap.get(t);
    this.ShapeToObstacleMap.delete(t), this.PortManager.RemoveObstaclePorts(e);
  }
  // Remove all obstacles from the graph.
  RemoveAllObstacles() {
    this.InternalClear(
      /* retainObstacles:*/
      !1
    );
  }
  RebuildTreeAndGraph() {
    const t = this.ObsTree.Root != null, e = this.GraphGenerator.VisibilityGraph != null;
    this.InternalClear(
      /* retainObstacles:*/
      !0
    ), t && this.GenerateObstacleTree(), e && this.GenerateVisibilityGraph();
  }
  // The visibility graph generated by GenerateVisibilityGraph.
  get VisibilityGraph() {
    return this.GenerateVisibilityGraph(), this.GraphGenerator.VisibilityGraph;
  }
  // Clears all data set into the router.
  Clear() {
    this.InternalClear(
      /* retainObstacles:*/
      !1
    );
  }
  static constructorEmpty() {
    return bt.constructorC(null);
  }
  static constructorC(t) {
    return new bt([], bt.DefaultPadding, bt.DefaultCornerFitRadius);
  }
  // Constructor that takes the obstacles but uses defaults for other arguments.
  // as well as any intervening obstacles.</param>
  static constructorI(t) {
    return new bt(t, bt.DefaultPadding, bt.DefaultCornerFitRadius);
  }
  // Constructor for a router that does not use obstacle rectangles in the visibility graph.
  // as well as any intervening obstacles.</param>
  // The minimum padding from an obstacle's curve to its enclosing polyline.
  // The radius of the arc inscribed into path corners
  // but may select suboptimal paths</param>
  static constructorINN(t, e, i) {
    return new bt(t, e, i);
  }
  // Constructor specifying graph and shape information.
  // as well as any intervening obstacles.</param>
  // The minimum padding from an obstacle's curve to its enclosing polyline.
  // The radius of the arc inscribed into path corners
  // but may select suboptimal paths</param>
  // Use obstacle bounding boxes in visibility graph
  constructor(t, e, i) {
    super(null), this.Padding = 0, this.CornerFitRadius = 0, this.edgeSeparatian = 3, this.BendPenaltyAsAPercentageOfDistance = 0, this.ShapeToObstacleMap = /* @__PURE__ */ new Map(), this.EdgesToRoute = new Array(), this.removeStaircases = !0, this.selfEdges = new Array(), this.Padding = e, this.CornerFitRadius = i, this.BendPenaltyAsAPercentageOfDistance = K.DefaultBendPenaltyAsAPercentageOfDistance, this.GraphGenerator = new Se(), this.PortManager = new Cn(this.GraphGenerator), this.AddShapes(t);
  }
  // The graph whose edges are being routed.
  // The minimum padding from an obstacle's curve to its enclosing polyline.
  // The radius of the arc inscribed into path corners
  // but may select suboptimal paths</param>
  // If true, use obstacle bounding boxes in visibility graph
  static constructorGNAN(t, e, i, s) {
    const n = new bt(le.GetShapes(t), i, s);
    if (e == null)
      for (const r of t.deepEdges)
        n.AddEdgeGeometryToRoute(r);
    else
      for (const r of e)
        n.AddEdgeGeometryToRoute(r);
    return n;
  }
  // Executes the algorithm.
  // Calculates the routed edges geometry, optionally forcing re-routing for existing paths.
  run() {
    this.GenerateVisibilityGraph(), this.GeneratePaths();
  }
  GeneratePaths() {
    const t = this.EdgesToRoute.map((e) => new Pf(e));
    this.FillEdgePathsWithShortestPaths(t), this.NudgePaths(t), this.RouteSelfEdges(), this.FinaliseEdgeGeometries();
  }
  RouteSelfEdges() {
    for (const t of this.selfEdges) {
      const e = { smoothedPolyline: null };
      t.curve = Zt.RouteSelfEdge(t.sourcePort.Curve, Math.max(this.Padding, 2 * t.GetMaxArrowheadLength()), e);
    }
  }
  FillEdgePathsWithShortestPaths(t) {
    this.PortManager.BeginRouteEdges();
    const e = new bn(this.BendPenaltyAsAPercentageOfDistance);
    for (const i of t)
      this.AddControlPointsAndGeneratePath(e, i);
    this.PortManager.EndRouteEdges();
  }
  AddControlPointsAndGeneratePath(t, e) {
    const i = this.PortManager.GetPortVisibilityIntersection(e.GeomEdge);
    if (i != null) {
      this.GeneratePathThroughVisibilityIntersection(e, i);
      return;
    }
    this.SpliceVisibilityAndGeneratePath(t, e);
  }
  GeneratePathThroughVisibilityIntersection(t, e) {
    t.PathPoints = e;
  }
  SpliceVisibilityAndGeneratePath(t, e) {
    this.PortManager.AddControlPointsToGraph(e.GeomEdge, this.ShapeToObstacleMap), this.GeneratePath(t, e, !1) || this.RetryPathsWithAdditionalGroupsEnabled(t, e), this.PortManager.RemoveControlPointsFromGraph();
  }
  // ReSharper disable UnusedMember.Local
  GeneratePath(t, e, i) {
    const s = this.PortManager.FindVertices(e.GeomEdge.sourcePort), n = this.PortManager.FindVertices(e.GeomEdge.targetPort);
    return bt.GetSingleStagePath(e, t, s, n, i);
  }
  static GetSingleStagePath(t, e, i, s, n) {
    return t.PathPoints = e.GetPath(i, s), n && bt.EnsureNonNullPath(t), t.PathPoints != null && t.PathPoints.length > 0;
  }
  static EnsureNonNullPath(t) {
    t.PathPoints == null && (b.IsPureDirection(t.GeomEdge.sourcePort.Location, t.GeomEdge.targetPort.Location) ? t.PathPoints = [t.GeomEdge.sourcePort.Location, t.GeomEdge.targetPort.Location] : t.PathPoints = [
      t.GeomEdge.sourcePort.Location,
      new u(t.GeomEdge.sourcePort.Location.x, t.GeomEdge.targetPort.Location.y),
      t.GeomEdge.targetPort.Location
    ]);
  }
  RetryPathsWithAdditionalGroupsEnabled(t, e) {
    (!this.PortManager.SetAllAncestorsActive(e.GeomEdge, this.ShapeToObstacleMap) || !this.GeneratePath(t, e, !1)) && (this.PortManager.SetAllGroupsActive(), this.GeneratePath(t, e, !0));
  }
  // static ShowPointEnum(p: Iterable<Point>) {
  //    //  ReSharper disable InconsistentNaming
  //    const w0: number = 0.1;
  //    const w1: number = 3;
  //    let arr: Point[] = p.toArray();
  //    let d: number = ((w1 - w0)
  //                / (arr.length - 1));
  //    let l = new Array<DebugCurve>();
  //    for (let i: number = 0; (i
  //                < (arr.length - 1)); i++) {
  //        l.Add(new DebugCurve(100, (w0
  //                            + (i * d)), "blue", new LineSegment(arr[i], arr[(i + 1)])));
  //    }
  //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);
  //    //  ReSharper restore InconsistentNaming
  // }
  NudgePaths(t) {
    const e = this.ObsTree.SpatialAncestorsAdjusted ? it.GetAncestorSetsMap(this.Obstacles) : this.AncestorsSets;
    nt.NudgePaths(t, this.edgeSeparatian, this.PaddedObstacles, e, this.RemoveStaircases);
  }
  get RemoveStaircases() {
    return this.removeStaircases;
  }
  set RemoveStaircases(t) {
    this.removeStaircases = t;
  }
  FinaliseEdgeGeometries() {
    for (const t of this.EdgesToRoute.concat(this.selfEdges)) {
      if (t.curve == null)
        continue;
      t.curve instanceof B && (t.curve = bt.FitArcsIntoCorners(this.CornerFitRadius, Array.from(t.curve))), bt.CalculateArrowheads(t);
    }
  }
  CreateVisibilityGraph() {
    this.GraphGenerator.Clear(), this.InitObstacleTree(), this.GraphGenerator.GenerateVisibilityGraph();
  }
  // mkDC(): Array<DebugCurve> {
  //   const dc = new Array<DebugCurve>()
  //   dc.push(
  //     ...Array.from(this.VisibilityGraph.Edges).map((e) =>
  //       DebugCurve.mkDebugCurveTWCI(100, 1, 'Blue', LineSegment.mkPP(e.SourcePoint, e.TargetPoint)),
  //     ),
  //   )
  //   dc.push(...this.Obstacles.map((o) => DebugCurve.mkDebugCurveTWCI(100, 2, 'Red', o.BoundaryCurve)))
  //   return dc
  // }
  static CalculateArrowheads(t) {
    vt.trimSplineAndCalculateArrowheadsII(t, t.sourcePort.Curve, t.targetPort.Curve, t.curve, !0);
  }
  get ObsTree() {
    return this.GraphGenerator.ObstacleTree;
  }
  GenerateObstacleTree() {
    if (this.Obstacles == null || this.Obstacles.length === 0)
      throw new Error("No obstacles have been added");
    this.ObsTree.Root == null && this.InitObstacleTree();
  }
  InitObstacleTree() {
    this.AncestorsSets = it.GetAncestorSetsMap(this.Obstacles), this.ObsTree.Init(this.ShapeToObstacleMap.values(), this.AncestorsSets, this.ShapeToObstacleMap);
  }
  InternalClear(t) {
    this.GraphGenerator.Clear(), this.ClearShortestPaths(), t ? this.PortManager.ClearVisibility() : (this.PortManager.Clear(), this.ShapeToObstacleMap.clear(), this.EdgesToRoute = []);
  }
  ClearShortestPaths() {
    for (const t of this.EdgesToRoute)
      t.curve = null;
  }
  GenerateVisibilityGraph() {
    if (this.Obstacles == null || this.Obstacles.length === 0)
      throw new Error("No obstacles have been set");
    this.GraphGenerator.VisibilityGraph == null && this.CreateVisibilityGraph();
  }
  // ShowPathWithTakenEdgesAndGraph(path: Iterable<VisibilityVertex>, takenEdges: Set<VisibilityEdge>) {
  //    let list = new Array<VisibilityVertex>(path);
  //    let lines = new Array<LineSegment>();
  //    for (let i: number = 0; (i
  //                < (list.Count - 1)); i++) {
  //        lines.Add(new LineSegment(list[i].Point, list[(i + 1)].Point));
  //    }
  //    //  ReSharper disable InconsistentNaming
  //    let w0: number = 4;
  //    const let w1: number = 8;
  //    let delta: number = ((w1 - w0)
  //                / (list.Count - 1));
  //    let dc = new Array<DebugCurve>();
  //    for (let line: LineSegment of lines) {
  //        dc.Add(new DebugCurve(50, w0, "red", line));
  //        w0 = (w0 + delta);
  //    }
  //    dc.AddRange(takenEdges.Select(() => {  }, new DebugCurve(50, 2, "black", new LineSegment(edge.SourcePoint, edge.TargetPoint))));
  //    let k: Iterable<DebugCurve> = this.GetGraphDebugCurves();
  //    dc.AddRange(k);
  //    LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(dc);
  //    //  ReSharper restore InconsistentNaming
  // }
  static FitArcsIntoCorners(t, e) {
    if (t == 0)
      return B.mkFromPoints(e);
    const i = bt.GetFittedArcSegs(t, e), s = new g();
    let n = null;
    for (const r of i) {
      const a = bt.EllipseIsAlmostLineSegment(r);
      n != null ? a ? g.continueWithLineSegmentP(s, bt.CornerPoint(r)) : (g.continueWithLineSegmentP(s, r.start), s.addSegment(r)) : a ? g.addLineSegment(s, e[0], bt.CornerPoint(r)) : (g.addLineSegment(s, e[0], r.start), s.addSegment(r)), n = r;
    }
    return s.segs.length > 0 ? g.continueWithLineSegmentP(s, e[e.length - 1]) : g.addLineSegment(s, e[0], e[e.length - 1]), s;
  }
  static CornerPoint(t) {
    return t.center.add(t.aAxis.add(t.bAxis));
  }
  static EllipseIsAlmostLineSegment(t) {
    return t.aAxis.lengthSquared < 1e-4 || t.aAxis.lengthSquared < 1e-4;
  }
  static *GetFittedArcSegs(t, e) {
    let i = e[1].sub(e[0]), s = i.normalize(), n = Math.min(t, i.length / 2);
    for (let r = 1; r < e.length - 1; r++) {
      i = e[r + 1].sub(e[r]);
      const a = i.length;
      if (a < m.intersectionEpsilon) {
        yield new j(0, 0, new u(0, 0), new u(0, 0), e[r]);
        continue;
      }
      const l = i.div(a);
      Math.abs(l.dot(s)) > 0.9 && (yield new j(0, 0, new u(0, 0), new u(0, 0), e[r]));
      const h = Math.min(t, i.length / 2), c = l.mul(-h), d = s.mul(n);
      yield new j(0, Math.PI / 2, c, d, e[r].sub(d.add(c))), s = l, n = h;
    }
  }
}
bt.DefaultPadding = 1;
bt.DefaultCornerFitRadius = 3;
class ji {
  constructor(t, e, i, s = 1) {
    this.Source = t, this.Target = e, this.CrossingWeight = i, this.Weight = s;
  }
  toString() {
    return Bt.String.format("{0}->{1}", this.Source, this.Target);
  }
}
let Ef = class gn {
  static FindClosestPoints(t, e) {
    const i = g.minDistWithinIntervals(t, e, t.parStart, t.parEnd, e.parStart, e.parEnd, (t.parStart + t.parEnd) / 2, (e.parStart + e.parEnd) / 2);
    if (i)
      return {
        curveClosestPoint: i.aX,
        labelSideClosest: i.bX
      };
  }
  static GetSegmentInFrontOfLabel(t, e) {
    if (t instanceof g) {
      for (const i of t.segs)
        if ((i.start.y - e) * (i.end.y - e) <= 0)
          return i;
    }
    return null;
  }
  static ShiftLabel(t, e, i) {
    const s = t.lineWidth / 2, n = e.sub(i), r = n.length;
    r > s && t.label.positionCenter(t.label.center.add(n.div(r * (r - s))));
  }
  static updateLabel(t, e) {
    let i = null;
    e.labelIsToTheRightOfTheSpline ? (t.label.positionCenter(new u(e.x + e.rightAnchor / 2, e.y)), i = v.mkPP(t.label.boundingBox.leftTop, t.label.boundingBox.leftBottom)) : e.labelIsToTheLeftOfTheSpline && (t.label.positionCenter(new u(e.x - e.leftAnchor / 2, e.y)), i = v.mkPP(t.label.boundingBox.rightTop, t.label.boundingBox.rightBottom));
    const s = gn.GetSegmentInFrontOfLabel(t.curve, t.label.center.y);
    if (s != null && g.getAllIntersections(t.curve, g.polyFromBox(t.label.boundingBox), !1).length === 0) {
      const n = gn.FindClosestPoints(s, i);
      if (n)
        gn.ShiftLabel(t, n.curveClosestPoint, n.labelSideClosest);
      else {
        let r, a;
        const l = s.closestParameter(i.start), h = s.closestParameter(i.end);
        s.value(l).sub(i.start).length < s.value(h).sub(i.end).length ? (r = s.value(l), a = i.start) : (r = s.value(h), a = i.end), gn.ShiftLabel(t, r, a);
      }
    }
  }
};
class Ye {
  get CrossingWeight() {
    return 1;
  }
  constructor(t, e, i, s = 1, n = 1) {
    this.reversed = !1, this.source = t, this.target = e, this.edge = i, this.weight = s, this.separation = n;
  }
  get hasLabel() {
    return this.edge.label != null;
  }
  get labelWidth() {
    return this.edge.label.width;
  }
  get labelHeight() {
    return this.edge.label.height;
  }
  // This function changes the edge by swapping source and target.
  reverse() {
    const t = this.source;
    this.source = this.target, this.target = t, this.reversed = !this.reversed;
  }
  toString() {
    return "edge(" + this.source + "->" + this.target + ")";
  }
  get curve() {
    return this.edge.curve;
  }
  set curve(t) {
    this.edge.curve = t;
  }
  get underlyingPolyline() {
    return this.edge.smoothedPolyline;
  }
  get LayerSpan() {
    return this.LayerEdges != null ? this.LayerEdges.length : 0;
  }
  isSelfEdge() {
    return this.source === this.target;
  }
  reversedClone() {
    const t = new Ye(this.target, this.source, this.edge);
    if (this.LayerEdges != null) {
      const e = this.LayerEdges.length;
      t.LayerEdges = new Array(e);
      for (let i = 0; i < e; i++) {
        const s = this.LayerEdges[e - 1 - i];
        t.LayerEdges[i] = new ji(s.Target, s.Source, s.CrossingWeight);
      }
      t.LayerEdges[0].Source = this.target, t.LayerEdges[this.LayerEdges.length - 1].Target = this.source;
    }
    return t;
  }
  get count() {
    return this.LayerEdges.length;
  }
  getNode(t) {
    if (t >= 0) {
      if (t < this.LayerEdges.length)
        return this.LayerEdges[t].Source;
      if (t === this.LayerEdges.length)
        return this.LayerEdges[t - 1].Target;
    }
    throw new Error("wrong index " + t);
  }
  updateEdgeLabelPosition(t) {
    if (this.edge.label != null) {
      const e = this.LayerEdges.length / 2, i = this.LayerEdges[e];
      Ef.updateLabel(this.edge, t[i.Source]);
    }
  }
  [Symbol.iterator]() {
    return this.nodes();
  }
  // enumerates over virtual virtices corresponding to the original edge
  *nodes() {
    yield this.LayerEdges[0].Source;
    for (const t of this.LayerEdges)
      yield t.Target;
  }
}
class Af {
  constructor() {
    this.maxLayerOfGeomGraph = /* @__PURE__ */ new Set(), this.minLayerOfGeomGraph = /* @__PURE__ */ new Set(), this.sameLayerConstraints = new Array(), this.upDownConstraints = new Array(), this.gluedUpDownIntConstraints = new ti(), this.sameLayerDictionaryOfRepresentatives = /* @__PURE__ */ new Map(), this.representativeToItsLayer = /* @__PURE__ */ new Map(), this.maxLayerInt = new Array(), this.minLayerInt = new Array(), this.sameLayerInts = new Array(), this.upDownInts = new Array();
  }
  getFeedbackSetExternal(t, e) {
    throw new Error("Method not implemented.");
  }
  // pins a node to max layer
  pinNodeToMaxLayer(t) {
    this.maxLayerOfGeomGraph.add(t);
  }
  // pins a node to min layer
  pinNodeToMinLayer(t) {
    this.minLayerOfGeomGraph.add(t);
  }
  get isEmpty() {
    return this.maxLayerOfGeomGraph.size === 0 && this.minLayerOfGeomGraph.size === 0 && this.sameLayerConstraints.length === 0 && this.upDownConstraints.length === 0;
  }
  clear() {
    this.maxLayerOfGeomGraph.clear(), this.minLayerOfGeomGraph.clear(), this.sameLayerConstraints = [], this.upDownConstraints = [];
  }
  getFeedbackSetImp(t, e) {
    return this.nodeIdToIndex = e, this.intGraph = t, this.maxRepresentative = -1, this.minRepresentative = -1, this.createIntegerConstraints(), this.glueTogetherSameConstraintsMaxAndMin(), this.addMaxMinConstraintsToGluedConstraints(), this.removeCyclesFromGluedConstraints(), this.getFeedbackSet();
  }
  removeCyclesFromGluedConstraints() {
    const t = fi(Array.from(this.gluedUpDownIntConstraints.values()), this.intGraph.nodeCount), e = Zi.getFeedbackSetWithConstraints(t, null);
    for (const i of e)
      this.gluedUpDownIntConstraints.remove(i);
  }
  addMaxMinConstraintsToGluedConstraints() {
    if (this.maxRepresentative !== -1)
      for (let t = 0; t < this.intGraph.nodeCount; t++) {
        const e = this.nodeToRepr(t);
        e !== this.maxRepresentative && this.gluedUpDownIntConstraints.add(new U(this.maxRepresentative, e));
      }
    if (this.minRepresentative !== -1)
      for (let t = 0; t < this.intGraph.nodeCount; t++) {
        const e = this.nodeToRepr(t);
        e !== this.minRepresentative && this.gluedUpDownIntConstraints.add(new U(e, this.minRepresentative));
      }
  }
  glueTogetherSameConstraintsMaxAndMin() {
    this.createDictionaryOfSameLayerRepresentatives(), this.upDownInts.map(this.gluedIntPairNN), this.gluedUpDownIntConstraints = new ti();
  }
  gluedIntPairNN(t) {
    return new U(this.nodeToRepr(t[0]), this.nodeToRepr(t[1]));
  }
  gluedIntPairI(t) {
    return new U(this.nodeToRepr(t.source), this.nodeToRepr(t.target));
  }
  gluedIntPair(t) {
    return new U(this.nodeToRepr(t.source), this.nodeToRepr(t.target));
  }
  gluedIntEdge(t) {
    const e = this.nodeToRepr(t.source), i = this.nodeToRepr(t.target), s = new Ye(e, i, t.edge);
    return s.separation = t.separation, s.weight = 0, s;
  }
  nodeToRepr(t) {
    const e = this.sameLayerDictionaryOfRepresentatives.get(t);
    return e || t;
  }
  createDictionaryOfSameLayerRepresentatives() {
    const t = this.createGraphOfSameLayers();
    for (const e of Xs(t))
      this.glueSameLayerNodesOfALayer(e);
  }
  createGraphOfSameLayers() {
    return fi(this.createEdgesOfSameLayers(), this.intGraph.nodeCount);
  }
  createEdgesOfSameLayers() {
    const t = new Array();
    return this.maxRepresentative !== -1 && this.maxLayerInt.filter((e) => e !== this.maxRepresentative).map((e) => new U(this.maxRepresentative, e)).forEach((e) => t.push(e)), this.minRepresentative !== -1 && this.minLayerInt.filter((e) => e !== this.minRepresentative).map((e) => new U(this.minRepresentative, e)).forEach((e) => t.push(e)), this.sameLayerInts.forEach((e) => t.push(new U(e[0], e[1]))), t;
  }
  // maps all nodes of the component to one random representative
  glueSameLayerNodesOfALayer(t) {
    if (t.length > 1) {
      let e = -1;
      if (this.componentsIsMaxLayer(t))
        for (const i of t)
          this.sameLayerDictionaryOfRepresentatives.set(i, e = this.maxRepresentative);
      else if (this.componentIsMinLayer(t))
        for (const i of t)
          this.sameLayerDictionaryOfRepresentatives.set(i, e = this.minRepresentative);
      else
        for (const i of t)
          e === -1 && (e = i), this.sameLayerDictionaryOfRepresentatives.set(i, e);
      this.representativeToItsLayer.set(e, t);
    }
  }
  componentIsMinLayer(t) {
    return t.findIndex((e) => this.minRepresentative === e) >= 0;
  }
  componentsIsMaxLayer(t) {
    return t.findIndex((e) => this.maxRepresentative === e) >= 0;
  }
  createIntegerConstraints() {
    this.createMaxIntConstraints(), this.createMinIntConstraints(), this.createUpDownConstraints(), this.createSameLayerConstraints();
  }
  createSameLayerConstraints() {
    this.sameLayerInts = this.createIntConstraintsFromStringCouples(this.sameLayerConstraints);
  }
  createUpDownConstraints() {
    this.upDownInts = this.createIntConstraintsFromStringCouples(this.upDownConstraints);
  }
  createIntConstraintsFromStringCouples(t) {
    return t.map((e) => [this.nodeIndex(e[0]), this.nodeIndex(e[1])]).filter((e) => e[0] !== -1 && e[1] !== -1);
  }
  createMinIntConstraints() {
    this.minLayerInt = this.createIntConstraintsFromExtremeLayer(this.minLayerOfGeomGraph), this.minLayerInt.length > 0 && (this.minRepresentative = this.minLayerInt[0]);
  }
  createMaxIntConstraints() {
    this.maxLayerInt = this.createIntConstraintsFromExtremeLayer(this.maxLayerOfGeomGraph), this.maxLayerInt.length > 0 && (this.maxRepresentative = this.maxLayerInt[0]);
  }
  createIntConstraintsFromExtremeLayer(t) {
    return Array.from(t).map((e) => this.nodeIndex(e)).filter((e) => e !== -1);
  }
  nodeIndex(t) {
    const e = this.nodeIdToIndex.get(t.node.id);
    return e || -1;
  }
  getFeedbackSet() {
    return this.gluedIntGraph = this.createGluedGraph(), Array.from(this.unglueIntPairs(Zi.getFeedbackSetWithConstraints(this.gluedIntGraph, this.gluedUpDownIntConstraints)));
  }
  *unglueIntPairs(t) {
    for (const e of t)
      for (const i of this.unglueEdge(e))
        yield i;
  }
  *unglueEdge(t) {
    for (const e of this.unglueNode(t.source))
      for (const i of this.intGraph.outEdges[e])
        this.nodeToRepr(i.target) === t.target && (yield i);
  }
  createGluedGraph() {
    const t = new ti();
    return this.intGraph.edges.forEach((e) => t.add(this.gluedIntPairI(e))), fi(Array.from(t.values()), this.intGraph.nodeCount);
  }
  unglueNode(t) {
    const e = this.representativeToItsLayer.get(t);
    return e || [t];
  }
  getGluedNodeCounts() {
    const t = new Array(this.nodeIdToIndex.size).fill(0);
    for (let e = 0; e < t.length; e++)
      t[this.nodeToRepr(e)]++;
    return t;
  }
}
function Tf(o, t) {
  return [o, t];
}
class Of {
  constructor() {
    this.leftRightConstraints = new Array(), this.leftRightNeighbors = new Array(), this.nodeToBlockRoot = /* @__PURE__ */ new Map(), this.upDownVerticalConstraints = new Array(), this.BlockRootToBlock = /* @__PURE__ */ new Map();
  }
  get IsEmpty() {
    return this.leftRightNeighbors.length === 0 && this.upDownVerticalConstraints.length === 0 && this.leftRightConstraints.length === 0;
  }
  AddSameLayerNeighbors(t) {
    for (let e = 0; e < t.length - 1; e++)
      this.AddSameLayerNeighborsPair(t[e], t[e + 1]);
  }
  AddSameLayerNeighborsPair(t, e) {
    this.leftRightNeighbors.push([t, e]);
  }
  NodeToBlockRootSoft(t) {
    const e = this.nodeToBlockRoot.get(t);
    return e || t;
  }
  CreateMappingOfNeibBlocks() {
    const t = this.BasicGraphFromLeftRightIntNeibs();
    for (let e = 0; e < t.nodeCount; e++)
      if (t.inEdges[e].length === 0 && !this.nodeToBlockRoot.has(e)) {
        const i = new Array();
        let s = e;
        for (let n = t.outEdges[s]; n.length > 0; n = t.outEdges[s])
          s = n[0].y, i.push(s), this.nodeToBlockRoot.set(s, e);
        i.length > 0 && this.BlockRootToBlock.set(e, i);
      }
  }
  BasicGraphFromLeftRightIntNeibs() {
    return Br(Array.from(this.LeftRightIntNeibs.values()).map((t) => new U(t.x, t.y)));
  }
  NodeIndex(t) {
    const e = this.nodeIdToIndex.get(t.id);
    return e || -1;
  }
  PrepareForOrdering(t, e) {
    this.nodeIdToIndex = t, this.MapNodesToToIntegers(e), this.CreateMappingOfNeibBlocks(), this.LiftLeftRightRelationsToNeibBlocks();
  }
  //see UpDownMonotone.png
  //       void MakeUpDownRelationsMonotone(number[] yLayers) {
  //           BasicGraph<IntPair> upDownGraph = new BasicGraph<IntPair>(from c in this.verticalInts select new IntPair(c.First,c.Second));
  //           Array<Tuple<number, number>> upDownToRemove = new Array<Tuple<number, number>>();
  //           foreach (Array<number> componentNodes of ConnectedComponentCalculator<IntPair>.GetComponents(GraphOfLeftRightRelations())) {
  //               ResolveConflictsUboveComponent(upDownGraph, componentNodes, upDownToRemove, yLayers);
  //               ResolveConflictsBelowComponent(upDownGraph, componentNodes, upDownToRemove, yLayers);
  //           }
  //
  //           foreach (var v of upDownToRemove)
  //               this.verticalInts.Remove(v);
  //       }
  //makes left-right relations to be between neighb blocks and removes cycles in these relations
  LiftLeftRightRelationsToNeibBlocks() {
    this.LeftRighInts = ti.mk(this.leftRightConstraints.map((e) => Tf(this.NodeIndex(e[0]), this.NodeIndex(e[1]))).filter((e) => e[0] !== -1 && e[1] !== -1).map((e) => new U(this.NodeToBlockRootSoft(e[0]), this.NodeToBlockRootSoft(e[1]))).filter((e) => e.x !== e.x));
    const t = Zi.getFeedbackSet(Br(Array.from(this.LeftRighInts.values())));
    for (const e of t)
      this.LeftRighInts.remove(new U(e.source, e.target));
  }
  MapNodesToToIntegers(t) {
    this.LeftRightIntNeibs = ti.mk(Array.from(this.leftRightNeighbors.values()).map((e) => [this.NodeIndex(e[0]), this.NodeIndex(e[1])]).filter((e) => e[0] !== -1 && e[1] !== -1).map((e) => new U(e[0], e[1]))), this.VerticalInts = ti.mk(this.upDownVerticalConstraints.map((e) => [this.NodeIndex(e[0]), this.NodeIndex(e[1])]).filter((e) => e[0] !== -1 && e[1] !== -1 && t[e[0]] > t[e[1]]).map((e) => new U(e[0], e[1])));
  }
}
var je;
(function(o) {
  o[o.TB = 0] = "TB", o[o.LR = 1] = "LR", o[o.BT = 2] = "BT", o[o.RL = 3] = "RL", o[o.None = 4] = "None";
})(je || (je = {}));
var Kt;
(function(o) {
  o[o.Spline = 0] = "Spline", o[o.SplineBundling = 1] = "SplineBundling", o[o.StraightLine = 2] = "StraightLine", o[o.SugiyamaSplines = 3] = "SugiyamaSplines", o[o.Rectilinear = 4] = "Rectilinear", o[o.RectilinearToCenter = 5] = "RectilinearToCenter", o[o.None = 6] = "None";
})(Kt || (Kt = {}));
class Fn {
  toJSON() {
    const t = {};
    return this.EdgeRoutingMode != Kt.Spline && (t.edgeRoutingMode = Kt.Spline), this.ConeAngle != 30 * (Math.PI / 180) && (t.coneAngle = this.ConeAngle), this.padding != 3 && (t.padding = this.padding), this.polylinePadding != 1.5 && (t.polylinePadding = this.polylinePadding), this.bundlingSettings && (t.bundlingSettingsJSON = this.bundlingSettings.toJSON()), t;
  }
  static fromJSON(t) {
    const e = new Fn();
    return t.edgeRoutingMode && (t.edgeRoutingMode = e.edgeRoutingMode), t.coneAngle && (e.coneAngle = t.coneAngle), t.padding && (e.padding = t.padding), t.polylinePadding && (e.polylinePadding = t.polylinePadding), t.bundlingSettingsJSON && (e.bundlingSettings = kt.createFromJSON(t.bundlingSettingsJSON)), t.routingToParentConeAngle && (e.routingToParentConeAngle = t.routingToParentConeAngle), t.simpleSelfLoopsForParentEdgesThreshold && (e.simpleSelfLoopsForParentEdgesThreshold = t.simpleSelfLoopsForParentEdgesThreshold), t.incrementalRoutingThreshold && (e.incrementalRoutingThreshold = t.incrementalRoutingThreshold), t.routeMultiEdgesAsBundles && (e.routeMultiEdgesAsBundles = t.routeMultiEdgesAsBundles), t.KeepOriginalSpline && (e.KeepOriginalSpline = t.KeepOriginalSpline), e;
  }
  constructor() {
    this.coneAngle = 30 * (Math.PI / 180), this.padding = 2, this.polylinePadding = 1, this.routingToParentConeAngle = Math.PI / 6, this.simpleSelfLoopsForParentEdgesThreshold = 200, this.incrementalRoutingThreshold = 5e6, this.routeMultiEdgesAsBundles = !0, this.KeepOriginalSpline = !1, this.EdgeRoutingMode = Kt.Spline;
  }
  // defines the way edges are routed
  get EdgeRoutingMode() {
    return this.edgeRoutingMode;
  }
  set EdgeRoutingMode(t) {
    t === Kt.SplineBundling && this.bundlingSettings == null && this.bundlingSettings == null && (this.bundlingSettings = new kt()), this.edgeRoutingMode = t;
  }
  // the angle in degrees of the cones in the routing with the spanner
  get ConeAngle() {
    return this.coneAngle;
  }
  set ConeAngle(t) {
    this.coneAngle = t;
  }
  // Amount of space to leave around nodes
  get Padding() {
    return this.padding;
  }
  set Padding(t) {
    this.padding = t;
  }
  // Additional amount of padding to leave around nodes when routing with polylines
  get PolylinePadding() {
    return this.polylinePadding;
  }
  set PolylinePadding(t) {
    this.polylinePadding = t;
  }
  // this is a cone angle to find a relatively close point on the parent boundary
  get RoutingToParentConeAngle() {
    return this.routingToParentConeAngle;
  }
  set RoutingToParentConeAngle(t) {
    this.routingToParentConeAngle = t;
  }
  // if the number of the nodes participating in the routing of the parent edges is less than the threshold
  // then the parent edges are routed avoiding the nodes
  get SimpleSelfLoopsForParentEdgesThreshold() {
    return this.simpleSelfLoopsForParentEdgesThreshold;
  }
  set SimpleSelfLoopsForParentEdgesThreshold(t) {
    this.simpleSelfLoopsForParentEdgesThreshold = t;
  }
  // defines the size of the changed graph that could be routed fast with the standard spline routing when dragging
  get IncrementalRoutingThreshold() {
    return this.incrementalRoutingThreshold;
  }
  set IncrementalRoutingThreshold(t) {
    this.incrementalRoutingThreshold = t;
  }
  // if set to true routes multi edges as ordered bundles, when routing in a spline mode
  // <exception cref="NotImplementedException"></exception>
  get RouteMultiEdgesAsBundles() {
    return this.routeMultiEdgesAsBundles;
  }
  set RouteMultiEdgesAsBundles(t) {
    this.routeMultiEdgesAsBundles = t;
  }
}
class Ys {
  constructor() {
    this.edgeRoutingSettings = new Fn(), this.nodeSeparation = 10, this.packingAspectRatio = 1.5;
  }
  static fromJSON(t) {
    const e = new Ys();
    return t.nodeSeparation != 10 && (e.nodeSeparation = t.nodeSeparation), t.packingAspectRatio && (e.packingAspectRatio = t.packingAspectRatio), t.edgeRoutingSettings && (e.edgeRoutingSettings = Fn.fromJSON(t.edgeRoutingSettings)), e;
  }
  toJSON() {
    let t = !1;
    const e = {};
    return this.nodeSeparation != 10 && (e.nodeSeparation = this.nodeSeparation, t = !0), this.packingAspectRatio != 1.5 && (e.packingAspectRatio = this.packingAspectRatio, t = !0), (e.edgeRoutingSettings = this.edgeRoutingSettings.toJSON()) && (t = !0), t ? e : void 0;
  }
  get NodeSeparation() {
    return this.nodeSeparation;
  }
  set NodeSeparation(t) {
    this.nodeSeparation = t;
  }
  get PackingAspectRatio() {
    return this.packingAspectRatio;
  }
  set PackingAspectRatio(t) {
    this.packingAspectRatio = t;
  }
}
var Js;
(function(o) {
  o[o.None = 0] = "None", o[o.Top = 1] = "Top", o[o.Bottom = 2] = "Bottom";
})(Js || (Js = {}));
class en {
  get NodeSeparation() {
    return this.commonSettings.NodeSeparation;
  }
  get edgeRoutingSettings() {
    return this.commonSettings.edgeRoutingSettings;
  }
  set edgeRoutingSettings(t) {
    this.commonSettings.edgeRoutingSettings = t;
  }
  toJSON() {
    const t = {};
    return this.sameRanks && (t.sameRanks = this.sameRanks), this.verticalConstraints && (t.verticalConstraints = this.verticalConstraints), this.horizontalConstraints && (t.horizontalConstraints = this.horizontalConstraints), this.NoGainAdjacentSwapStepsBound != 5 && (t.horizontalConstraints = this.horizontalConstraints), this.NoGainStepsForOrderingMultiplier != 1 && (t.RepetitionCoefficientForOrdering = this.NoGainStepsForOrderingMultiplier), this.AspectRatio && (t.AspectRatio = this.AspectRatio), this.MaxNumberOfPassesInOrdering != 24 && (t.MaxNumberOfPassesInOrdering = this.MaxNumberOfPassesInOrdering), this.BrandesThreshold != 600 && (t.BrandesThreshold = this.BrandesThreshold), this.LabelCornersPreserveCoefficient != 0.1 && (t.LabelCornersPreserveCoefficient = this.LabelCornersPreserveCoefficient), this.MinNodeHeight != 72 * 0.5 / 4 && (t.MinNodeHeight = this.MinNodeHeight), this.MinNodeWidth != 72 * 0.75 / 4 && (t.MinNodeWidth = this.MinNodeWidth), this.SnapToGridByY != Js.None && (t.SnapToGridByY = this.SnapToGridByY), this.yLayerSep != 30 && (t.yLayerSep = this.yLayerSep), this.transform && (t.transform = this.transform.elements), this.GridSizeByY && (t.GridSizeByY = this.GridSizeByY), this.GridSizeByX && (t.GridSizeByX = this.GridSizeByX), t.commonLayoutSettings = this.commonSettings.toJSON(), t;
  }
  static fromJSON(t) {
    const e = new en();
    return t.sameRanks && (e.sameRanks = t.sameRanks), t.verticalConstraints && (e.verticalConstraints = t.verticalConstraints), t.horizontalConstraints && (e.horizontalConstraints = t.horizontalConstraints), t.NoGainAdjacentSwapStepsBound && (e.horizontalConstraints = t.horizontalConstraints), t.RepetitionCoefficientForOrdering && (e.NoGainStepsForOrderingMultiplier = t.RepetitionCoefficientForOrdering), t.AspectRatio && (e.AspectRatio = t.AspectRatio), t.MaxNumberOfPassesInOrdering && (e.MaxNumberOfPassesInOrdering = t.MaxNumberOfPassesInOrdering), t.BrandesThreshold && (e.BrandesThreshold = t.BrandesThreshold), t.LabelCornersPreserveCoefficient && (e.LabelCornersPreserveCoefficient = t.LabelCornersPreserveCoefficient), t.MinNodeHeight && (e.MinNodeHeight = t.MinNodeHeight), t.MinNodeWidth && (e.MinNodeWidth = e.MinNodeWidth), t.SnapToGridByY && (e.SnapToGridByY = t.SnapToGridByY), t.yLayerSep && (e.yLayerSep = t.yLayerSep), t.transform && (e.transform = new Wt(t.transform[0][0], t.transform[0][1], t.transform[0][2], t.transform[1][0], t.transform[1][1], t.transform[1][2])), t.GridSizeByY && (e.GridSizeByY = t.GridSizeByY), t.GridSizeByX && (e.GridSizeByX = t.GridSizeByX), t.commonLayoutSettings && (e.commonSettings = Ys.fromJSON(t.commonLayoutSettings)), e;
  }
  /** the minimum distance between two layer horizontal lines passing througt the node centers */
  get LayerSeparation() {
    return this.yLayerSep;
  }
  set LayerSeparation(t) {
    this.yLayerSep = Math.max(30, t);
  }
  ActualLayerSeparation(t) {
    return t ? this.LayerSeparation / 2 : this.LayerSeparation;
  }
  constructor() {
    this.commonSettings = new Ys(), this.verticalConstraints = new Af(), this.horizontalConstraints = new Of(), this.NoGainAdjacentSwapStepsBound = 5, this.NoGainStepsForOrderingMultiplier = 1, this.AspectRatio = 0, this.MaxNumberOfPassesInOrdering = 24, this.BrandesThreshold = 600, this.LabelCornersPreserveCoefficient = 0.1, this.MinNodeHeight = 72 * 0.5 / 4, this.MinNodeWidth = 72 * 0.75 / 4, this.SnapToGridByY = Js.None, this.yLayerSep = 30, this.transform = Wt.getIdentity(), this.GridSizeByY = 0, this.GridSizeByX = 0, this.commonSettings.edgeRoutingSettings.EdgeRoutingMode = Kt.SugiyamaSplines;
  }
  transformIsRotation(t) {
    const e = Wt.rotation(t);
    for (let i = 0; i < 2; i++)
      for (let s = 0; s < 3; s++)
        if (!D(e.elements[i][s], this.transform.elements[i][s]))
          return !1;
    return !0;
  }
  get layerDirection() {
    if (this.transformIsRotation(0))
      return je.TB;
    if (this.transformIsRotation(Math.PI / 2))
      return je.LR;
    if (this.transformIsRotation(-Math.PI / 2))
      return je.RL;
    if (this.transformIsRotation(Math.PI))
      return je.BT;
    throw new Error("unexpected layout direction");
  }
  set layerDirection(t) {
    switch (t) {
      case je.TB:
        this.transform = Wt.getIdentity();
        break;
      case je.LR:
        this.transform = Wt.rotation(Math.PI / 2);
        break;
      case je.RL:
        this.transform = Wt.rotation(-Math.PI / 2);
        break;
      case je.BT:
        this.transform = Wt.rotation(Math.PI);
        break;
      default:
        throw new Error("unexpected layout direction");
    }
  }
}
class qh extends lt {
  // Dijkstra algorithm. Computes graph-theoretic distances from a node to
  // all other nodes in a graph with nonnegative edge lengths.
  // The distance between a node and itself is 0; the distance between a pair of
  // nodes for which no connecting path exists is Number.POSITIVE_INFINITY.
  constructor(t, e, i) {
    super(null), this.graph = t, this.source = e, this.length = i;
  }
  // An array of distances from the source node to all shallow nodes.
  // Nodes are indexed when iterating over them.
  get Result() {
    return this.result;
  }
  // Executes the algorithm.
  run() {
    const t = new es((s, n) => s - n), e = /* @__PURE__ */ new Map();
    for (const s of this.graph.shallowNodes) {
      const n = s === this.source ? 0 : Number.POSITIVE_INFINITY;
      t.Enqueue(s, n), e.set(s, n);
    }
    for (; t.count > 0; ) {
      const s = { priority: 0 }, n = t.DequeueAndGetPriority(s);
      e.set(n, s.priority);
      const r = e.get(n);
      for (const a of n.inEdges()) {
        const l = a.source, h = r + this.length(a);
        e.get(l) > h && (e.set(l, h), t.DecreasePriority(l, h));
      }
      for (const a of n.outEdges()) {
        const l = a.target, h = r + this.length(a);
        e.get(l) > h && (e.set(l, h), t.DecreasePriority(l, h));
      }
    }
    this.result = new Array(this.graph.shallowNodeCount);
    let i = 0;
    for (const s of this.graph.shallowNodes) {
      const n = e.get(s);
      n !== void 0 ? this.result[i++] = n : this.result[i++] = Number.POSITIVE_INFINITY;
    }
  }
}
class Sa extends lt {
  // The resulting distances between every pair of nodes in the graph.
  get Result() {
    return this.result;
  }
  set Result(t) {
    this.result = t;
  }
  // Computes distances between every pair of nodes in a graph.
  // Distances are symmetric if the graph is undirected.
  constructor(t, e) {
    super(null), this.graph = t, this.length = e;
  }
  // Executes the algorithm.
  run() {
    this.result = new Array(this.graph.shallowNodeCount);
    let t = 0;
    for (const e of this.graph.shallowNodes) {
      const i = new qh(this.graph, e, this.length);
      i.run(), this.Result[t++] = i.Result;
    }
  }
  // Computes the "stress" of the current layout of the given graph:
  //
  //   stress = sum_{(u,v) in V}  (d(u,v) - D(u,v))^2/(D(u,v)^2)
  //
  // where:
  //   V is the set of nodes
  //   d(u,v) is the euclidean distance between the centers of nodes u and v
  //   D(u,v) is the graph-theoretic path length between u and v - scaled by average edge length.
  //
  // Small stress in graph layout correlated with immediate neighbors to be closer
  // together than nodes that are a few hops apart (i.e. that have path length>1).  More generally
  // the distance between nodes in the drawing should be proportional to the path length between them.
  // The lower the stress of a particular graph layout the better it conforms to this ideal.
  //
  static Stress(t, e) {
    let i = 0;
    if (t.edgeCount === 0)
      return i;
    const s = new Sa(t, e);
    s.run();
    const n = s.Result;
    let r = 0;
    for (const l of t.shallowEdges)
      r += e(l);
    r /= t.edgeCount;
    let a = 0;
    for (const l of t.shallowNodes) {
      let h = 0;
      for (const c of t.shallowNodes) {
        if (a !== h) {
          const d = l.center.sub(c.center).length, f = r * n[a][h], p = f - d;
          i += p * p / (f * f);
        }
        h++;
      }
      a++;
    }
    return i;
  }
}
class xf extends lt {
  // A square matrix with shortest path distances.
  get Result() {
    return this.result;
  }
  // Computes distances between a selected set of nodes and all nodes.
  // Pivot nodes are selected with maxmin strategy (first at random, later
  // ones to maximize distances to all previously selected ones).
  constructor(t, e, i) {
    super(null), this.graph = t, this.pivotArray = e, this.length = i;
  }
  // Executes the algorithm.
  run() {
    this.result = new Array(this.pivotArray.length);
    const t = Array.from(this.graph.shallowNodes), e = new Array(this.graph.shallowNodeCount).fill(Number.POSITIVE_INFINITY);
    let i = t[0];
    this.pivotArray[0] = 0;
    for (let s = 0; ; s++) {
      const n = new qh(this.graph, i, this.length);
      if (n.run(), this.Result[s] = n.Result, s + 1 < this.pivotArray.length) {
        let r = 0;
        for (let a = 0; a < this.Result[s].length; a++)
          e[a] = Math.min(e[a], this.Result[s][a]), e[a] > e[r] && (r = a);
        i = t[r], this.pivotArray[s + 1] = r;
      } else
        break;
    }
  }
}
class Lf {
  // Rotates a 2D configuration clockwise by a given angle
  // The angle is given in degrees
  static Rotate(t, e, i) {
    const s = Math.sin(i * (Math.PI / 180)), n = Math.cos(i * (Math.PI / 180));
    for (let r = 0; r < t.length; r++) {
      const a = n * t[r] + s * e[r];
      e[r] = n * e[r] - s * t[r], t[r] = a;
    }
  }
}
class et {
  // Double-centers a matrix of such a way that the center of gravity is zero.
  // After number-centering, each row and each column sums up to zero.
  static DoubleCenter(t) {
    const e = new Array(t.length).fill(0), i = new Array(t[0].length).fill(0);
    let s = 0;
    for (let n = 0; n < t.length; n++)
      for (let r = 0; r < t[0].length; r++)
        e[n] += t[n][r], i[r] += t[n][r], s += t[n][r];
    for (let n = 0; n < t.length; n++)
      e[n] /= t.length;
    for (let n = 0; n < t[0].length; n++)
      i[n] /= t[0].length;
    s /= t.length, s /= t[0].length;
    for (let n = 0; n < t.length; n++)
      for (let r = 0; r < t[0].length; r++)
        t[n][r] -= e[n] + i[r] - s;
  }
  // Squares all entries of a matrix.
  static SquareEntries(t) {
    for (let e = 0; e < t.length; e++)
      for (let i = 0; i < t[0].length; i++)
        t[e][i] = Math.pow(t[e][i], 2);
  }
  // Multiplies a matrix with a scalar factor.
  static Multiply(t, e) {
    for (let i = 0; i < t.length; i++)
      for (let s = 0; s < t[0].length; s++)
        t[i][s] *= e;
  }
  // Multiply a square matrix and a vector.
  // Note that matrix width and vector length
  // have to be equal, otherwise null is returned.
  static MultiplyX(t, e) {
    if (t[0].length !== e.length)
      return null;
    const i = new Array(e.length).fill(0);
    for (let s = 0; s < t.length; s++)
      for (let n = 0; n < t[0].length; n++)
        i[s] += t[s][n] * e[n];
    return i;
  }
  // Gives the norm of a vector, that is, its length in
  // vector.length dimensional Euclidean space.
  static Norm(t) {
    let e = 0;
    for (let i = 0; i < t.length; i++)
      e += Math.pow(t[i], 2);
    return Math.sqrt(e);
  }
  // Normalizes a vector to unit length (1.0) in
  // vector.length dimensional Euclidean space.
  // If the vector is the 0-vector, nothing is done.
  static Normalize(t) {
    const e = et.Norm(t);
    if (e <= 0)
      return 0;
    for (let i = 0; i < t.length; i++)
      t[i] /= e;
    return e;
  }
  // Gives a random unit Euclidean length vector of a given size.
  static RandomUnitLengthVector(t) {
    const e = new Array(t);
    for (let i = 0; i < t; i++)
      e[i] = vs();
    return et.Normalize(e), e;
  }
  // Computes the two dominant eigenvectors and eigenvalues of a symmetric
  // square matrix.
  static SpectralDecomposition(t, e) {
    et.SpectralDecompositionIE(t, e, 30, 1e-6);
  }
  // Computes the two dominant eigenvectors and eigenvalues of a symmetric
  // square matrix.
  static SpectralDecompositionIE(t, e, i, s) {
    const n = t[0].length;
    e.u1 = et.RandomUnitLengthVector(n), e.lambda1 = 0, e.u2 = et.RandomUnitLengthVector(n), e.lambda2 = 0;
    let r = 0;
    const a = 1 - s;
    for (let l = 0; l < i && r < a; l++) {
      const h = et.MultiplyX(t, e.u1), c = et.MultiplyX(t, e.u2);
      e.lambda1 = et.Normalize(h), e.lambda2 = et.Normalize(c), et.MakeOrthogonal(c, h), et.Normalize(c), r = Math.min(et.DotProduct(e.u1, h), et.DotProduct(e.u2, c)), e.u1 = h, e.u2 = c;
    }
  }
  // Gives the inner product of two vectors of the same size.
  static DotProduct(t, e) {
    if (t.length !== e.length)
      return 0;
    let i = 0;
    for (let s = 0; s < t.length; s++)
      i += t[s] * e[s];
    return i;
  }
  // Orthogonalizes a vector against another vector, so that
  // their scalar product is 0.
  static MakeOrthogonal(t, e) {
    if (t.length !== e.length)
      return;
    const i = et.DotProduct(t, e) / et.DotProduct(e, e);
    for (let s = 0; s < t.length; s++)
      t[s] -= i * e[s];
  }
  // Classical multidimensional scaling.  Computes two-dimensional coordinates
  // for a given distance matrix by computing the two largest eigenvectors
  // and eigenvalues of a matrix assiciated with the distance matrix (called
  // "fitting inner products").
  static ClassicalScaling(t, e) {
    const i = new Array(t.length);
    for (let s = 0; s < t.length; s++)
      i[s] = t[s].slice();
    et.SquareEntries(i), et.DoubleCenter(i), et.Multiply(i, -0.5), et.SpectralDecomposition(i, e), e.lambda1 = Math.sqrt(Math.abs(e.lambda1)), e.lambda2 = Math.sqrt(Math.abs(e.lambda2));
    for (let s = 0; s < e.u1.length; s++)
      e.u1[s] *= e.lambda1, e.u2[s] *= e.lambda2;
  }
  // Multidimensional scaling.  Computes two-dimensional coordinates
  // for a given distance matrix by fitting the coordinates to these distances
  // iteratively by majorization (called "distance fitting").
  // Only objects that have rows of the distance/weight matrix
  // is subject to iterative relocation.
  static DistanceScalingSubset(t, e, i, s, n) {
    const r = e.length, a = t.length, l = new Array(a);
    for (let c = 0; c < a; c++)
      for (let d = 0; d < r; d++)
        t[c][d] === 0 && (l[c] = d);
    const h = new Array(a).fill(0);
    for (let c = 0; c < a; c++)
      for (let d = 0; d < r; d++)
        l[c] !== d && (h[c] += s[c][d]);
    for (let c = 0; c < n; c++)
      for (let d = 0; d < a; d++) {
        let f = 0, p = 0;
        for (let P = 0; P < r; P++)
          if (d !== P) {
            let y = Math.sqrt(Math.pow(e[l[d]] - e[P], 2) + Math.pow(i[l[d]] - i[P], 2));
            y > 0 && (y = 1 / y), f += s[d][P] * (e[P] + t[d][P] * (e[l[d]] - e[P]) * y), p += s[d][P] * (i[P] + t[d][P] * (i[l[d]] - i[P]) * y);
          }
        e[l[d]] = f / h[d], i[l[d]] = p / h[d];
      }
  }
  // Multidimensional scaling.  Computes two-dimensional coordinates
  // for a given distance matrix by fitting the coordinates to these distances
  // iteratively by majorization (called "distance fitting").
  // (McGee, Kamada-Kawai)
  static DistanceScaling(t, e, i, s, n) {
    const r = e.length, a = new Array(r).fill(0);
    for (let l = 0; l < r; l++)
      for (let h = 0; h < r; h++)
        l !== h && (a[l] += s[l][h]);
    for (let l = 0; l < n; l++)
      for (let h = 0; h < r; h++) {
        let c = 0, d = 0;
        for (let f = 0; f < r; f++)
          if (h !== f) {
            let p = Math.sqrt(Math.pow(e[h] - e[f], 2) + Math.pow(i[h] - i[f], 2));
            p > 0 && (p = 1 / p), c += s[h][f] * (e[f] + t[h][f] * (e[h] - e[f]) * p), d += s[h][f] * (i[f] + t[h][f] * (i[h] - i[f]) * p);
          }
        e[h] = c / a[h], i[h] = d / a[h];
      }
  }
  // Convenience method for generating a weight matrix from a distance matrix.
  // Each output entry is the corresponding input entry powered by a constant
  // exponent.
  static ExponentialWeightMatrix(t, e) {
    const i = new Array(t.length);
    for (let s = 0; s < t.length; s++) {
      i[s] = new Array(t[s].length).fill(0);
      for (let n = 0; n < t[s].length; n++)
        t[s][n] > 0 && (i[s][n] = Math.pow(t[s][n], e));
    }
    return i;
  }
  // Convenience method for all Euclidean distances within two-dimensional
  // positions.
  static EuclideanDistanceMatrix(t, e) {
    const i = new Array(t.length);
    for (let s = 0; s < t.length; s++) {
      i[s] = new Array(t.length);
      for (let n = 0; n < t.length; n++)
        i[s][n] = Math.sqrt(Math.pow(t[s] - t[n], 2) + Math.pow(e[s] - e[n], 2));
    }
    return i;
  }
  // Approximation to classical multidimensional scaling.
  // Computes two-dimensional coordinates
  // for a given rectangular distance matrix.
  static LandmarkClassicalScaling(t, e, i) {
    const s = new Array(t.length);
    for (let a = 0; a < t.length; a++) {
      s[a] = new Array(t.length);
      for (let l = 0; l < t.length; l++)
        s[a][l] = t[a][i[l]];
    }
    et.SquareEntries(s);
    const n = new Array(t.length).fill(0);
    for (let a = 0; a < t.length; a++) {
      for (let l = 0; l < t.length; l++)
        n[a] += s[a][l];
      n[a] /= t.length;
    }
    et.DoubleCenter(s), et.Multiply(s, -0.5);
    const r = {
      u1: new Array(),
      u2: new Array(),
      lambda1: 0,
      lambda2: 0
    };
    et.SpectralDecomposition(s, r), r.lambda1 = Math.sqrt(Math.abs(r.lambda1)), r.lambda2 = Math.sqrt(Math.abs(r.lambda2)), e.x = new Array(t[0].length).fill(0), e.y = new Array(t[0].length).fill(0);
    for (let a = 0; a < e.x.length; a++)
      for (let l = 0; l < s.length; l++) {
        const h = (Math.pow(t[l][a], 2) - n[l]) / 2;
        e.x[a] -= r.u1[l] * h, e.y[a] -= r.u2[l] * h;
      }
  }
}
class Rf {
  constructor(t, e) {
    this.constrained = !1, this.Capacity = 1e6, gt.AbovePP(t.point, e.point) === 1 ? (this.upperSite = t, this.lowerSite = e) : (this.lowerSite = t, this.upperSite = e), this.upperSite.AddEdgeToSite(this);
  }
  get CcwTriangle() {
    return this.ccwTriangle;
  }
  set CcwTriangle(t) {
    this.ccwTriangle = t;
  }
  get CwTriangle() {
    return this.cwTriangle;
  }
  set CwTriangle(t) {
    this.cwTriangle = t;
  }
  // returns the trianlge on the edge opposite to the site
  GetOtherTriangle_c(t) {
    return this.cwTriangle.Contains(t) ? this.ccwTriangle : this.cwTriangle;
  }
  IsAdjacent(t) {
    return t === this.upperSite || t === this.lowerSite;
  }
  GetOtherTriangle_T(t) {
    return this.ccwTriangle === t ? this.cwTriangle : this.ccwTriangle;
  }
  // A string that represents the current object.
  toString() {
    return Bt.String.format("({0},{1})", this.upperSite, this.lowerSite);
  }
  OtherSite(t) {
    return this.upperSite === t ? this.lowerSite : this.upperSite;
  }
}
class In {
  cleanRemovedEdges() {
    for (const t of this.Edges)
      t.CcwTriangle === null && t.CwTriangle === null && this.Edges.splice(this.Edges.indexOf(t), 1);
  }
  constructor(t) {
    this.Owner = null, this.InEdges = new Array(), this.point = t;
  }
  static mkSO(t, e) {
    const i = new In(t);
    return i.Owner = e, i;
  }
  AddEdgeToSite(t) {
    this.Edges == null && (this.Edges = new Array()), this.Edges.push(t);
  }
  // #if TEST_MSAGL && TEST_MSAGL
  //         // Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
  //         // A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
  //         // <filterpriority>2</filterpriority>
  //         public override string ToString()
  //         {
  //             return Point.ToString();
  //         }
  // #endif
  EdgeBetweenUpperSiteAndLowerSite(t) {
    if (this.Edges != null) {
      for (const e of this.Edges)
        if (e.lowerSite === t)
          return e;
    }
    return null;
  }
  AddInEdge(t) {
    this.InEdges.push(t);
  }
  *Triangles() {
    let t;
    if (this.Edges != null && this.Edges.length > 0)
      t = this.Edges[0];
    else if (this.InEdges != null && this.InEdges.length > 0)
      t = this.InEdges[0];
    else
      return;
    let e = t;
    do {
      const i = e.upperSite === this ? e.CcwTriangle : e.CwTriangle;
      if (i == null) {
        e = null;
        break;
      }
      yield i, e = i.Edges.getItem(i.Edges.index(e) + 2);
    } while (e !== t);
    if (e !== t) {
      e = t;
      do {
        const i = e.upperSite === this ? e.CwTriangle : e.CcwTriangle;
        if (i == null)
          break;
        yield i, e = i.Edges.getItem(i.Edges.index(e) + 1);
      } while (!0);
    }
  }
  toString() {
    return this.point.toString();
  }
}
class Ts {
  get x() {
    return this.LeftSite.point.x;
  }
  constructor(t, e) {
    this.RightSite = e.upperSite === t ? e.lowerSite : e.upperSite, this.LeftSite = t, this.Edge = e;
  }
  toString() {
    return "(" + this.LeftSite.toString() + ", " + this.Edge.toString() + "," + this.RightSite.toString() + ")";
  }
}
class vl {
  has(t) {
    return t === this.item0 || t === this.item1 || t === this.item2;
  }
  index(t) {
    return t === this.item0 ? 0 : t === this.item1 ? 1 : t === this.item2 ? 2 : -1;
  }
  getItem(t) {
    switch (t) {
      case 0:
      case 3:
      case -3:
        return this.item0;
      case 1:
      case 4:
      case -2:
        return this.item1;
      case 2:
      case 5:
      case -1:
        return this.item2;
      default:
        throw new Error();
    }
  }
  setItem(t, e) {
    switch (t) {
      case 0:
      case 3:
      case -3:
        this.item0 = e;
        break;
      case 1:
      case 4:
      case -2:
        this.item1 = e;
        break;
      case 2:
      case 5:
      case -1:
        this.item2 = e;
        break;
      default:
        throw new Error();
    }
  }
  [Symbol.iterator]() {
    return this.GetEnumerator();
  }
  // Returns an enumerator that iterates through the collection.
  *GetEnumerator() {
    yield this.item0, yield this.item1, yield this.item2;
  }
}
class se {
  constructor() {
    this.Edges = new vl(), this.Sites = new vl();
  }
  containsPoint(t) {
    return se.PointLocationForTriangle(t, this) !== F.Outside;
  }
  static PointLocationForTriangle(t, e) {
    let i = !1;
    for (let s = 0; s < 3; s++) {
      const n = u.signedDoubledTriangleArea(t, e.Sites.getItem(s).point, e.Sites.getItem(s + 1).point);
      if (n < -m.distanceEpsilon)
        return F.Outside;
      n < m.distanceEpsilon && (i = !0);
    }
    return i ? F.Boundary : F.Inside;
  }
  /** extend by eps the triangles edges before the test */
  intersectsLine(t, e, i) {
    if (se.PointLocationForTriangle(t, this) != F.Outside || se.PointLocationForTriangle(e, this) != F.Outside)
      return !0;
    for (const s of this.Edges)
      if (this.abIntersectsTrianglSide(t, e, s))
        return !0;
    return !1;
  }
  abIntersectsTrianglSide(t, e, i) {
    return Bh(t, e, i.lowerSite.point, i.upperSite.point);
  }
  static mkSSSD(t, e, i, s) {
    const n = u.getTriangleOrientation(t.point, e.point, i.point), r = new se();
    switch (n) {
      case L.Counterclockwise:
        r.FillCcwTriangle(t, e, i, s);
        break;
      case L.Clockwise:
        r.FillCcwTriangle(t, i, e, s);
        break;
      default:
        throw new Error();
    }
    return r;
  }
  static mkSED(t, e, i) {
    const s = new se();
    switch (u.getTriangleOrientation(e.upperSite.point, e.lowerSite.point, t.point)) {
      case L.Counterclockwise:
        e.CcwTriangle = s, s.Sites.setItem(0, e.upperSite), s.Sites.setItem(1, e.lowerSite);
        break;
      case L.Clockwise:
        e.CwTriangle = s, s.Sites.setItem(0, e.lowerSite), s.Sites.setItem(1, e.upperSite);
        break;
      default:
        throw new Error();
    }
    return s.Edges.setItem(0, e), s.Sites.setItem(2, t), s.CreateEdge(1, i), s.CreateEdge(2, i), s;
  }
  //
  static mkSSSEE(t, e, i, s, n, r) {
    const a = se.mkSSSD(t, e, i, r);
    return a.Edges.setItem(0, s), a.Edges.setItem(1, n), a.BindEdgeToTriangle(t, s), a.BindEdgeToTriangle(e, n), a.CreateEdge(2, r), a;
  }
  // in the trianlge, which is always oriented counterclockwise, the edge starts at site
  BindEdgeToTriangle(t, e) {
    t === e.upperSite ? e.CcwTriangle = this : e.CwTriangle = this;
  }
  // here a,b,c comprise a ccw triangle
  FillCcwTriangle(t, e, i, s) {
    this.Sites.setItem(0, t), this.Sites.setItem(1, e), this.Sites.setItem(2, i);
    for (let n = 0; n < 3; n++)
      this.CreateEdge(n, s);
  }
  CreateEdge(t, e) {
    const i = this.Sites.getItem(t), s = this.Sites.getItem(t + 1), n = e(i, s);
    this.Edges.setItem(t, n), this.BindEdgeToTriangle(i, n);
  }
  Contains(t) {
    return this.Sites.has(t);
  }
  OppositeEdge(t) {
    const e = this.Sites.index(t);
    return this.Edges.getItem(e + 1);
  }
  // #if TEST_MSAGL&&TEST_MSAGL
  //         // Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
  //         // A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
  //         // <filterpriority>2</filterpriority>
  //         public override string ToString() {
  //             return String.format("({0},{1},{2}", Sites[0], Sites[1], Sites[2]);
  //         }
  // #endif
  OppositeSite(t) {
    const e = this.Edges.index(t);
    return this.Sites.getItem(e + 2);
  }
  BoundingBox() {
    const t = T.mkPP(this.Sites.getItem(0).point, this.Sites.getItem(1).point);
    return t.add(this.Sites.getItem(2).point), t;
  }
  static mkSSSEED(t, e, i, s, n, r) {
    const a = new se();
    return a.Sites.setItem(0, t), a.Sites.setItem(1, e), a.Sites.setItem(2, i), a.Edges.setItem(0, s), a.Edges.setItem(1, n), a.BindEdgeToTriangle(t, s), a.BindEdgeToTriangle(e, n), a.CreateEdge(2, r), a;
  }
  toString() {
    return this.Sites.getItem(0).toString() + "," + this.Sites.getItem(1).toString() + "," + this.Sites.getItem(2).toString();
  }
}
class Cl {
  constructor(t) {
    this.Edge = t;
  }
}
class Vt extends lt {
  constructor(t, e, i, s) {
    if (super(null), this.front = new Ee((r, a) => r.x - a.x), this.triangles = /* @__PURE__ */ new Set(), this.listOfSites = t, this.listOfSites.length === 0)
      return;
    this.p_1 = e, this.p_2 = i, this.createEdgeDelegate = s;
    const n = se.mkSSSD(e, i, this.listOfSites[0], s);
    this.triangles.add(n), this.front.insert(new Ts(e, n.Edges.getItem(2))), this.front.insert(new Ts(this.listOfSites[0], n.Edges.getItem(1)));
  }
  run() {
    if (this.listOfSites.length !== 0) {
      for (let t = 1; t < this.listOfSites.length; t++)
        this.ProcessSite(this.listOfSites[t]);
      this.FinalizeTriangulation();
    }
  }
  FinalizeTriangulation() {
    this.RemoveP1AndP2Triangles(), this.triangles.size > 0 && this.MakePerimeterConvex();
  }
  MakePerimeterConvex() {
    let t = this.CreateDoubleLinkedListOfPerimeter();
    do {
      const e = this.FindConcaveEdge(t);
      if (e == null)
        return;
      t = this.ShortcutTwoListElements(e);
    } while (!0);
  }
  FindConcaveEdge(t) {
    let e = t, i;
    do {
      if (i = e.Next, u.getTriangleOrientation(e.Start.point, e.End.point, i.End.point) === L.Counterclockwise)
        return e;
      e = i;
    } while (i !== t);
    return null;
  }
  static FindPivot(t) {
    let e = t, i = t;
    do
      i = i.Next, (i.Start.point.x < e.Start.point.x || i.Start.point.x === e.Start.point.x && i.Start.point.y < e.Start.point.y) && (e = i);
    while (i !== t);
    return e;
  }
  FindFirsePerimeterEdge() {
    for (const t of this.triangles)
      for (const e of t.Edges)
        if (e.GetOtherTriangle_T(t) == null)
          return e;
    return null;
  }
  CreateDoubleLinkedListOfPerimeter() {
    const t = this.FindFirsePerimeterEdge();
    let e = t, i = null, s, n = null;
    const r = new Array();
    do
      s = Vt.CreatePerimeterElementFromEdge(e), r.push(v.mkPP(s.Start.point, s.End.point)), e = Vt.FindNextEdgeOnPerimeter(e), n != null ? (s.Prev = n, n.Next = s) : i = s, n = s;
    while (e !== t);
    return i.Prev = s, s.Next = i, i;
  }
  static FindNextEdgeOnPerimeter(t) {
    var e;
    let i = (e = t.CwTriangle) !== null && e !== void 0 ? e : t.CcwTriangle;
    for (t = i.Edges.getItem(i.Edges.index(t) + 2); t.CwTriangle != null && t.CcwTriangle != null; )
      i = t.GetOtherTriangle_T(i), t = i.Edges.getItem(i.Edges.index(t) + 2);
    return t;
  }
  static CreatePerimeterElementFromEdge(t) {
    const e = new Cl(t);
    return t.CwTriangle != null ? (e.Start = t.upperSite, e.End = t.lowerSite) : (e.End = t.upperSite, e.Start = t.lowerSite), e;
  }
  RemoveP1AndP2Triangles() {
    const t = /* @__PURE__ */ new Set();
    for (const e of this.triangles)
      (e.Sites.has(this.p_1) || e.Sites.has(this.p_2)) && t.add(e);
    for (const e of t)
      Vt.RemoveTriangleWithEdges(this.triangles, e);
  }
  static RemoveTriangleWithEdges(t, e) {
    t.delete(e);
    for (const i of e.Edges)
      i.CwTriangle === e ? i.CwTriangle = null : i.CcwTriangle = null, i.CwTriangle == null && i.CcwTriangle == null && _o(i.upperSite.Edges, i);
  }
  static RemoveTriangleButLeaveEdges(t, e) {
    t.delete(e);
    for (const i of e.Edges)
      i.CwTriangle === e ? i.CwTriangle = null : i.CcwTriangle = null;
  }
  ProcessSite(t) {
    this.PointEvent(t);
    for (let e = 0; e < t.Edges.length; e++) {
      const i = t.Edges[e];
      i.constrained && this.EdgeEvent(i);
    }
  }
  // #if TEST_MSAGL && TEST_MSAGL
  // void TestThatFrontIsConnected() {
  //     CdtFrontElement p = null;
  //     foreach(var cdtFrontElement of front) {
  //         if (p != null)
  //             Assert.assert(p.RightSite === cdtFrontElement.LeftSite);
  //         p = cdtFrontElement;
  //     }
  // }
  // #endif
  EdgeEvent(t) {
    Vt.EdgeIsProcessed(t) || (this.traversingEdge = t, this.runEdgeInserter());
  }
  static EdgeIsProcessed(t) {
    return t.CwTriangle != null || t.CcwTriangle != null;
  }
  ShowFrontWithSite(t, e = null) {
    const i = new Array();
    if (t.Edges != null)
      for (const s of t.Edges)
        i.push(q.mkDebugCurveTWCI(200, 0.8, s.constrained ? "Pink" : "Brown", v.mkPP(s.upperSite.point, s.lowerSite.point)));
    i.push(q.mkDebugCurveTWCI(200, 1, "Brown", j.mkFullEllipseNNP(0.5, 0.5, t.point)));
    for (const s of this.triangles)
      for (let n = 0; n < 3; n++) {
        const r = s.Edges.getItem(n);
        i.push(q.mkDebugCurveTWCI(r.constrained ? 155 : 100, r.constrained ? 0.8 : 0.4, r.constrained ? "Pink" : "Navy", v.mkPP(r.upperSite.point, r.lowerSite.point)));
      }
    if (e != null)
      for (const s of e)
        i.push(q.mkDebugCurveTWCI(100, 0.5, "Red", s));
    for (const s of this.front)
      i.push(q.mkDebugCurveTWCI(100, 5.5, "Green", v.mkPP(s.Edge.upperSite.point, s.Edge.lowerSite.point)));
  }
  Show(t) {
    Vt.ShowCdt(Array.from(this.triangles.values()), this.front, null, null, [], t);
  }
  static ShowCdt(t, e, i, s, n, r) {
    let a = new Array();
    if (i != null)
      for (const l of i)
        a.push(q.mkDebugCurveTWCI(200, 0.1, "Red", l));
    if (s != null)
      for (const l of s)
        a.push(q.mkDebugCurveTWCI(200, 0.1, "Blue", l));
    if (e != null)
      for (const l of e)
        a.push(q.mkDebugCurveTWCI(200, 0.1, "Green", v.mkPP(l.Edge.upperSite.point, l.Edge.lowerSite.point)));
    for (const l of t)
      for (let h = 0; h < 3; h++) {
        const c = l.Edges.getItem(h);
        a.push(Vt.GetDebugCurveOfCdtEdge(c));
      }
    a = a.concat(n);
  }
  static GetDebugCurveOfCdtEdge(t) {
    return t.CcwTriangle == null || t.CwTriangle == null ? q.mkDebugCurveTWCI(255, 0.5, t.constrained ? "Brown" : "Black", v.mkPP(t.upperSite.point, t.lowerSite.point)) : q.mkDebugCurveTWCI(200, t.constrained ? 0.8 : 0.2, t.constrained ? "Pink" : "Navy", v.mkPP(t.upperSite.point, t.lowerSite.point));
  }
  PointEvent(t) {
    const e = this.ProjectToFront(t), i = { rightSite: null }, s = e.item.x + m.distanceEpsilon < t.point.x ? this.MiddleCase(t, e, i) : this.LeftCase(t, e, i);
    let n = this.InsertSiteIntoFront(s, t, i.rightSite);
    this.TriangulateEmptySpaceToTheRight(n), n = Vt.FindNodeInFrontBySite(this.front, s), this.TriangulateEmptySpaceToTheLeft(n);
  }
  // #if TEST_MSAGL && TEST_MSAGL
  // void TestTriangles() {
  //     var usedSites = new Set<CdtSite>();
  //     foreach(var t of triangles)
  //     usedSites.InsertRange(t.Sites);
  //     foreach(var triangle of triangles) {
  //         TestTriangle(triangle, usedSites);
  //     }
  // }
  // void TestTriangle(CdtTriangle triangle, Set < CdtSite > usedSites) {
  //     var tsites = triangle.Sites;
  //     foreach(var site of usedSites) {
  //         if (!tsites.Contains(site)) {
  //             if (!SeparatedByConstrainedEdge(triangle, site) && InCircle(site, tsites[0], tsites[1], tsites[2])) {
  //                 Array < ICurve > redCurves=new Array<ICurve>();
  //                 redCurves.push(new Ellipse(2, 2, site.point));
  //                 Array < ICurve > blueCurves = new Array<ICurve>();
  //                 blueCurves.push(Circumcircle(tsites[0].point, tsites[1].point, tsites[2].point));
  //                 ShowFront(triangles, front, redCurves, blueCurves);
  //             }
  //         }
  //     }
  // }
  //         static bool SeparatedByConstrainedEdge(CdtTriangle triangle, CdtSite site) {
  //     for (int i = 0; i < 3; i++)
  //     if (SeparatedByEdge(triangle, i, site))
  //         return true;
  //     return false;
  // }
  //         static bool SeparatedByEdge(CdtTriangle triangle, int i, CdtSite site) {
  //     var e = triangle.Edges[i];
  //     var s = triangle.Sites.getItem(i + 2);
  //     var a0 = ApproximateComparer.Sign(Point.SignedDoubledTriangleArea(s.point, e.upperSite.point, e.lowerSite.point));
  //     var a1 = ApproximateComparer.Sign(Point.SignedDoubledTriangleArea(site.point, e.upperSite.point, e.lowerSite.point));
  //     return a0 * a1 <= 0;
  // }
  // #endif
  LeftCase(t, e, i) {
    const s = e.item;
    this.InsertAndLegalizeTriangle(t, s);
    const n = this.front.previous(e), r = n.item.LeftSite;
    return i.rightSite = e.item.RightSite, this.InsertAndLegalizeTriangle(t, n.item), this.front.deleteNodeInternal(n), this.front.remove(s), r;
  }
  MiddleCase(t, e, i) {
    const s = e.item.LeftSite;
    return i.rightSite = e.item.RightSite, this.InsertAndLegalizeTriangle(t, e.item), this.front.deleteNodeInternal(e), s;
  }
  TriangulateEmptySpaceToTheLeft(t) {
    const e = t.item.RightSite;
    let i = this.front.previous(t);
    for (; i != null; ) {
      const s = i.item, n = s.LeftSite, r = s.RightSite;
      if (r.point.sub(e.point).dot(n.point.sub(r.point)) < 0)
        t = this.ShortcutTwoFrontElements(i, t), i = this.front.previous(t);
      else {
        this.TryTriangulateBasinToTheLeft(t);
        break;
      }
    }
  }
  ShortcutTwoListElements(t) {
    var e;
    const i = t.Next;
    let s = se.mkSSSEE(t.Start, t.End, i.End, t.Edge, i.Edge, this.createEdgeDelegate);
    this.triangles.add(s);
    const n = s.Edges.getItem(2);
    this.LegalizeEdge(t.Start, s.OppositeEdge(t.Start)), s = (e = n.CcwTriangle) !== null && e !== void 0 ? e : n.CwTriangle, this.LegalizeEdge(i.End, s.OppositeEdge(i.End));
    const r = new Cl(n);
    return r.Start = t.Start, r.End = i.End, t.Prev.Next = r, r.Prev = t.Prev, r.Next = i.Next, i.Next.Prev = r, r;
  }
  // aNode is to the left of bNode, and they are consecutive
  ShortcutTwoFrontElements(t, e) {
    var i;
    const s = t.item, n = e.item;
    let r = se.mkSSSEED(s.LeftSite, s.RightSite, n.RightSite, s.Edge, n.Edge, this.createEdgeDelegate);
    this.triangles.add(r), this.front.deleteNodeInternal(t), this.front.remove(n);
    const a = r.Edges.getItem(2);
    return this.LegalizeEdge(s.LeftSite, r.OppositeEdge(s.LeftSite)), r = (i = a.CcwTriangle) !== null && i !== void 0 ? i : a.CwTriangle, this.LegalizeEdge(n.RightSite, r.OppositeEdge(n.RightSite)), this.front.insert(new Ts(s.LeftSite, a));
  }
  TryTriangulateBasinToTheLeft(t) {
    if (!Vt.DropsSharpEnoughToTheLeft(t.item))
      return;
    const e = new mt.Stack();
    for (e.push(t.item.LeftSite); ; ) {
      const i = e.pop();
      t = Vt.FindNodeInFrontBySite(this.front, i);
      const s = this.front.previous(t);
      if (s == null)
        return;
      if (u.getTriangleOrientation(s.item.LeftSite.point, t.item.LeftSite.point, t.item.RightSite.point) == L.Counterclockwise)
        e.push(s.item.LeftSite), this.ShortcutTwoFrontElements(s, t);
      else if (t.item.LeftSite.point.y > t.item.RightSite.point.y)
        e.push(s.item.LeftSite);
      else {
        if (s.item.LeftSite.point.y <= s.item.RightSite.point.y)
          return;
        e.push(s.item.LeftSite);
      }
    }
  }
  static DropsSharpEnoughToTheLeft(t) {
    const e = t.Edge;
    if (t.RightSite !== e.upperSite)
      return !1;
    const i = e.lowerSite.point.sub(e.upperSite.point);
    return i.x >= 0.5 * i.y;
  }
  InsertSiteIntoFront(t, e, i) {
    let s = null, n = null;
    for (const r of e.Edges)
      if (n == null && r.lowerSite === t && (n = r), s == null && r.lowerSite === i && (s = r), n != null && s != null)
        break;
    return this.front.insert(new Ts(t, n)), this.front.insert(new Ts(e, s));
  }
  TriangulateEmptySpaceToTheRight(t) {
    const i = t.item.LeftSite.point;
    let s = this.front.next(t);
    for (; s != null; ) {
      const n = s.item, r = n.LeftSite, a = n.RightSite;
      if (r.point.sub(i).dot(a.point.sub(r.point)) < 0)
        t = this.ShortcutTwoFrontElements(t, s), s = this.front.next(t);
      else {
        this.TryTriangulateBasinToTheRight(t);
        break;
      }
    }
  }
  TryTriangulateBasinToTheRight(t) {
    if (!Vt.DropsSharpEnoughToTheRight(t.item))
      return;
    const e = new mt.Stack();
    for (e.push(t.item.LeftSite); ; ) {
      const i = e.pop();
      t = Vt.FindNodeInFrontBySite(this.front, i);
      const s = this.front.next(t);
      if (s == null)
        return;
      if (u.getTriangleOrientation(t.item.LeftSite.point, t.item.RightSite.point, s.item.RightSite.point) == L.Counterclockwise)
        this.ShortcutTwoFrontElements(t, s), e.push(i);
      else if (t.item.LeftSite.point.y > t.item.RightSite.point.y)
        e.push(t.item.RightSite);
      else {
        if (s.item.LeftSite.point.y >= s.item.RightSite.point.y)
          return;
        e.push(t.item.RightSite);
      }
    }
  }
  static DropsSharpEnoughToTheRight(t) {
    const e = t.Edge;
    if (t.LeftSite !== e.upperSite)
      return !1;
    const i = e.lowerSite.point.sub(e.upperSite.point);
    return i.x <= -0.5 * i.y;
  }
  static FindNodeInFrontBySite(t, e) {
    return t.findLast((i) => i.LeftSite.point.x <= e.point.x);
  }
  InsertAndLegalizeTriangle(t, e) {
    var i;
    if (u.getTriangleOrientation(t.point, e.LeftSite.point, e.RightSite.point) !== L.Collinear) {
      const s = se.mkSED(t, e.Edge, this.createEdgeDelegate);
      this.triangles.add(s), this.LegalizeEdge(t, s.Edges.getItem(0));
    } else {
      const s = e.Edge;
      _o(s.upperSite.Edges, s);
      let n = (i = s.CcwTriangle) !== null && i !== void 0 ? i : s.CwTriangle;
      const r = n.OppositeSite(s);
      Vt.RemoveTriangleButLeaveEdges(this.triangles, n), n = se.mkSSSD(e.LeftSite, r, t, this.createEdgeDelegate);
      const a = se.mkSSSD(e.RightSite, r, t, this.createEdgeDelegate);
      this.triangles.add(n), this.triangles.add(a), this.LegalizeEdge(t, n.OppositeEdge(t)), this.LegalizeEdge(t, a.OppositeEdge(t));
    }
  }
  LegalizeEdge(t, e) {
    e.constrained || e.CcwTriangle == null || e.CwTriangle == null || (e.CcwTriangle.Contains(t) ? this.LegalizeEdgeForOtherCwTriangle(t, e) : this.LegalizeEdgeForOtherCcwTriangle(t, e));
  }
  LegalizeEdgeForOtherCwTriangle(t, e) {
    const i = e.CwTriangle.Edges.index(e);
    if (Il(t, e.upperSite, e.CwTriangle.Sites.getItem(i + 2), e.lowerSite)) {
      const s = wl(t, e);
      this.LegalizeEdge(t, s.CwTriangle.OppositeEdge(t)), this.LegalizeEdge(t, s.CcwTriangle.OppositeEdge(t));
    }
  }
  LegalizeEdgeForOtherCcwTriangle(t, e) {
    const i = e.CcwTriangle.Edges.index(e);
    if (Il(t, e.lowerSite, e.CcwTriangle.Sites.getItem(i + 2), e.upperSite)) {
      const s = wl(t, e);
      this.LegalizeEdge(t, s.CwTriangle.OppositeEdge(t)), this.LegalizeEdge(t, s.CcwTriangle.OppositeEdge(t));
    }
  }
  // #if TEST_MSAGL && TEST_MSAGL
  // Array < DebugCurve > ShowIllegalEdge(CdtEdge edge, CdtSite pi, int i) {
  //     Array < DebugCurve > ls = new Array<DebugCurve>();
  //     ls.push(DebugCurve.mkDebugCurveTWCI(new Ellipse(2, 2, pi.point)));
  //     for (int j = 0; j < 3; j++) {
  //         var ee = edge.CcwTriangle.Edges[j];
  //         ls.push(DebugCurve.mkDebugCurveTWCI(j === i ? "red" : "blue", LineSegment.mkPP(ee.upperSite.point, ee.lowerSite.point)));
  //     }
  //     ls.push(DebugCurve.mkDebugCurveTWCI(100, 1, "black", Circumcircle(edge.CcwTriangle.Sites.getItem(0].point, edge.CcwTriangle.Sites[1].point, edge.CcwTriangle.Sites[2).point)));
  //     LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(ls);
  //     return ls;
  // }
  //         static Ellipse Circumcircle(Point a, Point b, Point c) {
  //     var mab = 0.5 * (a + b);
  //     var mbc = 0.5 * (c + b);
  //     Point center;
  //     Point.LineLineIntersection(mab, mab + (b - a).Rotate(Math.PI / 2), mbc, mbc + (b - c).Rotate(Math.PI / 2), out center);
  //     var r = (center - a).Length;
  //     return new Ellipse(r, r, center);
  // }
  // #endif
  ProjectToFront(t) {
    return this.front.findLast((e) => e.x <= t.point.x);
  }
  runEdgeInserter() {
    this.initEdgeInserter(), this.TraceEdgeThroughTriangles(), this.TriangulatePolygon0(this.rightPolygon, this.traversingEdge.upperSite, this.traversingEdge.lowerSite, !0), this.TriangulatePolygon0(this.leftPolygon, this.traversingEdge.upperSite, this.traversingEdge.lowerSite, !1), this.UpdateFront();
  }
  initEdgeInserter() {
    this.rightPolygon = new Array(), this.leftPolygon = new Array(), this.addedTriangles = new Array(), this.piercedEdge = null, this.piercedTriangle = null, this.piercedToTheLeftFrontElemNode = null, this.piercedToTheRightFrontElemNode = null;
  }
  UpdateFront() {
    const t = /* @__PURE__ */ new Set();
    for (const e of this.addedTriangles)
      for (const i of e.Edges)
        if (i.CwTriangle == null || i.CcwTriangle == null) {
          if (i.lowerSite == this.p_2 && i.upperSite == this.p_1)
            continue;
          t.add(i);
        }
    for (const e of t)
      this.AddEdgeToFront(e);
  }
  AddEdgeToFront(t) {
    const e = t.upperSite.point.x < t.lowerSite.point.x ? t.upperSite : t.lowerSite;
    this.front.insert(new Ts(e, t));
  }
  TriangulatePolygon0(t, e, i, s) {
    t.length > 0 && this.TriangulatePolygon1(0, t.length - 1, t, e, i, s);
  }
  TriangulatePolygon1(t, e, i, s, n, r) {
    let a = i[t], l = t;
    for (let d = t + 1; d <= e; d++) {
      const f = i[d];
      c(f) && (l = d, a = f);
    }
    const h = se.mkSSSD(s, n, a, this.createEdgeDelegate);
    this.triangles.add(h), this.addedTriangles.push(h), t < l && this.TriangulatePolygon1(t, l - 1, i, s, a, r), l < e && this.TriangulatePolygon1(l + 1, e, i, a, n, r);
    function c(d) {
      return r ? Wo(d, s, a, n) : Wo(d, s, n, a);
    }
  }
  TraceEdgeThroughTriangles() {
    this.initEdgeTracer(), this.Traverse();
  }
  Traverse() {
    for (; !this.BIsReached(); )
      this.piercedToTheLeftFrontElemNode != null ? this.ProcessLeftFrontPiercedElement() : this.piercedToTheRightFrontElemNode != null ? this.ProcessRightFrontPiercedElement() : this.ProcessPiercedEdge();
    this.piercedTriangle != null && this.removePiercedTriangle(this.piercedTriangle), this.FindMoreRemovedFromFrontElements();
    for (const t of this.elementsToBeRemovedFromFront)
      this.front.remove(t);
  }
  ProcessLeftFrontPiercedElement() {
    let t = this.piercedToTheLeftFrontElemNode;
    do
      this.elementsToBeRemovedFromFront.push(t.item), this.AddSiteToLeftPolygon(t.item.LeftSite), t = this.front.previous(t);
    while (u.pointToTheLeftOfLine(t.item.LeftSite.point, this.a.point, this.b.point));
    if (this.elementsToBeRemovedFromFront.push(t.item), this.AddSiteToRightPolygon(t.item.LeftSite), t.item.LeftSite === this.b) {
      this.piercedToTheLeftFrontElemNode = t;
      return;
    }
    this.FindPiercedTriangle(t), this.piercedToTheLeftFrontElemNode = null;
  }
  FindPiercedTriangle(t) {
    var e;
    const i = t.item.Edge, s = (e = i.CcwTriangle) !== null && e !== void 0 ? e : i.CwTriangle, n = s.Edges.index(i);
    for (let r = 1; r <= 2; r++) {
      const a = s.Edges.getItem(r + n), l = zi.sign(u.signedDoubledTriangleArea(a.lowerSite.point, this.a.point, this.b.point));
      if (zi.sign(u.signedDoubledTriangleArea(a.upperSite.point, this.a.point, this.b.point)) * l <= 0) {
        this.piercedTriangle = s, this.piercedEdge = a;
        break;
      }
    }
  }
  FindMoreRemovedFromFrontElements() {
    for (const t of this.removedTriangles)
      for (const e of t.Edges)
        if (e.CcwTriangle == null && e.CwTriangle == null) {
          const i = e.upperSite.point.x < e.lowerSite.point.x ? e.upperSite : e.lowerSite, s = Vt.FindNodeInFrontBySite(this.front, i);
          s.item.Edge === e && this.elementsToBeRemovedFromFront.push(s.item);
        }
  }
  ProcessPiercedEdge() {
    this.piercedEdge.CcwTriangle === this.piercedTriangle ? (this.AddSiteToLeftPolygon(this.piercedEdge.lowerSite), this.AddSiteToRightPolygon(this.piercedEdge.upperSite)) : (this.AddSiteToLeftPolygon(this.piercedEdge.upperSite), this.AddSiteToRightPolygon(this.piercedEdge.lowerSite)), this.removePiercedTriangle(this.piercedTriangle), this.PrepareNextStateAfterPiercedEdge();
  }
  PrepareNextStateAfterPiercedEdge() {
    var t, e;
    const i = (t = this.piercedEdge.CwTriangle) !== null && t !== void 0 ? t : this.piercedEdge.CcwTriangle, s = i.Edges.index(this.piercedEdge);
    for (let n = 1; n <= 2; n++) {
      const r = i.Edges.getItem(n + s), a = zi.sign(u.signedDoubledTriangleArea(r.lowerSite.point, this.a.point, this.b.point));
      if (zi.sign(u.signedDoubledTriangleArea(r.upperSite.point, this.a.point, this.b.point)) * a <= 0) {
        if (r.CwTriangle != null && r.CcwTriangle != null) {
          this.piercedTriangle = i, this.piercedEdge = r;
          break;
        }
        this.piercedTriangle = null, this.piercedEdge = null;
        const h = r.upperSite.point.x < r.lowerSite.point.x ? r.upperSite : r.lowerSite, c = Vt.FindNodeInFrontBySite(this.front, h);
        h.point.x < this.a.point.x ? this.piercedToTheLeftFrontElemNode = c : this.piercedToTheRightFrontElemNode = c, this.removePiercedTriangle((e = r.CwTriangle) !== null && e !== void 0 ? e : r.CcwTriangle);
        break;
      }
    }
  }
  removePiercedTriangle(t) {
    this.triangles.delete(t);
    for (const e of t.Edges)
      e.CwTriangle === t ? e.CwTriangle = null : e.CcwTriangle = null, this.removedTriangles.push(t);
  }
  ProcessRightFrontPiercedElement() {
    let t = this.piercedToTheRightFrontElemNode;
    do
      this.elementsToBeRemovedFromFront.push(t.item), this.AddSiteToRightPolygon(t.item.RightSite), t = this.front.next(t);
    while (u.pointToTheRightOfLine(t.item.RightSite.point, this.a.point, this.b.point));
    if (this.elementsToBeRemovedFromFront.push(t.item), this.AddSiteToLeftPolygon(t.item.RightSite), t.item.RightSite === this.b) {
      this.piercedToTheRightFrontElemNode = t;
      return;
    }
    this.FindPiercedTriangle(t), this.piercedToTheRightFrontElemNode = null;
  }
  AddSiteToLeftPolygon(t) {
    this.AddSiteToPolygonWithCheck(t, this.leftPolygon);
  }
  AddSiteToPolygonWithCheck(t, e) {
    t !== this.b && (e.length === 0 || e[e.length - 1] !== t) && e.push(t);
  }
  AddSiteToRightPolygon(t) {
    this.AddSiteToPolygonWithCheck(t, this.rightPolygon);
  }
  BIsReached() {
    var t;
    const e = (t = this.piercedToTheLeftFrontElemNode) !== null && t !== void 0 ? t : this.piercedToTheRightFrontElemNode;
    return e != null ? e.item.Edge.IsAdjacent(this.b) : this.piercedEdge.IsAdjacent(this.b);
  }
  initEdgeTracer() {
    this.elementsToBeRemovedFromFront = [], this.a = this.traversingEdge.upperSite, this.b = this.traversingEdge.lowerSite, this.removedTriangles = [];
    const t = Vt.FindNodeInFrontBySite(this.front, this.a), e = this.front.previous(t);
    if (u.pointToTheLeftOfLine(this.b.point, e.item.LeftSite.point, e.item.RightSite.point))
      this.piercedToTheLeftFrontElemNode = e;
    else if (u.pointToTheRightOfLine(this.b.point, t.item.RightSite.point, t.item.LeftSite.point))
      this.piercedToTheRightFrontElemNode = t;
    else
      for (const i of this.a.Edges) {
        const s = i.CcwTriangle;
        if (s == null || u.pointToTheLeftOfLine(this.b.point, i.lowerSite.point, i.upperSite.point))
          continue;
        const n = s.Edges.index(i), r = s.Sites.getItem(n + 2);
        if (u.pointToTheLeftOfLineOrOnLine(this.b.point, r.point, i.upperSite.point)) {
          this.piercedEdge = s.Edges.getItem(n + 1), this.piercedTriangle = s;
          break;
        }
      }
  }
}
function _o(o, t) {
  if (o.length === 0)
    return;
  const e = o.findIndex((i) => t === i);
  e >= 0 && (e !== o.length - 1 && (o[e] = o[o.length - 1]), o.pop());
}
function Il(o, t, e, i) {
  return Nf(o, t, e, i) && Wo(o, t, e, i);
}
function Nf(o, t, e, i) {
  return u.getTriangleOrientation(t.point, o.point, e.point) === L.Clockwise && u.getTriangleOrientation(e.point, o.point, i.point) === L.Clockwise;
}
function Wo(o, t, e, i) {
  const s = t.point.x - o.point.x, n = t.point.y - o.point.y, r = e.point.x - o.point.x, a = e.point.y - o.point.y, l = i.point.x - o.point.x, h = i.point.y - o.point.y, c = s * s + n * n, d = r * r + a * a, f = l * l + h * h;
  return s * (a * f - h * d) - r * (n * f - h * c) + l * (n * d - a * c) > m.tolerance;
}
function wl(o, t) {
  let e, i;
  t.CcwTriangle.Contains(o) ? (e = t.CcwTriangle, i = t.CwTriangle) : (e = t.CwTriangle, i = t.CcwTriangle);
  const s = e.Edges.index(t), n = i.Edges.index(t), r = i.Sites.getItem(n + 2), a = e.Edges.getItem(s + 1), l = i.Edges.getItem(n + 1), h = gt.GetOrCreateEdge(o, r);
  return e.Sites.setItem(s + 1, r), e.Edges.setItem(s, l), e.Edges.setItem(s + 1, h), i.Sites.setItem(n + 1, o), i.Edges.setItem(n, a), i.Edges.setItem(n + 1, h), l.lowerSite === r ? l.CcwTriangle = e : l.CwTriangle = e, a.lowerSite === o ? a.CcwTriangle = i : a.CwTriangle = i, h.upperSite === o ? (h.CcwTriangle = i, h.CwTriangle = e) : (h.CcwTriangle = e, h.CwTriangle = i), _o(t.upperSite.Edges, t), h;
}
class gt extends lt {
  // constructor
  constructor(t, e, i) {
    super(null), this.isolatedSites = [], this.obstacles = [], this.PointsToSites = new ii(), this.simplifyObstacles = !0, this.rectangleNodeOnTriangles = null, this.isolatedSites = t, this.obstacles = e, this.isolatedSegments = i;
  }
  // constructor
  static constructor_(t) {
    const e = new gt(null, null, null);
    return e.isolatedSitesWithObject = t, e;
  }
  FillAllInputSites() {
    if (this.isolatedSitesWithObject != null)
      for (const t of this.isolatedSitesWithObject)
        this.AddSite(t[0], t[1]);
    if (this.isolatedSites != null)
      for (const t of this.isolatedSites)
        this.AddSite(t, null);
    if (this.obstacles != null)
      for (const t of this.obstacles)
        this.AddPolylineToAllInputSites(t);
    if (this.isolatedSegments != null)
      for (const t of this.isolatedSegments)
        this.AddConstrainedEdge(t.A, t.B, null);
    this.AddP1AndP2(), this.allInputSites = Array.from(this.PointsToSites.values());
  }
  AddSite(t, e) {
    let i;
    return (i = this.PointsToSites.get(t)) ? i.Owner = e : (i = In.mkSO(t, e), this.PointsToSites.set(t, i)), i;
  }
  AddP1AndP2() {
    const t = T.mkEmpty();
    for (const i of this.PointsToSites.keys())
      t.add(i);
    const e = 10;
    this.P1 = new In(t.leftBottom.add(new u(-e, -10))), this.P2 = new In(t.rightBottom.add(new u(e, -10)));
  }
  AddPolylineToAllInputSites(t) {
    if (this.simplifyObstacles)
      for (let e = t.startPoint; e != null; ) {
        const i = e.point;
        if (e = e.next, !e)
          break;
        for (; e.next && u.getTriangleOrientation(i, e.point, e.next.point) === L.Collinear; )
          e = e.next;
        this.AddConstrainedEdge(i, e.point, t);
      }
    else
      for (let e = t.startPoint; e.next != null; e = e.next)
        this.AddConstrainedEdge(e.point, e.next.point, t);
    t.closed && this.AddConstrainedEdge(t.endPoint.point, t.startPoint.point, t);
  }
  AddConstrainedEdge(t, e, i) {
    const s = gt.AbovePP(t, e);
    let n, r;
    s > 0 ? (n = this.AddSite(t, i), r = this.AddSite(e, i)) : (n = this.AddSite(e, i), r = this.AddSite(t, i));
    const a = gt.CreateEdgeOnOrderedCouple(n, r);
    a.constrained = !0;
  }
  static GetOrCreateEdge(t, e) {
    if (gt.AboveCC(t, e) === 1) {
      const i = t.EdgeBetweenUpperSiteAndLowerSite(e);
      return i ?? gt.CreateEdgeOnOrderedCouple(t, e);
    } else {
      const i = e.EdgeBetweenUpperSiteAndLowerSite(t);
      return i ?? gt.CreateEdgeOnOrderedCouple(e, t);
    }
  }
  static CreateEdgeOnOrderedCouple(t, e) {
    return new Rf(t, e);
  }
  GetTriangles() {
    return this.sweeper.triangles;
  }
  // Executes the actual algorithm.
  run() {
    this.Initialization(), this.SweepAndFinalize();
  }
  SweepAndFinalize() {
    this.sweeper = new Vt(this.allInputSites, this.P1, this.P2, gt.GetOrCreateEdge), this.sweeper.run(), this.cleanRemovedEdges();
  }
  cleanRemovedEdges() {
    for (const t of this.PointsToSites.values())
      t.cleanRemovedEdges();
  }
  Initialization() {
    this.FillAllInputSites(), this.allInputSites.sort(gt.OnComparison);
  }
  static OnComparison(t, e) {
    return gt.AboveCC(t, e);
  }
  // compare first y then -x coordinates
  static AbovePP(t, e) {
    let i = t.y - e.y;
    return i > 0 ? 1 : i < 0 ? -1 : (i = t.x - e.x, i > 0 ? -1 : i < 0 ? 1 : 0);
  }
  // compare first y then -x coordinates
  static AboveCC(t, e) {
    return gt.AbovePP(t.point, e.point);
  }
  RestoreEdgeCapacities() {
    for (const t of this.allInputSites)
      for (const e of t.Edges)
        e.constrained || (e.ResidualCapacity = e.Capacity);
  }
  SetInEdges() {
    for (const t of this.PointsToSites.values())
      for (const e of t.Edges)
        e.lowerSite.AddInEdge(e);
  }
  FindSite(t) {
    return this.PointsToSites.get(t);
  }
  static PointIsInsideOfTriangle(t, e) {
    for (let i = 0; i < 3; i++) {
      const s = e.Sites.getItem(i).point, n = e.Sites.getItem(i + 1).point;
      if (u.signedDoubledTriangleArea(t, s, n) < m.distanceEpsilon * -1)
        return !1;
    }
    return !0;
  }
  getRectangleNodeOnTriangles() {
    return this.rectangleNodeOnTriangles == null && (this.rectangleNodeOnTriangles = wt(Array.from(this.GetTriangles().values()).map((t) => Nt(t, t.BoundingBox())))), this.rectangleNodeOnTriangles;
  }
}
function Uh(o) {
  const t = Array.from(o.GetAllLeaves()), e = o.irect, i = e.diagonal / 4, s = e.clone();
  return s.pad(i), Bf(t.concat([s.perimeter()]));
}
function Bf(o) {
  const t = new gt(null, o, null);
  return t.run(), t;
}
class wn {
  // constructor
  constructor(t, e) {
    this.start = t, this.end = e;
  }
  add(t) {
    this.add_d(t);
  }
  add_rect(t) {
    const e = t, i = this.clone();
    return i.add_d(e.start), i.add_d(e.end), i;
  }
  clone() {
    return new wn(this.start, this.end);
  }
  contains_point(t) {
    return this.contains_d(t);
  }
  contains_rect(t) {
    const e = t;
    return this.contains_d(e.start) && this.contains_d(e.end);
  }
  intersection_rect(t) {
    const e = t;
    return new wn(Math.max(this.start, e.start), Math.min(this.end, e.end));
  }
  intersects_rect(t) {
    const e = t;
    return this.intersects(e);
  }
  contains_point_radius(t, e) {
    return this.contains_d(t - e) && this.contains_d(t + e);
  }
  //
  static mkInterval(t, e) {
    const i = new wn(t.start, t.end);
    return i.add_d(e.start), i.add_d(e.end), i;
  }
  // expanding the range to hold v
  add_d(t) {
    this.start > t && (this.start = t), this.end < t && (this.end = t);
  }
  get Start() {
    return this.start;
  }
  set Start(t) {
    this.start = t;
  }
  // the length
  get Length() {
    return this.end - this.start;
  }
  // return true if the value is inside the range
  contains_d(t) {
    return this.start <= t && t <= this.end;
  }
  // bringe v into the range
  GetInRange(t) {
    return t < this.start ? this.start : t > this.end ? this.end : t;
  }
  // returns true if and only if two intervals are intersecting
  intersects(t) {
    return t.start > this.end + m.distanceEpsilon ? !1 : !(t.end < this.start - m.distanceEpsilon);
  }
}
class Xh {
  get Count() {
    return this.heapSize;
  }
  // the constructor
  // we assume that all integers inserted into the queue will be non-negative and less then n
  constructor(t) {
    this.heapSize = 0, this._priors = new Array(t), this._heap = new Array(t + 1), this._reverse_heap = new Array(t);
  }
  SwapWithParent(t) {
    const e = this._heap[t >> 1];
    this.PutAtI(t >> 1, this._heap[t]), this.PutAtI(t, e);
  }
  Enqueue(t, e) {
    this.heapSize++;
    let i = this.heapSize;
    for (this._priors[t] = e, this.PutAtI(i, t); i > 1 && this._priors[this._heap[i >> 1]] > e; )
      this.SwapWithParent(i), i >>= 1;
  }
  PutAtI(t, e) {
    this._heap[t] = e, this._reverse_heap[e] = t;
  }
  // return the first element of the queue and removes it from the queue
  Dequeue() {
    if (this.heapSize === 0)
      throw new Error();
    const t = this._heap[1];
    if (this.heapSize > 1) {
      this.PutAtI(1, this._heap[this.heapSize]);
      let e = 1;
      for (; ; ) {
        let i = e;
        const s = e << 1;
        s <= this.heapSize && this._priors[this._heap[s]] < this._priors[this._heap[e]] && (i = s);
        const n = s + 1;
        if (n <= this.heapSize && this._priors[this._heap[n]] < this._priors[this._heap[i]] && (i = n), i !== e)
          this.SwapWithParent(i);
        else
          break;
        e = i;
      }
    }
    return this.heapSize--, t;
  }
  IsEmpty() {
    return this.heapSize === 0;
  }
  DecreasePriority(t, e) {
    this._priors[t] = e;
    let i = this._reverse_heap[t];
    for (; i > 1 && this._priors[this._heap[i]] < this._priors[this._heap[i >> 1]]; ) {
      this.SwapWithParent(i);
      i >>= 1;
    }
  }
}
class Mf {
  constructor(t, e, i, s) {
    this._numberOfOverlaps = 0, this._proximityEdges = t, this._nodeSizes = e, this._nodePositions = i, this._forLayers = s, this._q = new Xh(e.length * 2);
  }
  Run() {
    return this.InitQueue(), this.FindOverlaps(), this._numberOfOverlaps;
  }
  FindOverlaps() {
    for (; this._q.Count > 0; ) {
      let t = this._q.Dequeue();
      t < this._nodePositions.length ? (this.FindOverlapsWithInterval(t), this.AddIntervalToTree(t)) : (t -= this._nodePositions.length, this.RemoveIntervalFromTree(t));
    }
  }
  RemoveIntervalFromTree(t) {
    this._intervalTree.Remove(this.GetInterval(t), t);
  }
  AddIntervalToTree(t) {
    const e = this.GetInterval(t);
    this._intervalTree == null && (this._intervalTree = Pn([])), this._intervalTree.Add(e, t);
  }
  FindOverlapsWithInterval(t) {
    if (this._intervalTree == null)
      return;
    const e = this.GetInterval(t);
    for (const i of this._intervalTree.GetAllIntersecting(e)) {
      const s = qe.GetIdealEdge(t, i, this._nodePositions[t], this._nodePositions[i], this._nodeSizes);
      if (s.overlapFactor <= 1)
        return;
      this._proximityEdges.push(s), this._numberOfOverlaps++;
    }
  }
  GetInterval(t) {
    const e = this._nodeSizes[t].width / 2, i = this._nodePositions[t].x;
    return new wn(i - e, i + e);
  }
  InitQueue() {
    for (let t = 0; t < this._nodeSizes.length; t++) {
      const e = this._nodeSizes[t].height / 2, i = this._nodePositions[t].y;
      this._q.Enqueue(t, i - e), this._q.Enqueue(this._nodeSizes.length + t, i + e);
    }
  }
}
class El {
  constructor(t, e, i) {
    this.treeNodes = /* @__PURE__ */ new Set(), this.hedgehog = /* @__PURE__ */ new Map(), this.graph = t, this.weight = e, this.root = i, this.q = new Xh(this.graph.nodeCount);
  }
  NodeIsInTree(t) {
    return this.treeNodes.has(t);
  }
  GetTreeEdges() {
    const t = new Array();
    for (this.Init(); t.length < this.graph.nodeCount - 1 && this.q.Count > 0; )
      this.AddEdgeToTree(t);
    return t;
  }
  AddEdgeToTree(t) {
    const e = this.q.Dequeue(), i = this.hedgehog.get(e);
    this.treeNodes.add(e), t.push(i), this.UpdateOutEdgesOfV(e), this.UpdateInEdgesOfV(e);
  }
  UpdateOutEdgesOfV(t) {
    for (const e of this.graph.outEdges[t]) {
      const i = e.target;
      if (this.NodeIsInTree(i))
        continue;
      const s = this.hedgehog.get(i);
      if (s) {
        const n = this.weight(s), r = this.weight(e);
        r < n && (this.q.DecreasePriority(i, r), this.hedgehog.set(i, e));
      } else
        this.q.Enqueue(i, this.weight(e)), this.hedgehog.set(i, e);
    }
  }
  UpdateInEdgesOfV(t) {
    for (const e of this.graph.inEdges[t]) {
      const i = e.source;
      if (this.NodeIsInTree(i))
        continue;
      const s = this.hedgehog.get(i);
      if (s) {
        const n = this.weight(s), r = this.weight(e);
        r < n && (this.q.DecreasePriority(i, r), this.hedgehog.set(i, e));
      } else
        this.q.Enqueue(i, this.weight(e)), this.hedgehog.set(i, e);
    }
  }
  Init() {
    this.treeNodes.add(this.root);
    for (const t of this.graph.outEdges[this.root]) {
      const e = this.weight(t);
      this.q.Enqueue(t.target, e), this.hedgehog.set(t.target, t);
    }
    for (const t of this.graph.inEdges[this.root]) {
      const e = this.weight(t);
      this.q.Enqueue(t.source, e), this.hedgehog.set(t.source, t);
    }
  }
}
class ya {
  // Computes the minimum spanning tree on a set of edges
  static GetMst(t, e) {
    if (t.length === 0)
      return null;
    const i = t.map((a) => new U(a.source, a.target)), s = new Ji();
    for (let a = 0; a < t.length; a++)
      s.setPair(i[a], t[a]);
    const n = fi(i, e);
    return new El(n, (a) => s.get(a.source, a.target).weight, i[0].source).GetTreeEdges().map((a) => s.get(a.source, a.target));
  }
  // Computes the minimum spanning tree on a DT with given weights.
  static GetMstOnCdt(t, e) {
    const i = Array.from(t.PointsToSites.values()), s = /* @__PURE__ */ new Map();
    for (let l = 0; l < i.length; l++)
      s.set(i[l], l);
    const n = ya.GetEdges(i, s), r = Wh(Array.from(n.keys()));
    return new El(r, (l) => e(n.get(l.source, l.target)), 0).GetTreeEdges().map((l) => n.get(l.source, l.target));
  }
  static GetEdges(t, e) {
    const i = new Ji();
    for (let s = 0; s < t.length; s++) {
      const n = t[s], r = e.get(n);
      for (const a of n.Edges)
        i.set(r, e.get(a.lowerSite), a);
    }
    return i;
  }
}
class ba {
  constructor() {
    this.epsilon = 0.01, this.iterationsMax = 1e3, this.stopOnMaxIterat = !1, this.nodeSeparation = 4, this.randomizationSeed = 1, this.randomizationShift = 0.1;
  }
  // If true, the overlap iteration process stops after maxIterat iterations.
  get StopOnMaxIterat() {
    return this.stopOnMaxIterat;
  }
  set StopOnMaxIterat(t) {
    this.stopOnMaxIterat = t;
  }
  // Epsilon
  get Epsilon() {
    return this.epsilon;
  }
  set Epsilon(t) {
    this.epsilon = t;
  }
  // Number of maxIterat to be made. In each iteration overlap is partly removed.
  get IterationsMax() {
    return this.iterationsMax;
  }
  set IterationsMax(t) {
    this.iterationsMax = t;
  }
  // Minimal distance between nodes.
  get NodeSeparation() {
    return this.nodeSeparation;
  }
  set NodeSeparation(t) {
    this.nodeSeparation = t;
  }
  //
  get RandomizationSeed() {
    return this.randomizationSeed;
  }
  set RandomizationSeed(t) {
    this.randomizationSeed = t;
  }
  //
  get RandomizationShift() {
    return this.randomizationShift;
  }
  set RandomizationShift(t) {
    this.randomizationShift = t;
  }
  // Clones the settings together with the stressmajorization settings
  Clone() {
    const t = new ba();
    return t.Epsilon = this.Epsilon, t.IterationsMax = this.IterationsMax, t.StopOnMaxIterat = this.StopOnMaxIterat, t.NodeSeparation = this.NodeSeparation, t.RandomizationSeed = this.RandomizationSeed, t.RandomizationShift = this.randomizationShift, t;
  }
}
class qe {
  // Settings to be used for the overlap removal, not all of them are used.
  constructor(t, e) {
    this._settings = t, this._nodes = e;
  }
  // Removes the overlap by using the default settings.
  static RemoveOverlaps(t, e) {
    const i = new ba();
    i.RandomizationShift = 1, i.NodeSeparation = e, new qe(i, t).RemoveOverlaps();
  }
  // Removes the overlaps for the given graph.
  RemoveOverlaps() {
    if (this._nodes.length < 3) {
      this.RemoveOverlapsOnTinyGraph();
      return;
    }
    const t = { nodePositions: new Array(), nodeSizes: new Array() };
    for (Gf(this._settings, this._nodes, t, this._settings.RandomizationShift), this.lastRunNumberIterations = 0; this.OneIteration(t.nodePositions, t.nodeSizes, !1); )
      this.lastRunNumberIterations++;
    for (; this.OneIteration(t.nodePositions, t.nodeSizes, !0); )
      this.lastRunNumberIterations++;
    for (let e = 0; e < this._nodes.length; e++)
      this._nodes[e].center = t.nodePositions[e];
  }
  RemoveOverlapsOnTinyGraph() {
    if (this._nodes.length !== 1 && this._nodes.length === 2) {
      const t = this._nodes[0], e = this._nodes[1];
      u.closeDistEps(t.center, e.center) && (e.center = e.center.add(new u(1e-3, 0)));
      const i = this.GetIdealDistanceBetweenTwoNodes(t, e), s = u.middle(t.center, e.center);
      let n = t.center.sub(e.center);
      const r = n.length;
      n = n.mul(0.5 * (i / r)), t.center = s.add(n), e.center = s.sub(n);
    }
  }
  GetIdealDistanceBetweenTwoNodes(t, e) {
    const i = t.center.sub(e.center), s = Math.abs(i.x), n = Math.abs(i.y), r = (t.width + e.width) / 2 + this._settings.NodeSeparation, a = (t.height + e.height) / 2 + this._settings.NodeSeparation;
    let l = Number.POSITIVE_INFINITY, h = Number.POSITIVE_INFINITY;
    return s > m.tolerance && (l = r / s), n > m.tolerance && (h = a / n), Math.min(l, h) * i.length;
  }
  static AvgEdgeLength(t) {
    let e = 0, i = 0;
    for (const s of t)
      for (const n of s.outEdges())
        i += s.center.sub(n.target.center).length, e++;
    return e > 0 ? i / e : 1;
  }
  // Does one iterations in which a miniminum spanning tree is
  // determined on the delaunay triangulation and finally the tree is extended to resolve the overlaps.
  OneIteration(t, e, i) {
    const s = new Array();
    for (let c = 0; c < t.length; c++)
      s.push([t[c], c]);
    const n = gt.constructor_(s);
    n.run();
    const r = /* @__PURE__ */ new Map();
    for (let c = 0; c < t.length; c++)
      r.set(n.PointsToSites.get(t[c]), c);
    let a = 0;
    const l = new Array();
    for (const c of n.PointsToSites.values())
      for (const d of c.Edges) {
        const f = d.upperSite.point, p = d.lowerSite.point, P = r.get(d.upperSite), y = r.get(d.lowerSite), C = qe.GetIdealEdge(P, y, f, p, e);
        l.push(C), C.overlapFactor > 1 && a++;
      }
    if (a === 0 || i) {
      const c = this.FindProximityEdgesWithSweepLine(l, e, t);
      if (a === 0 && c === 0 || a === 0 && !i)
        return !1;
    }
    const h = ya.GetMst(l, t.length);
    return qe.MoveNodePositions(h, t, h[0].source), !0;
  }
  FindProximityEdgesWithSweepLine(t, e, i) {
    return new Mf(t, e, i, this._overlapForLayers).Run();
  }
  // Returns an edge with: i, j, t(overlapFactor), ideal distance, edge weight.
  static GetIdealEdge(t, e, i, s, n) {
    const r = { overlapFactor: 0 }, a = qe.GetIdealEdgeLength(t, e, i, s, n, r), l = i.sub(s).length, h = T.mkSizeCenter(n[t], i), c = T.mkSizeCenter(n[e], s), d = r.overlapFactor > 1 ? l - a : qe.GetDistanceRects(h, c);
    return {
      source: Math.min(t, e),
      target: Math.max(t, e),
      overlapFactor: r.overlapFactor,
      idealDistance: a,
      weight: d
    };
  }
  // Returns the ideal edge length, such that the overlap is removed.
  static GetIdealEdgeLength(t, e, i, s, n, r) {
    const a = i.sub(s), l = a.length, h = Math.abs(a.x), c = Math.abs(a.y), d = (n[t].width + n[e].width) / 2, f = (n[t].height + n[e].height) / 2;
    if (h >= d || c >= f)
      return r.overlapFactor = 1, a.length;
    let p;
    const P = 1e-10;
    if (h > P)
      c > P ? p = Math.min(d / h, f / c) : p = d / h;
    else if (c > P)
      p = f / c;
    else
      return r.overlapFactor = 2, Math.sqrt(d * d + f * f) / 4;
    return p = Math.max(p, 1.001), r.overlapFactor = p, p * l;
  }
  // Returns the distance between two given rectangles or zero if they intersect.
  static GetDistanceRects(t, e) {
    if (t.intersects(e))
      return 0;
    let i = 0, s = 0;
    return (t.right < e.left || e.right < t.left) && (s = t.left - e.right), t.top < e.bottom ? i = e.bottom - t.top : e.top < t.bottom && (i = t.bottom - e.top), Math.sqrt(s * s + i * i);
  }
  /*
    // Shows the current state of the algorithm for debug purposes.
    ShowAndMoveBoxesRemoveLater(treeEdges: Array<MstEdge>, proximityEdges: Array<MstEdge>, nodeSizes: Size[], nodePos: Point[], rootId: number) {
      let l = new Array<DebugCurve>();
      for (let tuple of proximityEdges) {
        l.Add(new DebugCurve(100, 0.5, "black", new LineSegment(nodePos[tuple.Item1], nodePos[tuple.Item2])));
      }
  
      // just for debug
      let nodeBoxes = new Array(nodeSizes.length);
      for (let i: number = 0; (i < nodePos.length); i++) {
        nodeBoxes[i] = new Rectangle(nodeSizes[i], nodePos[i]);
      }
  
      l.AddRange(nodeBoxes.Select(() => { }, new DebugCurve(100, 0.3, "green", b.Perimeter())));
      if ((treeEdges != null)) {
        l.AddRange(treeEdges.Select(() => { }, new DebugCurve(200, GTreeOverlapRemoval.GetEdgeWidth(e), "red", new LineSegment(nodePos[e.Item1], nodePos[e.Item2]))));
      }
  
      if ((rootId >= 0)) {
        l.Add(new DebugCurve(100, 10, "blue", CurveFactory.CreateOctagon(30, 30, nodePos[rootId])));
      }
  
      LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);
    }
  
    static GetEdgeWidth(edge: MstEdge): number {
      if ((edge.Item3 > 1)) {
        return 6;
      }
  
      return 2;
    }
  */
  // Lets the tree grow according to the ideal distances.
  static MoveNodePositions(t, e, i) {
    const s = e.map((r) => r.clone()), n = /* @__PURE__ */ new Set();
    n.add(i);
    for (let r = 0; r < t.length; r++) {
      const a = t[r];
      n.has(a.source) ? qe.MoveNode(a.source, a.target, s, e, n, a.idealDistance) : qe.MoveNode(a.target, a.source, s, e, n, a.idealDistance);
    }
  }
  static MoveNode(t, e, i, s, n, r) {
    let a = i[e].sub(i[t]);
    a = a.mul(r / a.length + 0.01), s[e] = s[t].add(a), n.add(e);
  }
  //
  GetLastRunIterations() {
    return this.lastRunNumberIterations;
  }
}
function Gf(o, t, e, i) {
  e.nodePositions = t.map((s) => s.center), i && Ff(e.nodePositions, new to(0, 0), i), e.nodeSizes = t.map((s) => {
    const n = s.boundingBox.size;
    return n.width += o.NodeSeparation, n.height += o.NodeSeparation, n;
  });
}
function Ff(o, t, e) {
  const i = new xt();
  for (let s = 0; s < o.length; s++) {
    let n = o[s];
    if (e || i.has(n))
      do {
        const r = n.x + (2 * t.random() - 1) * e, a = n.y + (2 * t.random() - 1) * e;
        n = new u(r, a);
      } while (i.has(n));
    o[s] = n, i.add(n);
  }
}
class Vn extends lt {
  // Constructs the multidimensional scaling algorithm.
  constructor(t, e, i, s) {
    super(i), this.settings = t, this.graph = e, this.length = s;
  }
  // Executes the algorithm
  run() {
    this.LayoutConnectedGraphWithMds(), this.graph.pumpTheBoxToTheGraphWithMargins();
  }
  // Scales a configuration such that the average edge length in the drawing
  // equals the average of the given edge lengths.
  static ScaleToAverageEdgeLength(t, e, i, s) {
    const n = /* @__PURE__ */ new Map();
    let r = 0;
    for (const h of t.shallowNodes)
      n.set(h, r), r++;
    let a = 0, l = 0;
    for (const h of t.shallowEdges) {
      const c = n.get(h.source), d = n.get(h.target);
      l += Math.sqrt(Math.pow(e[c] - e[d], 2) + Math.pow(i[c] - i[d], 2)), a += s(h);
    }
    if (a > 0 && (l /= a), l > 0)
      for (let h = 0; h < e.length; h++)
        e[h] /= l, i[h] /= l;
  }
  // Layouts a connected graph with Multidimensional Scaling, using
  // shortest-path distances as Euclidean target distances.
  static LayoutGraphWithMds(t, e, i, s) {
    if (i.x = new Array(t.shallowNodeCount), i.y = new Array(t.shallowNodeCount), i.x.length === 0)
      return;
    if (i.x.length === 1) {
      i.x[0] = i.y[0] = 0;
      return;
    }
    const n = Math.min(e.PivotNumber, t.shallowNodeCount), r = e.GetNumberOfIterationsWithMajorization(t.shallowNodeCount), a = e.Exponent, l = new Array(n), h = new xf(t, l, s);
    h.run();
    const c = h.Result;
    if (et.LandmarkClassicalScaling(c, i, l), Vn.ScaleToAverageEdgeLength(t, i.x, i.y, s), r > 0) {
      const d = new Sa(t, s);
      d.run();
      const f = d.Result, p = et.ExponentialWeightMatrix(f, a);
      et.DistanceScalingSubset(f, i.x, i.y, p, r);
    }
  }
  LayoutConnectedGraphWithMds() {
    const t = { x: [], y: [] };
    Vn.LayoutGraphWithMds(this.graph, this.settings, t, this.length), this.settings.RotationAngle !== 0 && Lf.Rotate(t.x, t.y, this.settings.RotationAngle);
    let e = 0;
    for (const i of this.graph.shallowNodes)
      i.boundingBox && (i.center = new u(t.x[e] * this.settings.ScaleX, t.y[e] * this.settings.ScaleY)), e++;
    this.settings.removeOverlaps && qe.RemoveOverlaps(Array.from(this.graph.shallowNodes), this.settings.NodeSeparation), this.graph.pumpTheBoxToTheGraphWithMargins();
  }
  ScaleNodes(t, e) {
    for (const i of t)
      i.center = i.center.mul(e);
  }
  //  static UpdateTree(tree: RectangleNode<Node, Point>) {
  //    if (tree.IsLeaf) {
  //      tree.irect = tree.UserData.BoundingBox
  //    } else {
  //      MdsGraphLayout.UpdateTree(tree.Left)
  //      MdsGraphLayout.UpdateTree(tree.Right)
  //      tree.rectangle = tree.Left.rectangle
  //      tree.rectangle.Add(tree.Right.rectangle)
  //    }
  //  }
  //  static NumberOfHits(
  //    numberOfChecks: number,
  //    random: Random,
  //    tree: RectangleNode<Node, Point>,
  //    maxNumberOfHits: number,
  //  ): number {
  //    //  var l = new Array<Point>();
  //    let numberOfHits = 0
  //    for (let i = 0; i < numberOfChecks; i++) {
  //      const point: Point = MdsGraphLayout.RandomPointFromBox(
  //        random,
  //        <Rectangle>tree.rectangle,
  //      )
  //      //    l.Add(point);
  //      HitTestBehavior.Stop
  //      null
  //      numberOfHits++
  //      if (numberOfHits === maxNumberOfHits) {
  //        return maxNumberOfHits
  //      }
  //    }
  //    // LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(Getdc(tree, l));
  //    return numberOfHits
  //  }
  //  static BuildNodeTree(nodes: IList<Node>): RectangleNode<Node, Point> {
  //    return RectangleNode.CreateRectangleNodeOnListOfNodes(
  //      nodes.Select(() => {}, new RectangleNode<Node, Point>(n, n.BoundingBox)),
  //    )
  //  }
  //  static RandomPointFromBox(random: Random, boundingBox: Rectangle): Point {
  //    const x = random.NextDouble()
  //    const y = random.NextDouble()
  //    const p = new Point(
  //      boundingBox.left + boundingBox.width * x,
  //      boundingBox.bottom + boundingBox.height * y,
  //    )
  //    return p
  //  }
  // Pack the given graph components to the specified aspect ratio
  static PackGraphs(t, e) {
    if (t.length === 0)
      return T.mkEmpty();
    if (t.length === 1)
      return t[0].boundingBox;
    const i = t.map((r) => r.boundingBox), s = new Array();
    for (const r of t)
      s.push({ g: r, lb: r.boundingBox.leftBottom.clone() });
    const n = new Dh(i, e.PackingAspectRatio);
    n.run();
    for (const { g: r, lb: a } of s) {
      const l = r.boundingBox.leftBottom.sub(a);
      r.translate(l);
    }
    return new T({
      left: 0,
      bottom: 0,
      right: n.PackedWidth,
      top: n.PackedHeight
    });
  }
}
class Dn {
  constructor() {
    this.commonSettings = new Ys(), this.pivotNumber = 50, this.iterationsWithMajorization = 30, this.scaleX = 100, this.scaleY = 100, this.exponent = -2, this.rotationAngle = 0, this._removeOverlaps = !0, this._callIterationsWithMajorizationThreshold = 2e3, this.adjustScale = !1;
  }
  static fromJSON(t) {
    const e = new Dn();
    return t.pivotNumber && (e.pivotNumber = t.pivotNumber), t.iterationsWithMajorization && (e.iterationsWithMajorization = t.iterationsWithMajorization), t.scaleX && (e.scaleX = t.scaleX), t.scaleY && (e.scaleY = t.scaleY), t.exponent && (e.exponent = t.exponent), t.rotationAngle && (e.rotationAngle = t.rotationAngle), t.removeOverlaps != null && (e._removeOverlaps = t.removeOverlaps), t._callIterationsWithMajorizationThreshold && (e._callIterationsWithMajorizationThreshold = t._callIterationsWithMajorizationThreshold), e;
  }
  toJSON() {
    const t = {};
    return this.pivotNumber != 50 && (t.pivotNumber = this.pivotNumber), this.iterationsWithMajorization != 30 && (t.iterationsWithMajorization = this.iterationsWithMajorization), this.scaleX != 200 && (t.scaleX = this.scaleX), this.scaleY != 200 && (t.scaleY = this.scaleY), this.exponent != -2 && (t.exponent = this.exponent), this.rotationAngle != 0 && (t.rotationAngle = this.rotationAngle), this._removeOverlaps || (t.removeOverlaps = this._removeOverlaps), this._callIterationsWithMajorizationThreshold != 3e3 && (t._callIterationsWithMajorizationThreshold = this._callIterationsWithMajorizationThreshold), t;
  }
  get NodeSeparation() {
    return this.commonSettings.NodeSeparation;
  }
  set NodeSeparation(t) {
    this.commonSettings.NodeSeparation = t;
  }
  get edgeRoutingSettings() {
    return this.commonSettings.edgeRoutingSettings;
  }
  set edgeRoutingSettings(t) {
    this.commonSettings.edgeRoutingSettings = t;
  }
  // remove overlaps between node boundaries
  get removeOverlaps() {
    return this._removeOverlaps;
  }
  set removeOverlaps(t) {
    this._removeOverlaps = t;
  }
  // Number of pivots in Landmark Scaling (between 3 and number of objects).
  get PivotNumber() {
    return this.pivotNumber;
  }
  set PivotNumber(t) {
    this.pivotNumber = t;
  }
  /** Number of iterations in distance scaling: these iterations beautify the layout locally. This heuristic is optional , and the property has to be set to zero for a large graph, because each iteration has O(n*n) time, where n is the number of nodes in the graph */
  get IterationsWithMajorization() {
    return this.iterationsWithMajorization;
  }
  set IterationsWithMajorization(t) {
    this.iterationsWithMajorization = t;
  }
  // X Scaling Factor.
  get ScaleX() {
    return this.scaleX;
  }
  set ScaleX(t) {
    this.scaleX = t;
  }
  // Y Scaling Factor.
  get ScaleY() {
    return this.scaleY;
  }
  set ScaleY(t) {
    this.scaleY = t;
  }
  // Weight matrix exponent.
  get Exponent() {
    return this.exponent;
  }
  set Exponent(t) {
    this.exponent = t;
  }
  // rotation angle
  get RotationAngle() {
    return this.rotationAngle;
  }
  set RotationAngle(t) {
    this.rotationAngle = t % 360;
  }
  // Adjust the scale of the graph if there is not enough whitespace between nodes
  get AdjustScale() {
    return this.adjustScale;
  }
  set AdjustScale(t) {
    this.adjustScale = t;
  }
  GetNumberOfIterationsWithMajorization(t) {
    return t > this.CallIterationsWithMajorizationThreshold ? 0 : this.IterationsWithMajorization;
  }
  get CallIterationsWithMajorizationThreshold() {
    return this._callIterationsWithMajorizationThreshold;
  }
  set CallIterationsWithMajorizationThreshold(t) {
    this._callIterationsWithMajorizationThreshold = t;
  }
}
class Qh extends lt {
  get scaleX() {
    return this.settings.ScaleX;
  }
  set scaleX(t) {
    this.settings.ScaleX = t;
  }
  // scales the final layout by the specified factor on Y
  get scaleY() {
    return this.settings.ScaleY;
  }
  set scaleY(t) {
    this.settings.ScaleY = t;
  }
  // Layout graph by the PivotMds method.  Uses spectral techniques to obtain a layout in
  // O(n^2) time when iterations with majorization are used, otherwise it is more like O(PivotNumber*n).
  constructor(t, e, i, s) {
    super(e), this.graph = t, this.length = i, this.settings = s, this.settings.ScaleX = this.settings.ScaleY = 200;
  }
  // Executes the actual algorithm.
  run() {
    new Vn(this.settings, this.graph, this.cancelToken, this.length).run();
  }
}
function Yh(o, t, e) {
  if (t)
    for (const i of t) {
      if (e && e.canceled)
        return;
      ye.RouteEdge(i);
    }
  else
    for (const i of o.nodesBreadthFirst) {
      if (e && e.canceled)
        return;
      for (const s of i.outEdges())
        s.curve == null && ye.RouteEdge(s);
      for (const s of i.selfEdges())
        s.curve == null && ye.RouteEdge(s);
    }
}
class ye extends lt {
  // Constructs a basic straight geomedge router.
  constructor(t, e) {
    super(null), this.edges = t, this.padding = e;
  }
  // Executes the algorithm.
  run() {
    it.CreatePortsIfNeeded(this.edges);
    for (const t of this.edges)
      ye.RouteEdge(t);
  }
  // populate the geometry including curve and arrowhead positioning for the given geomedge using simple
  // straight line routing style.  Self edges will be drawn as a loop, padding is used to control the
  // size of the loop.
  static RouteEdge(t) {
    const e = t;
    e.sourcePort == null && (e.sourcePort = Ki.mk(() => t.source.boundaryCurve, () => t.source.center)), e.targetPort == null && (e.targetPort = Ki.mk(() => t.target.boundaryCurve, () => t.target.center)), ye.ContainmentLoop(e) || (e.curve = ye.GetEdgeLine(t)), vt.trimSplineAndCalculateArrowheadsII(e, e.sourcePort.Curve, e.targetPort.Curve, t.curve, !1);
  }
  static ContainmentLoop(t) {
    const e = t.sourcePort.Curve, i = t.targetPort.Curve;
    if (e == null || i == null)
      return !1;
    const s = e.boundingBox, n = i.boundingBox, r = s.containsRect(n), a = !r && n.containsRect(s);
    return r || a ? (t.curve = ye.CreateLoop(s, n, a), !0) : !1;
  }
  static CreateLoop(t, e, i) {
    return i ? ye.CreateLoop_(t, e, !1) : ye.CreateLoop_(e, t, !0);
  }
  // creates a loop from sourceBox center to the closest point on the targetBox boundary
  static CreateLoop_(t, e, i) {
    const s = t.center, n = ye.FindClosestPointOnBoxBoundary(t.center, e);
    let r = n.sub(s);
    const l = (Math.abs(r.x) < m.distanceEpsilon ? Math.min(s.y - e.bottom, e.top - s.y) : Math.min(s.x - e.left, e.right - s.x)) / 2, h = 1, c = Math.min(h, l);
    r.length <= m.distanceEpsilon && (r = new u(1, 0));
    const d = r.normalize(), f = d.rotate(Math.PI / 2), p = n.add(d.mul(h)), P = p.add(f.mul(c)), y = n.add(f.mul(c)), C = s.add(f.mul(c));
    return (i ? Tt.mkFromPoints([C, y, P, p, n, s]) : Tt.mkFromPoints([s, n, p, P, y, C])).createCurve();
  }
  static FindClosestPointOnBoxBoundary(t, e) {
    const i = t.x - e.left < e.right - t.x ? e.left : e.right, s = t.y - e.bottom < e.top - t.y ? e.bottom : e.top;
    return Math.abs(i - t.x) < Math.abs(s - t.y) ? new u(i, t.y) : new u(t.x, s);
  }
  // Returns a line segment for the given geomedge.
  static GetEdgeLine(t) {
    let e, i;
    t.sourcePort == null ? (e = t.source.center, i = t.source.boundaryCurve) : (e = t.sourcePort.Location, i = t.sourcePort.Curve);
    let s, n;
    t.targetPort == null ? (s = t.target.center, n = t.target.boundaryCurve) : (s = t.targetPort.Location, n = t.targetPort.Curve);
    let r = v.mkPP(e, s), a = g.getAllIntersections(i, r, !1);
    if (a.length > 0) {
      let l = r.trim(a[0].par1, 1);
      l instanceof v && (r = l, a = g.getAllIntersections(n, r, !1), a.length > 0 && (l = r.trim(0, a[0].par1), l instanceof v && (r = l)));
    }
    return r;
  }
  // creates an geomedge curve based only on the source and target geometry
  static CreateSimpleEdgeCurveWithUnderlyingPolyline(t) {
    const e = t.sourcePort ? t.sourcePort.Location : t.source.center, i = t.targetPort ? t.targetPort.Location : t.target.center;
    if (t.source === t.target) {
      const s = 2 / (3 * t.source.boundaryCurve.boundingBox.width), n = t.source.boundingBox.height / 4;
      t.smoothedPolyline = ye.CreateUnderlyingPolylineForSelfEdge(e, s, n), t.curve = t.smoothedPolyline.createCurve();
    } else
      t.smoothedPolyline = Tt.mkFromPoints([e, i]), t.curve = t.smoothedPolyline.createCurve();
    vt.trimSplineAndCalculateArrowheadsII(t, t.source.boundaryCurve, t.target.boundaryCurve, t.curve, !1);
  }
  static CreateUnderlyingPolylineForSelfEdge(t, e, i) {
    const s = t.add(new u(0, i)), n = t.add(new u(e, i)), r = t.add(new u(e, i * -1)), a = t.add(new u(0, i * -1));
    let l = St.mkSiteP(t);
    const h = new Tt(l);
    return l = St.mkSiteSP(l, s), l = St.mkSiteSP(l, n), l = St.mkSiteSP(l, r), l = St.mkSiteSP(l, a), St.mkSiteSP(l, t), h;
  }
  static SetStraightLineEdgesWithUnderlyingPolylines(t) {
    it.CreatePortsIfNeeded(Array.from(t.deepEdges));
    for (const e of t.deepEdges)
      ye.CreateSimpleEdgeCurveWithUnderlyingPolyline(e);
  }
}
var rs;
(function(o) {
  o[o.OverlapsOtherLabels = 0] = "OverlapsOtherLabels", o[o.OverlapsNodes = 1] = "OverlapsNodes", o[o.OverlapsEdges = 2] = "OverlapsEdges", o[o.OverlapsNothing = Number.MAX_VALUE] = "OverlapsNothing";
})(rs || (rs = {}));
var re;
(function(o) {
  o[o.Any = 0] = "Any", o[o.Port = 1] = "Port", o[o.Starboard = 2] = "Starboard", o[o.Top = 3] = "Top", o[o.Bottom = 4] = "Bottom", o[o.Left = 5] = "Left", o[o.Right = 6] = "Right";
})(re || (re = {}));
class Vf {
}
class Df {
  constructor() {
    this.points = [], this.coveredLength = 0;
  }
  AddFirst(t) {
    if (this.points.length !== 0) {
      const e = this.points[0];
      this.coveredLength = this.coveredLength + t.Center.sub(e.Center).length;
    }
    return this.points.unshift(t), this.coveredLength;
  }
  AddLast(t) {
    if (this.points.length !== 0) {
      const e = this.points[this.points.length - 1];
      this.coveredLength = this.coveredLength + t.Center.sub(e.Center).length;
    }
    return this.points.push(t), this.coveredLength;
  }
}
var Gs;
(function(o) {
  o[o.AlongCurve = 0] = "AlongCurve", o[o.Horizontal = 1] = "Horizontal";
})(Gs || (Gs = {}));
class Al {
  constructor(t) {
    this.location = t, this.boundingBox = T.rectangleOnPoint(t);
  }
}
class un {
  constructor(t, e) {
    this.data = e, this.boundingBox = t;
  }
}
class kf {
  constructor(t) {
    this.innerPoints = [], this.outerPoints = [], this.placementSide = re.Any, this.placementOffset = 0.5, this.edgePoints = t, this.placementSide;
  }
}
class z extends lt {
  //     The granularity with which to break up a curve into sub points.
  get CollisionGranularity() {
    return this.granularity;
  }
  set CollisionGranularity(t) {
    this.granularity = t;
  }
  //     Constructs an edge label placer that places all labels in the graph.
  static constructorG(t) {
    return new z(Array.from(t.nodesBreadthFirst), Array.from(t.deepEdges).filter((e) => e.label));
  }
  //     Constructs an edge label placer that places the given labels in the graph.
  static constructorGA(t, e) {
    return new z(Array.from(t.nodesBreadthFirst), e.filter((i) => i.label));
  }
  //     Constructs a edge label placer that will only avoid overlaps with the given nodes and edges.
  constructor(t, e) {
    super(null), this.placementStrategy = [Gs.Horizontal, Gs.AlongCurve], this.obstacleMaps = [], this.edgeInfos = /* @__PURE__ */ new Map(), this.granularity = z.MinGranularity, this.ScaleCollisionGranularity = !0, this.granularity = this.ScaleCollisionGranularity ? this.interpolateGranularity(e.length) : z.MinGranularity, this.InitializeObstacles(t, e), this.edges = e;
  }
  interpolateGranularity(t) {
    if (t <= z.LowerEdgeBound)
      return z.MaxGranularity;
    if (t >= z.UpperEdgeBound)
      return z.MinGranularity;
    const e = (z.UpperEdgeBound - z.LowerEdgeBound) / (t - z.LowerEdgeBound);
    return Math.ceil(z.MinGranularity + e);
  }
  InitializeObstacles(t, e) {
    const i = this.GetEdgeObstacles(e);
    this.obstacleMaps[1] = Pn(t.map((s) => [s.boundingBox, new un(s.boundingBox, s)])), this.obstacleMaps[2] = Pn(i.map((s) => [s.boundingBox, new un(s.boundingBox, s)]));
  }
  static CurvePoints(t, e) {
    const i = [], s = t.end.sub(t.start).lengthSquared / (e * e);
    return z.SubdivideCurveSegment(i, t, s, t.parStart, t.parEnd), i.sort(z.compareByArgument), i;
  }
  static compareByArgument(t, e) {
    return t[0] < e[0] ? -1 : t[0] > e[0] ? 1 : 0;
  }
  static SubdivideCurveSegment(t, e, i, s, n) {
    if (t.length > 64)
      return;
    const r = e.value(s), a = e.value(n);
    if (r.sub(a).lengthSquared > i) {
      const l = (s + n) / 2;
      z.SubdivideCurveSegment(t, e, i, s, l), z.SubdivideCurveSegment(t, e, i, l, n);
    } else
      t.push([s, r]);
  }
  //Places the given labels at their default positions.  Only avoids overlaps with the edge and source/target node that the label is connected to.
  static PlaceLabelsAtDefaultPositions(t, e) {
    for (const i of e)
      i.label && new z([i.source, i.target], [i]).run();
  }
  GetEdgeObstacles(t) {
    const e = [];
    for (const i of t) {
      if (i.curve == null)
        continue;
      const s = z.CurvePoints(i.curve, this.CollisionGranularity);
      this.edgeInfos.set(i, new kf(s));
      for (const n of s)
        e.push(new Al(n[1]));
    }
    return e;
  }
  /**       Adds the label to the label obstacle map.*/
  AddLabelObstacle(t) {
    this.labelObstacleMap == null ? (this.labelObstacleMap = Pn([[t.boundingBox, t]]), this.obstacleMaps[0] = this.labelObstacleMap) : this.labelObstacleMap.Add(t.boundingBox, t);
  }
  //     Places the given labels.
  run() {
    this.edges.sort((t, e) => this.edgeInfos.get(t).edgePoints.length - this.edgeInfos.get(e).edgePoints.length);
    for (const t of this.edges)
      this.PlaceLabel(t);
  }
  //     Places the given label in an available location.
  PlaceLabel(t) {
    let e = !1;
    for (const i of this.placementStrategy) {
      switch (i) {
        case Gs.AlongCurve:
          e = this.PlaceEdgeLabelOnCurve(t.label);
          break;
        case Gs.Horizontal:
          e = this.PlaceEdgeLabelHorizontally(t);
          break;
        default:
          throw new Error("unexpected case");
      }
      if (e)
        break;
    }
    e ? this.CalculateCenterLabelInfoCenter(t.label) : this.PlaceLabelAtFirstPosition(t.label);
  }
  getLabelInfo(t) {
    const e = t.parent;
    return this.edgeInfos.get(e);
  }
  //     Places the label at the first position requested.  Ignores all overlaps.
  PlaceLabelAtFirstPosition(t) {
    const e = t.parent, i = e.curve, s = this.edgeInfos.get(e).edgePoints, n = this.StartIndex(t, s.map((f) => f[1])), r = s[n][1];
    let a = i.derivative(s[n][0]);
    a.length < m.distanceEpsilon && (a = new u(1, 1)), a = a.normalize();
    const l = new Ai(t.width, t.height), h = this.getLabelInfo(t), c = z.GetPossibleSides(h.placementSide, a)[0], d = z.GetLabelBounds(r, a, l, c);
    this.SetLabelBounds(this.getLabelInfo(t), d);
  }
  StartIndex(t, e) {
    const i = this.getLabelInfo(t);
    return Math.min(e.length - 1, Math.max(0, Math.floor(e.length * i.placementOffset)));
  }
  CalculateCenterLabelInfoCenter(t) {
    const e = this.getLabelInfo(t);
    let i = new u(0, 0);
    for (const s of e.innerPoints)
      i = i.add(s);
    for (const s of e.outerPoints)
      i = i.add(s);
    t.positionCenter(i.div(e.innerPoints.length + e.outerPoints.length));
  }
  PlaceEdgeLabelHorizontally(t) {
    const e = t.label, s = this.getLabelInfo(e).edgePoints, n = new Ai(e.width, e.height);
    let r = -1, a = T.mkEmpty();
    const l = t.curve;
    for (const h of z.ExpandingSearch(this.StartIndex(e, s.map((c) => c[1])), 0, s.length)) {
      const c = s[h];
      let d = l.derivative(c[0]);
      if (!D(d.lengthSquared, 0)) {
        d = d.normalize();
        for (const f of z.GetPossibleSides(this.getLabelInfo(e).placementSide, d)) {
          const p = z.GetLabelBounds(c[1], d, n, f), P = this.ConflictIndexRL(p, e);
          if (P > r && (r = P, a = p, r === Number.MAX_VALUE))
            break;
        }
        if (r === Number.MAX_VALUE)
          break;
      }
    }
    if (r >= 0) {
      this.SetLabelBounds(this.getLabelInfo(e), a);
      const h = new un(a, null);
      this.AddLabelObstacle(h);
      const c = this.getLabelInfo(e);
      return r === 0 ? c.placementResult = rs.OverlapsOtherLabels : r === 1 ? c.placementResult = rs.OverlapsNodes : r === 2 ? c.placementResult = rs.OverlapsEdges : c.placementResult = rs.OverlapsNothing, !0;
    }
    return !1;
  }
  //     Gets the label placement bounds for the given location, side, and label size.
  // The point along a curve that the label should be placed near.
  // The derivative of the curve at the point position.
  // The width and height of the label.
  // The side (1 or -1) of the line to place the label on.
  // <returns>The label's desired position.</returns>
  static GetLabelBounds(t, e, i, s) {
    const n = e.rotate(Math.PI / 2).mul(s), r = t.add(n), a = 1;
    let l = n.x > 0 ? r.x : r.x - i.width, h = n.y > 0 ? r.y : r.y - i.height;
    if (Math.abs(n.x) < 0.75) {
      const c = Math.acos(Math.abs(n.y) / a), d = a / Math.sin(c), f = a / Math.cos(c);
      l += (n.x > 0 ? -1 : 1) * Math.min(d, i.width / 2), h += (n.y > 0 ? 1 : -1) * f;
    } else if (Math.abs(n.y) < 0.75) {
      const c = Math.acos(Math.abs(n.x) / a), d = a / Math.sin(c), f = a / Math.cos(c);
      l += (n.x > 0 ? 1 : -1) * f, h += (n.y > 0 ? -1 : 1) * Math.min(d, i.height / 2);
    }
    return T.mkLeftBottomSize(l, h, i);
  }
  //     Sets the label's position to be the given bounds.
  SetLabelBounds(t, e) {
    t.innerPoints = [e.leftTop, e.rightTop], t.outerPoints = [e.leftBottom, e.rightBottom];
  }
  //     Gets the possible sides for the given label and the given derivative point.
  // <returns>An enumeration of the possible sides (-1 or 1).</returns>
  static GetPossibleSides(t, e) {
    switch (e.length === 0 && (t = re.Any), t) {
      case re.Port:
        return [-1];
      case re.Starboard:
        return [1];
      case re.Top:
        return D(e.x, 0) ? z.GetPossibleSides(re.Left, e) : [1];
      case re.Bottom:
        return D(e.x, 0) ? z.GetPossibleSides(re.Right, e) : [e.x < 0 ? -1 : 1];
      case re.Left:
        return D(e.y, 0) ? z.GetPossibleSides(re.Top, e) : [e.y < 0 ? -1 : 1];
      case re.Right:
        return D(e.y, 0) ? z.GetPossibleSides(re.Bottom, e) : [e.y < 0 ? 1 : -1];
      default:
        return [-1, 1];
    }
  }
  static *ExpandingSearch(t, e, i) {
    let s = t + 1, n = s;
    for (; n > e; )
      yield --n;
    for (; s < i; )
      yield s++;
  }
  static PointSetLength(t) {
    let e = 0, i = null;
    for (const s of t)
      i != null && (e += i.sub(s.Center).length), i = s.Center;
    return e;
  }
  PlaceEdgeLabelOnCurve(t) {
    const e = t.parent, i = this.getLabelInfo(t);
    i.innerPoints = null;
    const s = i.edgePoints, n = 3, r = t.height / 2, a = new Ai(r, r), l = t.width;
    for (const h of z.ExpandingSearch(this.StartIndex(t, s), 0, s.length)) {
      const c = this.GetSidesAndEdgeCurve(t, e, s, h);
      for (const d of c) {
        const f = new Df(), p = { coveredLength: 0 };
        if (this.ProcessExpandingSearchOnSide(h, s, e.curve, d, r, n, a, p, f, l), p.coveredLength >= l)
          return this.CaseOfCoveredLengthGreaterThanLabelLength(t, f, p.coveredLength, l, a), !0;
      }
    }
    return !1;
  }
  CaseOfCoveredLengthGreaterThanLabelLength(t, e, i, s, n) {
    const r = new Array(), a = new Array(), l = Array.from(e.points), h = i - s;
    if (h > 0) {
      let d = l[l.length - 1], f = l[l.length - 2], p = d.Center.sub(f.Center), P = p.length;
      h > P && (d = l[0], f = l[1], p = d.Center.sub(f.Center), P = p.length);
      const y = p.mul((P - h) / P);
      d.Center = f.Center.add(y), d.Inner = f.Inner.add(y), d.Outer = f.Outer.add(y);
    }
    this.GoOverOrderedPointsAndAddLabelObstacels(l, r, a, n);
    const c = this.getLabelInfo(t);
    c.innerPoints = r, c.outerPoints = a;
  }
  GoOverOrderedPointsAndAddLabelObstacels(t, e, i, s) {
    for (const n of t) {
      const r = n.Center;
      e.push(n.Inner), i.push(n.Outer);
      const a = new un(T.mkSizeCenter(new Ai(s.width * 2, s.height * 2), r), null);
      this.AddLabelObstacle(a);
    }
  }
  ProcessExpandingSearchOnSide(t, e, i, s, n, r, a, l, h, c) {
    for (const d of z.ExpandingSearch(t, 0, e.length)) {
      const [f, p] = e[d], P = i.derivative(f);
      if (D(P.lengthSquared, 0))
        continue;
      const y = P.rotate(Math.PI / 2).normalize().mul(s), C = p.add(y.mul(n + r));
      if (this.Conflict(C, n, a))
        break;
      {
        const E = new Vf();
        if (E.Center = C, E.Inner = p.add(y.mul(r)), E.Outer = p.add(y.mul(2 * n + r)), l.coveredLength = d <= t ? h.AddFirst(E) : h.AddLast(E), l.coveredLength >= c)
          break;
      }
    }
  }
  GetSidesAndEdgeCurve(t, e, i, s) {
    const n = e.curve.derivative(i[s][0]);
    return z.GetPossibleSides(this.getLabelInfo(t).placementSide, n);
  }
  //     Determines if the query point intersects with any of the obstacles.
  // <returns>True if the query point itnersects with any of the obstacles.</returns>
  Conflict(t, e, i) {
    return this.ConflictIndex(t, e, i) !== Number.MAX_VALUE;
  }
  //    Determines the index of the first obstacle map that the rectangle intersects.
  //    Clusters that are parents/grandparents of the label's source/target nodes are not considered intersection.
  // <returns>The index of the first obstacle map that the rectangle intersects. int.MaxValue if there is no intersection.</returns>
  ConflictIndexRL(t, e) {
    const i = e.parent, s = i.source, n = i.target;
    for (let r = 0; r < this.obstacleMaps.length; r++)
      if (this.obstacleMaps[r] != null) {
        for (const a of this.obstacleMaps[r].GetAllIntersecting(t))
          if (!(r === rs.OverlapsNodes && a instanceof un && a.data instanceof Rt && (s.node.isDescendantOf(a.data.graph) || n.node.isDescendantOf(a.data))))
            return r;
      }
    return Number.MAX_VALUE;
  }
  /**   Determines the index of the first obstacle map that the point intersects.
    Returns the index of the first obstacle map that the point intersects. int.MaxValue if there is no intersection.*/
  ConflictIndex(t, e, i) {
    const s = T.creatRectangleWithSize(new Ai(i.width * 2, i.height * 2), t), n = e * e;
    for (let r = 0; r < this.obstacleMaps.length; r++)
      if (this.obstacleMaps[r] != null) {
        for (let a = 0; a < this.obstacleMaps.length; a++)
          if (this.obstacleMaps[a] != null)
            for (const l of this.obstacleMaps[a].GetAllIntersecting(s))
              if (l instanceof Al) {
                if (t.sub(l.location).lengthSquared < n)
                  return a;
              } else
                return a;
        return Number.MAX_VALUE;
      }
  }
}
z.MinGranularity = 5;
z.MaxGranularity = 50;
z.LowerEdgeBound = 500;
z.UpperEdgeBound = 3e3;
class yi extends Nh {
  clone() {
    throw new Error("Method not implemented.");
  }
  rebind(t) {
    this.entity = t, this.bind(_e.AlgorithmDataIndex);
  }
  constructor(t, e = null) {
    super(t, _e.AlgorithmDataIndex), this.data = e;
  }
  static getAlgData(t) {
    return t.getAttr(_e.AlgorithmDataIndex);
  }
}
function Ho(o) {
  const t = yi.getAlgData(o.node);
  return t == null ? null : t.data;
}
class _f {
  //  local cache of node center (which in the MSAGL node has to be computed from the bounding box)
  get Center() {
    return this.center;
  }
  set Center(t) {
    this.geomNode.center = t, this.center = t;
  }
  //  When mNode's bounds change we need to update our local
  //  previous and current center to MSAGL node center
  //  and update width and height
  ResetBounds() {
    this.previousCenter = this.geomNode.center, this.center = this.geomNode.center, this.Width = this.geomNode.width, this.Height = this.geomNode.height;
  }
  constructor(t, e) {
    this.force = new u(0, 0), this.stayWeight = 1, this.index = t, this.geomNode = e, this.ResetBounds();
  }
  //  Update the current X or Y coordinate of the node center from the result of a solve
  ToString() {
    return "FINode(" + (this.index + ("):" + this.geomNode));
  }
}
class Wf {
  constructor(t) {
    this._length = 1, this.mEdge = t, this.sourceFiNode = Ho(this.mEdge.source), this.targetFiNode = Ho(this.mEdge.target);
  }
  get source() {
    return this.sourceFiNode.index;
  }
  get target() {
    return this.targetFiNode.index;
  }
  get length() {
    return this._length;
  }
  set length(t) {
    this._length = t;
  }
  vector() {
    return this.sourceFiNode.geomNode.center.sub(this.targetFiNode.geomNode.center);
  }
}
class Xt {
  /**   disc centre*/
  get Center() {
    return this.c;
  }
  set Center(t) {
    this.c = t;
  }
  /**   Radius of disc */
  get Radius() {
    return this.r;
  }
  set Radius(t) {
    this.r = t, this.r2 = t * t;
  }
  //  squared distance from the centre of this disc to point
  //  <returns></returns>
  Distance2(t) {
    const e = this.c.y - t.y, i = this.c.x - t.x;
    return i * i + e * e;
  }
  //  Test if point is contained in this disc
  //  <returns></returns>
  Contains(t) {
    return this.Distance2(t) - 1e-7 <= this.r2;
  }
  //  test if all specified points (apart from the except list) are contained in this disc
  //  <returns>true if all points are contained in the disc</returns>
  ContainsPN(t, e) {
    for (let i = 0; i < t.length; i++)
      if (e.findIndex((s) => s == i) == -1 && !this.Contains(t[i]))
        return !1;
    return !0;
  }
  //  create a zero radius disc centred at center
  static constructorP(t) {
    const e = new Xt();
    return e.c = t, e.r = 0, e.r2 = 0, e;
  }
  //  find the point mid-way between two points
  static midPoint(t, e) {
    return new u((e.x + t.x) / 2, (e.y + t.y) / 2);
  }
  //  Create the smallest possible disc with the specified points on the boundary
  static constructorPP(t, e) {
    const i = new Xt();
    return i.c = Xt.midPoint(t, e), i.r2 = i.Distance2(t), i.r = Math.sqrt(i.r2), at.assert(i.OnBoundary(t)), at.assert(i.OnBoundary(e)), i;
  }
  //  test if a point lies on (within a small delta of) the boundary of this disc
  //  <returns></returns>
  OnBoundary(t) {
    const e = this.Distance2(t);
    return Math.abs(e - this.r2) / (e + this.r2) < 1e-5;
  }
  //  computes the centre of the disc with the 3 specified points on the boundary
  //  <returns></returns>
  static centre(t, e, i) {
    at.assert(e.x != t.x), at.assert(i.x != e.x);
    const s = (e.y - t.y) / (e.x - t.x), n = (i.y - e.y) / (i.x - e.x);
    at.assert(n != s);
    let r;
    const a = (s * n * (t.y - i.y) + n * (t.x + e.x) - s * (e.x + i.x)) / (2 * (n - s));
    return Math.abs(s) > Math.abs(n) ? r = (t.y + e.y) / 2 - (a - (t.x + e.x) / 2) / s : r = (e.y + i.y) / 2 - (a - (e.x + i.x) / 2) / n, new u(a, r);
  }
  //  if the area of the triangle formed by the 3 points is 0 then the points are collinear
  //  <returns></returns>
  static Collinear(t, e, i) {
    return t.x * (e.y - i.y) + (e.x * (i.y - t.y) + i.x * (t.y - e.y)) == 0;
  }
  //  Create a disc with the specified points on the boundary
  static constructorPPP(t, e, i) {
    Xt.count++;
    const s = new Xt();
    if (Xt.Collinear(t, e, i)) {
      const n = new u(Math.min(t.x, Math.min(e.x, i.x)), Math.min(t.y, Math.max(e.y, i.y))), r = new u(Math.max(t.x, Math.max(e.x, i.x)), Math.max(t.y, Math.max(e.y, i.y)));
      s.c = Xt.midPoint(n, r), s.r2 = s.Distance2(r), s.r = Math.sqrt(s.r2);
    } else {
      const n = e.x - t.x, r = i.x - e.x, a = i.x - t.x;
      n != 0 ? r != 0 ? s.c = Xt.centre(t, e, i) : (at.assert(a != 0), s.c = Xt.centre(e, t, i)) : (at.assert(r != 0), s.c = Xt.centre(e, i, t)), s.r2 = s.Distance2(t), s.r = Math.sqrt(s.r2), at.assert(s.OnBoundary(t)), at.assert(s.OnBoundary(e)), at.assert(s.OnBoundary(i));
    }
    return s;
  }
}
Xt.count = 0;
function Hf(o) {
  const t = o.slice();
  return zf(t), zo(t, o.length, [], 0);
}
function zf(o) {
  let t, e, i;
  for (i = o.length - 1; i > 0; i--)
    t = Us(i + 1), e = o[i], o[i] = o[t], o[t] = e;
  return o;
}
function zo(o, t, e, i) {
  let s = null;
  return i === 3 ? s = jf(e[0], e[1], e[2]) : t === 1 && i === 0 ? s = { x: o[0].x, y: o[0].y, r: 0 } : t === 0 && i === 2 ? s = Tl(e[0], e[1]) : t === 1 && i === 1 ? s = Tl(e[0], o[0]) : (s = zo(o, t - 1, e, i), qf(o[t - 1], s) || (e[i++] = o[t - 1], s = zo(o, t - 1, e, i))), s;
}
function jf(o, t, e) {
  const i = o.x, s = o.y, n = t.x, r = t.y, a = e.x, l = e.y, h = n - i, c = r - s, d = a - i, f = l - s, p = h * (n + i) * 0.5 + c * (r + s) * 0.5, P = d * (a + i) * 0.5 + f * (l + s) * 0.5, y = h * f - c * d, C = (f * p - c * P) / y, E = (-d * p + h * P) / y;
  return { x: C, y: E, r: Math.sqrt((i - C) * (i - C) + (s - E) * (s - E)) };
}
function Tl(o, t) {
  const e = o.x, i = o.y, s = t.x, n = t.y, r = 0.5 * (e + s), a = 0.5 * (i + n);
  return { x: r, y: a, r: Math.sqrt((e - r) * (e - r) + (i - a) * (i - a)) };
}
function qf(o, t) {
  return (t.x - o.x) * (t.x - o.x) + (t.y - o.y) * (t.y - o.y) <= t.r * t.r;
}
class Uf {
  /**  linear-time computation using the move-to-front heuristic by Welzl */
  static LinearComputation(t) {
    const e = Hf(t), i = new Xt();
    return i.Center = new u(e.x, e.y), i.Radius = e.r, i;
  }
  //  Computing the minimum enclosing disc the naive way for testing purposes.
  static SlowComputation(t) {
    const e = t.length;
    let i = null, s = null;
    for (let n = 0; n < e; n++)
      for (let r = 0; r < e; r++) {
        if (n != r) {
          const a = Xt.constructorPP(t[n], t[r]);
          a.ContainsPN(t, [n, r]) && (i == null || i.Radius > a.Radius) && (i = a, s = [n, r]);
        }
        for (let a = 0; a < e; a++)
          if (a != n && a != r && !Xt.Collinear(t[n], t[r], t[a])) {
            const l = Xt.constructorPPP(t[n], t[r], t[a]);
            l.ContainsPN(t, [n, r, a]) && (i == null || i.Radius > l.Radius) && (i = l, s = [n, r, a]);
          }
      }
    return at.assert(s != null), i;
  }
}
class Re {
  static constructorNPA(t, e, i) {
    const s = new Re();
    s.p = t, s.z0 = new dt(e.x, e.y), s.a = new Array(t);
    for (let n = 0; n < t; n++)
      s.a[n] = s.compute(n, i);
    return s;
  }
  static constructorPMM(t, e, i) {
    const s = new Re();
    at.assert(e.p == i.p), s.p = e.p, s.z0 = new dt(t.x, t.y);
    const n = i.shift(s.z0), r = e.shift(s.z0);
    s.a = new Array(s.p);
    for (let a = 0; a < s.p; a++)
      s.a[a] = vo(r[a], n[a]);
    return s;
  }
  static factorial(t) {
    let e = 1;
    for (let i = 2; i <= t; i++)
      e *= i;
    return e;
  }
  static binomial(t, e) {
    return Re.factorial(t) / (Re.factorial(e) * Re.factorial(t - e));
  }
  sum(t, e) {
    let i = dt.constructorN(0);
    for (let s = 1; s <= t; s++) {
      const n = dt.constructorN(Re.binomial(t - 1, s - 1));
      i = vo(i, qi(this.a[s], qi(dt.Pow(e, t - s), n)));
    }
    return i;
  }
  shift(t) {
    const e = new Array(this.p), i = e[0] = this.a[0], s = dn(this.z0, t);
    for (let n = 1; n < this.p; n++) {
      const r = dt.constructorN(n);
      e[n] = vo(qi(Qf(i), Co(dt.Pow(s, n), r)), this.sum(n, s));
    }
    return e;
  }
  //  Compute kth multipole coefficient of a set of points ps around a centre z0
  compute(t, e) {
    const i = e.length;
    let s = dt.constructorN(0);
    if (t == 0)
      s.re = i;
    else {
      for (let n = 0; n < i; n++) {
        const r = e[n], a = new dt(r.x, r.y);
        s = dn(s, dt.Pow(dn(a, this.z0), t));
      }
      s.divideBy(t);
    }
    return s;
  }
  //  Compute approximate force at point v due to potential energy moments
  ApproximateForce(t) {
    const e = new dt(t.x, t.y), i = dn(e, this.z0);
    let s = Co(this.a[0], i), n = i, r = 0;
    for (; s = dn(s, Co(Xf(this.a[r], r), n)), r++, r != this.p; )
      n = qi(n, i);
    return new u(s.re, -s.im);
  }
  //  Force on point u due to point v.
  //  If v and u at the same position it returns a small vector to separate them
  static Force(t, e) {
    const i = e.sub(t), s = i.lengthSquared;
    return s < 0.1 ? s != 0 ? i.div(0.1) : new u(1, 0) : i.div(s);
  }
}
class dt {
  constructor(t, e) {
    this.re = t, this.im = e;
  }
  static constructorN(t) {
    return new dt(t, 0);
  }
  divideBy(t) {
    this.re /= t, this.im /= t;
  }
  static Pow(t, e) {
    switch (at.assert(e >= 0), e) {
      case 0:
        return dt.constructorN(1);
      case 1:
        return t;
      case 2:
        return qi(t, t);
      case 3:
        return qi(t, qi(t, t));
      default:
        return qi(dt.Pow(t, e / 2), dt.Pow(t, e / 2 + e % 2));
    }
  }
}
function vo(o, t) {
  return new dt(o.re + t.re, o.im + t.im);
}
function qi(o, t) {
  return new dt(o.re * t.re - o.im * t.im, o.re * t.im + t.re * o.im);
}
function Xf(o, t) {
  return new dt(o.re * t, o.im * t);
}
function dn(o, t) {
  return new dt(o.re - t.re, o.im - t.im);
}
function Qf(o) {
  return new dt(-o.re, -o.im);
}
function Co(o, t) {
  const e = t.re * t.re + t.im * t.im;
  if (e == 0)
    return dt.constructorN(0);
  const i = o.re * t.re + o.im * t.im, s = o.im * t.re - o.re * t.im;
  return new dt(i / e, s / e);
}
var Le;
(function(o) {
  o[o.Horizontal = 0] = "Horizontal", o[o.Vertical = 1] = "Vertical";
})(Le || (Le = {}));
class Jh {
  intersects(t) {
    return t.med.Center.sub(this.med.Center).length < t.med.Radius + this.med.Radius;
  }
}
class Yf extends Jh {
  constructor(t, e, i) {
    super(), this.med = t, this.parent = e.parent, this.parent != null && (this.parent.leftChild == e ? this.parent.leftChild = this : this.parent.rightChild = this), this.leftChild = e, this.rightChild = i, e.parent = this, i.parent = this;
  }
  computeMultipoleCoefficients(t) {
    this.leftChild.computeMultipoleCoefficients(t), this.rightChild.computeMultipoleCoefficients(t), this.multipoleCoefficients = Re.constructorPMM(this.med.Center, this.leftChild.multipoleCoefficients, this.rightChild.multipoleCoefficients);
  }
}
class kr extends Jh {
  constructor(t) {
    super(), this.particles = t, this.ComputeMinimumEnclosingDisc();
  }
  computeMultipoleCoefficients(t) {
    this.multipoleCoefficients = Re.constructorNPA(t, this.med.Center, this.ps);
  }
  ComputeMinimumEnclosingDisc() {
    const t = this.Size();
    this.ps = new Array(t);
    for (let e = 0; e < t; e++)
      this.ps[e] = this.particles[0][e].point;
    return this.med = Uf.LinearComputation(this.ps);
  }
  Min(t) {
    return this.particles[t][0].pos(t);
  }
  Size() {
    return this.particles[0].length;
  }
  Max(t) {
    return this.particles[t][this.Size() - 1].pos(t);
  }
  Dimension(t) {
    return this.Max(t) - this.Min(t);
  }
  Split(t) {
    const e = this.Dimension(Le.Horizontal) > this.Dimension(Le.Vertical) ? Le.Horizontal : Le.Vertical, i = e == Le.Horizontal ? Le.Vertical : Le.Horizontal, s = this.Size(), n = s >> 1, r = s - n, a = [new Array(n), new Array(n)], l = [new Array(r), new Array(r)];
    let h = 0, c = 0;
    for (let f = 0; f < s; f++) {
      const p = this.particles[e][f];
      f < n ? (a[e][f] = p, p.splitLeft = !0) : (l[e][f - n] = p, p.splitLeft = !1);
    }
    for (let f = 0; f < s; f++) {
      const p = this.particles[i][f];
      p.splitLeft ? a[i][c++] = p : l[i][h++] = p;
    }
    const d = this.med;
    return this.particles = a, this.ComputeMinimumEnclosingDisc(), t.rightSibling = new kr(l), new Yf(d, this, t.rightSibling);
  }
  ComputeForces() {
    for (const t of this.particles[0])
      for (const e of this.particles[0])
        t != e && (t.force = t.force.add(Re.Force(t.point, e.point)));
  }
}
class Jf {
  pos(t) {
    return t == Le.Horizontal ? this.point.x : this.point.y;
  }
  //  Create particle at point
  constructor(t) {
    this.point = t, this.force = new u(0, 0);
  }
}
class Kf {
  particlesBy(t) {
    return this.particles.map((e) => e).sort((e, i) => e.pos(t) - i.pos(t));
  }
  //  Create a KDTree over the specified particles, with the leaf partitions each containing bucketSize particles.
  constructor(t, e) {
    this.particles = t;
    const i = new Array();
    i.push(this.particlesBy(Le.Horizontal)), i.push(this.particlesBy(Le.Vertical)), this.leaves = new Array();
    let s = new kr(i);
    this.leaves.push(s);
    const n = { rightSibling: null };
    this.root = s.Split(n), this.leaves.push(n.rightSibling);
    const r = new Zf(e);
    for (r.EnqueueLL(s, n.rightSibling); r.length > 0; )
      s = r.dequeue(), s.Split(n), this.leaves.push(n.rightSibling), r.EnqueueLL(s, n.rightSibling);
  }
  //  Compute forces between particles using multipole approximations.
  ComputeForces(t) {
    this.root.computeMultipoleCoefficients(t);
    for (const e of this.leaves) {
      e.ComputeForces();
      const i = new Array();
      for (i.push(this.root); i.length > 0; ) {
        const s = i.pop();
        if (e.intersects(s))
          if (s instanceof kr)
            for (const n of e.particles[0])
              for (const r of s.particles[0])
                n != r && (n.force = n.force.add(Re.Force(n.point, r.point)));
          else {
            const n = s;
            i.push(n.leftChild), i.push(n.rightChild);
          }
        else
          for (const n of e.particles[0])
            n.force = n.force.sub(s.multipoleCoefficients.ApproximateForce(n.point));
      }
    }
  }
}
class Zf extends We.Queue {
  constructor(t) {
    super(), this.B = t;
  }
  EnqueueLL(t, e) {
    t.Size() > this.B && this.enqueue(t), e.Size() > this.B && this.enqueue(e);
  }
}
class kn extends lt {
  //  Create the graph data structures.
  constructor(t, e, i) {
    if (super(null), this.clustersInfo = /* @__PURE__ */ new Map(), this.clusterEdges = new Array(), this.graph = t, this.settings = e, this.initFiNodesEdges(), this.edges = Array.from(this.graph.shallowEdges).map((s) => yi.getAlgData(s.edge).data), this.nodes = Array.from(this.graph.shallowNodes).map((s) => yi.getAlgData(s.node).data), this.components = new Array(), this.settings.InterComponentForces)
      this.components.push(this.nodes);
    else {
      this.basicGraph = fi(this.edges, this.nodes.length);
      for (const s of Xs(this.basicGraph)) {
        const n = new Array(s.length);
        let r = 0;
        for (const a of s)
          n[r++] = this.nodes[a];
        this.components.push(n);
      }
    }
    this.computeWeight(t), this.setCurrentConstraintLevel(i);
  }
  initFiNodesEdges() {
    let t = 0;
    for (const e of this.graph.shallowNodes) {
      const i = new _f(t++, e);
      new yi(e.node, i);
    }
    for (const e of this.graph.shallowEdges) {
      const i = new Wf(e);
      new yi(e.edge, i);
    }
  }
  //  Controls which constraints are applied of CalculateLayout.  Setter enforces feasibility at that level.
  getCurrentConstraintLevel() {
    return this.currentConstraintLevel;
  }
  setCurrentConstraintLevel(t) {
    this.currentConstraintLevel = t, this.settings.Unconverge();
  }
  //  Add constraint to constraints lists.  Warning, no check that dictionary alread holds a list for the level.
  //  Make sure you call AddConstraintLevel first (perf).
  //  Check for constraint level of dictionary, if it doesn't exist add the list at that level.
  ResetNodePositions() {
    for (const t of this.nodes)
      t.ResetBounds();
  }
  AddRepulsiveForce(t, e) {
    t.force = e.mul(10 * this.settings.RepulsiveForceConstant);
  }
  AddLogSpringForces(t, e, i) {
    const s = e.length, n = 7e-4 * this.settings.AttractiveForceConstant * s * Math.log((s + 0.1) / (i + 0.1));
    t.sourceFiNode.force = t.sourceFiNode.force.add(e.mul(n)), t.targetFiNode.force = t.targetFiNode.force.sub(e.mul(n));
  }
  AddSquaredSpringForces(t, e, i) {
    const s = e.length, n = i * i + 0.1, r = this.settings.AttractiveForceConstant * (s - i) / n;
    t.sourceFiNode.force = t.sourceFiNode.force.add(e.mul(r)), t.targetFiNode.force = t.targetFiNode.force.sub(e.mul(r));
  }
  AddSpringForces(t) {
    let e;
    if (this.settings.RespectEdgePorts) {
      let i = t.sourceFiNode.Center, s = t.targetFiNode.Center;
      const n = t.mEdge.sourcePort;
      n instanceof Te && (i = n.Location);
      const r = t.mEdge.targetPort;
      r instanceof Te && (s = r.Location), e = i.sub(s);
    } else
      e = t.vector();
    this.settings.LogScaleEdgeForces ? this.AddLogSpringForces(t, e, t.length) : this.AddSquaredSpringForces(t, e, t.length);
  }
  static AddGravityForce(t, e, i) {
    i != null && (i.force = i.force.sub(t.sub(i.Center).mul(e * 1e-4)));
  }
  ComputeRepulsiveForces(t) {
    const e = t.length;
    if (e > 16 && this.settings.ApproximateRepulsion) {
      const i = new Array(t.length), s = 2 * (Math.PI / e);
      let n = 0;
      for (let a = 0; a < e; a++)
        i[a] = new Jf(t[a].Center.add(new u(Math.cos(n), Math.sin(n)).mul(1e-5))), n += s;
      new Kf(i, 8).ComputeForces(5);
      for (let a = 0; a < t.length; a++)
        this.AddRepulsiveForce(t[a], i[a].force);
    } else
      for (const i of t) {
        let s = new u(0, 0);
        for (const n of t)
          i != n && (s = s.add(Re.Force(i.Center, n.Center)));
        this.AddRepulsiveForce(i, s);
      }
  }
  SetBarycenter(t) {
    const e = this.clustersInfo.get(t);
    if (e != null)
      return e.barycenter;
    let i = new u(0, 0);
    if (t.shallowNodeCount || $f(t)) {
      const s = this.clustersInfo.get(t);
      if ((s == null || s.weight == null) && this.computeWeight(t), s.weight != null) {
        for (const n of t.shallowNodes)
          n instanceof Jt ? i = i.add(n.center) : i = i.add(this.SetBarycenter(n).mul(this.clustersInfo.get(n).weight));
        this.clustersInfo.get(t).barycenter = i = i.div(s.weight);
      }
    } else
      this.clustersInfo.get(t).barycenter = i;
    return i;
  }
  computeWeight(t) {
    let e = 0;
    for (const s of t.shallowNodes)
      s.entity instanceof di ? e += this.computeWeight(s) : e++;
    let i = this.clustersInfo.get(t);
    return i == null && this.clustersInfo.set(t, i = { barycenter: new u(0, 0) }), i.weight = e, e;
  }
  AddClusterForces(t) {
    if (t != null) {
      this.SetBarycenter(t);
      for (const e of this.clusterEdges) {
        const i = $.getGeom(e.source), s = $.getGeom(e.target), n = yi.getAlgData(e.source).data, r = yi.getAlgData(e.target).data, a = i.hasOwnProperty("shallowNodes"), l = a ? this.clustersInfo.get(i).barycenter : i.center, h = s.hasOwnProperty("shallowNodes"), c = h ? this.clustersInfo.get(s).barycenter : s.center;
        let d = l.sub(c);
        const f = d.length, p = 1e-8 * (this.settings.AttractiveInterClusterForceConstant * (f * Math.log(f + 0.1)));
        if (d = d.mul(p), a) {
          const P = i;
          for (const y of P.shallowNodes) {
            const C = yi.getAlgData(y.node).data;
            C.force = C.force.add(d);
          }
        } else
          n.force = n.force.add(d);
        if (h) {
          const P = s;
          for (const y of P.shallowNodes) {
            const C = yi.getAlgData(y.node).data;
            C.force = C.force.sub(d);
          }
        } else
          r.force = r.force.sub(d);
      }
      for (const e of t.subgraphsDepthFirst) {
        const i = this.clustersInfo.get(e).barycenter;
        for (const s of e.shallowNodes)
          kn.AddGravityForce(i, this.settings.ClusterGravity, Ho(s));
      }
    }
  }
  //  Aggregate all the forces affecting each node
  ComputeForces() {
    if (this.components != null)
      for (const t of this.components)
        this.ComputeRepulsiveForces(t);
    else
      this.ComputeRepulsiveForces(this.nodes);
    this.edges.forEach((t) => this.AddSpringForces(t));
    for (const t of this.components) {
      let e = new u(0, 0);
      for (let s = 0; s < t.length; s++)
        e = e.add(t[s].Center);
      e = e.div(t.length);
      let i = Number.NEGATIVE_INFINITY;
      for (let s = 0; s < t.length; s++) {
        const n = t[s];
        kn.AddGravityForce(e, this.settings.GravityConstant, n), n.force.length > i && (i = n.force.length);
      }
      if (i > 100)
        for (let s = 0; s < t.length; s++)
          t[s].force = t[s].force.mul(100 / i);
    }
    this.AddClusterForces(this.graph);
  }
  //  Checks if solvers need to be applied, i.e. if there are user constraints or
  //  generated constraints (such as non-overlap) that need satisfying
  //  Force directed layout is basically an iterative approach to solving a bunch of differential equations.
  //  Different integration schemes are possible for applying the forces iteratively.  Euler is the simplest:
  //   v_(i+1) = v_i + a dt
  //   x_(i+1) = x_i + v_(i+1) dt
  //
  //  Verlet is much more stable (and not really much more complicated):
  //   x_(i+1) = x_i + (x_i - x_(i-1)) + a dt dt
  VerletIntegration() {
    const t = this.energy;
    this.energy = this.ComputeDescentDirection(1), this.UpdateStepSize(t);
    let e = 0;
    for (let i = 0; i < this.nodes.length; i++) {
      const s = this.nodes[i];
      e += s.Center.sub(s.previousCenter).lengthSquared;
    }
    return e;
  }
  ComputeDescentDirection(t) {
    this.ResetForceVectors(), this.settings.ApplyForces && this.ComputeForces();
    let e = 0;
    for (const i of this.nodes) {
      e = e + i.force.lengthSquared;
      let s = i.Center.sub(i.previousCenter).mul(this.settings.Friction);
      const n = i.force.mul(-this.stepSize * t);
      i.previousCenter = i.Center, at.assert(!Number.isNaN(n.x), "!double.IsNaN(a.X)"), at.assert(!Number.isNaN(n.y), "!double.IsNaN(a.Y)"), at.assert(Number.isFinite(n.x), "!double.IsInfinity(a.X)"), at.assert(Number.isFinite(n.y), "!double.IsInfinity(a.Y)"), s = s.add(n), s = s.div(i.stayWeight), i.Center = i.Center.add(s);
    }
    return e;
  }
  ResetForceVectors() {
    for (const t of this.nodes)
      t.force = new u(0, 0);
  }
  //  Adapt StepSize based on change of energy.
  //  Five sequential improvements of energy mean we increase the stepsize.
  //  Any increase of energy means we reduce the stepsize.
  UpdateStepSize(t) {
    this.energy < t ? ++this.progress >= 3 && (this.progress = 0, this.stepSize /= this.settings.Decay) : (this.progress = 0, this.stepSize *= this.settings.Decay);
  }
  RungeKuttaIntegration() {
    const t = new Array(this.nodes.length), e = new Array(this.nodes.length), i = new Array(this.nodes.length), s = new Array(this.nodes.length), n = new Array(this.nodes.length), r = this.energy;
    for (let l = 0; l < this.nodes.length; l++)
      this.nodes[l].previousCenter = this.nodes[l].Center, t[l] = this.nodes[l].Center;
    const a = 3;
    this.ComputeDescentDirection(a);
    for (let l = 0; l < this.nodes.length; l++)
      e[l] = this.nodes[l].Center.sub(this.nodes[l].previousCenter), this.nodes[l].Center = t[l].add(e[l].mul(0.5));
    this.ComputeDescentDirection(a);
    for (let l = 0; l < this.nodes.length; l++)
      i[l] = this.nodes[l].Center.sub(this.nodes[l].previousCenter), this.nodes[l].previousCenter = t[l], this.nodes[l].Center = t[l].add(i[l].mul(0.5));
    this.ComputeDescentDirection(a);
    for (let l = 0; l < this.nodes.length; l++)
      s[l] = this.nodes[l].Center.sub(this.nodes[l].previousCenter), this.nodes[l].previousCenter = t[l], this.nodes[l].Center = t[l].add(s[l]);
    this.energy = this.ComputeDescentDirection(a);
    for (let l = 0; l < this.nodes.length; l++) {
      n[l] = this.nodes[l].Center.sub(this.nodes[l].previousCenter), this.nodes[l].previousCenter = t[l];
      const h = e[l].add(i[l].mul(2).add(s[l].mul(2)).add(n[l])).div(6);
      this.nodes[l].Center = t[l].add(h);
    }
    return this.UpdateStepSize(r), this.nodes.reduce((l, h) => h.Center.sub(h.previousCenter).lengthSquared + l, 0);
  }
  //  Apply a small number of iterations of the layout.
  //  The idea of incremental layout is that settings.minorIterations should be a small number (e.g. 3) and
  //  CalculateLayout should be invoked of a loop, e.g.:
  //
  //  while(settings.RemainingIterations > 0) {
  //     fastIncrementalLayout.CalculateLayout();
  //     InvokeYourProcedureToRedrawTheGraphOrHandleInteractionEtc();
  //  }
  //
  //  In the verletIntegration step above, the RemainingIterations is used to control damping.
  run() {
    this.settings.Converged = !1, this.settings.EdgeRoutesUpToDate = !1, this.settings.Iterations++ == 0 && (this.stepSize = this.settings.InitialStepSize, this.energy = Number.MAX_VALUE, this.progress = 0);
    for (let t = 0; t < this.settings.MinorIterations; t++) {
      if ((this.settings.RungeKuttaIntegration ? this.RungeKuttaIntegration() : this.VerletIntegration()) < this.settings.DisplacementThreshold || this.settings.Iterations > this.settings.MaxIterations) {
        this.settings.Converged = !0;
        break;
      }
      this.ProgressStep();
    }
  }
}
function $f(o) {
  for (const t of o.Clusters)
    return !0;
  return !1;
}
class Xi {
  get edgeRoutingSettings() {
    return this.commonSettings.edgeRoutingSettings;
  }
  set edgeRoutingSettings(t) {
    this.commonSettings.edgeRoutingSettings = t;
  }
  get PackingAspectRatio() {
    return this.commonSettings.PackingAspectRatio;
  }
  set PackingAspectRatio(t) {
    this.commonSettings.PackingAspectRatio = t;
  }
  get NodeSeparation() {
    return this.commonSettings.NodeSeparation;
  }
  set NodeSeparation(t) {
    this.commonSettings.NodeSeparation = t;
  }
  //  Stop after maxIterations completed
  get MaxIterations() {
    return this.maxIterations;
  }
  set MaxIterations(t) {
    this.maxIterations = t;
  }
  //  Number of iterations in inner loop.
  get MinorIterations() {
    return this.minorIterations;
  }
  set MinorIterations(t) {
    this.minorIterations = t;
  }
  //  Number of iterations completed
  get Iterations() {
    return this.iterations;
  }
  set Iterations(t) {
    this.iterations = t;
  }
  //  number of times to project over all constraints at each layout iteration
  get ProjectionIterations() {
    return this.projectionIterations;
  }
  set ProjectionIterations(t) {
    this.projectionIterations = t;
  }
  //  Rather than computing the exact repulsive force between all pairs of nodes (which would take O(n^2) time for n nodes)
  //  use a fast inexact technique (that takes O(n log n) time)
  get ApproximateRepulsion() {
    return this.approximateRepulsion;
  }
  set ApproximateRepulsion(t) {
    this.approximateRepulsion = t;
  }
  //  StepSize taken at each iteration (a coefficient of the force on each node) adapts depending on change in
  //  potential energy at each step.  With this scheme changing the InitialStepSize doesn't have much effect
  //  because if it is too large or too small it will be quickly updated by the algorithm anyway.
  get InitialStepSize() {
    return this.initialStepSize;
  }
  set InitialStepSize(t) {
    if (t <= 0 || t > 2)
      throw new Error("ForceScalar should be greater than 0 and less than 2 (if we let you set it to 0 nothing would happen, greater than 2 would most likely be very unstable!)");
    this.initialStepSize = t;
  }
  //  FrictionalDecay isn't really friction so much as a scaling of velocity to improve convergence.  0.8 seems to work well.
  get Decay() {
    return this.decay;
  }
  set Decay(t) {
    if (t < 0.1 || t > 1)
      throw new Error("Setting decay too small gives no progress.  1==no decay, 0.1==minimum allowed value");
    this.decay = t;
  }
  //  Friction isn't really friction so much as a scaling of velocity to improve convergence.  0.8 seems to work well.
  get Friction() {
    return this.friction;
  }
  set Friction(t) {
    if (t < 0 || t > 1)
      throw new Error("Setting friction less than 0 or greater than 1 would just be strange.  1==no friction, 0==no conservation of velocity");
    this.friction = t;
  }
  //  strength of repulsive force between each pair of nodes.  A setting of 1.0 should work OK.
  get RepulsiveForceConstant() {
    return this.repulsiveForceConstant;
  }
  set RepulsiveForceConstant(t) {
    this.repulsiveForceConstant = t;
  }
  //  strength of attractive force between pairs of nodes joined by an edge.  A setting of 1.0 should work OK.
  get AttractiveForceConstant() {
    return this.attractiveForceConstant;
  }
  set AttractiveForceConstant(t) {
    this.attractiveForceConstant = t;
  }
  //  gravity is a constant force applied to all nodes attracting them to the Origin
  //  and keeping disconnected components from flying apart.  A setting of 1.0 should work OK.
  get GravityConstant() {
    return this.gravity;
  }
  set GravityConstant(t) {
    this.gravity = t;
  }
  //  If the following is false forces will not be considered between each component and each component will have its own gravity origin.
  get InterComponentForces() {
    return this.interComponentForces;
  }
  set InterComponentForces(t) {
    this.interComponentForces = t;
  }
  //  If the following is false forces will not be applied, but constraints will still be satisfied.
  get ApplyForces() {
    return this.applyForces;
  }
  set ApplyForces(t) {
    this.applyForces = t;
  }
  constructor() {
    this.commonSettings = new Ys(), this.maxIterations = 100, this.clusterMargin = 10, this.minorIterations = 3, this.projectionIterations = 5, this.approximateRepulsion = !0, this.RungeKuttaIntegration = !1, this.initialStepSize = 1.4, this.decay = 0.9, this.friction = 0.8, this.repulsiveForceConstant = 1, this.attractiveForceConstant = 1, this.gravity = 1, this.interComponentForces = !0, this.applyForces = !0, this.AvoidOverlaps = !0, this.approximateRouting = !0, this.logScaleEdgeForces = !0, this.displacementThreshold = 0.1, this.maxConstraintLevel = 2, this.minConstraintLevel = 0, this.attractiveInterClusterForceConstant = 1, this.clusterGravity = 1, this.commonSettings.NodeSeparation *= 2;
  }
  //  restart layout, use e.g. after a mouse drag or non-structural change to the graph
  ResetLayout() {
    this.Unconverge(), this.algorithm != null && this.algorithm.ResetNodePositions();
  }
  /**   reset iterations and convergence status*/
  Unconverge() {
    this.iterations = 0, this.converged = !1;
  }
  InitializeLayoutGN(t, e) {
    this.InitializeLayout(t, e);
  }
  //  Initialize the layout algorithm
  InitializeLayout(t, e) {
    this.algorithm = new kn(t, this, e), this.ResetLayout();
  }
  //
  Uninitialize() {
    this.algorithm = null;
  }
  //
  get IsInitialized() {
    return this.algorithm != null;
  }
  //
  IncrementalRunG(t) {
    this.IncrementalRunGF(t);
  }
  SetupIncrementalRun(t) {
    this.IsInitialized ? this.IsDone && this.ResetLayout() : this.InitializeLayout(t, this.MaxConstraintLevel);
  }
  //  Run the FastIncrementalLayout instance incrementally
  IncrementalRunGF(t) {
    this.SetupIncrementalRun(t), this.algorithm.run();
  }
  //
  IncrementalRun(t, e) {
    t?.throwIfCanceled(), this.SetupIncrementalRun(e), this.algorithm.cancelToken = t, this.algorithm.run();
  }
  Clone() {
    return Xi.ctorClone(this);
  }
  //  If RouteEdges is true then the following is checked to see whether to do optimal shortest path routing
  //  or use a sparse visibility graph spanner to do approximate---but much faster---shortest path routing
  get ApproximateRouting() {
    return this.approximateRouting;
  }
  set ApproximateRouting(t) {
    this.approximateRouting = t;
  }
  //  If true then attractive forces across edges are computed as:
  //  AttractiveForceConstant * actualLength * Math.Log((actualLength + epsilon) / (idealLength + epsilon))
  //  where epsilon is a small positive constant to avoid divide by zero or taking the log of zero.
  //  Note that LogScaleEdges can lead to ghost forces in highly constrained scenarios.
  //  If false then a the edge force is based on (actualLength - idealLength)^2, which works better with
  //  lots of constraints.
  get LogScaleEdgeForces() {
    return this.logScaleEdgeForces;
  }
  set LogScaleEdgeForces(t) {
    this.logScaleEdgeForces = t;
  }
  //  If the amount of total squared displacement after a particular iteration falls below DisplacementThreshold then Converged is set to true.
  //  Make DisplacementThreshold larger if you want layout to finish sooner - but not necessarily make as much progress towards a good layout.
  get DisplacementThreshold() {
    return this.displacementThreshold;
  }
  set DisplacementThreshold(t) {
    this.displacementThreshold = t;
  }
  //  Set to true if displacement from the last iteration was less than DisplacementThreshold.
  //  The caller should invoke FastIncrementalLayout.CalculateLayout() in a loop, e.g.:
  //
  //   while(!settings.Converged)
  //   {
  //     layout.CalculateLayout();
  //     redrawGraphOrHandleInteractionOrWhatever();
  //   }
  //
  //  RemainingIterations affects damping.
  get Converged() {
    return this.converged;
  }
  set Converged(t) {
    this.converged = t;
  }
  //  Return iterations as a percentage of MaxIterations.  Useful for reporting progress, e.g. in a progress bar.
  get PercentDone() {
    return this.Converged ? 100 : 100 * this.iterations / this.MaxIterations;
  }
  //  Not quite the same as Converged:
  get IsDone() {
    return this.Converged || this.iterations >= this.MaxIterations;
  }
  //  Returns an estimate of the cost function calculated in the most recent iteration.
  //  It's a float because FastIncrementalLayout.Energy is a volatile float so it
  //  can be safely read from other threads
  get Energy() {
    return this.algorithm != null ? this.algorithm.energy : 0;
  }
  //
  get MaxConstraintLevel() {
    return this.maxConstraintLevel;
  }
  set MaxConstraintLevel(t) {
    this.maxConstraintLevel != t && (this.maxConstraintLevel = t, this.IsInitialized && this.Uninitialize());
  }
  //
  get MinConstraintLevel() {
    return this.minConstraintLevel;
  }
  set MinConstraintLevel(t) {
    this.minConstraintLevel = t;
  }
  //  Constraint level ranges from Min to MaxConstraintLevel.
  //  0 = no constraints
  //  1 = only structural constraints
  //  2 = all constraints including non-overlap constraints
  //
  //  A typical run of FastIncrementalLayout will apply it at each constraint level, starting at 0 to
  //  obtain an untangled unconstrained layout, then 1 to introduce structural constraints and finally 2 to beautify.
  //  Running only at level 2 will most likely leave the graph stuck in a tangled local minimum.
  getCurrentConstraintLevel() {
    return this.algorithm == null ? 0 : this.algorithm.getCurrentConstraintLevel();
  }
  setCurrentConstraintLevel(t) {
    this.algorithm.setCurrentConstraintLevel(t);
  }
  //  Attractive strength of edges connected to clusters
  get AttractiveInterClusterForceConstant() {
    return this.attractiveInterClusterForceConstant;
  }
  set AttractiveInterClusterForceConstant(t) {
    this.attractiveInterClusterForceConstant = t;
  }
  //  Shallow copy the settings
  static ctorClone(t) {
    const e = new Xi();
    return e.maxIterations = t.maxIterations, e.minorIterations = t.minorIterations, e.projectionIterations = t.projectionIterations, e.approximateRepulsion = t.approximateRepulsion, e.initialStepSize = t.initialStepSize, e.RungeKuttaIntegration = t.RungeKuttaIntegration, e.decay = t.decay, e.friction = t.friction, e.repulsiveForceConstant = t.repulsiveForceConstant, e.attractiveForceConstant = t.attractiveForceConstant, e.gravity = t.gravity, e.interComponentForces = t.interComponentForces, e.applyForces = t.applyForces, e.AvoidOverlaps = t.AvoidOverlaps, e.RespectEdgePorts = t.RespectEdgePorts, e.RouteEdges = t.RouteEdges, e.approximateRouting = t.approximateRouting, e.logScaleEdgeForces = t.logScaleEdgeForces, e.displacementThreshold = t.displacementThreshold, e.minConstraintLevel = t.minConstraintLevel, e.maxConstraintLevel = t.maxConstraintLevel, e.attractiveInterClusterForceConstant = t.attractiveInterClusterForceConstant, e.clusterGravity = t.clusterGravity, e.PackingAspectRatio = t.PackingAspectRatio, e.NodeSeparation = t.NodeSeparation, e.clusterMargin = t.clusterMargin, e;
  }
  //  Controls how tightly members of clusters are pulled together
  get ClusterGravity() {
    return this.clusterGravity;
  }
  set ClusterGravity(t) {
    this.clusterGravity = t;
  }
  //      creates the settings that seems working
  //  <returns></returns>
  static CreateFastIncrementalLayoutSettings() {
    const t = new Xi();
    return t.ApplyForces = !1, t.ApproximateRepulsion = !0, t.ApproximateRouting = !0, t.AttractiveForceConstant = 1, t.AttractiveInterClusterForceConstant = 1, t.AvoidOverlaps = !0, t.ClusterGravity = 1, t.Decay = 0.9, t.DisplacementThreshold = 5e-8, t.Friction = 0.8, t.GravityConstant = 1, t.InitialStepSize = 2, t.InterComponentForces = !1, t.Iterations = 0, t.LogScaleEdgeForces = !1, t.MaxConstraintLevel = 2, t.MaxIterations = 20, t.MinConstraintLevel = 0, t.MinorIterations = 1, t.ProjectionIterations = 5, t.RepulsiveForceConstant = 2, t.RespectEdgePorts = !1, t.RouteEdges = !1, t.RungeKuttaIntegration = !0, t.NodeSeparation = 20, t;
  }
}
class tg {
  constructor(t) {
    this.topNodes = t;
  }
  get nodesBreadthFirst() {
    return this.nodesBreadthFirst_();
  }
  *nodesBreadthFirst_() {
    for (const t of this.topNodes)
      if (yield Jt.getGeom(t), t instanceof di)
        for (const e of t.nodesBreadthFirst)
          yield Jt.getGeom(e);
  }
  get Clusters() {
    return this.clusters();
  }
  *clusters() {
    for (const t of this.topNodes)
      t instanceof di && (yield Rt.getGeom(t));
  }
  get subgraphsDepthFirst() {
    return this.subgraphsDepthFirst_();
  }
  *subgraphsDepthFirst_() {
    for (const t of this.topNodes)
      if (t instanceof di) {
        const e = Rt.getGeom(t);
        yield* e.subgraphsDepthFirst, yield e;
      }
  }
  get shallowEdges() {
    return this.edges_();
  }
  *edges_() {
    for (const t of this.topNodes) {
      for (const e of t.outEdges)
        yield Zt.getGeom(e);
      for (const e of t.selfEdges)
        yield Zt.getGeom(e);
    }
  }
  get shallowNodes() {
    return this.shallowNodes_();
  }
  *shallowNodes_() {
    for (const t of this.topNodes)
      yield Jt.getGeom(t);
  }
  pumpTheBoxToTheGraphWithMargins() {
    const t = { b: T.mkEmpty() };
    return oa(this, t), this.boundingBox = t.b;
  }
  get shallowNodeCount() {
    return this.topNodes.length;
  }
  translate(t) {
    this.boundingBox && (this.boundingBox.center = this.boundingBox.center.add(t));
    for (const e of this.topNodes)
      Jt.getGeom(e).translate(t);
  }
}
class Ol {
  //  Linearly interpolates a result between the minResult and the maxResult based on the location of the value between the lowerThreshold and the upperThreshold.
  //  <returns>The linearly interpolated result.  Between minResult and maxResult, inclusive.</returns>
  static LinearInterpolation(t, e, i, s, n) {
    if (t < e)
      return s;
    if (t > i)
      return n;
    const r = (t - e) / (i - e);
    return s + r * (n - s);
  }
  //  Negatively linearly interpolates a result between the minResult and the maxResult based on the location of the value between the lowerThreshold and the upperThreshold.
  //  <returns>The linearly interpolated result.  Between minResult and maxResult, inclusive.</returns>
  static NegativeLinearInterpolation(t, e, i, s, n) {
    if (t < e)
      return n;
    if (t > i)
      return s;
    const r = (t - e) / (i - e);
    return s + (1 - r) * (n - s);
  }
}
class eg extends lt {
  //  Static layout of graph by gradually adding constraints.
  //  Uses PivotMds to find initial layout.
  //  Breaks the graph into connected components (nodes of the same cluster are considered
  //  connected whether or not there is an edge between them), then lays out each component
  //  individually.  Finally, a simple packing is applied.
  //  ratio as close as possible to the PackingAspectRatio property (not currently used).
  constructor(t, e) {
    super(null), this.SingleComponent = !1, this.graph = t, this.settings = Xi.ctorClone(e), this.settings.ApplyForces = !0, this.settings.InterComponentForces = !0, this.settings.RungeKuttaIntegration = !1, this.settings.RespectEdgePorts = !1;
  }
  //  The actual layout process
  run() {
    if (this.SingleComponent)
      this.componentCount = 1, this.LayoutComponent(this.graph);
    else {
      const t = Array.from(this.graph.graph.getClusteredConnectedComponents()).map((e) => new tg(e));
      this.componentCount = t.length;
      for (const e of t)
        this.LayoutComponent(e);
      this.graph.boundingBox = Vn.PackGraphs(t, this.settings.commonSettings);
    }
  }
  LayoutComponent(t) {
    if (t.shallowNodeCount > 1) {
      if (this.settings.MaxIterations = Ol.NegativeLinearInterpolation(t.shallowNodeCount, 50, 500, 5, 10), this.settings.MinorIterations = Ol.NegativeLinearInterpolation(t.shallowNodeCount, 50, 500, 3, 20), this.settings.MinConstraintLevel == 0) {
        const i = new Dn();
        i.removeOverlaps = !1, i.IterationsWithMajorization = 0, new Qh(t, null, () => 1, new Dn()).run();
      }
      const e = new kn(t, this.settings, this.settings.MinConstraintLevel);
      for (const i of this.GetConstraintLevels(t)) {
        if (i > this.settings.MaxConstraintLevel)
          break;
        i > this.settings.MinConstraintLevel && e.setCurrentConstraintLevel(i);
        do
          e.run();
        while (!this.settings.IsDone);
      }
      this.settings.AvoidOverlaps && qe.RemoveOverlaps(Array.from(this.graph.shallowNodes), this.settings.NodeSeparation);
    }
    t.pumpTheBoxToTheGraphWithMargins(), t.uniformMargins = this.settings.NodeSeparation, t.translate(t.boundingBox.leftBottom.mul(-1));
  }
  /** returns 0, 1 or 2:
   *   Get the distinct ConstraintLevels that need to be applied to layout.
    Used by InitialLayout.
   Will only include ConstraintLevel == 2 if AvoidOverlaps is on and there are fewer than 2000 nodes
   */
  GetConstraintLevels(t) {
    const e = /* @__PURE__ */ new Set();
    return e.add(0), this.settings.AvoidOverlaps && t.shallowNodeCount < 2e3 && e.add(2), e;
  }
}
function Kh(o) {
  o.layoutSettings || (o.layoutSettings = Zh(o));
}
function ig(o) {
  let t = o.parent;
  for (; t; ) {
    if (t.layoutSettings)
      return t.layoutSettings;
    t = t.parent;
  }
  return null;
}
function Zh(o) {
  const t = ig(o);
  if (t)
    return t;
  if (o.graph.shallowNodeCount > 2e3 || o.graph.deepEdgesCount > 4e3)
    return new Xi();
  let i = !1;
  for (const s of o.deepEdges)
    if (s.sourceArrowhead != null || s.targetArrowhead != null) {
      i = !0;
      break;
    }
  return i ? new en() : new Xi();
}
function sg(o, t, e = () => 1) {
  if (Kh(o), o.layoutSettings instanceof en)
    new oc(o, o.layoutSettings, t).run();
  else if (o.layoutSettings instanceof Dn)
    new Qh(o, t, e, o.layoutSettings).run();
  else if (o.layoutSettings instanceof Xi) {
    const i = new eg(o, o.layoutSettings);
    i.SingleComponent = !0, i.run();
  } else
    throw new Error("not implemented");
}
function ng(o, t = null) {
  Kh(o), ec(o, t, sg, tc, Dd), hg(o);
}
function $h(o) {
  do {
    if (o.layoutSettings && o.layoutSettings.commonSettings.edgeRoutingSettings)
      return o.layoutSettings.commonSettings.edgeRoutingSettings;
    const e = o.graph.parent;
    if (e)
      o = $.getGeom(e);
    else
      break;
  } while (!0);
  const t = new Fn();
  return t.EdgeRoutingMode = Kt.Spline, t;
}
function tc(o, t, e) {
  const i = $h(o);
  i.EdgeRoutingMode === Kt.Rectilinear ? ag(o, t) : i.EdgeRoutingMode === Kt.Spline || i.EdgeRoutingMode === Kt.SplineBundling ? Eg(o, t, e) : i.EdgeRoutingMode === Kt.StraightLine ? Yh(o, t, e) : i.EdgeRoutingMode !== Kt.None && new it(o, t).run(), ic(o, t);
}
function ec(o, t, e, i, s, n = 1, r = () => 1) {
  if (o.graph.isEmpty())
    return;
  o.shallowNodes.next(), o.parent == null && (eo(n), lg(o));
  const a = f();
  d(o);
  const l = rg(o.graph), h = og(o);
  if (p(), l.forEach((P) => {
    P[0].edge.remove(), P[1].add();
  }), h.forEach((P) => {
    for (const y of P.graph.shallowNodes)
      y.parent = o.graph;
  }), a.forEach((P) => P.add()), o.graph.parent == null) {
    const P = c(o);
    i(o, P, t), ic(o, P), o.pumpTheBoxToTheGraphWithMargins();
  }
  function c(P) {
    const y = [];
    for (const C of P.nodesBreadthFirst) {
      for (const E of C.outEdges())
        E.curve == null && y.push(E);
      for (const E of C.selfEdges())
        E.curve == null && y.push(E);
    }
    return y;
  }
  function d(P) {
    for (const y of P.shallowNodes)
      y instanceof Rt && ec(y, t, e, i, s);
  }
  function f() {
    const P = /* @__PURE__ */ new Set(), y = o.graph;
    if (y.parent == null)
      return P;
    for (const C of y.shallowNodes) {
      for (const E of C.outEdges) {
        const N = y.liftNode(E.target);
        (N == null || N === C) && P.add(E);
      }
      for (const E of C.inEdges) {
        const N = y.liftNode(E.source);
        (N == null || N === C) && P.add(E);
      }
    }
    for (const C of P)
      C.remove();
    return P;
  }
  function p() {
    if (h.length === 1)
      e(o, t, r);
    else {
      for (const P of h)
        e(P, t, r), P.boundingBox = P.pumpTheBoxToTheGraphWithMargins();
      s(o, h);
    }
  }
}
function rg(o) {
  const t = new Array();
  for (const e of o.nodesBreadthFirst) {
    const i = o.liftNode(e);
    if (i != null)
      for (const s of e.outEdges.values()) {
        const n = s.target, r = o.liftNode(n);
        if (r == null || i === e && r === n || i === r)
          continue;
        s.remove();
        const a = new Vh(i, r), l = new Zt(a);
        t.push([l, s]);
      }
  }
  return t;
}
function og(o) {
  var t;
  const e = o.graph, i = Rd(e), s = [];
  let n = 0;
  for (const r of i) {
    const a = new di(e.id + n++);
    a.parent = e;
    const l = new Rt(a);
    l.layoutSettings = (t = o.layoutSettings) !== null && t !== void 0 ? t : Zh(o);
    for (const h of r)
      h.parent = a, a.addNode(h);
    s.push(l);
  }
  return s;
}
function ag(o, t, e, i = 1, s = 3, n = 3) {
  const r = bt.constructorGNAN(o, t, i, s);
  r.edgeSeparatian = n, r.run();
}
function ic(o, t) {
  if (t.length === 0)
    return;
  z.constructorGA(o, t).run();
}
function lg(o) {
  for (const t of o.deepEdges)
    t.label && (t.label.isPositioned = !1);
}
function hg(o) {
  const t = o.boundingBox.leftBottom;
  if (t.x < 0 || t.y < 0) {
    const e = new u(-t.x, -t.y);
    o.translate(e);
  }
}
class va {
  static constructorStatic(t, e) {
    const i = new va();
    i.edges = t, i.nodeBoundaries = e, i.boundingBox = T.mkEmpty();
    for (const s of i.nodeBoundaries)
      i.boundingBox = i.boundingBox.addRec(s.boundingBox);
    return i;
  }
  AddGraph(t) {
    this.edges = this.edges.concat(t.edges), this.nodeBoundaries = zs(this.nodeBoundaries, t.nodeBoundaries), this.boundingBox.addRec(t.boundingBox);
  }
  AddNodeBoundary(t) {
    this.nodeBoundaries.add(t), this.boundingBox.addRec(t.boundingBox);
  }
}
var jo;
(function(o) {
  o[o.Success = 0] = "Success", o[o.Overlaps = 1] = "Overlaps", o[o.EdgeSeparationIsTooLarge = 2] = "EdgeSeparationIsTooLarge";
})(jo || (jo = {}));
class dr {
  get CurrentPiercedEdge() {
    return this.currentPiercedEdge;
  }
  get CurrentTriangle() {
    return this.currentTriangle;
  }
  constructor(t, e, i) {
    this.currentTriangle = t, this.start = e, this.end = i;
  }
  /**This method finds the first edge of the current triangle that
     * is pierced by a segment (start,end). It assumes that the start
     * point is inside or on the boundary of the current triangle,
     *  and the end point is outside.
     * The function works by computing the sign of each vertex
     *  of the current triangle with respect to the segment.
     *  The sign is zero if the vertex is on the segment,
     * positive if it is to the right of the segment  (when looking from the start point to the end point),
     * and negative if it is to the left.
     * The function then checks if there are two consecutive
     * vertices with different signs. If so, it means that the edge between them is pierced by the segment. The function returns that edge as the result.
  
  The function also sets the positiveSign and negativeSign fields to store the signs of the vertices on either side of the pierced edge. This is useful for finding the next triangle in the path of the segment. */
  FindFirstPiercedEdge() {
    const t = this.GetHyperplaneSign(this.currentTriangle.Sites.item0), e = this.GetHyperplaneSign(this.currentTriangle.Sites.item1);
    if (t !== e && u.getTriangleOrientation(this.end, this.currentTriangle.Sites.item0.point, this.currentTriangle.Sites.item1.point) == L.Clockwise)
      return this.positiveSign = t, this.negativeSign = e, this.currentTriangle.Edges.item0;
    const i = this.GetHyperplaneSign(this.currentTriangle.Sites.item2);
    return e !== i && u.getTriangleOrientation(this.end, this.currentTriangle.Sites.item1.point, this.currentTriangle.Sites.item2.point) == L.Clockwise ? (this.positiveSign = e, this.negativeSign = i, this.currentTriangle.Edges.item1) : (this.positiveSign = i, this.negativeSign = t, this.currentTriangle.Edges.item2);
  }
  FindNextPierced() {
    if (this.currentTriangle = this.currentPiercedEdge.GetOtherTriangle_T(this.currentTriangle), this.currentTriangle == null) {
      this.currentPiercedEdge = null;
      return;
    }
    const t = this.currentTriangle.Edges.index(this.currentPiercedEdge);
    let e;
    const i = this.currentTriangle.Sites.getItem(t + 2), s = this.GetHyperplaneSign(i);
    this.negativeSign === 0 ? s === -1 || s === 0 ? (this.negativeSign = s, e = t + 1) : e = t + 2 : this.positiveSign === 0 ? s === 1 || s === 0 ? (this.positiveSign = s, e = t + 2) : e = t + 1 : s !== this.positiveSign ? (this.negativeSign = s, e = t + 1) : (this.positiveSign = s, e = t + 2), this.currentPiercedEdge = u.signedDoubledTriangleArea(this.end, this.currentTriangle.Sites.getItem(e).point, this.currentTriangle.Sites.getItem(e + 1).point) < -m.distanceEpsilon ? this.currentTriangle.Edges.getItem(e) : null;
  }
  //        void ShowDebug(Array<CdtTriangle> cdtTriangles, CdtEdge cdtEdge, CdtTriangle cdtTriangle) {
  //            var l = new Array<DebugCurve> { new DebugCurve(10,"red",new LineSegment(start,end)) };
  //            if(cdtEdge!=null)
  //                l.Add(new DebugCurve(100,3,"navy", new LineSegment(cdtEdge.upperSite.point,cdtEdge.lowerSite.point)));
  //            AddTriangleToListOfDebugCurves(l,cdtTriangle,100,2,"brown");
  //            LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);
  //
  //        }
  //        static void AddTriangleToListOfDebugCurves(Array<DebugCurve> debugCurves,CdtTriangle triangle,byte transparency,double width,string color) {
  //            foreach(var cdtEdge of triangle.Edges) {
  //                debugCurves.Add(new DebugCurve(transparency,width,color,new LineSegment(cdtEdge.upperSite.point,cdtEdge.lowerSite.point)));
  //            }
  //        }
  GetHyperplaneSign(t) {
    const e = u.signedDoubledTriangleArea(this.start, t.point, this.end);
    return e > m.distanceEpsilon ? 1 : e < -m.distanceEpsilon ? -1 : 0;
  }
  MoveNext() {
    return this.currentPiercedEdge == null ? this.currentPiercedEdge = this.FindFirstPiercedEdge() : this.FindNextPierced(), this.currentPiercedEdge != null;
  }
}
class Ca {
  EdgeIsLegal_(t, e, i, s) {
    if (gt.PointIsInsideOfTriangle(e, i))
      return !0;
    const n = new dr(i, t, e);
    for (; n.MoveNext(); ) {
      const r = n.CurrentPiercedEdge;
      if (r.constrained) {
        const a = r.lowerSite.Owner;
        if (!s.has(a))
          return !1;
      }
    }
    return !0;
  }
  constructor(t, e) {
    this.ComputeForcesForBundles = !1, this.metroGraphData = t, this.bundlingSettings = e;
  }
  /**   returns false iff an edge overlap an obstacle,
  otherwise it calulates distances to the closest obstacles */
  BundleAvoidsObstacles(t, e, i, s, n, r) {
    r.closestDist = new Array();
    const a = this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(t, e), l = this.FindCloseObstaclesForBundle(e.cdtTriangle, s, i, a, n);
    if (l == null)
      return !1;
    for (const h of l) {
      const c = h[1];
      r.closestDist.push(c);
    }
    return !0;
  }
  // returns null iff the edge overlap an obstacle
  FindCloseObstaclesForBundle(t, e, i, s, n) {
    const r = /* @__PURE__ */ new Map(), a = [];
    if (!this.ThreadLineSegmentThroughTriangles(t, e, i, s, a))
      return null;
    if (!this.ComputeForcesForBundles && !this.bundlingSettings.HighestQuality)
      return r;
    const l = /* @__PURE__ */ new Set();
    for (const h of a)
      for (const c of h.Sites) {
        if (l.has(c))
          continue;
        l.add(c);
        const d = c.Owner;
        if (s.has(d))
          continue;
        const f = Ca.FindPolylinePoint(d, c.point), p = v.minDistBetweenLineSegments(f.point, f.nextOnPolyline.point, e, i), P = p.dist, y = p.parab, C = p.parcd, E = v.minDistBetweenLineSegments(f.point, f.prevOnPolyline.point, e, i), N = E.dist, I = E.parab, x = E.parcd;
        let V, G, X;
        if (P < N) {
          if (X = P, X > n)
            continue;
          V = f.point.add(f.nextOnPolyline.point.sub(f.point).mul(y)), G = e.add(i.sub(e).mul(C));
        } else {
          if (X = N, X > n)
            continue;
          V = f.point.add(f.prevOnPolyline.point.sub(f.point).mul(I)), G = e.add(i.sub(e).mul(x));
        }
        r.get(d) || r.set(d, [V, G]);
      }
    return r;
  }
  /**   returns false iff the edge overlap an obstacle*/
  ThreadLineSegmentThroughTriangles(t, e, i, s, n) {
    if (gt.PointIsInsideOfTriangle(i, t))
      return n.push(t), !0;
    const r = new dr(t, e, i);
    for (n.push(t); r.MoveNext(); ) {
      n.push(r.CurrentTriangle);
      const a = r.CurrentPiercedEdge;
      if (a.constrained) {
        const l = a.lowerSite.Owner;
        if (!s.has(l))
          return !1;
      }
    }
    return r.CurrentTriangle != null && n.push(r.CurrentTriangle), !0;
  }
  static PointLocationInsideTriangle(t, e) {
    let i = !1;
    for (let s = 0; s < 3; s++) {
      const n = u.signedDoubledTriangleArea(t, e.Sites.getItem(s).point, e.Sites.getItem(s + 1).point);
      if (n < m.distanceEpsilon * -1)
        return F.Outside;
      n < m.distanceEpsilon && (i = !0);
    }
    return i ? F.Boundary : F.Inside;
  }
  static FindPolylinePoint(t, e) {
    for (const i of t.polylinePoints())
      if (i.point.equal(e))
        return i;
    throw new Error("polyline point " + e + " not found");
  }
  // checks if an edge intersects obstacles
  // otherwise it calulates distances to the closest obstacles
  EdgeIsLegal(t, e, i, s) {
    const n = [], r = this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(t, e);
    return this.ThreadLineSegmentThroughTriangles(t.cdtTriangle, i, s, r, n);
  }
  // checks if an edge intersects obstacles
  // otherwise it calulates distances to the closest obstacles
  EdgeIsLegalSSPPS(t, e, i) {
    const s = t.Position, n = t.cdtTriangle, r = e.Position;
    if (gt.PointIsInsideOfTriangle(r, n))
      return !0;
    const a = new dr(n, s, r);
    for (; a.MoveNext(); ) {
      const l = a.CurrentPiercedEdge;
      if (l.constrained) {
        const h = l.lowerSite.Owner;
        if (!i.has(h))
          return !1;
      }
    }
    return !0;
  }
}
class Ue {
  constructor(t, e, i, s) {
    this.metroGraphData = t, this.obstaclesToIgnoreLambda = s, this.bundlingSettings = e, this.obstacleTree = i;
  }
  ObstaclesToIgnoreForBundle(t, e) {
    return t != null && e != null ? zs(this.obstaclesToIgnoreLambda(t), this.obstaclesToIgnoreLambda(e)) : t == null && e == null ? /* @__PURE__ */ new Set() : t != null ? this.obstaclesToIgnoreLambda(t) : this.obstaclesToIgnoreLambda(e);
  }
  HubAvoidsObstaclesSPNBA(t, e, i, s) {
    const n = { minimalDistance: i };
    return Ue.IntersectCircleWithTree(this.obstacleTree, e, i, this.obstaclesToIgnoreLambda(t), s.touchedObstacles, n);
  }
  HubAvoidsObstaclesPNS__(t, e, i) {
    const s = { touchedObstacles: Array() }, n = { minimalDistance: 0 };
    return this.HubAvoidsObstaclesPNSTT(t, e, i, s, n);
  }
  GetMinimalDistanceToObstacles(t, e, i) {
    const s = new Array(), n = { minimalDistance: i };
    return Ue.IntersectCircleWithTree(this.obstacleTree, e, i, this.obstaclesToIgnoreLambda(t), s, n) ? n.minimalDistance : 0;
  }
  HubAvoidsObstaclesPNSTT(t, e, i, s, n) {
    return s.touchedObstacles = new Array(), n.minimalDistance = e, Ue.IntersectCircleWithTree(this.obstacleTree, t, e, i, s.touchedObstacles, n);
  }
  // Computes the intersection between the hub and obstacles
  // Returns false iff the center is inside of an obstacle, which is not ignored
  static IntersectCircleWithTree(t, e, i, s, n, r) {
    if (!t.irect.contains_point_radius(e, i))
      return !0;
    if (t.UserData == null) {
      let a = Ue.IntersectCircleWithTree(t.Left, e, i, s, n, r);
      if (!a || (a = Ue.IntersectCircleWithTree(t.Right, e, i, s, n, r), !a))
        return !1;
    } else {
      const a = t.UserData;
      if (s.has(a))
        return !0;
      if (g.PointRelativeToCurveLocation(e, a) !== F.Outside)
        return Ue.containingPoly = a, !1;
      const h = a.value(a.closestParameter(e)), c = h.sub(e).length;
      c <= i && n.push([a, h]), r.minimalDistance = Math.min(c, r.minimalDistance);
    }
    return !0;
  }
  static Create4gon(t, e, i, s) {
    let n = e.sub(t).normalize();
    return n = new u(n.y, n.x * -1), B.mkFromPoints([
      t.add(n.mul(i / 2)),
      t.sub(n.mul(i / 2)),
      e.sub(n.mul(s / 2)),
      e.add(n.mul(s / 2))
    ]);
  }
}
class cg {
  constructor(t, e, i, s) {
    this.Width = e, this.Polyline = t, this.sourceAndTargetLoosePolylines = i, this.Index = s;
  }
  UpdateLengths() {
    let t = 0;
    for (let e = this.Polyline.startPoint; e.next != null; e = e.next)
      t += e.next.point.sub(e.point).length;
    this.Length = t, this.IdealLength = this.Polyline.end.sub(this.Polyline.start).length;
  }
}
class ug {
  constructor(t, e, i) {
    this.metroline = t, this.station = e, this.polyPoint = i;
  }
  get Metroline() {
    return this.metroline;
  }
  get PolyPoint() {
    return this.polyPoint;
  }
}
class dg {
  constructor(t, e, i) {
    this.Radius = 0, this.BundleBases = /* @__PURE__ */ new Map(), this.MetroNodeInfos = new Array(), this._cachedIdealRadius = 0, this.SerialNumber = t, this.IsReal = e, this.Position = i;
  }
  debStop() {
    return (
      //(this.SerialNumber === 1 && this.Position.sub(new Point(706.0327200902565, 203.36018761064003)).length < 0.01) ||
      this.SerialNumber === 28 && this.Position.sub(new u(841.2662778763244, 303.3817005853006)).length < 1e-3
    );
  }
  get Position() {
    return this._Position;
  }
  set Position(t) {
    this._Position = t;
  }
  getELP() {
    return this.EnterableLoosePolylines;
  }
  setELP(t) {
    this.EnterableLoosePolylines = t;
  }
  addEL(t) {
    this.EnterableLoosePolylines.add(t);
  }
  get cachedIdealRadius() {
    return this._cachedIdealRadius;
  }
  set cachedIdealRadius(t) {
    this._cachedIdealRadius = t;
  }
  AddEnterableLoosePolyline(t) {
    this.EnterableLoosePolylines == null && (this.EnterableLoosePolylines = /* @__PURE__ */ new Set()), this.EnterableLoosePolylines.add(t);
  }
  AddEnterableTightPolyline(t) {
    this.EnterableTightPolylines == null && (this.EnterableTightPolylines = /* @__PURE__ */ new Set()), this.EnterableTightPolylines.add(t);
  }
}
class fg {
  constructor() {
    this.Width = 0, this.Metrolines = new Array(), this.cachedBundleCost = 0;
  }
  get Count() {
    return this.Metrolines.length;
  }
}
class Yt {
  constructor(t, e) {
    this.metroGraphData = t, this.bundlingSettings = e;
  }
  // calculate node radii with fixed hubs
  CreateNodeRadii() {
    for (const t of this.metroGraphData.VirtualStations())
      t.Radius = 0, t.cachedIdealRadius = Yt.CalculateIdealHubRadiusWithNeighborsMBS(this.metroGraphData, this.bundlingSettings, t);
    this.GrowHubs(!1), this.GrowHubs(!0);
    for (const t of this.metroGraphData.VirtualStations())
      t.Radius = Math.max(t.Radius, this.bundlingSettings.MinHubRadius);
  }
  // Grow hubs
  GrowHubs(t) {
    const e = new es(yt);
    for (const s of this.metroGraphData.VirtualStations())
      e.Enqueue(s, -this.CalculatePotential(s, t));
    let i = !1;
    for (; !e.IsEmpty(); ) {
      const s = { priority: 0 }, n = e.DequeueAndGetPriority(s);
      if (s.priority >= 0)
        break;
      this.TryGrowHub(n, t) && (e.Enqueue(n, -this.CalculatePotential(n, t)), i = !0);
    }
    return i;
  }
  TryGrowHub(t, e) {
    const i = this.CalculateAllowedHubRadius(t);
    if (t.Radius >= i)
      return !1;
    const s = e ? Yt.CalculateIdealHubRadiusWithAdjacentEdges(this.bundlingSettings, t) : t.cachedIdealRadius;
    if (t.Radius >= s)
      return !1;
    let r = 0.05 * (s - t.Radius);
    r < 1 && (r = 1);
    const a = Math.min(t.Radius + r, i);
    return a <= t.Radius ? !1 : (t.Radius = a, !0);
  }
  CalculatePotential(t, e) {
    const i = e ? Yt.CalculateIdealHubRadiusWithAdjacentEdges(this.bundlingSettings, t) : t.cachedIdealRadius;
    return i <= t.Radius ? 0 : (i - t.Radius) / i;
  }
  // Returns the maximal possible radius of the node
  CalculateAllowedHubRadius(t) {
    let e = this.bundlingSettings.MaxHubRadius;
    for (const s of t.Neighbors) {
      const n = s.Position.sub(t.Position).length;
      e = Math.min(e, n / 1.05 - s.Radius);
    }
    const i = this.metroGraphData.tightIntersections.GetMinimalDistanceToObstacles(t, t.Position, e);
    return i < e && (e = i - 1e-3), Math.max(e, 0.1);
  }
  // Returns the ideal radius of the hub
  static CalculateIdealHubRadius(t, e, i) {
    let s = 1;
    for (const n of i.Neighbors) {
      const a = t.GetWidthSSN(n, i, e.EdgeSeparation) / 2 + e.EdgeSeparation;
      s = Math.max(s, a);
    }
    return s = Math.min(s, 2 * e.MaxHubRadius), s;
  }
  // Returns the ideal radius of the hub
  static CalculateIdealHubRadiusWithNeighborsMBS(t, e, i) {
    return Yt.CalculateIdealHubRadiusWithNeighborsMBNP(t, e, i, i.Position);
  }
  // Returns the ideal radius of the hub
  static CalculateIdealHubRadiusWithNeighborsMBNP(t, e, i, s) {
    let n = Yt.CalculateIdealHubRadius(t, e, i);
    if (i.Neighbors.length > 1) {
      const r = i.Neighbors;
      for (let a = 0; a < r.length; a++) {
        const l = r[a], h = r[(a + 1) % r.length];
        n = Math.max(n, Yt.GetMinRadiusForTwoAdjacentBundles(n, i, s, l, h, t, e));
      }
    }
    return n = Math.min(n, 2 * e.MaxHubRadius), n;
  }
  // Returns the ideal radius of the hub
  static CalculateIdealHubRadiusWithAdjacentEdges(t, e) {
    let i = t.MaxHubRadius;
    for (const s of e.Neighbors)
      i = Math.min(i, e.Position.sub(s.Position).length / 2);
    return i;
  }
  static GetMinRadiusForTwoAdjacentBundles(t, e, i, s, n, r, a) {
    const l = r.GetWidthSSN(e, s, a.EdgeSeparation), h = r.GetWidthSSN(e, n, a.EdgeSeparation);
    return Yt.GetMinRadiusForTwoAdjacentBundlesNPPPNNB(t, i, s.Position, n.Position, l, h, a);
  }
  // Radius we need to draw to separate adjacent bundles ab and ac
  static GetMinRadiusForTwoAdjacentBundlesNPPPNNB(t, e, i, s, n, r, a) {
    if (n < m.distanceEpsilon || r < m.distanceEpsilon)
      return t;
    let l = u.anglePCP(i, e, s);
    if (l = Math.min(l, Math.PI * 2 - l), l < m.distanceEpsilon)
      return 2 * a.MaxHubRadius;
    if (l >= Math.PI / 2)
      return t * 1.05;
    const h = Math.sin(l), c = Math.cos(l), d = n / (4 * h), f = r / (4 * h);
    let p = 2 * Math.sqrt(d * d + (f * f + 2 * (d * (f * c))));
    return p = Math.min(p, 2 * a.MaxHubRadius), p = Math.max(p, t), p;
  }
}
class no {
  constructor(t, e, i, s) {
    this.metroGraphData = t, this.bundlingSettings = e, this.costCalculator = i, this.cdt = s;
  }
  InitializeCostCache() {
    for (const t of this.metroGraphData.VirtualStations())
      t.cachedIdealRadius = Yt.CalculateIdealHubRadiusWithNeighborsMBS(this.metroGraphData, this.bundlingSettings, t), t.cachedRadiusCost = this.costCalculator.RadiusCost(t, t.Position), t.cachedBundleCost = 0;
    for (const t of this.metroGraphData.VirtualEdges()) {
      const e = t[0], i = t[1], s = this.metroGraphData.GetIjInfo(e, i);
      s.cachedBundleCost = this.costCalculator.BundleCost(e, i, e.Position), e.cachedBundleCost += s.cachedBundleCost, i.cachedBundleCost += s.cachedBundleCost;
    }
  }
  UpdateCostCache(t) {
    const e = this.cdt.getRectangleNodeOnTriangles();
    t.cdtTriangle = e.FirstHitNodeWithPredicate(t.Position, no.testPointInside).UserData, t.cachedIdealRadius = Yt.CalculateIdealHubRadiusWithNeighborsMBS(this.metroGraphData, this.bundlingSettings, t), t.cachedRadiusCost = this.costCalculator.RadiusCost(t, t.Position), t.cachedBundleCost = 0;
    for (const i of t.Neighbors) {
      i.IsReal || (i.cachedIdealRadius = Yt.CalculateIdealHubRadiusWithNeighborsMBS(this.metroGraphData, this.bundlingSettings, i), i.cachedRadiusCost = this.costCalculator.RadiusCost(i, i.Position));
      const s = this.metroGraphData.GetIjInfo(t, i);
      i.cachedBundleCost -= s.cachedBundleCost, s.cachedBundleCost = this.costCalculator.BundleCost(t, i, t.Position), t.cachedBundleCost += s.cachedBundleCost, i.cachedBundleCost += s.cachedBundleCost;
    }
  }
  static testPointInside(t, e) {
    return gt.PointIsInsideOfTriangle(t, e) ? ot.Stop : ot.Continue;
  }
}
class sc {
  constructor() {
    this.mainMap = /* @__PURE__ */ new Map();
  }
  get isEmpty() {
    return this.mainMap.size === 0 || this.everyMapIsEmpty();
  }
  everyMapIsEmpty() {
    for (const t of this.mainMap.values())
      if (t.size)
        return !1;
    return !0;
  }
  get(t, e) {
    const i = this.mainMap.get(t);
    if (i)
      return i.get(e);
  }
  has(t, e) {
    const i = this.mainMap.get(t);
    return i ? i.has(e) : !1;
  }
  set(t, e, i) {
    let s = this.mainMap.get(t);
    s || (s = /* @__PURE__ */ new Map(), this.mainMap.set(t, s)), s.set(e, i);
  }
  *[Symbol.iterator]() {
    for (const [t, e] of this.mainMap)
      for (const [i, s] of e)
        yield [t, i, s];
  }
  *keys() {
    for (const [t, e] of this.mainMap)
      for (const [i] of e)
        yield [t, i];
  }
}
class gg {
  constructor(t, e, i, s, n, r, a, l) {
    this.cachedEnterableLooseForEnd = new ii(), this.bundlingSettings = s, this.regularEdges = t, n != null ? this.cdt = n : this.cdt = Uh(e), this.EdgeLooseEnterable = r, this.EdgeTightEnterable = a, this.LoosePolylineOfPort = l, this.looseIntersections = new Ue(this, s, e, (h) => h.getELP()), this.tightIntersections = new Ue(this, s, i, (h) => h.EnterableTightPolylines), this.cdtIntersections = new Ca(this, s), this.Initialize(!1);
  }
  get Ink() {
    return this.ink;
  }
  get Edges() {
    return this.regularEdges;
  }
  VirtualStations() {
    return Array.from(this.Stations).filter((t) => !t.IsReal);
  }
  get Metrolines() {
    return this.metrolines;
  }
  get LooseTree() {
    return this.looseIntersections.obstacleTree;
  }
  get TightTree() {
    return this.tightIntersections.obstacleTree;
  }
  *VirtualEdges() {
    for (const t of this.edgeInfoDictionary.keys())
      yield t;
  }
  // number of real edges passing the edge uv
  RealEdgeCount(t, e) {
    const i = t.SerialNumber < e.SerialNumber ? [t, e] : [e, t], s = this.edgeInfoDictionary.get(i[0], i[1]);
    return s ? s.Count : 0;
  }
  // real edges passing the node
  MetroNodeInfosOfNode(t) {
    return t.MetroNodeInfos;
  }
  // real edges passing the edge uv
  GetIjInfo(t, e) {
    const i = t.SerialNumber < e.SerialNumber ? [t, e] : [e, t];
    return this.edgeInfoDictionary.get(i[0], i[1]);
  }
  // Move node to the specified position
  MoveNode(t, e) {
    const i = t.Position;
    this.PointToStations.deleteP(i), this.PointToStations.set(e, t), t.Position = e;
    for (const s of this.MetroNodeInfosOfNode(t))
      s.PolyPoint.point = e;
    for (const s of this.MetroNodeInfosOfNode(t)) {
      const n = s.Metroline, r = s.PolyPoint.prev.point, a = s.PolyPoint.next.point;
      n.Length += a.sub(e).length + r.sub(e).length - a.sub(i).length - r.sub(i).length;
    }
    for (const s of t.Neighbors)
      this.ink += e.sub(s.Position).length - i.sub(s.Position).length;
    this.SortNeighbors(t);
    for (const s of t.Neighbors)
      this.SortNeighbors(s);
  }
  GetWidthSSN(t, e, i) {
    const s = t.SerialNumber < e.SerialNumber ? [t, e] : [e, t], n = this.edgeInfoDictionary.get(s[0], s[1]);
    return n ? n.Width + (n.Count - 1) * i : 0;
  }
  GetWidthAN(t, e) {
    let i = 0;
    for (const n of t)
      i += n.Width;
    const s = t.length;
    return i += s > 0 ? (s - 1) * e : 0, i;
  }
  // Initialize data
  Initialize(t) {
    this.SimplifyRegularEdges(), this.InitializeStationData(), this.InitializeEdgeData(), this.InitializeVirtualGraph(), this.InitializeEdgeNodeInfo(t), this.InitializeCdtInfo();
  }
  // remove self-cycles
  SimplifyRegularEdges() {
    for (const t of this.regularEdges)
      this.SimplifyRegularEdge(t);
  }
  // change the polyline by removing cycles
  SimplifyRegularEdge(t) {
    const e = t.curve, i = new mt.Stack(), s = new xt();
    for (let n = e.endPoint; n != null; n = n.prev) {
      const r = n.point;
      if (s.has(n.point)) {
        let a = n.next;
        do {
          const l = i.top;
          if (!l.equal(r))
            s.delete(l), i.pop(), a = a.next;
          else
            break;
        } while (!0);
        a.prev = n.prev, a.prev.next = a;
      } else
        i.push(r), s.add(r);
    }
  }
  InitializeStationData() {
    this.Stations = [], this.PointToStations = new ii();
    for (const t of this.regularEdges) {
      const e = t.curve;
      this.ProcessPolylinePoints(e);
    }
  }
  ProcessPolylinePoints(t) {
    let e = t.startPoint;
    for (this.RegisterStation(e, !0), e = e.next; e !== t.endPoint; e = e.next)
      this.RegisterStation(e, !1);
    this.RegisterStation(e, !0);
  }
  RegisterStation(t, e) {
    if (!this.PointToStations.has(t.point)) {
      const i = new dg(this.Stations.length, e, t.point);
      this.PointToStations.set(t.point, i), this.Stations.push(i);
    }
  }
  InitializeEdgeData() {
    this.metrolines = new Array();
    for (let t = 0; t < this.regularEdges.length; t++) {
      const e = this.regularEdges[t];
      this.InitEdgeData(e, t);
    }
  }
  InitEdgeData(t, e) {
    const i = new cg(t.curve, this.bundlingSettings.ActualEdgeWidth(t), this.EdgeSourceAndTargetFunc(t), e);
    this.metrolines.push(i), this.PointToStations.get(i.Polyline.start).BoundaryCurve = t.sourcePort.Curve, this.PointToStations.get(i.Polyline.end).BoundaryCurve = t.targetPort.Curve;
  }
  EdgeSourceAndTargetFunc(t) {
    return () => [this.LoosePolylineOfPort(t.sourcePort), this.LoosePolylineOfPort(t.targetPort)];
  }
  /**   Initialize graph comprised of stations and their neighbors */
  InitializeVirtualGraph() {
    const t = /* @__PURE__ */ new Map();
    for (const e of this.metrolines) {
      let i = this.PointToStations.get(e.Polyline.start), s;
      for (let n = e.Polyline.startPoint; n.next != null; n = n.next, i = s)
        s = this.PointToStations.get(n.next.point), xr(t, i, s), xr(t, s, i);
    }
    for (const e of this.Stations)
      e.Neighbors = Array.from(t.get(e));
  }
  GetUnorderedIjInfo(t, e) {
    return t.SerialNumber < e.SerialNumber ? this.GetCreateOrderedIjInfo(t, e) : this.GetCreateOrderedIjInfo(e, t);
  }
  static closedeb(t, e) {
    return t.Position.sub(new u(360.561, 428.416)).length < 0.1 && e.Position.sub(new u(414.281, 440.732)).length < 0.1;
  }
  GetCreateOrderedIjInfo(t, e) {
    let i = this.edgeInfoDictionary.get(t, e);
    return i || (i = new fg(), this.edgeInfoDictionary.set(t, e, i), i);
  }
  InitializeEdgeNodeInfo(t) {
    this.edgeInfoDictionary = new sc(), this.InitAllMetroNodeInfos(t), this.SortAllNeighbors(), this.InitEdgeIjInfos(), this.ink = 0;
    for (const e of this.VirtualEdges())
      this.ink += e[0].Position.sub(e[1].Position).length;
  }
  InitAllMetroNodeInfos(t) {
    for (let e = 0; e < this.metrolines.length; e++) {
      const i = this.metrolines[e];
      this.InitMetroNodeInfos(i), this.InitNodeEnterableLoosePolylines(i, this.regularEdges[e]), t && this.InitNodeEnterableTightPolylines(i, this.regularEdges[e]), i.UpdateLengths();
    }
  }
  InitMetroNodeInfos(t) {
    for (let e = t.Polyline.startPoint; e != null; e = e.next) {
      const i = this.PointToStations.get(e.point);
      i.MetroNodeInfos.push(new ug(t, i, e));
    }
  }
  InitNodeEnterableLoosePolylines(t, e) {
    const i = this.EdgeLooseEnterable != null ? this.EdgeLooseEnterable.get(e) : /* @__PURE__ */ new Set();
    for (let s = t.Polyline.startPoint.next; s != null && s.next != null; s = s.next) {
      const n = this.PointToStations.get(s.point);
      n.getELP() != null ? n.setELP(Wi(n.getELP(), i)) : n.setELP(new Set(i));
    }
    this.AddLooseEnterableForMetrolineStartEndPoints(t);
  }
  AddLooseEnterableForMetrolineStartEndPoints(t) {
    this.AddLooseEnterableForEnd(t.Polyline.start), this.AddLooseEnterableForEnd(t.Polyline.end);
  }
  AddTightEnterableForMetrolineStartEndPoints(t) {
    this.AddTightEnterableForEnd(t.Polyline.start), this.AddTightEnterableForEnd(t.Polyline.end);
  }
  AddLooseEnterableForEnd(t) {
    const e = this.PointToStations.get(t);
    if (this.cachedEnterableLooseForEnd.has(t))
      e.setELP(this.cachedEnterableLooseForEnd.get(t));
    else {
      for (const i of this.LooseTree.AllHitItems_(t))
        g.PointRelativeToCurveLocation(t, i) === F.Inside && e.AddEnterableLoosePolyline(i);
      this.cachedEnterableLooseForEnd.set(t, e.getELP());
    }
  }
  AddTightEnterableForEnd(t) {
    const e = this.PointToStations.get(t);
    for (const i of this.TightTree.AllHitItems_(t))
      g.PointRelativeToCurveLocation(t, i) === F.Inside && e.AddEnterableTightPolyline(i);
  }
  InitNodeEnterableTightPolylines(t, e) {
    const i = this.EdgeTightEnterable != null ? this.EdgeTightEnterable.get(e) : /* @__PURE__ */ new Set();
    for (let s = t.Polyline.startPoint.next; s != null && s.next != null; s = s.next) {
      const n = this.PointToStations.get(s.point), r = n.EnterableTightPolylines;
      r != null ? n.EnterableTightPolylines = Wi(r, i) : n.EnterableTightPolylines = new Set(i);
    }
    this.AddTightEnterableForMetrolineStartEndPoints(t);
  }
  SortAllNeighbors() {
    for (const t of this.Stations)
      this.SortNeighbors(t);
  }
  SortNeighbors(t) {
    if (t.Neighbors.length <= 2)
      return;
    const e = t.Neighbors[0].Position, i = t.Position;
    t.Neighbors.sort((s, n) => hs(e.sub(i), s.Position.sub(i), n.Position.sub(i)));
  }
  InitEdgeIjInfos() {
    for (const t of this.metrolines) {
      const e = t.Polyline;
      let i = this.PointToStations.get(e.start), s;
      for (let n = t.Polyline.startPoint; n.next != null; n = n.next, i = s) {
        s = this.PointToStations.get(n.next.point);
        const r = this.GetUnorderedIjInfo(i, s);
        r.Width += t.Width, r.Metrolines.push(t);
      }
    }
  }
  InitializeCdtInfo() {
    const t = this.cdt.getRectangleNodeOnTriangles();
    for (const e of this.Stations)
      e.cdtTriangle = t.FirstHitNodeWithPredicate(e.Position, no.testPointInside).UserData;
  }
  PointIsAcceptableForEdge(t, e) {
    if (this.LoosePolylineOfPort == null)
      return !0;
    const i = t.sourceAndTargetLoosePolylines();
    return g.PointRelativeToCurveLocation(e, i[0]) === F.Outside && g.PointRelativeToCurveLocation(e, i[1]) === F.Outside;
  }
}
function hs(o, t, e) {
  const i = u.crossProduct(o, e), s = o.dot(e), n = u.crossProduct(o, t), r = o.dot(t);
  return D(n, 0) && fr(r, 0) ? D(i, 0) && fr(s, 0) ? 0 : 1 : D(i, 0) && fr(s, 0) ? -1 : D(n, 0) || D(i, 0) || n * i > 0 ? Er(u.crossProduct(e, t), 0) : -Er(Math.sign(n), 0);
}
function fr(o, t) {
  return Er(o, t) >= 0;
}
class ft {
  constructor(t, e) {
    this.metroGraphData = t, this.bundlingSettings = e;
  }
  // Error of ink
  static InkError(t, e, i) {
    return (t - e) * i.InkImportance;
  }
  // Error of path lengths
  static PathLengthsError(t, e, i, s) {
    return (t - e) * (s.PathLengthImportance / i);
  }
  // Error of hubs
  static RError(t, e, i) {
    return t <= e ? 0 : i.HubRepulsionImportance * ((1 - e / t) * (t - e));
  }
  // Error of bundles
  static BundleError(t, e, i) {
    return t <= e ? 0 : i.BundleRepulsionImportance * ((1 - e / t) * (t - e));
  }
  // Cost of the whole graph
  static Cost(t, e) {
    let i = e.InkImportance * t.Ink;
    for (const s of t.Metrolines)
      i += e.PathLengthImportance * s.Length / s.IdealLength;
    return i += this.CostOfForces(t), i;
  }
  // Cost of the whole graph (hubs and bundles)
  static CostOfForces(t) {
    let e = 0;
    for (const i of t.VirtualStations())
      e = e + i.cachedRadiusCost;
    for (const i of t.VirtualEdges()) {
      const s = i[0], n = i[1];
      e += t.GetIjInfo(s, n).cachedBundleCost;
    }
    return e;
  }
  // Gain of ink
  InkGain(t, e) {
    const i = this.metroGraphData.Ink;
    let s = this.metroGraphData.Ink;
    for (const n of t.Neighbors) {
      const r = n.Position;
      s -= r.sub(t.Position).length, s += r.sub(e).length;
    }
    return ft.InkError(i, s, this.bundlingSettings);
  }
  // Gain of path lengths
  PathLengthsGain(t, e) {
    let i = 0;
    for (const s of this.metroGraphData.MetroNodeInfosOfNode(t)) {
      const n = s.Metroline.Length, r = s.PolyPoint.prev.point, a = s.PolyPoint.next.point, l = s.Metroline.Length + a.sub(e).length + r.sub(e).length - a.sub(t.Position).length - r.sub(t.Position).length;
      i += ft.PathLengthsError(n, l, s.Metroline.IdealLength, this.bundlingSettings);
    }
    return i;
  }
  // Gain of radii
  RadiusGain(t, e) {
    let i = 0;
    return i = i + t.cachedRadiusCost, i = i - this.RadiusCost(t, e), i;
  }
  RadiusCost(t, e) {
    let i;
    u.closeDistEps(t.Position, e) ? i = t.cachedIdealRadius : i = Yt.CalculateIdealHubRadiusWithNeighborsMBNP(this.metroGraphData, this.bundlingSettings, t, e);
    const s = { touchedObstacles: [] };
    if (!this.metroGraphData.looseIntersections.HubAvoidsObstaclesSPNBA(t, e, i, s))
      return ft.Inf;
    let n = 0;
    for (const r of s.touchedObstacles) {
      const a = r[1].sub(e).length;
      n += ft.RError(i, a, this.bundlingSettings);
    }
    return n;
  }
  // Gain of bundles
  // if a newPosition is not valid (e.g. intersect obstacles) the result is -inf
  BundleGain(t, e) {
    let i = t.cachedBundleCost;
    for (const s of t.Neighbors) {
      const n = this.BundleCost(t, s, e);
      if (fr(n, ft.Inf))
        return -ft.Inf;
      i -= n;
    }
    return i;
  }
  BundleCost(t, e, i) {
    const s = this.metroGraphData.GetWidthSSN(t, e, this.bundlingSettings.EdgeSeparation), n = { closestDist: [] };
    if (!this.metroGraphData.cdtIntersections.BundleAvoidsObstacles(t, e, i, e.Position, s, n))
      return ft.Inf;
    let r = 0;
    for (const a of n.closestDist) {
      const l = a[0].sub(a[1]).length;
      r += ft.BundleError(s / 2, l, this.bundlingSettings);
    }
    return r;
  }
}
ft.Inf = 1e9;
class pg {
  get Polylines() {
    return Array.from(this.polylineToEdgeGeom.keys());
  }
  constructor(t) {
    this.polylineToEdgeGeom = /* @__PURE__ */ new Map(), this.pathsThroughPoints = new ii(), this.interestingPoints = new xt(), this.metroGraphData = t;
  }
  Run() {
    this.Init(), this.SwitchFlips();
  }
  Init() {
    for (const t of this.metroGraphData.Edges)
      this.polylineToEdgeGeom.set(t.curve, t);
    for (const t of this.Polylines)
      this.RegisterPolylinePointInPathsThrough(t.polylinePoints());
  }
  RegisterPolylinePointInPathsThrough(t) {
    for (const e of t)
      this.RegisterPolylinePointInPathsThroughP(e);
  }
  RegisterPolylinePointInPathsThroughP(t) {
    mg(this.pathsThroughPoints, t.point, t);
  }
  UnregisterPolylinePointsInPathsThrough(t) {
    for (const e of t)
      this.UnregisterPolylinePointInPathsThrough(e);
  }
  UnregisterPolylinePointInPathsThrough(t) {
    Pg(this.pathsThroughPoints, t.point, t);
  }
  SwitchFlips() {
    const t = new Set(this.Polylines), e = new We.Queue();
    for (const i of this.Polylines)
      e.enqueue(i);
    for (; e.length > 0; ) {
      const i = e.dequeue();
      t.delete(i);
      const s = this.ProcessPolyline(i);
      s != null && (t.has(i) || (t.add(i), e.enqueue(i)), t.has(s) || (t.add(s), e.enqueue(s)));
    }
  }
  ProcessPolyline(t) {
    const e = /* @__PURE__ */ new Map();
    for (let i = t.startPoint.next; i != null; i = i.next) {
      this.FillDepartedPolylinePoints(i, e);
      for (const s of this.pathsThroughPoints.get(i.point)) {
        const n = e.get(s.polyline);
        if (n) {
          if (this.ProcessFlip(i, n))
            return s.polyline;
          e.delete(s.polyline);
        }
      }
    }
    return null;
  }
  FillDepartedPolylinePoints(t, e) {
    const i = t.prev.point;
    for (const s of this.pathsThroughPoints.get(i))
      this.IsNeighborOnTheSamePolyline(s, t) || e.has(s.polyline) || e.set(s.polyline, s);
  }
  ProcessFlip(t, e) {
    const i = t.polyline, s = e.polyline, n = t.point, r = e.point, a = this.polylineToEdgeGeom.get(i), l = this.polylineToEdgeGeom.get(s);
    if (a.lineWidth !== l.lineWidth || this.metroGraphData.EdgeLooseEnterable == null || !Or(this.metroGraphData.EdgeLooseEnterable.get(a), this.metroGraphData.EdgeLooseEnterable.get(l)))
      return !1;
    let h = this.FindPointsOnPolyline(i, n, r);
    const c = h[0], d = h[1], f = h[2];
    h = this.FindPointsOnPolyline(s, n, r);
    const p = h[0], P = h[1], y = h[2], C = this.FindRelationOnFirstPoint(c, p, f, y), E = this.FindRelationOnLastPoint(d, P, f, y);
    return C !== 2 && E !== 2 || C === 1 || E === 1 ? !1 : (this.UnregisterPolylinePointsInPathsThrough(i.polylinePoints()), this.UnregisterPolylinePointsInPathsThrough(s.polylinePoints()), this.Swap(c, p, d, P, f, y), this.RegisterPolylinePointInPathsThrough(i.polylinePoints()), this.RegisterPolylinePointInPathsThrough(s.polylinePoints()), this.RegisterInterestingPoint(c.point), this.RegisterInterestingPoint(d.point), this.numberOfReducedCrossings++, !0);
  }
  FindPointsOnPolyline(t, e, i) {
    let s, n;
    for (let r = t.startPoint; r != null; r = r.next)
      if (s == null)
        if (r.point.equal(e)) {
          if (n != null)
            return [r, n, !1];
          s = r;
        } else
          n == null && r.point.equal(i) && (n = r);
      else if (r.point.equal(i))
        return [s, r, !0];
  }
  PolylinePointsAreInForwardOrder(t, e) {
    for (let i = t; i != null; i = i.next)
      if (i === e)
        return !0;
    return !1;
  }
  Next(t, e) {
    return e ? t.next : t.prev;
  }
  Prev(t, e) {
    return e ? t.prev : t.next;
  }
  FindRelationOnFirstPoint(t, e, i, s) {
    const n = t, r = e;
    for (; ; ) {
      const a = this.Prev(t, i), l = this.Prev(e, s);
      if (a == null || l == null)
        return 0;
      if (!a.point.equal(l.point))
        break;
      t = a, e = l;
    }
    return this.PolylinesIntersect(n, r, t, e, i, s);
  }
  FindRelationOnLastPoint(t, e, i, s) {
    const n = t, r = e;
    for (; ; ) {
      const a = this.Next(t, i), l = this.Next(e, s);
      if (a == null || l == null)
        return 0;
      if (!a.point.equal(l.point))
        break;
      t = a, e = l;
    }
    for (; this.Next(t, i).point.equal(this.Prev(e, s).point); )
      t = this.Next(t, i), e = this.Prev(e, s);
    return this.PolylinesIntersect(t, e, n, r, i, s);
  }
  PolylinesIntersect(t, e, i, s, n, r) {
    const a = this.Prev(t, n), l = this.Next(t, n), h = this.Next(i, n), c = this.Prev(i, n), d = this.Next(e, r), f = this.Prev(s, r);
    if (t.point.equal(i.point)) {
      const p = t.point, P = hs(c.point.sub(p), f.point.sub(p), l.point.sub(p)), y = hs(c.point.sub(p), d.point.sub(p), l.point.sub(p));
      return P === y ? 1 : 2;
    } else {
      const p = hs(a.point.sub(t.point), l.point.sub(t.point), d.point.sub(t.point)), P = hs(h.point.sub(i.point), f.point.sub(i.point), c.point.sub(i.point));
      return p === P ? 1 : 2;
    }
  }
  Swap(t, e, i, s, n, r) {
    const a = this.GetRangeOnPolyline(this.Next(t, n), i, n), l = this.GetRangeOnPolyline(this.Next(e, r), s, r);
    this.ChangePolylineSegment(t, i, n, l), this.ChangePolylineSegment(e, s, r, a), _n.RemoveSelfCyclesFromPolyline(t.polyline), _n.RemoveSelfCyclesFromPolyline(e.polyline);
  }
  ChangePolylineSegment(t, e, i, s) {
    let n = t;
    for (const r of s) {
      const a = ei.mkFromPoint(r.point);
      a.polyline = n.polyline, i ? (a.prev = n, n.next = a) : (a.next = n, n.prev = a), n = a;
    }
    i ? (n.next = e, e.prev = n) : (n.prev = e, e.next = n);
  }
  GetRangeOnPolyline(t, e, i) {
    const s = new Array();
    for (let n = t; n !== e; n = this.Next(n, i))
      s.push(n);
    return s;
  }
  IsNeighborOnTheSamePolyline(t, e) {
    return t.prev != null && t.prev.point.equal(e.point) || t.next != null && t.next.point.equal(e.point);
  }
  RegisterInterestingPoint(t) {
    this.interestingPoints.has(t) || this.interestingPoints.add(t);
  }
  GetChangedHubs() {
    return this.interestingPoints;
  }
  NumberOfReducedCrossings() {
    return this.numberOfReducedCrossings;
  }
  PolylineIsOK(t) {
    const e = new xt();
    for (let i = t.startPoint; i != null; i = i.next) {
      if (i === t.startPoint) {
        if (i.prev != null)
          return !1;
      } else if (i.prev.next !== i)
        return !1;
      if (i === t.endPoint) {
        if (i.next != null)
          return !1;
      } else if (i.next.prev !== i)
        return !1;
      if (e.has(i.point))
        return !1;
      e.add(i.point);
    }
    return !(t.startPoint.prev != null || t.endPoint.next != null);
  }
}
function mg(o, t, e) {
  let i = o.get(t);
  i || (i = /* @__PURE__ */ new Set(), o.set(t, i)), i.add(e);
}
function Pg(o, t, e) {
  const i = o.get(t);
  i && (i.delete(e), i.size === 0 && o.deleteP(t));
}
class _n {
  constructor(t, e) {
    this.foundCrossings = new xt(), this.crossingsThatShouldBecomeHubs = new xt(), this.metroGraphData = t, this.polylineAcceptsPoint = e;
  }
  *Vertices() {
    for (const t of this.Polylines)
      for (const e of t.polylinePoints())
        yield e;
  }
  get Polylines() {
    return this.metroGraphData.Edges.map((t) => t.curve);
  }
  Edges() {
    const t = new Nn();
    for (const e of this.Vertices())
      e.next && t.set(new ne(e.point, e.next.point), 0);
    return Array.from(t.keys());
  }
  run() {
    if (this.metroGraphData.Edges.length === 0)
      return !1;
    const t = new Nn(), e = new Rr(null);
    for (const a of this.Vertices()) {
      const l = T.mkOnPoints([a.point]);
      l.pad(m.intersectionEpsilon), e.Add(l, a.point);
    }
    const i = Tr(this.Edges(), (a) => T.mkPP(a.first, a.second));
    Qt(i, i, (a, l) => this.IntersectTwoEdges.bind(a, l, t, e)), this.SortInsertedPoints(t);
    const s = this.InsertPointsIntoPolylines(t), n = this.FixPaths(), r = this.RemoveUnimportantCrossings();
    return n || s || r;
  }
  FixPaths() {
    let t = !1;
    return this.RemoveSelfCycles() && (t = !0), this.ReduceEdgeCrossings() && (t = !0), t;
  }
  SortInsertedPoints(t) {
    for (const e of t)
      this.SortInsideSegment(e[0], e[1]);
  }
  SortInsideSegment(t, e) {
    e.sort((i, s) => yt(Z(i, t.first), Z(s, t.first)));
  }
  InsertPointsIntoPolylines(t) {
    let e = !1;
    for (const i of this.metroGraphData.Metrolines)
      return this.InsertPointsIntoPolyline(i, t) && (e = !0), e;
  }
  InsertPointsIntoPolyline(t, e) {
    let i = !1;
    for (let s = t.Polyline.startPoint; s.next != null; s = s.next)
      this.InsertPointsOnPolypoint(s, e, t) && (i = !0);
    return i;
  }
  InsertPointsOnPolypoint(t, e, i) {
    const s = new ne(t.point, t.next.point), n = t.point !== s.first, r = e.get(s);
    if (!r)
      return !1;
    const a = t.next, l = t.polyline;
    if (n)
      for (let h = r.length - 1; h >= 0; h--) {
        if (this.polylineAcceptsPoint != null && !this.polylineAcceptsPoint(i, r[h]))
          continue;
        const c = ei.mkFromPoint(r[h]);
        c.prev = t, c.polyline = l, t.next = c, t = c;
      }
    else
      for (let h = 0; h < r.length; h++) {
        if (this.polylineAcceptsPoint != null && !this.polylineAcceptsPoint(i, r[h]))
          continue;
        const c = ei.mkFromPoint(r[h]);
        c.prev = t, c.polyline = l, t.next = c, t = c;
      }
    return t.next = a, a.prev = t, !0;
  }
  RemoveSelfCycles() {
    let t = !1;
    for (const e of this.Polylines)
      _n.RemoveSelfCyclesFromPolyline(e) && (t = !0);
    return t;
  }
  // returns removed points
  static RemoveSelfCyclesFromPolyline(t) {
    let e = !1;
    const i = new ii();
    for (let s = t.startPoint; s != null; s = s.next) {
      const n = s.point, r = i.get(n);
      if (r) {
        for (let a = r.next; a !== s.next; a = a.next)
          i.deleteP(a.point);
        r.next = s.next, s.next.prev = r, e = !0;
      } else
        i.set(s.point, s);
    }
    return e;
  }
  // bool CollapseCycles() {
  //    var cycleCollapser = new FlipCollapser(metroGraphData, bundlingSettings, cdt);
  //    cycleCollapser.Run();
  //    crossingsThatShouldBecomeHubs.InsertRange(cycleCollapser.GetChangedCrossing());
  //    //TimeMeasurer.DebugOutput("#crossingsThatShouldBecomeHubs = " + crossingsThatShouldBecomeHubs.Count);
  //    return false;
  // }
  ReduceEdgeCrossings() {
    const t = new pg(this.metroGraphData);
    t.Run();
    for (const e of t.GetChangedHubs())
      this.crossingsThatShouldBecomeHubs.add(e);
    return t.NumberOfReducedCrossings() > 0;
  }
  RemoveUnimportantCrossings() {
    let t = !1;
    this.pointsToDelete = Ed(this.foundCrossings, this.crossingsThatShouldBecomeHubs);
    for (const e of this.Polylines)
      this.RemoveUnimportantCrossingsFromPolyline(e) && (t = !0);
    return t;
  }
  RemoveUnimportantCrossingsFromPolyline(t) {
    let e = !1;
    for (let i = t.startPoint.next; i != null && i.next != null; i = i.next)
      if (this.pointsToDelete.has(i.point) && u.getTriangleOrientation(i.prev.point, i.point, i.next.point) === L.Collinear) {
        const s = i.prev, n = i.next;
        s.next = n, n.prev = s, i = s, e = !0;
      }
    return e;
  }
  IntersectTwoEdges(t, e, i, s) {
    const n = v.IntersectPPPP(t.first, t.second, e.first, e.second);
    if (n) {
      const r = this.FindExistingVertexOrCreateNew(s, n);
      (this.AddVertexToSplittingList(t, i, r) || this.AddVertexToSplittingList(e, i, r)) && this.foundCrossings.add(r);
    }
  }
  FindExistingVertexOrCreateNew(t, e) {
    const i = t.RootNode.FirstHitNode(e);
    if (i != null)
      return i.UserData;
    const s = T.mkOnPoints([e]);
    return s.pad(m.intersectionEpsilon), t.Add(s, e), e;
  }
  AddVertexToSplittingList(t, e, i) {
    if (!g.closeIntersectionPoints(i, t.first) && !g.closeIntersectionPoints(i, t.second)) {
      let s = e.get(t);
      if (s || (s = new Array(), e.set(t, s)), !s.find((n) => n.equal(i)))
        return s.push(i), !0;
    }
    return !1;
  }
}
class xl {
  isCorrectlyOrienected() {
    return u.getTriangleOrientation(this.Curve.boundingBox.center, this.Curve.value(this.parEnd), this.Curve.value(this.parStart)) !== L.Counterclockwise;
  }
  get Count() {
    return this.points.length;
  }
  constructor(t, e, i, s) {
    this.BelongsToRealNode = s, this.Curve = e, this.Position = i, this.points = new Array(t), this.tangents = new Array(t), this.OrientedHubSegments = new Array(t);
  }
  get CurveCenter() {
    return this.Curve.boundingBox.center;
  }
  get OppositeBase() {
    return this.OutgoingBundleInfo != null ? this.OutgoingBundleInfo.TargetBase : this.IncomingBundleInfo.SourceBase;
  }
  get length() {
    return this.points.length;
  }
  get Points() {
    return this.points;
  }
  get Tangents() {
    return this.tangents;
  }
  get InitialMidParameter() {
    return this.initialMidParameter;
  }
  set InitialMidParameter(t) {
    this.initialMidParameter = t, this.InitialMidPoint = this.Curve.value(t);
  }
  /**
   * corresponds to the left point of the base: if looking from the center of
   * this.Curve.boundingBox.center
   */
  get ParStart() {
    return this.parStart;
  }
  set ParStart(t) {
    this.parStart = t, this.StartPoint = this.Curve.value(this.parStart);
  }
  /**
   * corresponds to the right point of the base: if looking from the center of
   * this.Curve.boundingBox.center */
  get ParEnd() {
    return this.parEnd;
  }
  set ParEnd(t) {
    this.parEnd = t, this.EndPoint = this.Curve.value(this.parEnd);
  }
  get ParMid() {
    return (this.parStart + this.parEnd) / 2;
  }
  get MidPoint() {
    return u.middle(this.StartPoint, this.EndPoint);
  }
  get Span() {
    return this.SpanBetweenTwoParameters(this.parStart, this.parEnd);
  }
  SpanBetweenTwoParameters(t, e) {
    return t <= e ? e - t : e - t + Fi(this.Curve);
  }
  RotateLeftPoint(t, e) {
    return t === 0 ? this.EndPoint : this.RotatePoint(t, this.parEnd, e);
  }
  RotateRigthPoint(t, e) {
    return t === 0 ? this.StartPoint : this.RotatePoint(t, this.parStart, e);
  }
  RotatePoint(t, e, i) {
    const s = Fi(this.Curve) * i;
    return e += t * s, e = this.AdjustParam(e), this.Curve.value(e);
  }
  AdjustParam(t) {
    return t > this.Curve.parEnd ? t = this.Curve.parStart + (t - this.Curve.parEnd) : t < this.Curve.parStart && (t = this.Curve.parEnd - (this.Curve.parStart - t)), t;
  }
  RotateBy(t, e, i) {
    const s = Fi(this.Curve) * i;
    t !== 0 && (this.ParStart = this.AdjustParam(this.ParStart + t * s)), e !== 0 && (this.ParEnd = this.AdjustParam(this.ParEnd + e * s));
  }
  RelativeOrderOfBasesIsPreserved(t, e, i) {
    const s = Fi(this.Curve) * i, n = this.parStart + t * s, r = this.parStart < this.parEnd ? this.parEnd + e * s : this.parEnd + Fi(this.Curve) + e * s;
    if (n > r || this.SpanBetweenTwoParameters(n, r) > Fi(this.Curve) / 2)
      return !1;
    if (this.Prev == null || this.SpanBetweenTwoParameters(this.Prev.ParMid, this.ParMid) > s && this.SpanBetweenTwoParameters(this.ParMid, this.Next.ParMid) > s)
      return !0;
    const a = this.RotateLeftPoint(e, i), l = this.RotateRigthPoint(t, i), h = u.middle(a, l), c = this.MidPoint;
    return !(u.getTriangleOrientation(this.CurveCenter, this.Prev.MidPoint, c) != u.getTriangleOrientation(this.CurveCenter, this.Prev.MidPoint, h) || u.getTriangleOrientation(this.CurveCenter, this.Next.MidPoint, c) != u.getTriangleOrientation(this.CurveCenter, this.Next.MidPoint, h));
  }
}
class Di {
  constructor(t, e, i, s) {
    this.SourceBase = t, this.TargetBase = e, this.obstaclesToIgnore = i, this.HalfWidthArray = s, this.TotalRequiredWidth = this.HalfWidthArray.reduce((r, a) => r + a, 0) * 2, this.longEnoughSideLength = t.Curve.boundingBox.addRec(e.Curve.boundingBox).diagonal;
    const n = Math.max(t.Curve.boundingBox.diagonal, e.Curve.boundingBox.diagonal);
    if (this.TotalRequiredWidth > n) {
      const r = this.TotalRequiredWidth / n;
      for (let a = 0; a < this.HalfWidthArray.length; a++)
        this.HalfWidthArray[a] /= r;
      this.TotalRequiredWidth /= r;
    }
  }
  SetParamsFeasiblySymmetrically(t) {
    this.CalculateTightObstaclesForBundle(t, this.obstaclesToIgnore), this.SetEndParamsSymmetrically();
  }
  CalculateTightObstaclesForBundle(t, e) {
    const i = this.SourceBase.Curve.boundingBox.diagonal / 2, s = this.TargetBase.Curve.boundingBox.diagonal / 2, n = Ue.Create4gon(this.SourceBase.Position, this.TargetBase.Position, i * 2, s * 2);
    this.tightObstaclesInTheBoundingBox = Array.from(t.AllHitItems(n.boundingBox, (r) => !e.has(r) && g.ClosedCurveInteriorsIntersect(n, r)));
  }
  SetEndParamsSymmetrically() {
    const t = this.TargetBase.Position, e = this.SourceBase.Position, i = t.sub(e).normalize(), s = i.rotate90Ccw(), n = u.middle(t, e), r = i.mul(this.longEnoughSideLength), a = n.add(r), l = n.sub(r);
    if (this.SetRLParamsIfWidthIsFeasible(s.mul(this.TotalRequiredWidth / 2), a, l)) {
      this.SetInitialMidParams();
      return;
    }
    let h = this.TotalRequiredWidth, c = 0, d = h / 2;
    for (; h - c > Di.FeasibleWidthEpsilon; )
      this.SetRLParamsIfWidthIsFeasible(s.mul(d / 2), a, l) ? c = d : h = d, d = 0.5 * (h + c);
    d <= Di.FeasibleWidthEpsilon && (this.SetRLParamsIfWidthIsFeasible_(s.mul(Di.FeasibleWidthEpsilon), new u(0, 0), a, l) || this.SetRLParamsIfWidthIsFeasible_(new u(0, 0), s.mul(-Di.FeasibleWidthEpsilon), a, l)) && (d = 2 * Di.FeasibleWidthEpsilon), this.SourceBase.InitialMidParameter = this.SourceBase.AdjustParam(this.SourceBase.ParStart + this.SourceBase.Span / 2), this.TargetBase.InitialMidParameter = this.TargetBase.AdjustParam(this.TargetBase.ParStart + this.TargetBase.Span / 2);
  }
  mkNameFromLRST() {
    return "./tmp/leftRight" + this.SourceBase.Position.toString() + "_" + this.TargetBase.Position.toString() + ".svg";
  }
  SetRLParamsIfWidthIsFeasible(t, e, i) {
    return this.SetRLParamsIfWidthIsFeasible_(t, t.neg(), e, i);
  }
  SetRLParamsIfWidthIsFeasible_(t, e, i, s) {
    const n = { par: 0 }, r = { par: 0 }, a = { par: 0 }, l = { par: 0 };
    let h = this.TrimSegWithBoundaryCurves(v.mkPP(i.add(t), s.add(t)), r, a);
    return h == null || this.tightObstaclesInTheBoundingBox.find((d) => g.intersectionOne(h, d, !1) != null) || (h = this.TrimSegWithBoundaryCurves(v.mkPP(i.add(e), s.add(e)), l, n), h == null) || this.tightObstaclesInTheBoundingBox.find((d) => g.intersectionOne(h, d, !1) != null) ? !1 : (this.SourceBase.IsParent ? (this.SourceBase.ParStart = r.par, this.SourceBase.ParEnd = l.par) : (this.SourceBase.ParStart = l.par, this.SourceBase.ParEnd = r.par), this.TargetBase.IsParent ? (this.TargetBase.ParStart = n.par, this.TargetBase.ParEnd = a.par) : (this.TargetBase.ParStart = a.par, this.TargetBase.ParEnd = n.par), !0);
  }
  SetInitialMidParams() {
    const t = { par: 0 }, e = { par: 0 };
    this.TrimSegWithBoundaryCurves(v.mkPP(this.TargetBase.CurveCenter, this.TargetBase.CurveCenter), e, t) != null ? (this.SourceBase.InitialMidParameter = e.par, this.TargetBase.InitialMidParameter = t.par) : (this.SourceBase.InitialMidParameter = this.SourceBase.AdjustParam(this.SourceBase.ParStart + this.SourceBase.Span / 2), this.TargetBase.InitialMidParameter = this.TargetBase.AdjustParam(this.TargetBase.ParStart + this.TargetBase.Span / 2));
  }
  mkNameFromST() {
    return "./tmp/mparam" + this.SourceBase.Position.toString() + "_" + this.TargetBase.Position.toString() + ".svg";
  }
  TrimSegWithBoundaryCurves(t, e, i) {
    let s = g.getAllIntersections(t, this.SourceBase.Curve, !0);
    if (s.length === 0)
      return i.par = 0, e.par = 0, null;
    let n;
    if (s.length === 1 ? n = s[0] : this.SourceBase.IsParent ? n = s[0].par0 < s[1].par0 ? s[1] : s[0] : n = s[0].par0 < s[1].par0 ? s[0] : s[1], s = g.getAllIntersections(t, this.TargetBase.Curve, !0), s.length === 0)
      return i.par = 0, e.par = 0, null;
    let r;
    return s.length === 1 ? r = s[0] : this.TargetBase.IsParent ? r = s[0].par0 > s[1].par0 ? s[1] : s[0] : r = s[0].par0 > s[1].par0 ? s[0] : s[1], e.par = n.par1, i.par = r.par1, v.mkPP(n.x, r.x);
  }
  RotateBy(t, e, i, s, n) {
    const r = t !== 0 || e !== 0, a = i !== 0 || s !== 0;
    r && this.SourceBase.RotateBy(t, e, n), a && this.TargetBase.RotateBy(i, s, n), this.UpdateSourceAndTargetBases(r, a);
  }
  UpdateSourceAndTargetBases(t, e) {
    t && this.UpdatePointsOnBundleBase(this.SourceBase), e && this.UpdatePointsOnBundleBase(this.TargetBase), this.UpdateTangentsOnBases();
  }
  UpdateTangentsOnBases() {
    const t = this.TargetBase.length;
    for (let e = 0; e < t; e++) {
      let i = this.TargetBase.Points[e].sub(this.SourceBase.Points[t - 1 - e]);
      const s = i.length;
      s >= m.tolerance && (i = i.div(s), this.TargetBase.Tangents[e] = i, this.SourceBase.Tangents[t - 1 - e] = i.neg());
    }
  }
  UpdatePointsOnBundleBase(t) {
    const e = t.length, i = t.Points, s = v.mkPP(t.EndPoint, t.StartPoint), n = 1 / this.TotalRequiredWidth;
    let r = this.HalfWidthArray[0];
    i[0] = s.value(r * n);
    for (let a = 1; a < e; a++)
      r += this.HalfWidthArray[a - 1] + this.HalfWidthArray[a], i[a] = s.value(r * n);
  }
  RotationIsLegal(t, e, i, s, n) {
    if (!this.SourceBase.IsParent && !this.TargetBase.IsParent) {
      if (e !== 0 || i !== 0) {
        const r = this.SourceBase.RotateLeftPoint(e, n), a = this.TargetBase.RotateRigthPoint(i, n);
        if (!this.LineIsLegal(r, a))
          return !1;
      }
      if (t !== 0 || s !== 0) {
        const r = this.SourceBase.RotateRigthPoint(t, n), a = this.TargetBase.RotateLeftPoint(s, n);
        if (!this.LineIsLegal(r, a))
          return !1;
      }
    } else {
      if (e !== 0 || s !== 0) {
        const r = this.SourceBase.RotateLeftPoint(e, n), a = this.TargetBase.RotateLeftPoint(s, n);
        if (!this.LineIsLegal(r, a))
          return !1;
      }
      if (t !== 0 || i !== 0) {
        const r = this.SourceBase.RotateRigthPoint(t, n), a = this.TargetBase.RotateRigthPoint(i, n);
        if (!this.LineIsLegal(r, a))
          return !1;
      }
    }
    return !((t !== 0 || e !== 0) && !this.SourceBase.RelativeOrderOfBasesIsPreserved(t, e, n) || (i !== 0 || s !== 0) && !this.TargetBase.RelativeOrderOfBasesIsPreserved(i, s, n));
  }
  LineIsLegal(t, e) {
    return this.tightObstaclesInTheBoundingBox.find((i) => g.intersectionOne(v.mkPP(t, e), i, !1) != null) == null;
  }
}
Di.FeasibleWidthEpsilon = 0.1;
class Ll {
  get Segment() {
    return this.segment;
  }
  set Segment(t) {
    this.segment = t;
  }
  constructor(t, e, i, s) {
    this.Segment = t, this.Reversed = e, this.Index = i, this.BundleBase = s;
  }
  value(t) {
    return this.Reversed ? this.Segment.value(this.Segment.parEnd - t) : this.Segment.value(t);
  }
}
class H {
  constructor(t, e, i) {
    this.fixedBundles = /* @__PURE__ */ new Set(), this.stepsWithProgress = 0, this.metroOrdering = t, this.metroGraphData = e, this.bundlingSettings = i;
  }
  Run() {
    this.AllocateBundleBases(), this.SetBasesRightLeftParamsToTheMiddles(), this.bundlingSettings.KeepOverlaps ? (this.UpdateSourceAndTargetBases(), this.CreateOrientedSegs()) : (this.SetRightLeftParamsFeasiblySymmetrically(), this.AdjustStartEndParamsToAvoidBaseOverlaps(), this.UpdateSourceAndTargetBases(), this.CreateOrientedSegs(), this.bundlingSettings.RotateBundles && this.RotateBundlesToDiminishCost(), this.AdjustStartEndParamsToAvoidBaseOverlaps(), this.UpdateSourceAndTargetBases());
  }
  AllocateBundleBases() {
    this.externalBases = /* @__PURE__ */ new Map(), this.internalBases = /* @__PURE__ */ new Map(), this.Bundles = new Array();
    for (const t of this.metroGraphData.Stations)
      t.BoundaryCurve == null && (t.BoundaryCurve = j.mkCircle(t.Radius, t.Position));
    for (const t of this.metroGraphData.Stations)
      for (const e of t.Neighbors)
        if (t.SerialNumber < e.SerialNumber) {
          const i = new xl(this.metroGraphData.RealEdgeCount(t, e), t.BoundaryCurve, t.Position, t.IsReal);
          t.BundleBases.set(e, i);
          const s = new xl(this.metroGraphData.RealEdgeCount(t, e), e.BoundaryCurve, e.Position, e.IsReal);
          e.BundleBases.set(t, s), g.PointRelativeToCurveLocation(e.Position, t.BoundaryCurve) !== F.Outside ? (i.IsParent = !0, As(this.internalBases, t, i), As(this.externalBases, e, s)) : g.PointRelativeToCurveLocation(t.Position, e.BoundaryCurve) !== F.Outside ? (s.IsParent = !0, As(this.externalBases, t, i), As(this.internalBases, e, s)) : (As(this.externalBases, t, i), As(this.externalBases, e, s));
          const n = this.metroGraphData.tightIntersections.ObstaclesToIgnoreForBundle(t, e), r = new Di(i, s, n, Array.from(this.metroOrdering.GetOrder(t, e)).map((a) => a.Width / 2));
          i.OutgoingBundleInfo = s.IncomingBundleInfo = r, this.Bundles.push(r);
        }
    this.SetBundleBaseNeighbors();
  }
  SetBundleBaseNeighbors() {
    for (const t of this.externalBases.keys()) {
      const e = this.externalBases.get(t);
      this.SortBundlesCounterClockwise(e), this.SetLeftRightBases(e);
    }
    for (const t of this.internalBases.keys()) {
      const e = this.internalBases.get(t);
      this.SortBundlesCounterClockwise(e), this.SetLeftRightBases(e);
    }
  }
  SortBundlesCounterClockwise(t) {
    if (t.length > 2) {
      const e = t[0].OppositeBase.Position, i = t[0].CurveCenter;
      t.sort((s, n) => hs(e.sub(i), s.OppositeBase.Position.sub(i), n.OppositeBase.Position.sub(i)));
    }
  }
  SetLeftRightBases(t) {
    const e = t.length;
    if (!(e <= 1))
      for (let i = 0; i < e; i++)
        t[i].Prev = t[(i - 1 + e) % e], t[i].Next = t[(i + 1) % e];
  }
  CreateOrientedSegs() {
    for (const t of this.metroGraphData.Metrolines)
      this.CreateOrientedSegsOnLine(t);
  }
  CreateOrientedSegsOnLine(t) {
    for (let e = t.Polyline.startPoint.next; e.next != null; e = e.next)
      this.CreateOrientedSegsOnLineVertex(t, e);
  }
  CreateOrientedSegsOnLineVertex(t, e) {
    const i = this.metroGraphData.PointToStations.get(e.prev.point), s = this.metroGraphData.PointToStations.get(e.point), n = this.metroGraphData.PointToStations.get(e.next.point), r = s.BundleBases.get(i), a = s.BundleBases.get(n), l = this.metroOrdering.GetLineIndexInOrder(i, s, t), h = this.metroOrdering.GetLineIndexInOrder(n, s, t), c = r.OrientedHubSegments[l] = new Ll(null, !1, l, r), d = a.OrientedHubSegments[h] = new Ll(null, !0, h, a);
    d.Other = c, c.Other = d;
  }
  UpdateSourceAndTargetBases() {
    for (const t of this.Bundles)
      t.UpdateSourceAndTargetBases(!0, !0);
  }
  SetBasesRightLeftParamsToTheMiddles() {
    for (const t of this.Bundles) {
      const e = t.SourceBase, i = t.TargetBase;
      e.ParEnd = e.ParStart = this.GetBaseMiddleParamInDirection(e, e.Position, i.Position), i.ParEnd = i.ParStart = this.GetBaseMiddleParamInDirection(i, i.Position, e.Position);
    }
  }
  GetBaseMiddleParamInDirection(t, e, i) {
    const s = t.Curve;
    if (s instanceof j) {
      const a = s;
      if (a.isArc())
        return u.angle(a.aAxis, i.sub(e));
    }
    const r = g.getAllIntersections(s, v.mkPP(e, i), !0);
    for (const a of r) {
      const l = a.x;
      if (l.sub(e).dot(l.sub(i)) <= 0)
        return a.par0;
    }
    throw new Error();
  }
  SetRightLeftParamsFeasiblySymmetrically() {
    for (const t of this.Bundles)
      t.SetParamsFeasiblySymmetrically(this.metroGraphData.TightTree);
  }
  AdjustStartEndParamsToAvoidBaseOverlaps() {
    for (const t of this.externalBases.values())
      this.AdjustCurrentBundleWidthsOnCurve(t);
    for (const t of this.internalBases.values())
      this.AdjustCurrentBundleWidthsOnCurve(t);
  }
  AdjustCurrentBundleWidthsOnCurve(t) {
    const e = t.length;
    if (!(e <= 1))
      for (let i = 0; i < e; i++) {
        const s = t[i], n = s.Next;
        this.ShrinkBasesToMakeTwoConsecutiveNeighborsHappy(s, n);
      }
  }
  ShrinkBasesToMakeTwoConsecutiveNeighborsHappy(t, e) {
    const i = Sg(t, e);
    if (i == null || D(i.start, i.end))
      return;
    const s = i.rbaseMiddle, n = i.lbaseMiddle;
    if (s < n) {
      const h = t;
      t = e, e = h;
    }
    const r = t.Span, a = e.Span, l = (i.end * r + i.start * a) / (a + r);
    t.ParStart = t.AdjustParam(l + m.distanceEpsilon), e.ParEnd = e.AdjustParam(l - m.distanceEpsilon);
  }
  // find a cut point for 2 segments
  RegularCut(t, e, i, s, n, r) {
    let a = (n * s + r * t) / (n + r);
    const l = Math.min(e, s), h = Math.max(t, i);
    return a < h && (a = h), a > l && (a = l), a;
  }
  RotateBundlesToDiminishCost() {
    let t = H.MaxParameterChange;
    const e = { cost: this.Cost() };
    let i = 0;
    for (; i++ < H.MaxIterations; ) {
      const s = e.cost;
      if (this.RotateBundlesToDiminishCostOneIteration(t, e), t = this.UpdateParameterChange(t, s, e.cost), t < H.MinParameterChange)
        break;
    }
  }
  UpdateParameterChange(t, e, i) {
    return i + 1 < e ? (this.stepsWithProgress++, this.stepsWithProgress >= 5 && (this.stepsWithProgress = 0, this.fixedBundles.clear())) : (this.stepsWithProgress = 0, t *= 0.8, this.fixedBundles.clear()), t;
  }
  RotateBundlesToDiminishCostOneIteration(t, e) {
    let i = !1;
    for (const s of this.Bundles)
      this.fixedBundles.has(s) || (this.OptimizeBundle(s, t, e) ? i = !0 : this.fixedBundles.add(s));
    return i;
  }
  OptimizeBundle(t, e, i) {
    const s = this.CostBi(t);
    if (s < H.CostThreshold)
      return !1;
    let n = 0, r = -1, a = -1;
    for (let l = 0; l < H.Deltas.length - 1; l++) {
      let h = this.DeltaWithChangedAngles(H.Deltas[l][0], H.Deltas[l][1], 0, 0, t, s, e);
      h > H.CostDeltaThreshold && h > n && (a = l, r = H.Deltas.length - 1, n = h), h = this.DeltaWithChangedAngles(0, 0, H.Deltas[l][0], H.Deltas[l][1], t, s, e), h > H.CostDeltaThreshold && h > n && (a = H.Deltas.length - 1, r = l, n = h);
    }
    return n < H.CostDeltaThreshold ? !1 : (i.cost -= n, t.RotateBy(H.Deltas[a][0], H.Deltas[a][1], H.Deltas[r][0], H.Deltas[r][1], e), !0);
  }
  DeltaWithChangedAngles(t, e, i, s, n, r, a) {
    if (!n.RotationIsLegal(t, e, i, s, a))
      return 0;
    n.RotateBy(t, e, i, s, a);
    const l = this.CostBN(n, r);
    return n.RotateBy(t * -1, e * -1, i * -1, s * -1, a), r - l;
  }
  CostBi(t) {
    return H.SeparationCoeff * this.SeparationCost(t) + (H.SqueezeCoeff * this.SqueezeCost(t) + (H.AssymetryCoeff * this.AssymetryCost(t) + H.CenterCoeff * this.CenterCostBi(t)));
  }
  // this is an accelerated version of the above function (calculate cost partly)
  CostBN(t, e) {
    let i = 0;
    return i = i + H.CenterCoeff * this.CenterCostBi(t), i > e || (i = i + H.SeparationCoeff * this.SeparationCost(t), i > e) || (i = i + H.SqueezeCoeff * this.SqueezeCost(t), i > e) || (i = i + H.AssymetryCoeff * this.AssymetryCost(t)), i;
  }
  SqueezeCost(t) {
    const i = t.TargetBase.MidPoint.sub(t.SourceBase.MidPoint).normalize().rotate90Ccw(), s = Math.abs(t.SourceBase.StartPoint.sub(t.SourceBase.EndPoint).dot(i)), n = Math.abs(t.TargetBase.StartPoint.sub(t.TargetBase.EndPoint).dot(i)), r = Math.abs(t.TotalRequiredWidth - s) / t.TotalRequiredWidth, a = Math.abs(t.TotalRequiredWidth - n) / t.TotalRequiredWidth, l = Math.abs(s - n) / t.TotalRequiredWidth;
    return Math.exp(r * 10) - 1 + (Math.exp(a * 10) - 1) + l;
  }
  CenterCostBi(t) {
    return !t.SourceBase.BelongsToRealNode && !t.TargetBase.BelongsToRealNode ? 0 : this.CenterCostBb(t.SourceBase) + this.CenterCostBb(t.TargetBase);
  }
  CenterCostBb(t) {
    if (!t.BelongsToRealNode)
      return 0;
    const e = t.ParMid, i = Math.min(t.InitialMidParameter, e), s = Math.max(t.InitialMidParameter, e), n = Math.min(s - i, i + (Fi(t.Curve) - s));
    return t.CurveCenter.equal(t.Position) || t.IsParent ? 25 * (n * n) : 500 * (n * n);
  }
  AssymetryCost(t) {
    return this.GetAssymetryCostForBase(t.SourceBase) + this.GetAssymetryCostForBase(t.TargetBase);
  }
  GetAssymetryCostForBase(t) {
    if (t.BelongsToRealNode)
      return 0;
    const e = t.OppositeBase.BelongsToRealNode ? 200 : 500;
    let i = 0;
    for (const s of t.OrientedHubSegments) {
      const n = s.Index, r = s.Other.Index, a = t.Points[n], l = t.Tangents[n], h = s.Other.BundleBase, c = h.Points[r], d = h.Tangents[r], f = t.Count + h.Count;
      i += this.GetAssymetryCostOnData(a, l, c, d, e) / f;
    }
    return i;
  }
  GetAssymetryCostOnData(t, e, i, s, n) {
    const r = t.sub(i);
    if (r.length < m.distanceEpsilon)
      return 0;
    const l = e.add(s).dot(r), h = u.crossProduct(r, e), c = u.crossProduct(r, s), d = h - c, f = l * l + d * d, p = h * h + c * c;
    return 10 * f + n * p;
  }
  SeparationCost(t) {
    return this.SeparationCostForBundleBase(t.SourceBase) + this.SeparationCostForBundleBase(t.TargetBase);
  }
  SeparationCostForBundleBase(t) {
    return t.Prev == null ? 0 : this.SeparationCostForAdjacentBundleBases(t, t.Prev) + this.SeparationCostForAdjacentBundleBases(t, t.Next);
  }
  SeparationCostForAdjacentBundleBases(t, e) {
    const i = t.Curve, s = this.IntervalsOverlapLength(t.ParStart, t.ParEnd, e.ParStart, e.ParEnd, i), n = Math.min(t.Span, e.Span);
    return Math.exp(s / (n * 10)) - 1;
  }
  // returns the length of the overlapped interval of parameter space
  IntervalsOverlapLength(t, e, i, s, n) {
    const r = n.parStart, a = n.parEnd;
    return t < e ? i < s ? this.IntersectRegularIntervals(t, e, i, s) : this.IntersectRegularIntervals(t, e, i, a) + this.IntersectRegularIntervals(t, e, r, s) : i < s ? this.IntersectRegularIntervals(t, a, i, s) + this.IntersectRegularIntervals(r, e, i, s) : this.IntersectRegularIntervals(t, a, i, a) + this.IntersectRegularIntervals(r, e, r, s);
  }
  IntersectRegularIntervals(t, e, i, s) {
    const n = Math.max(t, i), r = Math.min(e, s);
    return n < r ? r - n : 0;
  }
  Cost() {
    let t = 0;
    for (const e of this.Bundles) {
      const i = H.SeparationCoeff * this.SeparationCost(e), s = H.AssymetryCoeff * this.AssymetryCost(e), n = H.SqueezeCoeff * this.SqueezeCost(e), r = H.CenterCoeff * this.CenterCostBi(e);
      t += (i + s) / 2 + n + r;
    }
    return t;
  }
}
H.Deltas = [
  [1, -1],
  // [0, 1],
  //[-1, 1],
  // [1, 0],
  // [-1, 0],
  //[1, -1],
  // [0, -1],
  [1, -1]
  //rotating the left point cw, the right ccw
];
H.SeparationCoeff = 1;
H.SqueezeCoeff = 1;
H.CenterCoeff = 10;
H.AssymetryCoeff = 1;
H.MaxIterations = 200;
H.MaxParameterChange = 8 / 360;
H.MinParameterChange = 0.1 / 360;
H.CostThreshold = 1e-5;
H.CostDeltaThreshold = 0.01;
function Sg(o, t) {
  const e = Fi(o.Curve);
  let i = o.ParEnd, s = o.ParStart < o.ParEnd ? o.ParStart : o.ParStart - e, n = t.ParEnd, r = t.ParStart < t.ParEnd ? t.ParStart : t.ParStart - e;
  i > n ? i - r > e && (r += e, n += e) : n - s > e && (s += e, i += e);
  const a = Math.min(i, n), l = Math.max(s, r);
  return l <= a ? { start: l, end: a, rbaseMiddle: (s + i) / 2, lbaseMiddle: (r + n) / 2 } : null;
}
class yg {
  constructor() {
    this.Metrolines = new Array();
  }
  Add(t) {
    this.Metrolines.push(t);
  }
}
class _r {
  // Initialize bundle graph and build the ordering
  constructor(t) {
    this.Metrolines = t, this.BuildOrder();
  }
  *GetOrder(t, e) {
    const i = new ne(t.Position, e.Position), s = this.bundles.get(i).Metrolines;
    if (t.Position === i.first)
      for (let n = 0; n < s.length; n++)
        yield s[n];
    else
      for (let n = s.length - 1; n >= 0; n--)
        yield s[n];
  }
  /**   Get the index of line on the edge (u->v) and node u */
  GetLineIndexInOrder(t, e, i) {
    const s = new ne(t.Position, e.Position), n = t.Position !== s.first, r = this.bundles.get(s).LineIndexInOrder;
    return n ? r.size - 1 - r.get(i) : r.get(i);
  }
  /**   Do the main job */
  BuildOrder() {
    this.bundles = new Nn();
    for (const t of this.Metrolines)
      for (let e = t.Polyline.startPoint; e.next != null; e = e.next) {
        const i = new ne(e.point, e.next.point);
        let s = this.bundles.get(i);
        s || this.bundles.set(i, s = new yg()), s.Add(t);
      }
    for (const t of this.bundles)
      this.BuildOrderPP(t[0], t[1]);
  }
  /**   Build an order for edge (u->v) */
  BuildOrderPP(t, e) {
    if (!e.orderFixed) {
      e.Metrolines.sort((i, s) => this.CompareLines(i, s, t.first, t.second)), e.orderFixed = !0, e.LineIndexInOrder = /* @__PURE__ */ new Map();
      for (let i = 0; i < e.Metrolines.length; i++)
        e.LineIndexInOrder.set(e.Metrolines[i], i);
    }
  }
  /**   Compare two lines on station u with respect to edge (u->v) */
  CompareLines(t, e, i, s) {
    const n = { polyPoint: null, next: null, prev: null };
    this.FindStationOnLine(i, s, t, n);
    const r = n.polyPoint, a = n.next, l = n.prev;
    this.FindStationOnLine(i, s, e, n);
    const h = n.polyPoint, c = n.next, d = n.prev;
    let f = r, p = h, P, y;
    for (; (y = l(f)) != null && (P = d(p)) != null && y.point.equal(P.point); ) {
      const C = new ne(y.point, f.point);
      if (this.bundles.get(C).orderFixed)
        return this.CompareOnFixedOrder(C, t, e, !y.point.equal(C.first));
      f = y, p = P;
    }
    if (y != null && P != null) {
      const C = f.point;
      return -_r.IsLeft(a(f).point.sub(C), y.point.sub(C), P.point.sub(C));
    }
    for (f = r, p = h; (y = a(f)) != null && (P = c(p)) != null && y.point.equal(P.point); ) {
      const C = new ne(y.point, f.point);
      if (this.bundles.get(C).orderFixed)
        return this.CompareOnFixedOrder(C, t, e, !f.point.equal(C.first));
      f = y, p = P;
    }
    if (y != null && P != null) {
      const C = f.point;
      return _r.IsLeft(l(f).point.sub(C), y.point.sub(C), P.point.sub(C));
    }
    return yt(t.Index, e.Index);
  }
  CompareOnFixedOrder(t, e, i, s) {
    const n = this.bundles.get(t).LineIndexInOrder;
    return (s ? -1 : 1) * yt(n.get(e), n.get(i));
  }
  /** Fills Next and Prev functions according to the direction of the metroline */
  // todo?  Reimplement it in more efficient way!!! (cache indexes)
  FindStationOnLine(t, e, i, s) {
    for (let n = i.Polyline.startPoint; n.next != null; n = n.next) {
      if (n.point.equal(t) && n.next.point.equal(e)) {
        s.next = (r) => r.next, s.prev = (r) => r.prev, s.polyPoint = n;
        return;
      }
      if (n.point.equal(e) && n.next.point.equal(t)) {
        s.next = (r) => r.prev, s.prev = (r) => r.next, s.polyPoint = n.next;
        return;
      }
    }
    throw new Error();
  }
  /**  computes orientation of three vectors with a common source
     (compare the polar angles of v1 and v2 with respect to v0),
      return -1 if the orientation is v0 v1 v2,
               1 if the orientation is v0 v2 v1,
               0  if v1 and v2 are collinear and codirectinal, TODO: seems fishy */
  static IsLeft(t, e, i) {
    return hs(t, e, i);
  }
}
class Y extends lt {
  // Constructor
  constructor(t, e) {
    super(null), this.metroGraphData = t, this.bundlingSettings = e;
  }
  run() {
    this.CreateMetroOrdering(), this.InitRadii(), this.FinalizePaths();
  }
  InitRadii() {
    new Yt(this.metroGraphData, this.bundlingSettings).CreateNodeRadii();
  }
  // bundle-map ordering
  CreateMetroOrdering() {
    this.metroOrdering = new _r(this.metroGraphData.Metrolines);
  }
  FinalizePaths() {
    this.CreateBundleBases(), this.CreateSegmentsInsideHubs(), this.CreateCurves();
  }
  CreateBundleBases() {
    new H(this.metroOrdering, this.metroGraphData, this.bundlingSettings).Run();
  }
  CreateCurves() {
    for (let t = 0; t < this.metroGraphData.Metrolines.length; t++)
      this.CreateCurveLine(this.metroGraphData.Metrolines[t], this.metroGraphData.Edges[t]);
  }
  CreateCurveLine(t, e) {
    const i = new g();
    let n = Y.FindCurveStart(this.metroGraphData, this.metroOrdering, t);
    const r = Y.HubSegsOfLine(this.metroGraphData, this.metroOrdering, t);
    for (const a of r)
      a != null && (i.addSegment(v.mkPP(n, a.start)), i.addSegment(a), n = a.end);
    i.addSegment(v.mkPP(n, Y.FindCurveEnd(this.metroGraphData, this.metroOrdering, t))), e.curve = i;
  }
  static FindCurveStart(t, e, i) {
    const s = t.PointToStations.get(i.Polyline.startPoint.point), n = t.PointToStations.get(i.Polyline.startPoint.next.point), r = s.BundleBases.get(n), a = r.IsParent ? e.GetLineIndexInOrder(s, n, i) : e.GetLineIndexInOrder(n, s, i);
    return r.Points[a];
  }
  static FindCurveEnd(t, e, i) {
    const s = t.PointToStations.get(i.Polyline.endPoint.prev.point), n = t.PointToStations.get(i.Polyline.endPoint.point), r = n.BundleBases.get(s), a = r.IsParent ? e.GetLineIndexInOrder(n, s, i) : e.GetLineIndexInOrder(s, n, i);
    return r.Points[a];
  }
  static *HubSegsOfLine(t, e, i) {
    for (let s = i.Polyline.startPoint.next; s.next != null; s = s.next)
      yield Y.SegOnLineVertex(t, e, i, s);
  }
  static SegOnLineVertex(t, e, i, s) {
    const n = t.PointToStations.get(s.prev.point), r = t.PointToStations.get(s.point), a = r.BundleBases.get(n), l = e.GetLineIndexInOrder(n, r, i);
    if (a.OrientedHubSegments[l] == null || a.OrientedHubSegments[l].Segment == null) {
      const h = t.PointToStations.get(s.next.point), c = r.BundleBases.get(h), d = e.GetLineIndexInOrder(h, r, i);
      return v.mkPP(a.Points[l], c.Points[d]);
    }
    return a.OrientedHubSegments[l].Segment;
  }
  CreateSegmentsInsideHubs() {
    for (const t of this.metroGraphData.Metrolines)
      this.CreateOrientedSegsOnLine(t);
    this.bundlingSettings.UseCubicBezierSegmentsInsideOfHubs && this.FanBezierSegs();
  }
  CreateOrientedSegsOnLine(t) {
    for (let e = t.Polyline.startPoint.next; e.next != null; e = e.next)
      this.CreateICurveForOrientedSeg(t, e);
  }
  CreateICurveForOrientedSeg(t, e) {
    const i = this.metroGraphData.PointToStations.get(e.prev.point), s = this.metroGraphData.PointToStations.get(e.point), n = this.metroGraphData.PointToStations.get(e.next.point), r = s.BundleBases.get(i), a = s.BundleBases.get(n), l = this.metroOrdering.GetLineIndexInOrder(i, s, t), h = this.metroOrdering.GetLineIndexInOrder(n, s, t), c = this.bundlingSettings.UseCubicBezierSegmentsInsideOfHubs ? Y.StandardBezier(r.Points[l], r.Tangents[l], a.Points[h], a.Tangents[h]) : Y.BiArc(r.Points[l], r.Tangents[l], a.Points[h], a.Tangents[h]);
    r.OrientedHubSegments[l].Segment = c, a.OrientedHubSegments[h].Segment = c;
  }
  static ShowHubs(t, e, i, s, n = []) {
    let r = Y.GetAllDebugCurves(e, t);
    i != null && r.push(q.mkDebugCurveTWCI(255, 1, "red", pt.mkDiamond(5, 25, i.Position))), r = r.concat(n);
  }
  static GetAllDebugCurves(t, e) {
    return Y.GraphNodes(e).concat(Y.VertexDebugCurves(t, e)).concat(Y.DebugEdges(e));
  }
  static DebugEdges(t) {
    return t.Edges.map((e) => q.mkDebugCurveTWCI(40, 0.1, "gray", e.curve));
  }
  static VertexDebugCurves(t, e) {
    return Y.DebugCircles(e).concat(Y.DebugHubBases(e)).concat(Y.DebugSegs(e)).concat(Y.BetweenHubs(t, e));
  }
  static BetweenHubs(t, e) {
    const i = [];
    for (const s of e.Metrolines) {
      const n = Y.GetInterestingSegs(e, t, s), r = Y.GetMonotoneColor(s.Polyline.start, s.Polyline.end, n);
      for (const a of n)
        i.push(q.mkDebugCurveTWCI(100, s.Width, r, v.mkPP(a[0], a[1])));
    }
    return i;
  }
  static GetInterestingSegs(t, e, i) {
    const s = new Array();
    if (t.Stations.length === 0 || t.Stations[0].BundleBases == null || t.Stations[0].BundleBases.size === 0)
      return [];
    let n = Y.FindCurveStart(t, e, i);
    const r = Y.HubSegsOfLine(t, e, i);
    for (const a of r)
      a != null && (s.push([n, a.start]), n = a.end);
    return s.push([n, Y.FindCurveEnd(t, e, i)]), s;
  }
  static GetMonotoneColor(t, e, i) {
    return "green";
  }
  static DebugHubBases(t) {
    const e = new Array();
    for (const i of t.Stations)
      for (const s of i.BundleBases.values())
        e.push(q.mkDebugCurveTWCI(100, 1, "red", v.mkPP(s.EndPoint, s.StartPoint)));
    return e;
  }
  static DebugCircles(t) {
    return t.Stations.map((e) => q.mkDebugCurveTWCI(100, 0.1, "blue", pt.mkCircle(e.Radius, e.Position)));
  }
  static DebugSegs(t) {
    const e = new Array();
    for (const i of t.VirtualStations())
      for (const s of i.BundleBases.values())
        for (const n of s.OrientedHubSegments)
          if (n != null)
            if (n.Segment == null) {
              const r = n.Other.BundleBase, a = n.Index, l = n.Other.Index;
              e.push(v.mkPP(s.Points[a], r.Points[l]));
            } else
              e.push(n.Segment);
    return e.map((i) => q.mkDebugCurveTWCI(100, 0.01, "green", i));
  }
  static GraphNodes(t) {
    return t.Edges.map((i) => i.sourcePort.Curve).concat(t.Edges.map((i) => i.targetPort.Curve)).map((i) => q.mkDebugCurveTWCI(40, 1, "black", i));
  }
  static BiArc(t, e, i, s) {
    const n = t.sub(i);
    if (n.length < m.distanceEpsilon)
      return null;
    const r = n.dot(e.sub(s)), a = -e.dot(s);
    if (e.dot(i.sub(t)) <= 0 && e.dot(s) <= 0)
      return Y.StandardBezier(t, e, i, s);
    const l = 2 * (a - 1), h = 2 * r, c = n.dot(n);
    let d;
    if (Math.abs(l) < m.distanceEpsilon)
      if (Math.abs(h) > m.distanceEpsilon)
        d = -c / h;
      else
        return null;
    else {
      let N = h * h - 4 * l * c;
      N < 0 && (N = 0), N = Math.sqrt(N), d = (-h + N) / (2 * l), d < 0 && (d = (-h - N) / (2 * l));
    }
    const f = t.add(e.mul(d)), p = i.add(s.mul(d)), P = u.middle(f, p), y = u.getTriangleOrientation(t, f, P), C = u.getTriangleOrientation(P, p, i);
    if (y !== C)
      return Y.StandardBezier(t, e, i, s);
    const E = new g();
    return E.addSegs([Y.ArcOn(t, f, P), Y.ArcOn(P, p, i)]), E;
  }
  // returns the arc that a,b,c touches
  static ArcOn(t, e, i) {
    const s = { center: null };
    if (Math.abs(u.signedDoubledTriangleArea(t, e, i)) < 1e-4 || !Y.FindArcCenter(t, e, i, s))
      return v.mkPP(t, i);
    const n = s.center, r = Z(t, n);
    if (Z(t, e) / r < 1e-4)
      return v.mkPP(t, i);
    const l = t.sub(n);
    let h = Math.atan2(l.y, l.x);
    const c = i.sub(n);
    let d = Math.atan2(c.y, c.x), f = d - h;
    if (f < 0 && (f += 2 * Math.PI, d += 2 * Math.PI), f <= Math.PI)
      return new j(h, d, new u(r, 0), new u(0, r), n);
    for (d > 2 * Math.PI && (d -= 2 * Math.PI), h = Math.PI - h, d = Math.PI - d, h < 0 && (h += 2 * Math.PI); d < h; )
      d += 2 * Math.PI;
    return f = d - h, new j(h, d, new u(-r, 0), new u(0, r), n);
  }
  static FindArcCenter(t, e, i, s) {
    const n = e.sub(t).rotate90Cw(), r = e.sub(i).rotate90Cw();
    return s.center = u.lineLineIntersection(t, t.add(n), i, i.add(r)), s.center != null;
  }
  static StandardBezier(t, e, i, s) {
    const n = Z(t, i) / 4;
    return st.mkBezier([t, t.add(e.mul(n)), i.add(s.mul(n)), i]);
  }
  FanBezierSegs() {
    let t = !0;
    const e = 5;
    let i = 0;
    for (; t && i++ < e; ) {
      t = !1;
      for (const s of this.metroGraphData.Stations)
        for (const n of s.BundleBases.values())
          t || (t = this.FanEdgesOfHubSegment(n));
    }
  }
  FanEdgesOfHubSegment(t) {
    let e = !1;
    for (let i = 0; i < t.Count - 1; i++)
      e || (e = this.FanCouple(t, i, t.CurveCenter, t.Curve.boundingBox.diagonal / 2));
    return e;
  }
  // fans the couple i,i+1
  FanCouple(t, e, i, s) {
    const n = t.OrientedHubSegments[e], r = t.OrientedHubSegments[e + 1];
    if (n == null || Bh(n.Segment.start, n.Segment.end, r.Segment.start, r.Segment.end) || u.getTriangleOrientation(n.value(0), n.value(0.5), n.value(1)) != u.getTriangleOrientation(r.value(0), r.value(0.5), r.value(1)))
      return !1;
    const l = this.BaseLength(n), h = this.BaseLength(r);
    return Math.abs(l - h) < m.intersectionEpsilon ? !1 : l > h ? this.AdjustLongerSeg(n, r, i, s) : this.AdjustLongerSeg(r, n, i, s);
  }
  AdjustLongerSeg(t, e, i, s) {
    const n = t.value(0).sub(e.value(0)), r = t.value(1).sub(e.value(1)), a = Math.min(n.length, r.length), l = e.value(0.5), h = Math.max(n.length, r.length);
    return this.NicelyAligned(t.Segment, n, r, l, a, h) === 0 ? !1 : this.FitLonger(t, n, r, l, a, h, i, s);
  }
  FitLonger(t, e, i, s, n, r, a, l) {
    let h = t.Segment;
    const c = h.start, d = h.end;
    let f = 0;
    const p = 10;
    let P = h.start.mul(1 - Y.SqueezeBound).add(h.B(1).mul(Y.SqueezeBound)), y = h.end.mul(1 - Y.SqueezeBound).add(h.B(2).mul(Y.SqueezeBound)), C = h.B(1).mul(2).sub(h.start), E = h.B(2).mul(2).sub(h.end);
    const N = { highP: C };
    this.PullControlPointToTheCircle(h.start, N, a, l), C = N.highP;
    let I = this.NicelyAligned(h, e, i, s, n, r);
    do {
      if (I === -1) {
        const x = u.middle(h.B(1), P), V = u.middle(h.B(2), y);
        C = h.B(1), E = h.B(2), h = new st(c, x, V, d);
      } else {
        const x = u.middle(h.B(1), C), V = (h.B(2), E);
        P = h.B(1), y = h.B(2), h = new st(c, x, V, d);
      }
      if ((I = this.NicelyAligned(h, e, i, s, n, r)) === 0)
        return t.Segment = h, t.Other.Segment = h, !0;
      if (f++ > p)
        return !1;
    } while (!0);
  }
  PullControlPointToTheCircle(t, e, i, s) {
    const n = u.ProjectionToLine(t, e.highP, i), r = Math.sqrt(s * s - n.sub(i).lengthSquared), a = e.highP.sub(n), l = a.length;
    l > r && (e.highP = n.add(a.mul(r / l)));
  }
  //
  NicelyAligned(t, e, i, s, n, r) {
    const l = t.value(0.5).sub(s), h = l.length;
    return e.dot(l) < 0 || i.dot(l) < 0 || h < n - 1e-3 ? 1 : h > r + 1e-3 ? -1 : 0;
  }
  BaseLength(t) {
    return t.value(0).sub(t.value(1)).lengthSquared;
  }
}
Y.SqueezeBound = 0.2;
class At {
  // fix routing by simulated annealing algorithm
  static FixRouting(t, e) {
    return this.FixRoutingMBP(t, e, null);
  }
  static FixRoutingMBP(t, e, i) {
    return new At(t, e).FixRoutingP(i);
  }
  constructor(t, e) {
    this.stepsWithProgress = 0, this.metroGraphData = t, this.bundlingSettings = e, this.costCalculator = new ft(this.metroGraphData, this.bundlingSettings), this.cache = new no(this.metroGraphData, this.bundlingSettings, this.costCalculator, this.metroGraphData.cdt);
  }
  // Use constraint edge routing to reduce ink
  FixRoutingP(t) {
    this.stationsForOptimizations = this.GetStationsForOptimizations(t), this.cache.InitializeCostCache();
    let e = At.MaxStep, i = Number.POSITIVE_INFINITY, s = this.metroGraphData.VirtualStations().map((r) => r.Position), n = 0;
    for (; n++ < At.MaxIterations; ) {
      const r = this.TryMoveStations();
      if (n <= 1 && !r)
        return !1;
      if (!r)
        break;
      const a = i;
      i = ft.Cost(this.metroGraphData, this.bundlingSettings), e = this.UpdateMaxStep(e, a, i);
      const l = s;
      if (s = this.metroGraphData.VirtualStations().map((h) => h.Position), e < At.MinStep || this.Converged(e, l, s))
        break;
    }
    return !0;
  }
  static stationsArePositionedCorrectly(t) {
    for (const e of t.VirtualEdges())
      if (!this.edgeIsPositionedCorrectly(e, t))
        return !1;
    return !0;
  }
  static edgeIsPositionedCorrectly(t, e) {
    const i = t[0], s = t[1], n = e.looseIntersections.ObstaclesToIgnoreForBundle(i, s), r = v.mkPP(i.Position, s.Position), a = Array.from(e.looseIntersections.obstacleTree.GetNodeItemsIntersectingRectangle(r.boundingBox)).filter((l) => !n.has(l)).filter((l) => g.CurvesIntersect(r, l));
    return a.length > 0 ? (Y.ShowHubs(e, null, null, "./tmp/badcross.svg", [
      q.mkDebugCurveTWCI(200, 1, "Brown", r),
      q.mkDebugCurveTWCI(200, 1, "Red", pt.mkCircle(2, i.Position)),
      q.mkDebugCurveTWCI(200, 1, "Blue", pt.mkCircle(5, s.Position)),
      q.mkDebugCurveTWCI(100, 1, "Blue", pt.mkCircle(5, s.Position))
    ].concat(a.map((l) => q.mkDebugCurveTWCI(100, 1, "Pink", l)))), !1) : !0;
  }
  GetStationsForOptimizations(t) {
    if (t == null)
      return new Set(this.metroGraphData.VirtualStations());
    {
      const e = /* @__PURE__ */ new Set();
      for (const i of t) {
        const s = this.metroGraphData.PointToStations.get(i);
        s && !s.IsReal && e.add(s);
      }
      return e;
    }
  }
  // stop SA if relative changes are small
  Converged(t, e, i) {
    let s = 0, n = 0;
    for (let a = 0; a < e.length; a++)
      n += e[a].sub(i[a]).lengthSquared, s += e[a].lengthSquared;
    return Math.sqrt(n / s) < At.MinRelativeChange;
  }
  UpdateMaxStep(t, e, i) {
    return i + 1 < e ? (this.stepsWithProgress++, this.stepsWithProgress >= 5 && (this.stepsWithProgress = 0, t = Math.min(At.MaxStep, t / 0.8))) : (this.stepsWithProgress = 0, t *= 0.8), t;
  }
  TryMoveStations() {
    let t = !1;
    const e = /* @__PURE__ */ new Set();
    for (const i of this.stationsForOptimizations)
      if (this.TryMoveStation(i)) {
        t = !0, e.add(i);
        for (const s of i.Neighbors)
          s.IsReal || e.add(s);
      }
    return this.stationsForOptimizations = e, t;
  }
  /**
      Move node to decrease the cost of the drawing
     Returns true iff position has changed
  */
  TryMoveStation(t) {
    let e = this.BuildDirection(t);
    if (e.length === 0)
      return !1;
    let i = this.BuildStepLength(t, e);
    if (i < At.MinStep && (e = bg(), i = this.BuildStepLength(t, e), i < At.MinStep))
      return !1;
    const s = e.mul(i), n = t.Position.add(s);
    return this.metroGraphData.PointToStations.has(n) || !this.moveIsLegalForAdjacentBundles(t, n) ? !1 : (this.metroGraphData.MoveNode(t, n), this.cache.UpdateCostCache(t), !0);
  }
  /** checking the node position and neigborhood bundles */
  moveIsLegalForAdjacentBundles(t, e) {
    for (const i of this.metroGraphData.looseIntersections.obstacleTree.AllHitItems(T.mkOnPoints([e]), (s) => g.PointRelativeToCurveLocation(e, s) !== F.Outside))
      if (t.getELP().has(i) === !1)
        return !1;
    for (const i of t.Neighbors) {
      const s = this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(i, t);
      if (!this.metroGraphData.cdtIntersections.EdgeIsLegal_(i.Position, e, i.cdtTriangle, s))
        return !1;
    }
    return !0;
  }
  // Calculate the direction to improve the ink function
  BuildDirection(t) {
    const e = this.BuildForceForInk(t), i = this.BuildForceForPathLengths(t), s = this.BuildForceForRadius(t), n = this.BuildForceForBundle(t), r = e.add(i.add(s.add(n)));
    return r.length < 0.1 ? new u(0, 0) : r.normalize();
  }
  BuildStepLength(t, e) {
    let i = At.MinStep, s = this.CostGain(t, t.Position.add(e.mul(i)));
    if (s < 0.01)
      return 0;
    for (; 2 * i <= At.MaxStep; ) {
      const n = this.CostGain(t, t.Position.add(e.mul(i * 2)));
      if (n <= s)
        break;
      i *= 2, s = n;
    }
    return i;
  }
  // Computes cost delta when moving the node
  // the cost will be negative if a new position overlaps obstacles
  CostGain(t, e) {
    const s = this.costCalculator.RadiusGain(t, e);
    if (s < -12345678)
      return -12345678;
    const n = this.costCalculator.BundleGain(t, e);
    if (n < -12345678)
      return -12345678;
    const r = this.costCalculator.InkGain(t, e), a = this.costCalculator.PathLengthsGain(t, e);
    return s + r + a + n;
  }
  // force to decrease ink
  BuildForceForInk(t) {
    let e = new u(0, 0);
    for (const s of t.Neighbors) {
      const n = s.Position.sub(t.Position);
      e = e.add(n.normalize());
    }
    return e.mul(this.bundlingSettings.InkImportance);
  }
  // direction to decrease path lengths
  BuildForceForPathLengths(t) {
    let e = new u(0, 0);
    for (const s of this.metroGraphData.MetroNodeInfosOfNode(t)) {
      const n = s.Metroline, r = s.PolyPoint.next.point, a = s.PolyPoint.prev.point, l = r.sub(t.Position), h = a.sub(t.Position);
      e = e.add(l.div(l.length * n.IdealLength)), e = e.add(h.div(h.length * n.IdealLength));
    }
    return e.mul(this.bundlingSettings.PathLengthImportance);
  }
  // direction to increase radii
  BuildForceForRadius(t) {
    let e = new u(0, 0);
    const i = t.cachedIdealRadius, s = { touchedObstacles: [] };
    if (!this.metroGraphData.looseIntersections.HubAvoidsObstaclesSPNBA(t, t.Position, i, s))
      throw Y.ShowHubs(this.metroGraphData, null, t, "./tmp/hubs.svg", [
        q.mkDebugCurveTWCI(255, 1, "Brown", Ue.containingPoly),
        q.mkDebugCurveTWCI(100, 1, "Blue", pt.mkCircle(i, t.Position))
      ]), new Error();
    for (const a of s.touchedObstacles) {
      const h = 2 * (1 - a[1].sub(t.Position).length / i), c = t.Position.sub(a[1]).normalize();
      e = e.add(c.mul(h));
    }
    return e.mul(this.bundlingSettings.HubRepulsionImportance);
  }
  /** calculates the direction to push a bundle away from obstacle*/
  BuildForceForBundle(t) {
    let e = new u(0, 0);
    for (const s of t.Neighbors) {
      const n = this.metroGraphData.GetWidthSSN(t, s, this.bundlingSettings.EdgeSeparation), r = { closestDist: [] };
      this.metroGraphData.cdtIntersections.BundleAvoidsObstacles(t, s, t.Position, s.Position, n / 2, r);
      for (const a of r.closestDist) {
        const h = 2 * (1 - a[0].sub(a[1]).length / (n / 2)), c = a[0].sub(a[1]).normalize().neg();
        e = e.add(c.mul(h));
      }
    }
    return e.mul(this.bundlingSettings.BundleRepulsionImportance);
  }
}
At.MaxIterations = 100;
At.MaxStep = 50;
At.MinStep = 1;
At.MinRelativeChange = 5e-4;
function bg() {
  return new u(1 + 2 * vs(), 1 + 2 * vs());
}
class os {
  constructor(t, e) {
    this.metroGraphData = t, this.bundlingSettings = e;
  }
  /**  apply a number of heuristics to improve current routing */
  static FixRouting(t, e) {
    const i = new os(t, e);
    i.GlueConflictingStations(), i.UnglueEdgesFromBundleToSaveInk(!0);
    let s = 0;
    const n = 10;
    for (; ++s < n; ) {
      let r = i.GlueConflictingStations();
      if (r || (r = i.RelaxConstrainedEdges()), r || (r = s <= 3 && i.UnglueEdgesFromBundleToSaveInk(!1)), r || (r = i.GlueCollinearNeighbors(s)), r || (r = s === 3 && i.RemoveDoublePathCrossings()), !r)
        break;
    }
    for (t.cdtIntersections.ComputeForcesForBundles = !0, i.RemoveDoublePathCrossings(), i.UnglueEdgesFromBundleToSaveInk(!0); i.GlueConflictingStations(); )
      ;
    t.Initialize(!0);
  }
  /** unite the nodes that are close to each other */
  GlueConflictingStations() {
    const t = this.GetCirclesHierarchy();
    if (t == null)
      return !1;
    const e = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Set();
    if (Qt(t, t, (n, r) => this.TryToGlueStations(n, r, e, i)), e.size === 0)
      return !1;
    for (let n = 0; n < this.metroGraphData.Edges.length; n++)
      this.RegenerateEdge(e, n);
    const s = new xt();
    for (const n of i) {
      s.add(n.Position);
      for (const r of n.Neighbors)
        r.IsReal || s.add(r.Position);
    }
    return this.metroGraphData.Initialize(!1), At.FixRoutingMBP(this.metroGraphData, this.bundlingSettings, s), !0;
  }
  GetCirclesHierarchy() {
    for (const i of this.metroGraphData.VirtualStations())
      i.Radius = this.GetCurrentHubRadius(i);
    const t = this.metroGraphData.VirtualStations().map(e);
    return wt(t);
    function e(i) {
      const s = i.Position, n = Math.max(i.Radius, 5), r = new u(n, n), a = T.mkPP(s.add(r), s.sub(r));
      return Nt(i, a);
    }
  }
  GetCurrentHubRadius(t) {
    if (t.IsReal)
      return t.BoundaryCurve.boundingBox.diagonal / 2;
    {
      const e = t.cachedIdealRadius;
      let i = this.metroGraphData.looseIntersections.GetMinimalDistanceToObstacles(t, t.Position, e);
      for (const s of t.Neighbors)
        i = Math.min(i, t.Position.sub(s.Position).length);
      return i;
    }
  }
  TryToGlueStations(t, e, i, s) {
    if (!Or(t.getELP(), e.getELP()))
      return !1;
    const n = t.Position.sub(e.Position).length, r = Math.max(t.Radius, 5), a = Math.max(e.Radius, 5);
    n >= r + a || this.TryGlueOrdered(t, e, s, i) || this.TryGlueOrdered(e, t, s, i);
  }
  TryGlueOrdered(t, e, i, s) {
    return !s.has(t) && !i.has(t) && this.StationGluingIsAllowed(t, e, s) ? (this.Map(t, e, i, s), !0) : !1;
  }
  Map(t, e, i, s) {
    s.set(t, e), i.add(e);
  }
  /**  trying to glue i to j */
  StationGluingIsAllowed(t, e, i) {
    for (const n of t.Neighbors) {
      const r = os.Glued(n, i), a = this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(r, t);
      if (!this.metroGraphData.cdtIntersections.EdgeIsLegalSSPPS(r, e, a))
        return !1;
    }
    return !(this.ComputeCostDeltaAfterStationGluing(t, e, i) < 0);
  }
  ComputeCostDeltaAfterStationGluing(t, e, i) {
    const s = t.Position.sub(e.Position).length;
    if (t.Radius >= s || e.Radius >= s)
      return 1;
    let n = 0;
    const r = this.metroGraphData.Ink;
    let a = this.metroGraphData.Ink - e.Position.sub(t.Position).length;
    for (const l of t.Neighbors) {
      const h = os.Glued(l, i);
      a -= h.Position.sub(t.Position).length, a += this.metroGraphData.RealEdgeCount(h, e) === 0 ? h.Position.sub(e.Position).length : 0;
    }
    n += ft.InkError(r, a, this.bundlingSettings);
    for (const l of this.metroGraphData.MetroNodeInfosOfNode(t)) {
      const h = l.Metroline.Length;
      let c = l.Metroline.Length;
      const d = l.PolyPoint, f = d.prev, p = d.next;
      c -= f.point.sub(t.Position).length + p.point.sub(t.Position).length, c += f.point.sub(e.Position).length + p.point.sub(e.Position).length, n += ft.PathLengthsError(h, c, l.Metroline.IdealLength, this.bundlingSettings);
    }
    return n;
  }
  RegenerateEdge(t, e) {
    const i = this.metroGraphData.Metrolines[e].Polyline;
    for (const r of i)
      if (!this.metroGraphData.PointToStations.has(r))
        return;
    let s = !1;
    for (const r of i)
      if (t.has(this.metroGraphData.PointToStations.get(r))) {
        s = !0;
        break;
      }
    if (!s)
      return;
    const n = Array.from(i).map((r) => this.metroGraphData.PointToStations.get(r));
    this.metroGraphData.Edges[e].curve = B.mkFromPoints(os.GluedPolyline(n, t));
  }
  static GluedPolyline(t, e) {
    let i;
    const s = new mt.Stack();
    s.push(t[0]);
    const n = /* @__PURE__ */ new Set();
    for (i = 1; i < t.length - 1; i++) {
      const r = os.Glued(t[i], e);
      if (n.has(r)) {
        for (; s.top !== r; )
          n.delete(s.pop());
        continue;
      }
      u.closeDistEps(r.Position, s.top.Position) || (n.add(r), s.push(r));
    }
    return s.push(t[i]), Array.from(s).reverse().map((r) => r.Position);
  }
  static Glued(t, e) {
    var i;
    return (i = e.get(t)) !== null && i !== void 0 ? i : t;
  }
  // Unbundle unnecessary edges:
  //  instead of one bundle (a->bcd) we get two bundles (a->b,a->cd) with smaller ink
  UnglueEdgesFromBundleToSaveInk(t) {
    const e = new Nn();
    this.ink = this.metroGraphData.Ink, this.polylineLength = /* @__PURE__ */ new Map();
    for (const n of this.metroGraphData.Metrolines) {
      this.polylineLength.set(n, n.Length);
      for (let r = n.Polyline.startPoint; r.next != null; r = r.next) {
        const a = new ne(r.point, r.next.point);
        Fh(e, a, n);
      }
    }
    const i = new xt();
    let s = !1;
    for (const n of this.metroGraphData.Metrolines) {
      const r = Wi(this.metroGraphData.PointToStations.get(n.Polyline.start).getELP(), this.metroGraphData.PointToStations.get(n.Polyline.end).getELP());
      this.TrySeparateOnPolyline(n, e, i, r) && (s = !0);
    }
    return s && this.metroGraphData.Initialize(!1), (t || s) && At.FixRoutingMBP(this.metroGraphData, this.bundlingSettings, t ? null : i), s;
  }
  TrySeparateOnPolyline(t, e, i, s) {
    let n = !1, r = !0;
    for (; r; ) {
      r = !1;
      for (let a = t.Polyline.startPoint; a.next != null && a.next.next != null; a = a.next)
        this.TryShortcutPolypoint(a, e, i, s) && (r = !0);
      r && (n = !0);
    }
    return n;
  }
  TryShortcutPolypoint(t, e, i, s) {
    return this.SeparationShortcutAllowed(t, e, s) ? (i.add(t.point), i.add(t.next.point), i.add(t.next.next.point), this.RemoveShortcuttedPolypoint(t, e), !0) : !1;
  }
  // allowed iff line (a,c) is legal and inkgain > 0
  SeparationShortcutAllowed(t, e, i) {
    const s = t.point, n = t.next.point, r = t.next.next.point, a = this.metroGraphData.PointToStations.get(s), l = this.metroGraphData.PointToStations.get(n), h = this.metroGraphData.PointToStations.get(r), c = zs(a.getELP(), h.getELP()), d = Ad([i, l.getELP(), c]);
    return !(!this.metroGraphData.cdtIntersections.EdgeIsLegalSSPPS(a, h, d) || this.GetInkgain(t, e, s, n, r) < 0);
  }
  GetInkgain(t, e, i, s, n) {
    const [r, a, l] = this.FindPolylines(t, e);
    let h = 0;
    const c = this.ink;
    let d = this.ink;
    const f = i.sub(s).length, p = s.sub(n).length, P = i.sub(n).length;
    r.size === l.size && (d -= f), a.size === l.size && (d -= p);
    const y = e.get(new ne(i, n));
    (!y || y.size === 0) && (d += P), h += ft.InkError(c, d, this.bundlingSettings);
    for (const V of l) {
      const G = this.polylineLength.get(V), X = G - (f + p - P);
      h += ft.PathLengthsError(G, X, V.IdealLength, this.bundlingSettings);
    }
    let C = this.GetCurrentHubRadius(this.metroGraphData.PointToStations.get(i));
    const E = this.metroGraphData.GetWidthAN(Array.from(l), this.bundlingSettings.EdgeSeparation), N = this.metroGraphData.GetWidthAN(Array.from(Hs(r, l)), this.bundlingSettings.EdgeSeparation);
    let I = Yt.GetMinRadiusForTwoAdjacentBundlesNPPPNNB(C, i, n, s, E, N, this.bundlingSettings);
    I > C && (h -= ft.RError(I, C, this.bundlingSettings)), C = this.GetCurrentHubRadius(this.metroGraphData.PointToStations.get(n));
    const x = this.metroGraphData.GetWidthAN(Array.from(Hs(a, l)), this.bundlingSettings.EdgeSeparation);
    return I = Yt.GetMinRadiusForTwoAdjacentBundlesNPPPNNB(C, n, s, i, x, E, this.bundlingSettings), I > C && (h -= ft.RError(I, C, this.bundlingSettings)), h;
  }
  RemoveShortcuttedPolypoint(t, e) {
    const i = t.point, s = t.next.point, n = t.next.next.point, [r, a, l] = this.FindPolylines(t, e), h = Z(i, s), c = Z(s, n), d = Z(i, n);
    r.size === l.size && (this.ink -= h), a.size === l.size && (this.ink -= c);
    const f = e.get(new ne(i, n));
    (!f || f.size === 0) && (this.ink += d);
    for (const p of l) {
      const P = this.polylineLength.get(p);
      this.polylineLength.set(p, P - (h + c - d));
    }
    for (const p of l) {
      const P = Array.from(p.Polyline.polylinePoints()).find((y) => y.point.equal(s));
      this.RemovePolypoint(P), Ya(e, [i, s], p), Ya(e, [s, n], p), Td(e, [i, n], p);
    }
  }
  FindPolylines(t, e) {
    const i = t.point, s = t.next.point, n = t.next.next.point, r = e.getPP(i, s), a = e.getPP(s, n), l = Wi(r, a);
    return [r, a, l];
  }
  RemovePolypoint(t) {
    const e = t.prev, i = t.next;
    e.next = i, i.prev = e;
  }
  /**   Fix the situation where a station has two neighbors that are almost in the same directions */
  GlueCollinearNeighbors(t) {
    const e = new xt();
    let i = !1;
    for (const s of this.metroGraphData.Stations)
      this.GlueCollinearNeighborsSPN(s, e, t) && (i = !0);
    return i && (this.metroGraphData.Initialize(!1), At.FixRoutingMBP(this.metroGraphData, this.bundlingSettings, e)), i;
  }
  GlueCollinearNeighborsSPN(t, e, i) {
    if (t.Neighbors.length <= 1)
      return !1;
    const s = new sc(), n = t.Neighbors;
    for (let r = 0; r < n.length; r++)
      this.TryToGlueEdges(t, n[r], n[(r + 1) % n.length], s, i);
    if (s.isEmpty)
      return !1;
    for (const r of s)
      this.GlueEdge(r), e.add(r[0].Position), e.add(r[1].Position), e.add(r[2]);
    return !0;
  }
  TryToGlueEdges(t, e, i, s, n) {
    if (u.anglePCP(e.Position, t.Position, i.Position) < this.bundlingSettings.AngleThreshold) {
      const a = Z(e.Position, t.Position), l = Z(i.Position, t.Position), h = Math.min(a, l) / Math.max(a, l);
      if (h < 0.05)
        return;
      if (a < l) {
        if (this.EdgeGluingIsAllowedSSS(t, e, i)) {
          this.AddEdgeToGlue(t, i, e, e.Position, s);
          return;
        }
      } else if (this.EdgeGluingIsAllowedSSS(t, i, e)) {
        this.AddEdgeToGlue(t, e, i, i.Position, s);
        return;
      }
      if (n < 5 && h > 0.5) {
        const c = this.ConstructGluingPoint(t, e, i);
        this.EdgeGluingIsAllowedSSSP(t, e, i, c) && this.AddEdgeToGlue(t, i, e, c, s);
      }
    }
  }
  ConstructGluingPoint(t, e, i) {
    const s = Math.min(Z(e.Position, t.Position), Z(i.Position, t.Position) / 2), n = e.Position.sub(t.Position).normalize().add(i.Position.sub(t.Position).normalize());
    return t.Position.add(n.mul(s / 2));
  }
  EdgeGluingIsAllowedSSS(t, e, i) {
    if (e.IsReal || i.IsReal || !Or(e.getELP(), i.getELP()) || !this.metroGraphData.cdtIntersections.EdgeIsLegal(e, i, e.Position, i.Position))
      return !1;
    const s = this.metroGraphData.looseIntersections.ObstaclesToIgnoreForBundle(t, i);
    return !(tt.IntersectionsOfLineAndRectangleNodeOverPolylineLR(v.mkPP(t.Position, e.Position), this.metroGraphData.LooseTree).find((l) => !s.has(l.seg1)) || tt.IntersectionsOfLineAndRectangleNodeOverPolylineLR(v.mkPP(e.Position, i.Position), this.metroGraphData.LooseTree).find((l) => !s.has(l.seg1)) || this.ComputeCostDeltaAfterEdgeGluing(t, e, i, e.Position) < 0);
  }
  EdgeGluingIsAllowedSSSP(t, e, i, s) {
    return !(!this.metroGraphData.looseIntersections.HubAvoidsObstaclesPNS__(s, 0, Wi(e.getELP(), i.getELP())) || !this.metroGraphData.cdtIntersections.EdgeIsLegal(t, null, t.Position, s) || !this.metroGraphData.cdtIntersections.EdgeIsLegal(e, null, e.Position, s) || !this.metroGraphData.cdtIntersections.EdgeIsLegal(i, null, i.Position, s) || this.ComputeCostDeltaAfterEdgeGluing(t, e, i, s) < 0);
  }
  ComputeCostDeltaAfterEdgeGluing(t, e, i, s) {
    let n = 0;
    const r = this.metroGraphData.Ink, a = this.metroGraphData.Ink - Z(t.Position, i.Position) - Z(t.Position, e.Position) + Z(t.Position, s) + Z(s, e.Position) + Z(s, i.Position);
    n += ft.InkError(r, a, this.bundlingSettings);
    for (const d of this.metroGraphData.GetIjInfo(t, i).Metrolines) {
      const f = d.Length, p = d.Length - Z(t.Position, i.Position) + Z(t.Position, s) + Z(s, i.Position);
      n += ft.PathLengthsError(f, p, d.IdealLength, this.bundlingSettings);
    }
    for (const d of this.metroGraphData.GetIjInfo(t, e).Metrolines) {
      const f = d.Length, p = d.Length - Z(t.Position, e.Position) + Z(t.Position, s) + Z(s, e.Position);
      n += ft.PathLengthsError(f, p, d.IdealLength, this.bundlingSettings);
    }
    const l = t.cachedIdealRadius, h = this.GetCurrentHubRadius(t), c = Yt.GetMinRadiusForTwoAdjacentBundles(h, t, t.Position, e, i, this.metroGraphData, this.bundlingSettings);
    return c > h && (n += ft.RError(c, h, this.bundlingSettings)), l > Z(t.Position, s) && !t.IsReal && (n -= ft.RError(l, Z(t.Position, s), this.bundlingSettings)), n;
  }
  AddEdgeToGlue(t, e, i, s, n) {
    n.has(i, t) || n.has(e, t) || n.has(t, i) || n.has(t, e) || (n.set(t, i, s), n.set(t, e, s));
  }
  GlueEdge(t) {
    const e = t[0], i = t[1], s = t[2];
    for (const n of e.MetroNodeInfos.map((r) => r.PolyPoint))
      n.next != null && n.next.point.equal(i.Position) ? this.SplitPolylinePoint(n, s) : n.prev != null && n.prev.point.equal(i.Position) && this.SplitPolylinePoint(n.prev, s);
  }
  SplitPolylinePoint(t, e) {
    if (t.point === e || t.next.point === e)
      return;
    const i = ei.mkFromPoint(e);
    i.polyline = t.polyline, i.next = t.next, i.prev = t, i.next.prev = i, i.prev.next = i;
  }
  // split each edge that is too much constrained by the obstacles
  RelaxConstrainedEdges() {
    const t = new xt();
    let e = !1;
    for (const i of this.metroGraphData.VirtualEdges())
      this.RelaxConstrainedEdge(i[0], i[1], t) && (e = !0);
    return e && (this.metroGraphData.Initialize(!1), At.FixRoutingMBP(this.metroGraphData, this.bundlingSettings, t)), e;
  }
  RelaxConstrainedEdge(t, e, i) {
    const s = this.metroGraphData.GetWidthSSN(t, e, this.bundlingSettings.EdgeSeparation), n = { closestDist: new Array() };
    this.metroGraphData.cdtIntersections.BundleAvoidsObstacles(t, e, t.Position, e.Position, 0.99 * s / 2, n);
    const r = n.closestDist;
    if (r.length > 0) {
      let a = -1, l;
      for (const h of r) {
        const c = Math.min(Z(t.Position, h[1]), Z(e.Position, h[1])), d = Z(t.Position, e.Position);
        if (c / d < 0.1)
          continue;
        const p = Z(h[0], h[1]);
        (a === -1 || p < a) && (a = p, l = h[1]);
      }
      if (a === -1 || !this.metroGraphData.looseIntersections.HubAvoidsObstaclesPNS__(l, 0, Wi(t.getELP(), e.getELP())))
        return !1;
      i.add(l), i.add(t.Position), i.add(e.Position);
      for (const h of this.metroGraphData.GetIjInfo(t, e).Metrolines) {
        let c = null;
        for (const d of h.Polyline.polylinePoints())
          if (d.point.equal(t.Position)) {
            c = d;
            break;
          }
        c.next != null && c.next.point.equal(e.Position) ? this.SplitPolylinePoint(c, l) : this.SplitPolylinePoint(c.prev, l);
      }
      return !0;
    }
    return !1;
  }
  // switch flips
  RemoveDoublePathCrossings() {
    const t = new _n(this.metroGraphData, this.metroGraphData.PointIsAcceptableForEdge.bind(this)).run();
    return t && (this.metroGraphData.Initialize(!1), At.FixRouting(this.metroGraphData, this.bundlingSettings)), t;
  }
}
class Wr {
  constructor(t, e, i) {
    this.upperBound = Number.POSITIVE_INFINITY, this._visGraph = i, i.ClearPrevEdgesTable();
    for (const s of i.Vertices())
      s.Distance = Number.POSITIVE_INFINITY;
    this.sources = t, this.targets = new Set(e);
  }
  // Returns  a  path
  GetPath() {
    const t = new es();
    for (const e of this.sources)
      e.Distance = 0, t.Enqueue(e, 0);
    for (; !t.IsEmpty() && (this._current = t.Dequeue(), !this.targets.has(this._current)); ) {
      for (const e of this._current.OutEdges)
        this.PassableOutEdge(e) && this.ProcessNeighbor(t, e, e.Target);
      for (const e of this._current.InEdges.filter(this.PassableInEdge.bind))
        this.ProcessNeighbor(t, e, e.Source);
    }
    return this._visGraph.PreviosVertex(this._current) == null ? null : this.CalculatePath();
  }
  PassableOutEdge(t) {
    return this.targets.has(t.Target) || !Wr.IsForbidden(t);
  }
  PassableInEdge(t) {
    return this.targets.has(t.Source) || !Wr.IsForbidden(t);
  }
  static IsForbidden(t) {
    return (t.IsPassable != null && !t.IsPassable() || t) instanceof pi;
  }
  ProcessNeighbor(t, e, i) {
    const s = e.Length, n = this._current.Distance + s;
    n >= this.upperBound || (this.targets.has(i) && (this.upperBound = n, this.closestTarget = i), this._visGraph.PreviosVertex(i) == null ? (i.Distance = n, this._visGraph.SetPreviousEdge(i, e), t.Enqueue(i, n)) : n < i.Distance && (i.Distance = n, this._visGraph.SetPreviousEdge(i, e), t.DecreasePriority(i, n)));
  }
  CalculatePath() {
    if (this.closestTarget == null)
      return null;
    const t = new Array();
    let e = this.closestTarget;
    do
      t.push(e), e = this._visGraph.PreviosVertex(e);
    while (e.Distance > 0);
    return t.push(e), t.reverse();
  }
}
class En extends lt {
  constructor(t, e, i, s, n, r, a, l, h, c) {
    super(null), this.bundlingSettings = s, this.bundlingSettings.edgeWidthShrinkCoeff = 1, this.edgesToRoute = t, this.regularEdges = t.filter((d) => d.source !== d.target), this.VisibilityGraph = i, this.shortestPathRouter = e, this.LoosePadding = n, this.LooseHierarchy = a, this.TightHierarchy = r, this.EdgeLooseEnterable = l, this.EdgeTightEnterable = h, this.loosePolylineOfPort = c, eo(0);
  }
  ThereAreOverlaps(t) {
    return xe(t, t, g.CurvesIntersect);
  }
  // edge routing with Ordered Bundles:
  // 1. route edges with bundling
  // 2. nudge bundles and hubs
  // 3. order paths
  run() {
    if (this.ThereAreOverlaps(this.TightHierarchy)) {
      this.Status = jo.Overlaps;
      return;
    }
    this.FixLocationsForHookAnywherePorts(this.edgesToRoute), this.RoutePathsWithSteinerDijkstra(), this.FixChildParentEdges(), this.bundlingSettings.StopAfterShortestPaths || this.OrderOptimizeNudgeEtc(), this.RouteSelfEdges(), this.FixArrowheads();
  }
  OrderOptimizeNudgeEtc() {
    const t = new gg(this.regularEdges, this.LooseHierarchy, this.TightHierarchy, this.bundlingSettings, this.shortestPathRouter.cdt, this.EdgeLooseEnterable, this.EdgeTightEnterable, this.loosePolylineOfPort);
    os.FixRouting(t, this.bundlingSettings), new Y(t, this.bundlingSettings).run();
  }
  // set endpoint of the edge from child to parent (cluster) to the boundary of the parent
  // TODO: is there a better solution?
  FixChildParentEdges() {
    for (const t of this.regularEdges) {
      const e = t.sourcePort, i = t.targetPort;
      if (e.Curve.boundingBox.containsRect(i.Curve.boundingBox)) {
        const s = g.intersectionOne(e.Curve, v.mkPP(t.curve.start, t.curve.end), !1), n = t.curve;
        n.startPoint.point = s.x;
      }
      if (i.Curve.boundingBox.containsRect(e.Curve.boundingBox)) {
        const s = g.intersectionOne(i.Curve, v.mkPP(t.curve.start, t.curve.end), !0), n = t.curve;
        n.endPoint.point = s.x;
      }
    }
  }
  // ReSharper disable UnusedMember.Local
  // ShowGraphLocal() {
  //  //  ReSharper restore UnusedMember.Local
  //  const l = new List<ICurve>()
  //  l.Clear()
  //  for (const e in this.geometryGraph.edges) {
  //    l.Add(new Ellipse(2, 2, e.Curve.Start))
  //    l.Add(CurveFactory.CreateDiamond(5, 5, e.Curve.End))
  //    l.Add(e.Curve)
  //  }
  //  SplineRouter.ShowVisGraph(this.VisibilityGraph, this.LooseHierarchy.GetAllLeaves(), null, l)
  // }
  FixLocationsForHookAnywherePorts(t) {
    for (const e of t) {
      let i = e.sourcePort instanceof ee;
      if (i) {
        const s = e.sourcePort;
        s.SetLocation(this.FigureOutHookLocation(s.LoosePolyline, e.targetPort, e));
      } else if (i = e.targetPort instanceof ee, i) {
        const s = e.targetPort;
        s.SetLocation(this.FigureOutHookLocation(s.LoosePolyline, e.sourcePort, e));
      }
    }
  }
  FigureOutHookLocation(t, e, i) {
    return e instanceof Ve ? this.FigureOutHookLocationForClusterOtherPort(t, e, i) : this.FigureOutHookLocationForSimpleOtherPort(t, e, i);
  }
  FigureOutHookLocationForClusterOtherPort(t, e, i) {
    const s = this.shortestPathRouter.MakeTransparentShapesOfEdgeGeometry(i), r = new Wr(Array.from(e.LoosePolyline).map(this.VisibilityGraph.FindVertex.bind), Array.from(t).map(this.VisibilityGraph.FindVertex.bind), this.VisibilityGraph).GetPath();
    for (const a of s)
      a.IsTransparent = !1;
    return r[r.length - 1].point;
  }
  FigureOutHookLocationForSimpleOtherPort(t, e, i) {
    const s = e.Location, n = this.shortestPathRouter.MakeTransparentShapesOfEdgeGeometry(i), a = new Rn(this.VisibilityGraph.FindVertex(s), Array.from(t).map((l) => this.VisibilityGraph.FindVertex(l)), this.VisibilityGraph).GetPath();
    for (const l of n)
      l.IsTransparent = !1;
    return a[a.length - 1].point;
  }
  RoutePathsWithSteinerDijkstra() {
    this.shortestPathRouter.VisibilityGraph = this.VisibilityGraph, this.shortestPathRouter.BundlingSettings = this.bundlingSettings, this.shortestPathRouter.geomEdges = this.regularEdges, this.shortestPathRouter.ObstacleHierarchy = this.LooseHierarchy, this.shortestPathRouter.RouteEdges(), this.shortestPathRouter.cdt != null && this.AdjustEdgeSeparation();
  }
  // calculates maximum possible edge separation for the computed routing
  //   if it is greater than bundlingSettings.EdgeSeparation, then proceed
  //   if it is smaller, then either
  //     stop edge bundling, or
  //     reduce edge separation, or
  //     move obstacles to get more free space
  AdjustEdgeSeparation() {
    const t = /* @__PURE__ */ new Map();
    this.shortestPathRouter.FillCrossedCdtEdges(t);
    const e = this.GetPathsOnCdtEdge(t);
    this.bundlingSettings.edgeWidthShrinkCoeff = this.CalculateEdgeWidthShrinkCoeff(e);
  }
  //  //  reducing edge separation
  //  //  TimeMeasurer.DebugOutput("reducing edge separation to " + es);
  //  this.bundlingSettings.EdgeSeparation = es
  //  this.shortestPathRouter.RouteEdges()
  //  return true
  // }
  GetPathsOnCdtEdge(t) {
    const e = /* @__PURE__ */ new Map();
    for (const i of t.keys())
      for (const s of t.get(i))
        xr(e, s, i);
    return e;
  }
  CalculateEdgeWidthShrinkCoeff(t) {
    let e = 0, i = this.bundlingSettings.edgeWidthShrinkCoeff;
    if (this.EdgeSeparationIsOkMN(t, i))
      return i;
    let s = !1;
    for (; !s || Math.abs(i - e) > 0.01; ) {
      const n = (e + i) / 2;
      this.EdgeSeparationIsOkMN(t, n) ? (e = n, s = !0) : i = n;
    }
    return e;
  }
  EdgeSeparationIsOkMN(t, e) {
    for (const i of t.keys())
      if (!this.EdgeSeparationIsOk(i, t.get(i), e))
        return !1;
    return !0;
  }
  EdgeSeparationIsOk(t, e, i) {
    return Array.from(e).map((n) => this.bundlingSettings.ActualEdgeWidth(n, i)).reduce((n, r) => n + r, 0) <= t.Capacity;
  }
  RouteSelfEdges() {
    for (const t of this.edgesToRoute)
      if (t.source === t.target) {
        const e = { smoothedPolyline: null };
        t.curve = Zt.RouteSelfEdge(t.source.boundaryCurve, this.LoosePadding * 2, e);
      }
  }
  FixArrowheads() {
    for (const t of this.edgesToRoute)
      vt.trimSplineAndCalculateArrowheadsII(t, t.source.boundaryCurve, t.target.boundaryCurve, t.curve, !1);
  }
}
En.SuperLoosePaddingCoefficient = 1.1;
class vg {
  constructor(t, e, i) {
    this.numberOfPassedPaths = 0, this.VisibilityEdge = t, this.Source = e, this.Target = i;
  }
  get TargetPoint() {
    return this.Target.Point;
  }
  get SourcePoint() {
    return this.Source.Point;
  }
  get IsOccupied() {
    return this.numberOfPassedPaths > 0;
  }
  get IsPassable() {
    return this.Target.IsTargetOfRouting || this.Source.IsSourceOfRouting || this.VisibilityEdge.IsPassable == null || this.VisibilityEdge.IsPassable();
  }
  AddOccupiedEdge() {
    this.numberOfPassedPaths++;
  }
  RemoveOccupiedEdge() {
    this.numberOfPassedPaths--;
  }
}
class Cg {
  get Prev() {
    return this.PrevEdge == null ? null : this.PrevEdge.Source === this ? this.PrevEdge.Target : this.PrevEdge.Source;
  }
  constructor(t) {
    this.InBoneEdges = new Array(), this.OutBoneEdges = new Array(), this.VisibilityVertex = t;
  }
  get Point() {
    return this.VisibilityVertex.point;
  }
  get Cost() {
    return this.IsSourceOfRouting ? this.cost : this.Prev == null ? Number.POSITIVE_INFINITY : this.cost;
  }
  set Cost(t) {
    this.cost = t;
  }
  SetPreviousToNull() {
    this.PrevEdge = null;
  }
}
class ki {
  constructor(t, e, i) {
    this.EdgesToRoutes = /* @__PURE__ */ new Map(), this.EdgesToRouteSources = /* @__PURE__ */ new Map(), this.MakeTransparentShapesOfEdgeGeometry = t, this.cdt = e, this.Gates = i;
  }
  CreateGraphElements() {
    for (const t of this.vertexArray) {
      const e = t.VisibilityVertex;
      for (const i of e.InEdges) {
        const s = new vg(i, this.VisibilityVerticesToSdVerts.get(i.Source), this.VisibilityVerticesToSdVerts.get(i.Target)), n = this.VisibilityVerticesToSdVerts.get(i.Source);
        t.InBoneEdges.push(s), n.OutBoneEdges.push(s);
      }
    }
  }
  CreateRoutingGraph() {
    this.vertexArray = [], this.VisibilityVerticesToSdVerts = /* @__PURE__ */ new Map();
    for (const t of this.VisibilityGraph.Vertices()) {
      const e = new Cg(t);
      this.vertexArray.push(e), this.VisibilityVerticesToSdVerts.set(t, e);
    }
    this.CreateGraphElements();
  }
  // routing of the edges minimizing (ink+path length+capacity penalty)
  RouteEdges() {
    this.Initialize(), this.RestoreCapacities();
    for (const t of this.geomEdges)
      this.EdgesToRoutes.set(t, this.RouteEdge(t));
    this.RerouteEdges();
    for (const t of this.geomEdges)
      this.SetEdgeGeometryCurve(t);
  }
  SetEdgeGeometryCurve(t) {
    const e = new B();
    let i = this.EdgesToRouteSources.get(t);
    e.addPoint(i.Point);
    for (const r of this.EdgesToRoutes.get(t))
      r.SourcePoint.equal(i.Point) ? (e.addPoint(r.TargetPoint), i = r.Target) : (e.addPoint(r.SourcePoint), i = r.Source);
    t.curve = e, t.sourcePort instanceof Ve && ki.ExtendPolylineStartToClusterBoundary(e, t.sourcePort.Curve), t.targetPort instanceof Ve && ki.ExtendPolylineEndToClusterBoundary(e, t.targetPort.Curve);
  }
  static ExtendPolylineEndToClusterBoundary(t, e) {
    const i = e.closestParameter(t.end);
    t.addPoint(e.value(i));
  }
  static ExtendPolylineStartToClusterBoundary(t, e) {
    const i = e.closestParameter(t.start);
    t.PrependPoint(e.value(i));
  }
  RerouteEdges() {
    this.RestoreCapacities();
    for (const t of this.geomEdges) {
      const e = this.RerouteEdge(t);
      this.EdgesToRoutes.set(t, e);
    }
  }
  RestoreCapacities() {
    this.cdt != null && this.cdt.RestoreEdgeCapacities();
  }
  // Reroute edge
  RerouteEdge(t) {
    const e = this.EdgesToRoutes.get(t);
    for (const i of e)
      i.RemoveOccupiedEdge();
    return this.RouteEdge(t);
  }
  RouteEdge(t) {
    this.CurrentEdgeGeometry = t;
    for (let s = 0; s < this.vertexArray.length; s++) {
      const n = this.vertexArray[s];
      n.SetPreviousToNull(), n.IsTargetOfRouting = n.IsSourceOfRouting = !1;
    }
    const e = this.MakeTransparentShapesOfEdgeGeometry(t), i = this.RouteEdgeWithGroups();
    for (const s of e)
      s.IsTransparent = !1;
    return i;
  }
  RouteEdgeWithGroups() {
    for (let t = 0; t < 2; t++) {
      this.SetLengthCoefficient(), this.Queue = new es(), this.sourceLoosePoly = this.SetPortVerticesAndObstacles(this.CurrentEdgeGeometry.sourcePort, !0), this.targetLoosePoly = this.SetPortVerticesAndObstacles(this.CurrentEdgeGeometry.targetPort, !1);
      const e = this.RouteOnKnownSourceTargetVertices(this.CurrentEdgeGeometry.targetPort.Location.sub(this.CurrentEdgeGeometry.sourcePort.Location).normalize(), t === 0);
      if (e != null)
        return e;
      for (let i = 0; i < this.vertexArray.length; i++)
        this.vertexArray[i].SetPreviousToNull();
    }
    throw new Error();
  }
  RouteOnKnownSourceTargetVertices(t, e) {
    for (this.LowestCostToTarget = Number.POSITIVE_INFINITY, this.ClosestTargetVertex = null; this.Queue.count > 0; ) {
      const i = { priority: 0 }, s = this.Queue.DequeueAndGetPriority(i);
      if (!(i.priority >= this.LowestCostToTarget)) {
        for (let n = 0; n < s.OutBoneEdges.length; n++) {
          const r = s.OutBoneEdges[n];
          r.IsPassable && this.ProcessOutcomingBoneEdge(s, r, t, e);
        }
        for (let n = 0; n < s.InBoneEdges.length; n++) {
          const r = s.InBoneEdges[n];
          r.IsPassable && this.ProcessIncomingBoneEdge(s, r, t, e);
        }
      }
    }
    return this.GetPathAndUpdateRelatedCosts();
  }
  ProcessOutcomingBoneEdge(t, e, i, s) {
    s && i.dot(e.TargetPoint.sub(e.SourcePoint)) < 0 || this.ProcessBoneEdge(t, e.Target, e);
  }
  ProcessIncomingBoneEdge(t, e, i, s) {
    s && i.dot(e.SourcePoint.sub(e.TargetPoint)) < 0 || this.ProcessBoneEdge(t, e.Source, e);
  }
  ProcessBoneEdge(t, e, i) {
    const s = this.GetEdgeAdditionalCost(i, t.Cost);
    if (!(e.Cost <= s))
      if (e.Cost = s, e.PrevEdge = i, this.Queue.ContainsElement(e))
        this.Queue.DecreasePriority(e, s);
      else {
        if (e.IsTargetOfRouting) {
          let n = 0;
          this.CurrentEdgeGeometry.targetPort instanceof Ve && (n = this.LengthCoefficient * e.Point.sub(this.CurrentEdgeGeometry.targetPort.Location).length), s + n < this.LowestCostToTarget && (this.LowestCostToTarget = s + n, this.ClosestTargetVertex = e);
          return;
        }
        this.Enqueue(e);
      }
  }
  GetPathAndUpdateRelatedCosts() {
    let t = this.ClosestTargetVertex;
    if (t == null)
      return null;
    const e = new Array();
    for (; t.PrevEdge != null; )
      e.push(t.PrevEdge), this.RegisterPathInBoneEdge(t.PrevEdge), t = t.Prev;
    return this.EdgesToRouteSources.set(this.CurrentEdgeGeometry, t), e.reverse(), e;
  }
  RegisterPathInBoneEdge(t) {
    t.AddOccupiedEdge(), this.cdt != null && this.BundlingSettings.CapacityOverflowCoefficient !== 0 && this.UpdateResidualCostsOfCrossedCdtEdges(t);
  }
  UpdateResidualCostsOfCrossedCdtEdges(t) {
    for (const e of t.CrossedCdtEdges)
      this.AdjacentToSourceOrTarget(e) || (e.ResidualCapacity === e.Capacity ? e.ResidualCapacity -= this.BundlingSettings.edgeWidthShrinkCoeff * this.CurrentEdgeGeometry.lineWidth : e.ResidualCapacity -= this.BundlingSettings.ActualEdgeWidth(this.CurrentEdgeGeometry));
  }
  H(t) {
    return t.Cost + this.LengthCoefficient * t.Point.sub(this.CurrentEdgeGeometry.targetPort.Location).length;
  }
  GetEdgeAdditionalCost(t, e) {
    const i = t.TargetPoint.sub(t.SourcePoint).length;
    return this.LengthCoefficient * i + e + (t.IsOccupied ? 0 : this.BundlingSettings.InkImportance * i) + this.CapacityOverflowCost(t);
  }
  CapacityOverflowCost(t) {
    if (this.cdt == null || this.BundlingSettings.CapacityOverflowCoefficient === 0)
      return 0;
    let e = 0;
    for (const i of this.CrossedCdtEdgesOfBoneEdge(t))
      e += this.CostOfCrossingCdtEdgeLocal(this.capacityOverlowPenaltyMultiplier, this.BundlingSettings, this.CurrentEdgeGeometry, i);
    return e;
  }
  CrossedCdtEdgesOfBoneEdge(t) {
    return t.CrossedCdtEdges != null ? Array.from(t.CrossedCdtEdges) : Array.from(t.CrossedCdtEdges = this.ThreadBoneEdgeThroughCdt(t));
  }
  ThreadBoneEdgeThroughCdt(t) {
    const e = t.SourcePoint, i = t.Source.Triangle, s = /* @__PURE__ */ new Set(), n = t.TargetPoint;
    if (gt.PointIsInsideOfTriangle(n, i))
      return s;
    const r = new dr(i, e, n);
    for (; r.MoveNext(); ) {
      const a = r.CurrentPiercedEdge;
      this.Gates.has(a) && s.add(a);
    }
    return s;
  }
  // TODO: method incorrect since id doesn't check AdjacentToSourceOrTarget condition
  static CostOfCrossingCdtEdge(t, e, i, s) {
    let n = i.lineWidth * e.edgeWidthShrinkCoeff;
    s.Capacity !== s.ResidualCapacity && (n += e.EdgeSeparation * e.edgeWidthShrinkCoeff);
    const r = s.ResidualCapacity - n;
    return r >= 0 ? 0 : -r * t;
  }
  CostOfCrossingCdtEdgeLocal(t, e, i, s) {
    return this.AdjacentToSourceOrTarget(s) ? 0 : ki.CostOfCrossingCdtEdge(t, e, i, s);
  }
  AdjacentToSourceOrTarget(t) {
    return t.upperSite.Owner === this.sourceLoosePoly || t.lowerSite.Owner === this.sourceLoosePoly || t.upperSite.Owner === this.targetLoosePoly || t.lowerSite.Owner === this.targetLoosePoly;
  }
  SetLengthCoefficient() {
    const t = this.GetIdealDistanceBetweenSourceAndTarget(this.CurrentEdgeGeometry);
    this.LengthCoefficient = this.BundlingSettings.PathLengthImportance / t;
  }
  GetIdealDistanceBetweenSourceAndTarget(t) {
    return t.sourcePort.Location.sub(t.targetPort.Location).length;
  }
  SetPortVerticesAndObstacles(t, e) {
    let i;
    if (t instanceof Ve) {
      i = t.LoosePolyline;
      for (const n of i) {
        let r = 0;
        e && (r = this.LengthCoefficient * n.sub(this.CurrentEdgeGeometry.sourcePort.Location).length), this.AddAndEnqueueVertexToEnds(n, e, r);
      }
    } else if (t instanceof ee) {
      i = t.LoosePolyline;
      for (const n of i)
        this.AddAndEnqueueVertexToEnds(n, e, 0);
    } else {
      this.AddAndEnqueueVertexToEnds(t.Location, e, 0);
      const s = Array.from(this.ObstacleHierarchy.GetNodeItemsIntersectingRectangle(t.Curve.boundingBox));
      let n = s[0].boundingBox.diagonal;
      i = s[0];
      for (let r = 1; r < s.length; r++) {
        const a = s[r], l = a.boundingBox.diagonal;
        l < n && (n = l, i = a);
      }
    }
    return i;
  }
  Enqueue(t) {
    this.Queue.Enqueue(t, this.H(t));
  }
  AddAndEnqueueVertexToEnds(t, e, i) {
    const s = this.FindVertex(t), n = this.VisibilityVerticesToSdVerts.get(s);
    e ? (n.IsSourceOfRouting = !0, n.Cost = i, this.Enqueue(n)) : n.IsTargetOfRouting = !0;
  }
  FindVertex(t) {
    return this.VisibilityGraph.FindVertex(t);
  }
  Initialize() {
    this.CreateRoutingGraph(), this.cdt != null && (this.capacityOverlowPenaltyMultiplier = ki.CapacityOverflowPenaltyMultiplier(this.BundlingSettings), this.SetVertexTriangles(), this.CalculateCapacitiesOfTrianglulation());
  }
  CalculateCapacitiesOfTrianglulation() {
    for (const t of this.Gates)
      ki.CalculateCdtEdgeCapacityForEdge(t);
  }
  static CalculateCdtEdgeCapacityForEdge(t) {
    if (t.constrained || t.CwTriangle == null || t.CcwTriangle == null)
      return;
    const e = t.upperSite.Owner, i = t.lowerSite.Owner;
    if (e !== i) {
      const s = ue.DistancePoint(new ue(e), t.lowerSite.point), n = ue.DistancePoint(new ue(i), t.upperSite.point);
      t.Capacity = (s + n) / 2;
    }
  }
  SetVertexTriangles() {
    const t = wt(Array.from(this.cdt.GetTriangles()).map((i) => Nt(i, i.BoundingBox()))), e = wt(this.vertexArray.map((i) => Nt(i, T.mkOnPoints([i.Point]))));
    ae(t, e, (i, s) => this.TryToAssigenTriangleToVertex(i, s));
  }
  TryToAssigenTriangleToVertex(t, e) {
    e.Triangle == null && gt.PointIsInsideOfTriangle(e.Point, t) && (e.Triangle = t);
  }
  static CapacityOverflowPenaltyMultiplier(t) {
    return t.CapacityOverflowCoefficient * (t.PathLengthImportance + t.InkImportance);
  }
  // compute cdt edges crossed by paths
  FillCrossedCdtEdges(t) {
    for (const e of this.geomEdges) {
      this.sourceLoosePoly = this.SetPortVerticesAndObstacles(e.sourcePort, !0), this.targetLoosePoly = this.SetPortVerticesAndObstacles(e.targetPort, !1);
      for (const i of this.EdgesToRoutes.get(e))
        for (const s of this.CrossedCdtEdgesOfBoneEdge(i))
          this.AdjacentToSourceOrTarget(s) || xr(t, e, s);
    }
  }
}
class Hr {
  constructor(t, e, i, s, n) {
    this.multiEdges = t, this.interactiveEdgeRouter = e, this.bundlingSettings = s, this.bundlingSettings.edgeWidthShrinkCoeff = 1, this.transparentShapeSetter = n, this.nodeTree = Tr(i, (r) => r.boundingBox);
  }
  run() {
    for (const t of this.GetIndependantPreGraphs())
      new En(t.edges, new ki(this.transparentShapeSetter, null, null), this.interactiveEdgeRouter.VisibilityGraph, this.bundlingSettings, this.interactiveEdgeRouter.LoosePadding, this.interactiveEdgeRouter.TightHierarchy, this.interactiveEdgeRouter.LooseHierarchy, null, null, null).run();
  }
  GetPortCurve(t) {
    return this.nodeTree.FirstHitNodeWithPredicate(t.Location, (i, s) => g.PointRelativeToCurveLocation(i, s) !== F.Outside ? ot.Stop : ot.Continue).UserData;
  }
  // creates a set of pregraphs suitable for bundle routing
  GetIndependantPreGraphs() {
    const t = this.CreateInitialPregraphs();
    do {
      const e = t.length, i = { preGraphs: t };
      if (this.UniteConnectedPreGraphs(i), e <= t.length)
        break;
    } while (!0);
    return t;
  }
  UniteConnectedPreGraphs(t) {
    const e = Hr.GetIntersectionGraphOfPreGraphs(t.preGraphs);
    if (e == null)
      return;
    const i = Xs(e), s = new Array();
    for (const n of i) {
      let r = null;
      for (const a of n)
        r == null ? (r = t.preGraphs[a], s.push(r)) : r.AddGraph(t.preGraphs[a]);
    }
    t.preGraphs = s;
    for (const n of t.preGraphs)
      this.AddIntersectingNodes(n);
  }
  AddIntersectingNodes(t) {
    const e = t.boundingBox;
    for (const i of this.nodeTree.GetNodeItemsIntersectingRectangle(e))
      t.AddNodeBoundary(i);
  }
  static GetIntersectionGraphOfPreGraphs(t) {
    const e = Hr.EnumeratePairsOfIntersectedPreGraphs(t);
    return e.length ? fi(e, t.length) : null;
  }
  static EnumeratePairsOfIntersectedPreGraphs(t) {
    const e = Array.from(Array(t.length).keys()), i = Tr(e, (n) => t[n].boundingBox), s = new Array();
    return Qt(i, i, (n, r) => s.push(new U(n, r))), s;
  }
  CreateInitialPregraphs() {
    return this.multiEdges.map((t) => this.CreatePregraphFromSetOfEdgeGeometries(t));
  }
  CreatePregraphFromSetOfEdgeGeometries(t) {
    const e = /* @__PURE__ */ new Set(), i = t[0], s = this.GetPortCurve(i.sourcePort), n = s.boundingBox;
    e.add(s), e.add(i.targetPort.Curve), n.addRec(i.targetPort.Curve.boundingBox);
    const r = this.nodeTree.GetNodeItemsIntersectingRectangle(n);
    for (const a of r)
      e.add(a);
    return va.constructorStatic(t, e);
  }
}
class Ig {
  constructor() {
    this.triangles = /* @__PURE__ */ new Set();
  }
  setCdt(t) {
    this.cdt = t, this.cdt.SetInEdges();
    const e = /* @__PURE__ */ new Set();
    for (const i of t.GetTriangles())
      for (const s of i.Sites)
        s.Owner != null && e.add(s.Owner);
  }
  outsideOfObstacles(t) {
    var e;
    if (t == null)
      return !1;
    const i = (e = t.Sites.item0.Owner) !== null && e !== void 0 ? e : t.Sites.item1.Owner;
    return i === this.sourcePoly || i === this.targetPoly || !wg(t);
  }
  /** following "https://page.mi.fu-berlin.de/mulzer/notes/alggeo/polySP.pdf" */
  run(t) {
    if (this.triangles.clear(), this.poly = t, this.d = [], t.count <= 2 || this.cdt == null)
      return;
    this.sourcePoly = this.findPoly(t.start), this.targetPoly = this.findPoly(t.end), this.findChannelTriangles();
    let e = this.getPerimeterEdges();
    e = this.fillTheCollapedSites(e);
    const i = new gt([], [], Array.from(e).map((n) => ({ A: n.lowerSite.point, B: n.upperSite.point })));
    i.run();
    const s = this.getSleeve(this.findSourceTriangle(i));
    if (s == null) {
      console.log("failed to create sleeve");
      return;
    }
    if (s.length == 0) {
      this.poly = B.mkFromPoints([t.start, t.end]);
      return;
    }
    this.initDiagonals(s), this.refineFunnel();
  }
  /**A function that returns an array of all crossed triangles
   * by a line segment from start to end
   * assuming the initial triangle contains the start point*/
  getAllCrossedTriangles(t, e, i) {
    const s = [], n = [];
    let r = null;
    for (n.push(t); n.length > 0; ) {
      const a = n.pop();
      if (r == null && a.containsPoint(i) && (r = a), a.intersectsLine(e, i, 0)) {
        s.push(a);
        for (const l of a.Edges) {
          const h = l.GetOtherTriangle_T(a);
          h && !s.includes(h) && !n.includes(h) && n.push(h);
        }
      }
    }
    return { triangles: s, containsEnd: r };
  }
  findChannelTriangles() {
    let e = this.cdt.FindSite(this.poly.start).Triangles().next().value;
    this.triangles.clear();
    for (let i = this.poly.startPoint; i.next != null; i = i.next) {
      const s = this.getAllCrossedTriangles(e, i.point, i.next.point);
      e = s.containsEnd;
      for (const n of s.triangles)
        this.outsideOfObstacles(n) && this.triangles.add(n);
    }
  }
  findPoly(t) {
    var e;
    const i = this.cdt.FindSite(t);
    for (const s of i.Edges)
      return (e = s.lowerSite.Owner) !== null && e !== void 0 ? e : s.upperSite.Owner;
  }
  /** Because of the floating point operations we might miss some triangles and get a polygon collapsing to a point somewhere inside of the polyline.
   * This point will correspond to a site adjacent to more than two edges from 'perimeter'.
   * We add to the polygon all the 'legal' triangles adjacent to this cite.
   */
  fillTheCollapedSites(t) {
    const e = /* @__PURE__ */ new Map();
    for (const n of t)
      s(n.lowerSite, n), s(n.upperSite, n);
    const i = [];
    for (const [n, r] of e)
      r.length > 2 && i.push(n);
    if (i.length == 0)
      return t;
    for (const n of i)
      for (const r of n.Triangles())
        this.outsideOfObstacles(r) && this.triangles.add(r);
    return this.getPerimeterEdges();
    function s(n, r) {
      let a = e.get(n);
      a == null && e.set(n, a = []), a.push(r);
    }
  }
  findSourceTriangle(t) {
    let e;
    for (const i of t.GetTriangles())
      if (i.containsPoint(this.poly.start)) {
        e = i;
        break;
      }
    return e;
  }
  // debugDraw(triangles: Tr[], perimEdges: Set<Ed>, poly: Polyline, originalPoly: Polyline, strangeObs: ICurve[] = [], ls: ICurve = null) {
  //   const dc = []
  //   if (ls) {
  //     dc.push(DebugCurve.mkDebugCurveTWCI(255, 5, 'PapayaWhip', ls))
  //   }
  //   const box = this.poly.boundingBox.clone()
  //   box.addRec(this.sourcePoly.boundingBox)
  //   box.addRec(this.targetPoly.boundingBox)
  //   for (const t of triangles) {
  //     // if (t.BoundingBox().intersects(box) == false) continue
  //     for (const e of t.Edges) {
  //       dc.push(
  //         DebugCurve.mkDebugCurveTWCI(
  //           e.constrained ? 150 : 100,
  //           e.constrained ? 1.5 : 1,
  //           e.constrained ? 'DarkSeaGreen' : 'Cyan',
  //           LineSegment.mkPP(e.upperSite.point, e.lowerSite.point),
  //         ),
  //       )
  //     }
  //   }
  //   if (perimEdges) {
  //     for (const e of perimEdges) {
  //       dc.push(DebugCurve.mkDebugCurveTWCI(200, 2.5, 'Blue', LineSegment.mkPP(e.lowerSite.point, e.upperSite.point)))
  //     }
  //   }
  //   if (poly) dc.push(DebugCurve.mkDebugCurveTWCI(200, 1, 'Green', poly))
  //   for (const strangeOb of strangeObs) {
  //     dc.push(DebugCurve.mkDebugCurveTWCI(200, 3, 'Pink', strangeOb))
  //   }
  //   if (originalPoly) dc.push(DebugCurve.mkDebugCurveTWCI(200, 1, 'Brown', originalPoly))
  //   dc.push(DebugCurve.mkDebugCurveTWCI(200, 0.5, 'Violet', this.sourcePoly))
  //   dc.push(DebugCurve.mkDebugCurveTWCI(200, 0.5, 'Magenta', this.targetPoly))
  //   writeDebugCurves('./tmp/poly' + ++drawCount + '.svg', dc)
  // }
  refineFunnel() {
    const t = [];
    let e = this.poly.start;
    const i = { point: e }, s = { point: e };
    let n = { point: this.d[0].left, prev: i }, r = { point: this.d[0].right, prev: s };
    i.next = n, s.next = r;
    let a;
    for (let I = 1; I < this.d.length; I++)
      h(I, this.d);
    this.d.push({ right: this.poly.end, left: n.point }), h(this.d.length - 1, this.d);
    const l = B.mkFromPoints(t);
    for (let I = s; I != null; I = I.next)
      l.addPoint(I.point);
    this.poly = l;
    function h(I, x) {
      if (x[I - 1].left !== x[I].left) {
        a = x[I].left;
        let G = n;
        for (; !(C(G) || f(G)); G = G.prev)
          ;
        C(G) ? P() : N(G);
      } else {
        a = x[I].right;
        let G = r;
        for (; !(C(G) || p(G)); G = G.prev)
          ;
        C(G) ? y() : E(G);
      }
    }
    function c(I) {
      return I.next == null ? !0 : u.pointToTheLeftOfLineOrOnLine(a, I.point, I.next.point);
    }
    function d(I) {
      return I.next == null ? !0 : u.pointToTheRightOfLineOrOnLine(a, I.point, I.next.point);
    }
    function f(I) {
      return u.pointToTheLeftOfLine(a, I.prev.point, I.point);
    }
    function p(I) {
      return u.pointToTheRightOfLine(a, I.prev.point, I.point);
    }
    function P() {
      let I = s;
      for (; !c(I); )
        I = I.next;
      if (!C(I)) {
        let x = s;
        for (; !x.point.equal(I.point); x = x.next)
          t.push(x.point);
        s.point = x.point, s.next = x.next, e = x.point, r.point.equal(s.point) && (r.prev = r.next = null);
      }
      i.point = e, n.point = a, n.prev = i, i.next = n;
    }
    function y() {
      let I = i;
      for (; !d(I); )
        I = I.next;
      if (!C(I)) {
        let x = i;
        for (; !x.point.equal(I.point); x = x.next)
          t.push(x.point);
        i.point = x.point, i.next = x.next, e = x.point, n.point.equal(i.point) && (n.prev = i.next = null);
      }
      s.point = e, r.point = a, r.prev = s, s.next = r;
    }
    function C(I) {
      return I.point == e;
    }
    function E(I) {
      I != r ? (r.point = a, r.prev = I, I.next = r) : (r = { point: a, prev: I }, I.next = r);
    }
    function N(I) {
      I != n ? (n.point = a, n.prev = I, I.next = n) : (n = { point: a, prev: I }, I.next = n);
    }
  }
  initDiagonals(t) {
    for (const e of t) {
      const i = e.edge, s = e.source.OppositeSite(i);
      u.getTriangleOrientation(s.point, i.lowerSite.point, i.upperSite.point) == L.Counterclockwise ? this.d.push({ left: i.upperSite.point, right: i.lowerSite.point }) : this.d.push({ right: i.upperSite.point, left: i.lowerSite.point });
    }
  }
  getSleeve(t) {
    const e = new We.Queue();
    e.enqueue(t);
    const i = /* @__PURE__ */ new Map();
    for (i.set(t, void 0); e.length > 0; ) {
      const s = e.dequeue(), n = i.get(s);
      if (s.containsPoint(this.poly.end))
        return this.recoverPath(t, i, s);
      for (const r of s.Edges) {
        if (r.constrained || n !== void 0 && r === n)
          continue;
        const a = r.GetOtherTriangle_T(s);
        a != null && (i.has(a) || (i.set(a, r), e.enqueue(a)));
      }
    }
  }
  recoverPath(t, e, i) {
    const s = [];
    for (let n = i; n != t && n !== t; ) {
      const r = e.get(n);
      n = r.GetOtherTriangle_T(n), s.push({ source: n, edge: r });
    }
    return s.reverse();
  }
  getPerimeterEdges() {
    const t = /* @__PURE__ */ new Set();
    for (const e of this.triangles)
      for (const i of e.Edges)
        this.triangles.has(i.GetOtherTriangle_T(e)) || t.add(i);
    return t;
  }
}
function wg(o) {
  return o.Sites.item0.Owner == null || o.Sites.item1.Owner == null || o.Sites.item2.Owner == null ? !0 : o.Sites.item0.Owner == o.Sites.item1.Owner && o.Sites.item0.Owner == o.Sites.item2.Owner;
}
class it extends lt {
  get ContinueOnOverlaps() {
    return this.continueOnOverlaps;
  }
  set ContinueOnOverlaps(t) {
    this.continueOnOverlaps = t;
  }
  get LoosePadding() {
    return this.loosePadding;
  }
  set LoosePadding(t) {
    this.loosePadding = t;
  }
  get MultiEdgesSeparation() {
    return this.multiEdgesSeparation;
  }
  set MultiEdgesSeparation(t) {
    this.multiEdgesSeparation = t;
  }
  static mk2(t, e) {
    return it.mk5(t, e.Padding, e.PolylinePadding, e.ConeAngle, e.bundlingSettings);
  }
  static mk4(t, e, i, s) {
    return new it(t, Array.from(t.deepEdges), e, i, s, null);
  }
  // Creates a spline group router for the given graph
  static mk5(t, e, i, s, n) {
    return new it(t, Array.from(t.deepEdges), e, i, s, n);
  }
  // Creates a spline group router for a given GeomGraph.
  constructor(t, e, i = 1, s = 2, n = 30 * (Math.PI / 180), r = null, a = null) {
    super(a), this.continueOnOverlaps = !0, this.shapesToTightLooseCouples = /* @__PURE__ */ new Map(), this.multiEdgesSeparation = 0.5, this.routeMultiEdgesAsBundles = !0, this.UsePolylineEndShortcutting = !0, this.UseInnerPolylingShortcutting = !0, this.AllowedShootingStraightLines = !0, this._overlapsDetected = !1, this.edges = e, this.BundlingSettings = r, this.geomGraph = t, this.LoosePadding = s, this.tightPadding = i, this.coneAngle = n, this.routeMultiEdgesAsBundles = e.length < 1e3 && t.deepNodeCount < 1e3;
  }
  static mk6(t, e, i, s, n, r) {
    const a = it.mk4(t, e, i, s), l = ze.GetShapes(n, r);
    return a.Initialize(l, s), a;
  }
  Initialize(t, e) {
    this.rootShapes = t.filter((i) => i.Parents == null || i.Parents.length === 0), this.coneAngle = e, this.coneAngle === 0 && (this.coneAngle = Math.PI / 6);
  }
  // Executes the algorithm.
  run() {
    if (this.edges.length == 0 || this.geomGraph.isEmpty())
      return;
    console.time("SplineRouter");
    const t = le.GetShapes(this.geomGraph, this.edges);
    this.BundlingSettings == null && this.geomGraph.layoutSettings && this.geomGraph.layoutSettings.commonSettings.edgeRoutingSettings && this.geomGraph.layoutSettings.commonSettings.edgeRoutingSettings.bundlingSettings && (this.BundlingSettings = this.geomGraph.layoutSettings.commonSettings.edgeRoutingSettings.bundlingSettings), this.Initialize(t, this.coneAngle), this.GetOrCreateRoot(), this.RouteOnRoot(), this.RemoveRoot(), console.timeEnd("SplineRouter");
  }
  /** Uses the existing routes and optimizing them only to avoid 'activeNodes'.   */
  rerouteOnSubsetOfNodes(t) {
    this.RouteMultiEdgesAsBundles = !1, this.edges = Array.from(this.geomGraph.deepEdges).filter((i) => cr(i.edge, t));
    const e = le.GetShapes(this.geomGraph, this.edges);
    this.rootShapes = e.filter((i) => i.Parents == null || i.Parents.length === 0), this.GetOrCreateRoot(), this.CalculateShapeToBoundaries(this.root), this.calcLooseShapesToNodes(), this.CalculatePortsToShapes(), this.rerouteOnActiveNodes(t), this.RemoveRoot();
  }
  calcLooseShapesToNodes() {
    if (this.loosePolylinesToNodes = /* @__PURE__ */ new Map(), !this.OverlapsDetected) {
      for (const [i, s] of this.shapesToTightLooseCouples)
        this.loosePolylinesToNodes.set(s.LooseShape.BoundaryCurve, /* @__PURE__ */ new Set([i.node.node]));
      return;
    }
    const t = Tr(this.geomGraph.nodesBreadthFirst, (i) => i.boundingBox), e = this.GetLooseHierarchy();
    ae(e, t, (i, s) => {
      if (g.CurveIsInsideOther(s.boundaryCurve, i)) {
        let n = this.loosePolylinesToNodes.get(i);
        for (const r of s.getAncestors())
          if (!(r instanceof Rt && r.parent == null) && r.boundaryCurve != null && g.CurveIsInsideOther(r.boundaryCurve, i))
            return;
        n == null && this.loosePolylinesToNodes.set(i, n = /* @__PURE__ */ new Set()), n.add(s.node);
      }
    });
  }
  RouteOnRoot() {
    eo(0), this.CalculatePortsToShapes(), this.CalculatePortsToEnterableShapes(), this.CalculateShapeToBoundaries(this.root), !(this.OverlapsDetected && !this.ContinueOnOverlaps) && (this.BindLooseShapes(), this.SetLoosePolylinesForAnywherePorts(), this.CalculateVisibilityGraph(), this.RouteOnVisGraph());
  }
  CalculatePortsToEnterableShapes() {
    this.portsToEnterableShapes = /* @__PURE__ */ new Map();
    for (const [t, e] of this.portsToShapes) {
      const i = /* @__PURE__ */ new Set();
      it.EdgesAttachedToPortAvoidTheNode(t) || i.add(e), this.portsToEnterableShapes.set(t, i);
    }
    for (const t of this.rootShapes)
      for (const e of t.Descendants())
        for (const i of e.Ports) {
          const s = this.portsToEnterableShapes.get(i);
          ln(s, Array.from(e.Ancestors()).filter((n) => n.BoundaryCurve != null));
        }
  }
  static EdgesAttachedToPortAvoidTheNode(t) {
    return t instanceof Oe || t instanceof Ve;
  }
  SetLoosePolylinesForAnywherePorts() {
    for (const [t, e] of this.shapesToTightLooseCouples)
      for (const i of t.Ports) {
        if (i instanceof ee) {
          const n = i;
          n.LoosePolyline = e.LooseShape.BoundaryCurve;
        }
        if (i instanceof Ve) {
          const n = i;
          n.LoosePolyline = e.LooseShape.BoundaryCurve;
        }
      }
  }
  BindLooseShapes() {
    this.looseRoot = new js();
    for (const t of this.root.Children) {
      const e = this.shapesToTightLooseCouples.get(t).LooseShape;
      this.BindLooseShapesUnderShape(t), this.looseRoot.AddChild(e);
    }
  }
  BindLooseShapesUnderShape(t) {
    const e = this.shapesToTightLooseCouples.get(t).LooseShape;
    for (const i of t.Children) {
      const s = this.shapesToTightLooseCouples.get(i).LooseShape;
      e.AddChild(s), this.BindLooseShapesUnderShape(i);
    }
  }
  CalculateShapeToBoundaries(t) {
    if (this.ProgressStep(), t.Children.length === 0)
      return;
    for (const i of t.Children)
      this.CalculateShapeToBoundaries(i);
    const e = Number.POSITIVE_INFINITY;
    this.obstacleCalculator = new fa(t, this.tightPadding, Math.min(this.AdjustedLoosePadding, e), this.shapesToTightLooseCouples), this.obstacleCalculator.Calculate(0.01), this.OverlapsDetected || (this.OverlapsDetected = this.obstacleCalculator.OverlapsDetected);
  }
  get OverlapsDetected() {
    return this._overlapsDetected;
  }
  set OverlapsDetected(t) {
    this._overlapsDetected = t;
  }
  get AdjustedLoosePadding() {
    return this.BundlingSettings == null ? this.LoosePadding : this.LoosePadding * En.SuperLoosePaddingCoefficient;
  }
  GroupEdgesByPassport() {
    const t = new Array();
    for (const e of this.edges) {
      const i = this.EdgePassport(e);
      let s = t.find((n) => Or(n.passport, i));
      s || (s = { passport: i, edges: [] }, t.push(s)), s.edges.push(e);
    }
    return t;
  }
  RouteOnVisGraph() {
    if (this.ancestorSets = it.GetAncestorSetsMap(Array.from(this.root.Descendants())), this.BundlingSettings == null) {
      const t = this.GroupEdgesByPassport();
      for (let e = 0; e < t.length; e++) {
        const i = t[e], s = i.passport, n = this.GetObstaclesFromPassport(s), r = this.CreateInteractiveEdgeRouter(Array.from(n));
        this.RouteEdgesWithTheSamePassport(i, r, n);
      }
    } else
      this.RouteBundles();
  }
  rerouteOnActiveNodes(t) {
    if (this.ancestorSets = it.GetAncestorSetsMap(Array.from(this.root.Descendants())), this.BundlingSettings == null)
      for (const e of this.GroupEdgesByPassport()) {
        const i = e.passport, s = this.GetObstaclesFromPassport(i), n = /* @__PURE__ */ new Set();
        for (const a of s) {
          const l = this.LooseShapeOfOriginalShape(a);
          for (const h of this.loosePolylinesToNodes.get(l.BoundaryCurve))
            t.has(h) && n.add(a);
        }
        const r = this.CreateInteractiveEdgeRouter(Array.from(n));
        this.rerouteEdgesWithTheSamePassportActiveNodes(e, r, n, t);
      }
    else
      this.RouteBundles();
  }
  getDebugCurvesFromEdgesAndCdt(t) {
    const e = Array.from(this.geomGraph.deepEdges).map((i) => i.curve).filter((i) => i != null).filter((i) => i.count > 5).map((i) => q.mkDebugCurveTWCI(200, 1, "Red", i));
    for (const i of t.PointsToSites.values())
      for (const s of i.Edges)
        e.push(q.mkDebugCurveTWCI(200, 0.5, s.constrained ? "Blue" : "Green", v.mkPP(s.lowerSite.point, s.upperSite.point)));
    return e;
  }
  RouteEdgesWithTheSamePassport(t, e, i) {
    const s = {
      regularEdges: [],
      multiEdges: []
    };
    try {
      const n = this.getCdtFromPassport(i);
      e.pathOptimizer.setCdt(n);
    } catch {
      e.pathOptimizer.setCdt(null);
    }
    if (this.RouteMultiEdgesAsBundles) {
      if (this.SplitOnRegularAndMultiedges(t.edges, s), s.regularEdges.length > 0)
        for (let n = 0; n < s.regularEdges.length; n++)
          this.routeEdge(e, s.regularEdges[n]);
      s.multiEdges != null && (this.ScaleDownLooseHierarchy(e, i), this.RouteMultiEdges(s.multiEdges, e, t.passport));
    } else
      for (let n = 0; n < t.edges.length; n++)
        this.routeEdge(e, t.edges[n]);
  }
  /** edgeToPolys maps edges to their original polyline routes */
  rerouteEdgesWithTheSamePassportActiveNodes(t, e, i, s) {
    const n = {
      regularEdges: [],
      multiEdges: []
    };
    try {
      const r = this.getCdtFromPassport(i);
      e.pathOptimizer.setCdt(r);
    } catch (r) {
      console.log(r), e.pathOptimizer.setCdt(null);
    }
    if (this.RouteMultiEdgesAsBundles) {
      if (this.SplitOnRegularAndMultiedges(t.edges, n), n.regularEdges.length > 0)
        for (let r = 0; r < n.regularEdges.length; r++) {
          const a = n.regularEdges[r];
          at.assert(cr(a.edge, s)), this.rerouteEdge(e, a);
        }
      n.multiEdges != null && (this.ScaleDownLooseHierarchy(e, i), this.RouteMultiEdges(n.multiEdges, e, t.passport));
    } else
      for (let r = 0; r < t.edges.length; r++) {
        const a = t.edges[r];
        cr(a.edge, s) && this.rerouteEdge(e, a);
      }
  }
  /** poly gives the polyline to reroute */
  rerouteEdge(t, e) {
    try {
      t.rerouteEdge(e), vt.trimSplineAndCalculateArrowheadsII(e, e.sourcePort.Curve, e.targetPort.Curve, e.curve, !1);
    } catch {
      console.log("failed");
    }
  }
  getCdtFromPassport(t) {
    const e = /* @__PURE__ */ new Set(), i = [], s = T.mkEmpty();
    for (const a of t) {
      const l = this.LoosePolyOfOriginalShape(a);
      if (l != null) {
        e.add(l);
        for (const h of a.Ports)
          i.push(h.Location);
        s.addRecSelf(l.boundingBox);
      }
    }
    s.pad(Math.max(s.diagonal / 4, 100));
    const n = Array.from(e);
    n.push(s.perimeter());
    const r = new gt(i, n, []);
    return r.run(), r;
  }
  // if set to true routes multi edges as ordered bundles
  get RouteMultiEdgesAsBundles() {
    return this.routeMultiEdgesAsBundles;
  }
  set RouteMultiEdgesAsBundles(t) {
    this.routeMultiEdgesAsBundles = t;
  }
  routeEdge(t, e) {
    const i = this.makeTransparentShapesOfEdgeAndGetTheShapes(e);
    this.ProgressStep(), this.RouteEdgeInternal(e, t), it.SetTransparency(i, !1);
  }
  ScaleDownLooseHierarchy(t, e) {
    const i = new Array();
    for (const s of e) {
      const n = this.shapesToTightLooseCouples.get(s);
      i.push(M.LoosePolylineWithFewCorners(
        n.TightPolyline,
        n.Distance / 1.1,
        // 1.1 is BundleRouter.SuperLoosePaddingCoefficient,
        0
      ));
    }
    t.LooseHierarchy = it.CreateLooseObstacleHierarachy(i), t.ClearActivePolygons(), t.AddActivePolygons(i.map((s) => new ue(s)));
  }
  RouteMultiEdges(t, e, i) {
    const s = [];
    for (const a of i)
      for (const l of a.Children)
        s.push(l.BoundaryCurve);
    const n = new kt();
    n.InkImportance = 1e-5, n.EdgeSeparation = this.MultiEdgesSeparation, new Hr(t, e, s, n, (a) => this.makeTransparentShapesOfEdgeAndGetTheShapes(a)).run();
  }
  SplitOnRegularAndMultiedges(t, e) {
    const i = new Nn();
    for (const s of t)
      it.IsEdgeToParent(s) ? e.regularEdges.push(s) : it.RegisterInPortLocationsToEdges(s, i);
    e.multiEdges = null;
    for (const s of i.values())
      s.length === 1 || this.OverlapsDetected ? Vi(e.regularEdges, s) : (e.multiEdges == null && (e.multiEdges = new Array()), e.multiEdges.push(s));
  }
  static RegisterInPortLocationsToEdges(t, e) {
    let i;
    const s = new ne(t.sourcePort.Location, t.targetPort.Location);
    i = e.get(s), i || (i = new Array(), e.set(s, i)), i.push(t);
  }
  static IsEdgeToParent(t) {
    return t.sourcePort instanceof ee || t.targetPort instanceof ee;
  }
  CreateInteractiveEdgeRouter(t) {
    const e = new Set(t.map((s) => this.shapesToTightLooseCouples.get(s).LooseShape.BoundaryCurve)), i = new tt(this.cancelToken);
    return i.pathOptimizer = new Ig(), i.ObstacleCalculator = new M(t.map((s) => s.BoundaryCurve), this.tightPadding, this.loosePadding, !1), i.VisibilityGraph = this.visGraph, i.TightHierarchy = this.CreateTightObstacleHierarachy(t), i.LooseHierarchy = it.CreateLooseObstacleHierarachy(Array.from(e)), i.UseSpanner = !0, i.LookForRoundedVertices = !0, i.TightPadding = this.tightPadding, i.LoosePadding = this.LoosePadding, i.UseEdgeLengthMultiplier = this.UseEdgeLengthMultiplier, i.UsePolylineEndShortcutting = this.UsePolylineEndShortcutting, i.UseInnerPolylingShortcutting = this.UseInnerPolylingShortcutting, i.AllowedShootingStraightLines = this.AllowedShootingStraightLines, i.AddActivePolygons(Array.from(e).map((s) => new ue(s))), i;
  }
  GetObstaclesFromPassport(t) {
    if (t.size === 0)
      return new Set(this.root.Children);
    const e = this.GetCommonAncestorsAbovePassport(t), i = this.GetAllAncestors(t), s = /* @__PURE__ */ new Set();
    for (const a of t)
      for (const l of a.Children)
        i.has(l) || s.add(l);
    const n = zs(new Set(t), s), r = new We.Queue();
    for (const a of t)
      e.has(a) || r.enqueue(a);
    for (; r.length > 0; ) {
      const a = r.dequeue();
      for (const l of a.Parents) {
        for (const h of l.Children)
          i.has(h) || s.add(h);
        !e.has(l) && !n.has(l) && (r.enqueue(l), n.add(l));
      }
    }
    return s;
  }
  GetAllAncestors(t) {
    if (t.size === 0)
      return /* @__PURE__ */ new Set();
    let e = new Set(t);
    for (const i of t)
      e = zs(e, this.ancestorSets.get(i));
    return e;
  }
  GetCommonAncestorsAbovePassport(t) {
    if (t.size === 0)
      return /* @__PURE__ */ new Set();
    const e = Array.from(t);
    let i = this.ancestorSets.get(e[0]);
    for (let s = 1; s < e.length; s++) {
      const n = e[s];
      i = Wi(i, this.ancestorSets.get(n));
    }
    return i;
  }
  RouteBundles() {
    this.ScaleLooseShapesDown(), this.CalculateEdgeEnterablePolylines();
    const t = this.GetLooseHierarchy(), e = Uh(t), i = new ki((n) => this.makeTransparentShapesOfEdgeAndGetTheShapes(n), e, this.FindCdtGates(e));
    new En(this.edges, i, this.visGraph, this.BundlingSettings, this.LoosePadding, this.GetTightHierarchy(), t, this.enterableLoose, this.enterableTight, (n) => this.LoosePolyOfOriginalShape(this.portsToShapes.get(n))).run();
  }
  CreateTheMapToParentLooseShapes(t, e) {
    for (const i of t.Children) {
      const n = this.shapesToTightLooseCouples.get(i).LooseShape.BoundaryCurve;
      e.set(n, t), this.CreateTheMapToParentLooseShapes(i, e);
    }
  }
  FindCdtGates(t) {
    const e = /* @__PURE__ */ new Map();
    this.CreateTheMapToParentLooseShapes(this.root, e);
    const i = /* @__PURE__ */ new Set();
    for (const s of t.PointsToSites.values())
      for (const n of s.Edges) {
        if (n.CwTriangle == null && n.CcwTriangle == null)
          continue;
        const r = s.Owner, a = n.lowerSite.Owner;
        if (r === a)
          continue;
        const l = e.get(r);
        if (l) {
          const h = e.get(a);
          l === h && i.add(n);
        }
      }
    return i;
  }
  CalculateEdgeEnterablePolylines() {
    this.enterableLoose = /* @__PURE__ */ new Map(), this.enterableTight = /* @__PURE__ */ new Map();
    for (const t of this.edges) {
      const e = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set();
      this.GetEdgeEnterablePolylines(t, e, i), this.enterableLoose.set(t, e), this.enterableTight.set(t, i);
    }
  }
  GetEdgeEnterablePolylines(t, e, i) {
    const s = this.portsToShapes.get(t.sourcePort), n = this.portsToShapes.get(t.targetPort);
    s !== this.root && this.GetEnterablesForShape(s, e, i), n !== this.root && this.GetEnterablesForShape(n, e, i);
  }
  GetEnterablesForShape(t, e, i) {
    for (const s of this.ancestorSets.get(t)) {
      const n = this.LoosePolyOfOriginalShape(s);
      n && e.add(n);
      const r = this.TightPolyOfOriginalShape(s);
      r && i.add(r);
    }
  }
  GetTightHierarchy() {
    return wt(Array.from(this.shapesToTightLooseCouples.values()).map((t) => Nt(t.TightPolyline, t.TightPolyline.boundingBox)));
  }
  GetLooseHierarchy() {
    const t = /* @__PURE__ */ new Set();
    for (const e of this.shapesToTightLooseCouples.values())
      t.add(e.LooseShape.BoundaryCurve);
    return wt(Array.from(t).map((e) => Nt(e, e.boundingBox)));
  }
  ScaleLooseShapesDown() {
    for (const [, t] of this.shapesToTightLooseCouples)
      t.LooseShape.BoundaryCurve = M.LoosePolylineWithFewCorners(t.TightPolyline, t.Distance / En.SuperLoosePaddingCoefficient, 0);
  }
  /**
   * The set of shapes where the edge source and target ports shapes are citizens: the shapes who's interior the edge can cross
   *   In the simple case it is the union of the target port shape parents and the sourceport shape parents.
   *   When one end shape contains another, the passport is the set consisting of the end shape and all other shape parents.
   */
  EdgePassport(t) {
    const e = /* @__PURE__ */ new Set(), i = this.portsToShapes.get(t.sourcePort), s = this.portsToShapes.get(t.targetPort);
    return this.IsAncestor(i, s) ? (ln(e, s.Parents), e.add(i), e) : this.IsAncestor(s, i) ? (ln(e, i.Parents), e.add(s), e) : (i !== this.looseRoot && ln(e, i.Parents), s !== this.looseRoot && ln(e, s.Parents), e);
  }
  *AllPorts() {
    for (const t of this.edges)
      yield t.sourcePort, yield t.targetPort;
  }
  CalculatePortsToShapes() {
    this.portsToShapes = /* @__PURE__ */ new Map();
    for (const t of this.root.Descendants())
      for (const e of t.Ports)
        this.portsToShapes.set(e, t);
    for (const t of this.AllPorts())
      this.portsToShapes.has(t) || (this.root.Ports.add(t), this.portsToShapes.set(t, this.root));
  }
  RouteEdgeInternal(t, e) {
    const i = new Array();
    t.sourcePort instanceof ee || Vi(i, this.AddVisibilityEdgesFromPort(t.sourcePort)), t.targetPort instanceof ee || Vi(i, this.AddVisibilityEdgesFromPort(t.targetPort));
    const s = { smoothedPolyline: null };
    if (u.closeDistEps(t.sourcePort.Location, t.targetPort.Location) ? t.curve = Zt.RouteSelfEdge(t.sourcePort.Curve, Math.max(this.LoosePadding * 2, t.GetMaxArrowheadLength()), s) : t.curve = e.RouteSplineFromPortToPortWhenTheWholeGraphIsReady(t.sourcePort, t.targetPort, !0, s), t.smoothedPolyline = null, t.curve == null)
      throw new Error();
    for (const n of i)
      Et.RemoveEdge(n);
    vt.trimSplineAndCalculateArrowheadsII(t, t.sourcePort.Curve, t.targetPort.Curve, t.curve, !1);
  }
  *AddVisibilityEdgesFromPort(t) {
    let e, i;
    if (t instanceof Oe || !(e = this.portsToShapes.get(t)) || !(i = this.shapesToTightLooseCouples.get(e)))
      return;
    const s = i.LooseShape;
    for (const n of s.BoundaryCurve)
      this.visGraph.FindEdgePP(t.Location, n) == null && (yield this.visGraph.AddEdgePP(t.Location, n));
  }
  makeTransparentShapesOfEdgeAndGetTheShapes(t) {
    const e = this.portsToShapes.get(t.sourcePort), i = this.portsToShapes.get(t.targetPort), s = new Array();
    for (const n of this.GetTransparentShapes(t.sourcePort, t.targetPort, e, i))
      n != null && s.push(this.LooseShapeOfOriginalShape(n));
    for (const n of this.portsToEnterableShapes.get(t.sourcePort))
      s.push(this.LooseShapeOfOriginalShape(n));
    for (const n of this.portsToEnterableShapes.get(t.targetPort))
      s.push(this.LooseShapeOfOriginalShape(n));
    return it.SetTransparency(s, !0), s;
  }
  LooseShapeOfOriginalShape(t) {
    return t === this.root ? this.looseRoot : this.shapesToTightLooseCouples.get(t).LooseShape;
  }
  LoosePolyOfOriginalShape(t) {
    return this.LooseShapeOfOriginalShape(t).BoundaryCurve;
  }
  TightPolyOfOriginalShape(t) {
    return t === this.root ? null : this.shapesToTightLooseCouples.get(t).TightPolyline;
  }
  //    static GetEdgeColor(e: VisibilityEdge, sourcePort: Port, targetPort: Port): string {
  //  if (((sourcePort == null )
  //    || (targetPort == null ))) {
  //    return "green";
  //  }
  //  if ((closeDistEps(e.SourcePoint, sourcePort.Location)
  //    || (closeDistEps(e.SourcePoint, targetPort.Location)
  //      || (closeDistEps(e.TargetPoint, sourcePort.Location) || closeDistEps(e.TargetPoint, targetPort.Location))))) {
  //    return "lightgreen";
  //  }
  //  return "green";
  //  // TODO: Warning!!!, inline IF is not supported ?
  //  ((e.IsPassable == null )
  //    || e.IsPassable());
  //  "red";
  // }
  *GetTransparentShapes(t, e, i, s) {
    for (const n of this.ancestorSets.get(i))
      yield n;
    for (const n of this.ancestorSets.get(s))
      yield n;
    it.EdgesAttachedToPortAvoidTheNode(t) || (yield i), it.EdgesAttachedToPortAvoidTheNode(e) || (yield s);
  }
  static SetTransparency(t, e) {
    for (const i of t)
      i.IsTransparent = e;
  }
  IsAncestor(t, e) {
    let i;
    return e != null && (i = this.ancestorSets.get(e)) != null && i.has(t);
  }
  static CreateLooseObstacleHierarachy(t) {
    return wt(t.map((e) => Nt(e, e.boundingBox)));
  }
  CreateTightObstacleHierarachy(t) {
    const e = t.map((i) => this.shapesToTightLooseCouples.get(i).TightPolyline);
    return wt(e.map((i) => Nt(i, i.boundingBox)));
  }
  CalculateVisibilityGraph() {
    const t = this.LineSweeperPorts != null ? xt.mk(this.LineSweeperPorts) : new xt();
    this.ProcessHookAnyWherePorts(t), this.portRTree = Pn(Array.from(t.values()).map((e) => [T.rectangleOnPoint(e), e])), this.visGraph = new Et(), this.FillVisibilityGraphUnderShape(this.root);
  }
  ProcessHookAnyWherePorts(t) {
    for (const e of this.edges)
      e.sourcePort instanceof ee || e.sourcePort instanceof Ve || t.add(e.sourcePort.Location), e.targetPort instanceof ee || e.targetPort instanceof Ve || t.add(e.targetPort.Location);
  }
  // this function might change the shape's loose polylines by inserting new points
  FillVisibilityGraphUnderShape(t) {
    const e = t.Children;
    for (let c = 0; c < e.length; c++) {
      const d = e[c];
      this.FillVisibilityGraphUnderShape(d);
    }
    const i = this.shapesToTightLooseCouples.get(t), s = i ? i.LooseShape.BoundaryCurve : null, n = i ? i.LooseShape : this.looseRoot, r = new Set(n.Children.map((c) => c.BoundaryCurve)), a = this.RemoveInsidePortsAndSplitBoundaryIfNeeded(s);
    let l = new Et(), h = qs.mk([], l, this.coneAngle, a, s);
    h.run(), l = new Et(), h = qs.mk(Array.from(r), l, this.coneAngle, a, s), h.run(), this.ProgressStep();
    for (const c of l.Edges)
      this.TryToCreateNewEdgeAndSetIsPassable(c, n);
    this.AddBoundaryEdgesToVisGraph(s);
  }
  // #if TEST_MSAGL
  //     static internal void ShowVisGraph(VisibilityGraph tmpVisGraph, Iterable<Polyline> obstacles, Iterable<ICurve> greenCurves, Iterable<ICurve> redCurves) {
  //       var l = new Array<DebugCurve>(tmpVisGraph.Edges.Select(e => new DebugCurve(100, 1,
  //           e.IsPassable != null && e.IsPassable() ? "green" : "black"
  //           , new LineSegment(e.SourcePoint, e.TargetPoint))));
  //       if (obstacles != null)
  //         l.AddRange(obstacles.Select(p => new DebugCurve(100, 1, "brown", p)));
  //       if (greenCurves != null)
  //         l.AddRange(greenCurves.Select(p => new DebugCurve(100, 10, "navy", p)));
  //       if (redCurves != null)
  //         l.AddRange(redCurves.Select(p => new DebugCurve(100, 10, "red", p)));
  //       LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(l);
  //     }
  // #endif
  TryToCreateNewEdgeAndSetIsPassable(t, e) {
    let i = this.visGraph.FindEdgePP(t.SourcePoint, t.TargetPoint);
    i == null && (i = this.visGraph.AddEdgePP(t.SourcePoint, t.TargetPoint), e != null && (i.IsPassable = () => e.IsTransparent));
  }
  AddBoundaryEdgesToVisGraph(t) {
    if (t == null)
      return;
    let e;
    for (let i = t.startPoint; e = i.nextOnPolyline, this.visGraph.AddEdgePP(i.point, e.point), e !== t.startPoint; i = e)
      ;
  }
  /** this run will split the polyline enough to route later from the inner ports */
  RemoveInsidePortsAndSplitBoundaryIfNeeded(t) {
    const e = new xt();
    if (t == null) {
      for (const n of this.portRTree.GetAllLeaves())
        e.add(n);
      return this.portRTree.clear(), e;
    }
    const i = t.boundingBox, s = this.portRTree.GetAllIntersecting(i);
    for (const n of s)
      switch (g.PointRelativeToCurveLocation(n, t)) {
        case F.Inside:
          e.add(n), this.portRTree.Remove(T.rectangleOnPoint(n), n);
          break;
        case F.Boundary:
          this.portRTree.Remove(T.rectangleOnPoint(n), n);
          const r = it.FindPointOnPolylineToInsertAfter(t, n);
          if (r != null)
            Ut.InsertPointIntoPolylineAfter(t, r, n);
          else
            throw new Error();
          break;
      }
    return e;
  }
  static FindPointOnPolylineToInsertAfter(t, e) {
    for (let i = t.startPoint; ; ) {
      const s = i.nextOnPolyline;
      if (u.closeDistEps(e, i.point) || u.closeDistEps(e, s.point))
        return null;
      const n = u.distToLineSegment(e, i.point, s.point).dist;
      if (D(n, 0))
        return i;
      if (i = s, i === t.startPoint)
        throw new Error();
    }
  }
  // creates a root; a shape with BoundaryCurve set to null
  GetOrCreateRoot() {
    if (this.rootShapes.length === 1) {
      const t = this.rootShapes[0];
      if (t.BoundaryCurve == null) {
        this.root = t;
        return;
      }
    }
    this.rootWasCreated = !0, this.root = new js(null);
    for (const t of this.rootShapes)
      this.root.AddChild(t);
  }
  RemoveRoot() {
    if (this.rootWasCreated) {
      for (const t of this.rootShapes)
        t.RemoveParent(this.root);
      this.root = null, this.rootWasCreated = !1;
    }
  }
  // #if TEST_MSAGL
  //     // ReSharper disable UnusedMember.Local
  //     static void Show(
  //         Iterable<GeomEdge> edgeGeometries, Iterable<Shape> listOfShapes) {
  //       // ReSharper restore UnusedMember.Local
  //       var r = new Random(1);
  //       LayoutAlgorithmSettings.ShowDebugCurvesEnumeration(
  //           listOfShapes.Select(s => s.BoundaryCurve).Select(
  //               c => new DebugCurve(50, 1, DebugCurve.Colors[r.Next(DebugCurve.Colors.Length - 1)], c)).Concat(
  //                   edgeGeometries.Select(e => new DebugCurve(100, 1, "red", e.Curve))));
  //     }
  // #endif
  static GetAncestorSetsMap(t) {
    const e = /* @__PURE__ */ new Map();
    for (const i of t.filter((s) => !e.has(s)))
      e.set(i, it.GetAncestorSet(i, e));
    return e;
  }
  static GetAncestorSet(t, e) {
    const i = new Set(t.Parents);
    for (const s of t.Parents) {
      let n = e.get(s);
      n || e.set(s, n = it.GetAncestorSet(s, e));
      for (const r of n)
        i.add(r);
    }
    return i;
  }
  static CreatePortsIfNeeded(t) {
    for (const e of t) {
      if (e.sourcePort == null) {
        const i = e;
        new Ki(() => i.source.boundaryCurve, () => i.source.center, new u(0, 0));
      }
      if (e.targetPort == null) {
        const i = e;
        new Ki(() => i.target.boundaryCurve, () => i.target.center, new u(0, 0));
      }
    }
  }
}
function Eg(o, t, e) {
  const i = $h(o);
  new it(o, t, i.Padding, i.PolylinePadding, i.coneAngle, i.bundlingSettings, e).run();
}
class Gp {
  /** retrieves the data for a single tile(x-y-z) */
  getTileData(t, e, i) {
    const s = this.levels[i];
    return s ? s.get(t, e) : null;
  }
  /** retrieves all the tiles of z-th level */
  *getTilesOfLevel(t) {
    const e = this.levels[t];
    if (e != null)
      for (const [i, s] of e.keyValues())
        yield { x: i.x, y: i.y, data: s };
  }
  /** geomGraph  - the graph to work with.
   * The topLevelTileRect serves as the only tile of the top level.
   */
  constructor(t, e) {
    this.numberOfNodesOnLevel = [], this.nodeScales = [], this.tileCapacity = 5e3, this.levels = [], this.nodeIndexInSortedNodes = /* @__PURE__ */ new Map(), this.geomGraph = t, this.topLevelTileRect = e, this.tileSizes = [], this.tileSizes.push(e.size);
  }
  getMinTileSize() {
    let t = 0, e = 0, i = 0;
    for (const s of this.geomGraph.nodesBreadthFirst)
      s instanceof Rt || (i == 0 ? (t = s.width, e = s.height) : (t = (i * t + s.width) / (i + 1), e = (i * e + s.height) / (i + 1)), i++);
    return new Ai(t * 10, e * 10);
  }
  fillTheLowestLayer() {
    const t = new Ji(), e = new er(this.topLevelTileRect), i = e.arrowheads, s = e.labels;
    for (const r of this.geomGraph.graph.deepEdges)
      n(r);
    e.nodes = Array.from(this.geomGraph.nodesBreadthFirst), t.set(0, 0, e), this.levels.push(t);
    function n(r) {
      const a = Zt.getGeom(r), l = Zt.getGeom(r).curve;
      if (l instanceof g)
        for (const h of l.segs)
          e.addElement({ edge: r, curve: h, startPar: h.parStart, endPar: h.parEnd });
      else
        e.addElement({ edge: r, curve: l, startPar: l.parStart, endPar: l.parEnd });
      a.sourceArrowhead && i.push({ edge: a.edge, tip: a.sourceArrowhead.tipPosition, base: a.curve.start }), a.targetArrowhead && i.push({ edge: a.edge, tip: a.targetArrowhead.tipPosition, base: a.curve.end }), a.label && s.push(a.label);
    }
  }
  /**
   * Creates tilings for levels from 0 to z, including the level z.
   * The method does not necesserely creates all levels until z, but can exit earlier
   *  if all tiles either has size smaller or equal than this.minTileSize or have at most this.tileCapacityMin elements.
   * Returns the number of created levels.
   */
  buildUpToLevel(t) {
    if (this.fillTheLowestLayer(), this.minTileSize = this.getMinTileSize(), this.pageRank = Nd(this.geomGraph.graph, 0.85), !this.needToSubdivide())
      return 1;
    for (let i = 1; i <= t && !this.subdivideLevel(i); i++)
      ;
    this.sortedNodes = Array.from(this.pageRank.keys()).sort(this.compareByPagerank.bind(this));
    for (let i = 0; i < this.sortedNodes.length; i++)
      this.nodeIndexInSortedNodes.set(this.sortedNodes[i], i);
    for (let i = 0; i < this.levels.length - 1; i++)
      this.numberOfNodesOnLevel.push(this.filterOutEntities(this.levels[i], i));
    this.numberOfNodesOnLevel.push(this.sortedNodes.length);
    const e = new it(this.geomGraph, []);
    for (let i = this.levels.length - 2; i >= 0; i--) {
      const s = this.setOfNodesOnTheLevel(i);
      e.rerouteOnSubsetOfNodes(s), this.regenerateCurveClipsUpToLevel(i, s);
    }
    return this.calculateNodeRank(), this.levels.length;
  }
  // private makeSomeNodesVizible() {
  //   for (let levelIndex = 0; levelIndex < this.levels.length - 1; levelIndex++) {
  //     this.calculateNodeAdditionalScales(levelIndex)
  //   }
  // }
  // calculateNodeAdditionalScalesOnLevelZero() {
  //   const tree = new RTree()
  //   // we always get at least one intersection with the whole graph record
  //   tree.batchInsert([
  //     {
  //       x: this.geomGraph.left,
  //       y: this.geomGraph.bottom,
  //       width: this.geomGraph.width,
  //       height: this.geomGraph.height,
  //       data: {node: this.geomGraph.graph, nodeBB: this.geomGraph.boundingBox},
  //     },
  //   ]) // to init with the whole
  //   const scales = new Map<Node, number>()
  //   this.nodeScales.push(scales)
  //   // with this scale the node will be rendered at level[this.level.length -1]
  //   let scale = Math.pow(2, this.levels.length - 1)
  //   for (let j = 0; j < this.numberOfNodesOnLevel[0]; j++) {
  //     const n = this.sortedNodes[j]
  //     scale = this.findMaxScaleToNotIntersectTree(n, tree, scale)
  //     if (scale < 1.1) break // getting almost no enlargement
  //     scales.set(n, scale)
  //   }
  // }
  // findMaxScaleToNotIntersectTree(n: Node, tree: RTree, maxScale: number): number {
  //   const geomNode = GeomNode.getGeom(n)
  //   let nodeBB = geomNode.boundingBox
  //   // make sure that we are not rendering the node outside of  the the graph bounding box
  //   maxScale = Math.min(this.keepInsideGraphBoundingBox(nodeBB), maxScale)
  //   const ret = this.intersectWithTreeAndGetScale(tree, nodeBB, maxScale)
  //   // use the resulting bounding box and insert it to the tree
  //   nodeBB = geomNode.boundingBox.clone()
  //   nodeBB.scaleAroundCenter(ret)
  //   tree.insert({x: nodeBB.left, y: nodeBB.bottom, width: nodeBB.width, height: nodeBB.height, data: {node: n, nodeBB: nodeBB}})
  //   return ret
  // }
  /** returns the maximal scale keeping nodeBB inside of the graph bounding box */
  keepInsideGraphBoundingBox(t) {
    const e = this.geomGraph.boundingBox, i = t.width / 2, s = t.height / 2;
    return Math.min(
      // left stays inside
      (t.center.x - e.left) / i,
      // top stays inside
      (e.top - t.center.y) / s,
      // right stays inside
      (e.right - t.center.x) / i,
      //bottom stays inside
      (t.center.y - e.bottom) / s
    );
  }
  // intersectWithTreeAndGetScale(tree: RTree, nodeBB: Rectangle, maxScale: number): number {
  //   const xx = tree.search({x: nodeBB.left, y: nodeBB.bottom, width: nodeBB.width, height: nodeBB.height}) as {
  //     node: Node
  //     nodeBB: Rectangle
  //   }[]
  //   if (xx.length == 1) return maxScale // there is always one intersection with the whole graph
  //   let scale = maxScale
  //   for (const x of xx) {
  //     if (x.node == this.geomGraph.graph) continue
  //     scale = this.diminishScaleToAvoidTree(x.node, x.nodeBB, nodeBB)
  //     if (scale == 1) return scale // no separation
  //   }
  //   return scale
  // }
  diminishScaleToAvoidTree(t, e, i) {
    at.assert(e.intersects(i));
    let s;
    const n = i.center.x, r = i.center.y, a = i.height / 2, l = i.width / 2;
    if (n < e.left)
      s = (e.left - n) / a;
    else if (n > e.right)
      s = (n - e.right) / a;
    else
      return 1;
    let h;
    if (r < e.bottom)
      h = (e.bottom - r) / l;
    else if (r > e.top)
      h = (r - e.top) / l;
    else
      return s;
    return Math.min(s, h);
  }
  // calculateNodeAdditionalScales(levelIndex: number) {
  //   const tree = new RTree()
  //   // we always get at least one intersection with the whole graph record
  //   tree.batchInsert([
  //     {
  //       x: this.geomGraph.left,
  //       y: this.geomGraph.bottom,
  //       width: this.geomGraph.width,
  //       height: this.geomGraph.height,
  //       data: {node: this.geomGraph.graph, nodeBB: this.geomGraph.boundingBox},
  //     },
  //   ]) // to init with the whole graph bounding box
  //   const scales = new Map<Node, number>()
  //   this.nodeScales.push(scales)
  //   let scale = Math.pow(2, this.levels.length - 1 - levelIndex)
  //   for (let j = 0; j < this.numberOfNodesOnLevel[levelIndex]; j++) {
  //     const n = this.sortedNodes[j]
  //     scale = this.findMaxScaleToNotIntersectTree(n, tree, scale)
  //     if (scale <= 1) break
  //     scales.set(n, scale)
  //   }
  // }
  // findMaxScale(n: Node, levelIndex: number, tree: RTree, maxScale: number): number {
  //   const geomNode = GeomNode.getGeom(n)
  //   let boundingBox = geomNode.boundingBox.clone()
  //   boundingBox.scaleAroundCenter(maxScale)
  //   let ret = maxScale
  //   while (ret > 1 && treeIntersectsRect(tree, boundingBox)) {
  //     ret /= 2
  //     if (ret < 1) ret = 1
  //   }
  //   boundingBox = geomNode.boundingBox.clone()
  //   boundingBox.scaleAroundCenter(ret)
  //   tree.insert({x: boundingBox.left, y: boundingBox.bottom, width: boundingBox.width, height: boundingBox.height})
  //   return ret
  // }
  needToSubdivide() {
    let t = !1;
    for (const e of this.levels[0].values())
      if (e.entityCount > this.tileCapacity) {
        t = !0;
        break;
      }
    return t;
  }
  setOfNodesOnTheLevel(t) {
    const e = /* @__PURE__ */ new Set();
    for (const i of this.levels[t].values())
      for (const s of i.nodes)
        e.add(s.node);
    return e;
  }
  // checkLevel(i: number) {
  //   const [edgeMap, nodeSet] = this.getEntityDataFromLevel(i)
  //   for (const [e, entDataArray] of edgeMap) {
  //     this.checkEntityDataArray(e, entDataArray, nodeSet)
  //   }
  // }
  // checkEntityDataArray(e: Entity, entDataArray: EntityDataInTile[], nodeSet: Set<Node>) {
  //   if (e instanceof Edge) {
  //     if (!nodeSet.has(e.source)) {
  //       Assert.assert(false)
  //     }
  //     if (!nodeSet.has(e.target)) {
  //       Assert.assert(false)
  //     }
  //     let connectedToSource = false
  //     let connectedToTarget = false
  //     const ge = GeomEdge.getGeom(e)
  //     const sb = ge.source.boundingBox
  //     const tb = ge.target.boundingBox
  //     for (const cc of entDataArray) {
  //       if ('curve' in cc.data) {
  //         Assert.assert(cc.data.edge === e)
  //         const curve = cc.data.curve
  //         if (sb.contains(curve.start)) connectedToSource = true
  //         if (tb.contains(curve.end)) connectedToTarget = true
  //       }
  //     }
  //     Assert.assert(connectedToSource && connectedToTarget)
  //   }
  // }
  regenerateCurveClipsUpToLevel(t, e) {
    this.clearCurveClipsInLevelsUpTo(t);
    for (const i of this.levels[0].values())
      this.regenerateCurveClipsUnderTileUpToLevel(i, t, e);
  }
  clearCurveClipsInLevelsUpTo(t) {
    for (let e = 0; e <= t; e++)
      for (const i of this.levels[e].values())
        i.initCurveClips();
  }
  regenerateCurveClipsUnderTileUpToLevel(t, e, i) {
    t.arrowheads = [], t.initCurveClips();
    for (const s of this.geomGraph.deepEdges)
      if (cr(s.edge, i)) {
        if (s.curve instanceof g)
          for (const n of s.curve.segs)
            t.addElement({ edge: s.edge, curve: n, startPar: n.parStart, endPar: n.parEnd });
        else
          t.addElement({ edge: s.edge, curve: s.curve, startPar: s.curve.parStart, endPar: s.curve.parEnd });
        s.sourceArrowhead && t.arrowheads.push({ edge: s.edge, tip: s.sourceArrowhead.tipPosition, base: s.curve.start }), s.targetArrowhead && t.arrowheads.push({ edge: s.edge, tip: s.targetArrowhead.tipPosition, base: s.curve.end });
      }
    for (let s = 1; s <= e; s++)
      this.regenerateCurveClipsWhenPreviosLayerIsDone(s), this.removeEmptyTiles(s);
  }
  removeEmptyTiles(t) {
    const e = this.levels[t], i = [];
    for (const [s, n] of e.keyValues())
      n.isEmpty() && i.push(s);
    for (const s of i)
      e.delete(s.x, s.y);
  }
  regenerateCurveClipsWhenPreviosLayerIsDone(t) {
    for (const [e, i] of this.levels[t - 1].keyValues())
      this.subdivideTile(
        e,
        t,
        i,
        /** for regenerate */
        !0
      );
  }
  // regenerateUnderOneTile(key: IntPair, upperTile: Tile, z: number) {
  //   const subTilesRects = createSubTileRects()
  //   const clipsPerRect = this.regenerateCurveClipsUnderTile(upperTile, subTilesRects)
  //   pushRegeneratedClips(this.levels[z])
  //   cleanArrowheadsInSubtiles(this.levels[z])
  //   pushArrowheadsToSubtiles(this.levels[z])
  //   cleanUpSubtilesAboveTile(this.levels[z])
  //   function cleanUpSubtilesAboveTile(level: IntPairMap<Tile>) {
  //     for (let i = 0; i < 2; i++)
  //       for (let j = 0; j < 2; j++) {
  //         const ti = 2 * key.x + i
  //         const tj = 2 * key.y + j
  //         const tile = level.get(ti, tj)
  //         if (tile == null) continue
  //         if (tile.isEmpty()) {
  //           level.delete(ti, tj)
  //         }
  //       }
  //   }
  //   function pushArrowheadsToSubtiles(level: IntPairMap<Tile>) {
  //     for (const arrowhead of upperTile.arrowheads) {
  //       const arrowheadBox = Rectangle.mkPP(arrowhead.base, arrowhead.tip)
  //       const d = arrowhead.tip.sub(arrowhead.base).div(3)
  //       const dRotated = d.rotate90Cw()
  //       arrowheadBox.add(arrowhead.base.add(dRotated))
  //       arrowheadBox.add(arrowhead.base.sub(dRotated))
  //       for (let i = 0; i < 2; i++)
  //         for (let j = 0; j < 2; j++) {
  //           const k = 2 * i + j
  //           if (arrowheadBox.intersects(subTilesRects[k])) {
  //             const ti = 2 * key.x + i
  //             const tj = 2 * key.y + j
  //             level.get(ti, tj).arrowheads.push(arrowhead)
  //           }
  //         }
  //     }
  //   }
  //   function cleanArrowheadsInSubtiles(levelMap: IntPairMap<Tile>) {
  //     for (let i = 0; i < 2; i++)
  //       for (let j = 0; j < 2; j++) {
  //         const ti = 2 * key.x + i
  //         const tj = 2 * key.y + j
  //         const tile = levelMap.get(ti, tj)
  //         if (tile == null) {
  //           continue
  //         }
  //         tile.arrowheads = []
  //       }
  //   }
  //   function pushRegeneratedClips(levelMap: IntPairMap<Tile>) {
  //     for (let i = 0; i < 2; i++)
  //       for (let j = 0; j < 2; j++) {
  //         const k = 2 * i + j
  //         const clips = clipsPerRect[k]
  //         const ti = 2 * key.x + i
  //         const tj = 2 * key.y + j
  //         let tile = levelMap.get(ti, tj)
  //         if (tile == null) {
  //           if (clips.length) {
  //             levelMap.set(ti, tj, (tile = new Tile(subTilesRects[k])))
  //           } else {
  //             continue
  //           }
  //         }
  //         tile.initCurveClips()
  //         for (const clip of clips) {
  //           tile.addElement({edge: clip.edge, curve: clip.curve})
  //         }
  //       }
  //   }
  //   function createSubTileRects() {
  //     const subTilesRects = new Array<Rectangle>()
  //     const w = upperTile.rect.width / 2
  //     const h = upperTile.rect.height / 2
  //     for (let i = 0; i < 2; i++)
  //       for (let j = 0; j < 2; j++) {
  //         const tileRect = new Rectangle({
  //           left: upperTile.rect.left + w * i,
  //           right: upperTile.rect.left + w * (i + 1),
  //           bottom: upperTile.rect.bottom + h * j,
  //           top: upperTile.rect.bottom + h * (j + 1),
  //         })
  //         subTilesRects.push(tileRect)
  //       }
  //     return subTilesRects
  //   }
  // }
  // lastLayerHasAllNodes(): boolean {
  //   const lastLayerNodes = new Set<Node>()
  //   for (const tile of this.levels[this.levels.length - 1].values()) {
  //     for (const n of tile.nodes) {
  //       lastLayerNodes.add(n.node)
  //     }
  //   }
  //   const gNodes = new Set<Node>(this.geomGraph.graph.nodesBreadthFirst)
  //   return setsAreEqual(gNodes, lastLayerNodes)
  // }
  calculateNodeRank() {
    this.nodeRank = /* @__PURE__ */ new Map();
    const t = this.sortedNodes.length, e = Math.log10(t);
    for (let i = 0; i < t; i++)
      this.nodeRank.set(this.sortedNodes[i], e - Math.log10(i + 1));
  }
  compareByPagerank(t, e) {
    return this.pageRank.get(e) - this.pageRank.get(t);
  }
  /** Fills the tiles up to the capacity.
   * Returns the number of inserted node.
   * An edge and its attributes is inserted just after its source and the target are inserted.
   * The nodes are sorted by rank here.  */
  filterOutEntities(t, e) {
    const i = this.transferDataOfLevelToMap(t);
    let s = 0;
    for (; s < this.sortedNodes.length; s++) {
      const n = this.sortedNodes[s];
      if (!this.addNodeToLevel(t, n, i))
        break;
    }
    return this.removeEmptyTiles(e), s;
  }
  /** Goes over all tiles where 'node' had presence and tries to add.
   *  If the above succeeds then all edges leading to the higher ranking nodes added without consulting with tileCapacity. The edge attributes added as well
   */
  addNodeToLevel(t, e, i) {
    const s = i.get(e);
    for (const r of s)
      if (r.tile.entityCount >= this.tileCapacity)
        return !1;
    for (const r of s) {
      const a = r.tile, l = r.data;
      a.addElement(l);
    }
    for (const r of e.selfEdges) {
      const a = i.get(r);
      for (const l of a) {
        const h = l.tile, c = l.data;
        h.addElement(c);
      }
      if (r.label)
        for (const l of i.get(r.label)) {
          const h = l.tile, c = l.data;
          h.addElement(c);
        }
    }
    const n = this.nodeIndexInSortedNodes.get(e);
    for (const r of e.inEdges) {
      const a = r.source;
      if (!(this.nodeIndexInSortedNodes.get(a) > n)) {
        for (const h of i.get(r)) {
          const c = h.tile, d = h.data;
          c.addElement(d);
        }
        if (r.label)
          for (const h of i.get(r.label)) {
            const c = h.tile, d = h.data;
            c.addElement(d);
          }
      }
    }
    for (const r of e.outEdges) {
      const a = r.target;
      if (!(this.nodeIndexInSortedNodes.get(a) > n)) {
        for (const h of i.get(r)) {
          const c = h.tile, d = h.data;
          c.addElement(d);
        }
        if (r.label && i.get(r.label))
          for (const h of i.get(r.label)) {
            const c = h.tile, d = h.data;
            c.addElement(d);
          }
      }
    }
    return !0;
  }
  transferDataOfLevelToMap(t) {
    const e = /* @__PURE__ */ new Map();
    for (const s of t.values()) {
      for (const n of s.curveClips) {
        const r = n.edge;
        i(r).push({ tile: s, data: n });
      }
      for (const n of s.labels) {
        const r = n.parent.edge;
        i(r).push({ tile: s, data: n });
      }
      for (const n of s.nodes) {
        const r = n.node;
        i(r).push({ tile: s, data: n });
      }
      for (const n of s.arrowheads) {
        const r = n.edge;
        i(r).push({ tile: s, data: n });
      }
      s.clear();
    }
    return e;
    function i(s) {
      let n = e.get(s);
      return n || e.set(s, n = new Array()), n;
    }
  }
  /** It is assumed that the previous level z-1 have been calculated.
   * Returns true if every edge is appears in some tile as the first edge
   */
  subdivideLevel(t) {
    if (console.log("subdivideLevel", t), this.levels[t] = new Ji(), this.subdivideTilesOnLevel(t))
      return console.log("done subdividing at level", t, "because each tile contains less than", this.tileCapacity), !0;
    const { w: i, h: s } = this.getWHOnLevel(t);
    return i <= this.minTileSize.width && s <= this.minTileSize.height ? (console.log("done subdividing at level", t, " because of tile size = ", i, s, "is less than ", this.minTileSize), !0) : !1;
  }
  countClips(t) {
    let e = 0;
    for (const i of this.levels[t].values())
      e += i.curveClips.length;
    return e;
  }
  getWHOnLevel(t) {
    for (let e = this.tileSizes.length; e <= t; e++) {
      const i = this.tileSizes[e - 1];
      this.tileSizes.push(new Ai(i.width / 2, i.height / 2));
    }
    return { w: this.tileSizes[t].width, h: this.tileSizes[t].height };
  }
  subdivideTilesOnLevel(t) {
    let e = !0;
    for (const [i, s] of this.levels[t - 1].keyValues()) {
      const n = this.subdivideTile(i, t, s, !1);
      e && (e = n.allSmall);
    }
    return this.removeEmptyTiles(t), console.log("generated", this.levels[t].size, "tiles"), e;
  }
  subdivideTile(t, e, i, s) {
    const { w: n, h: r } = this.getWHOnLevel(e), a = this.levels[e], l = t.x, h = t.y, c = this.topLevelTileRect.left + l * n * 2, d = this.topLevelTileRect.bottom + h * r * 2, f = new Array(4);
    for (let I = 0; I < 2; I++)
      for (let x = 0; x < 2; x++)
        f[I * 2 + x] = new U(l * 2 + I, h * 2 + x);
    s || this.generateSubtilesWithoutTileClips(c, n, d, r, f, i, e);
    const p = new v(c, d + r, c + 2 * n, d + r), P = new v(c + n, d, c + n, d + 2 * r);
    E();
    let y = 0, C = !0;
    for (const I of f) {
      const x = a.get(I.x, I.y);
      x != null && (y++, x.entityCount > this.tileCapacity && (C = !1));
    }
    return { count: y, allSmall: C };
    function E() {
      for (const I of i.curveClips) {
        const x = I.curve, V = N(x, I.startPar, I.endPar);
        if (at.assert(V.length >= 2), V.length == 2) {
          const G = (V[0] + V[1]) / 2, X = x.value(G), $t = X.x <= c + n ? 0 : 1, ht = X.y <= d + r ? 0 : 1, zt = 2 * $t + ht, Mt = f[zt];
          let Gt = a.getI(Mt);
          if (!Gt) {
            const te = c + $t * n, de = d + ht * r;
            Gt = new er(new T({ left: te, bottom: de, top: de + r, right: te + n })), a.setPair(Mt, Gt);
          }
          Gt.addCurveClip({ curve: x, edge: I.edge, startPar: V[0], endPar: V[1] });
        } else
          for (let G = 0; G < V.length - 1; G++) {
            const X = (V[G] + V[G + 1]) / 2, $t = x.value(X), ht = $t.x <= c + n ? 0 : 1, zt = $t.y <= d + r ? 0 : 1, Mt = 2 * ht + zt, Gt = f[Mt];
            let te = a.getI(Gt);
            if (!te) {
              const de = c + ht * n, mi = d + zt * r;
              te = new er(new T({ left: de, bottom: mi, top: mi + r, right: de + n })), a.setPair(Gt, te);
            }
            te.addCurveClip({ curve: x, edge: I.edge, startPar: V[G], endPar: V[G + 1] });
          }
      }
    }
    function N(I, x, V) {
      let G = Array.from(g.getAllIntersections(I, p, !0)).concat(Array.from(g.getAllIntersections(I, P, !0))).map((X) => X.par0);
      return G.sort((X, $t) => X - $t), [x].concat(G.filter((X) => X >= x && X <= V)).concat(V);
    }
  }
  /** returns the updated value of allTilesAreSmall */
  addSubtilesToLevel(t, e, i, s, n) {
    for (let r = 0; r < 2; r++)
      for (let a = 0; a < 2; a++) {
        const l = t[r * 2 + a];
        l.isEmpty() || (e.set(2 * i + r, 2 * s + a, l), n && l.entityCount > this.tileCapacity && (n = !1));
      }
    return n;
  }
  generateSubtilesWithoutTileClips(t, e, i, s, n, r, a) {
    let l = 0;
    for (let h = 0; h < 2; h++)
      for (let c = 0; c < 2; c++) {
        const d = new T({
          left: t + e * h,
          right: t + e * (h + 1),
          bottom: i + s * c,
          top: i + s * (c + 1)
        }), f = this.generateOneSubtileExceptEdgeClips(r, d);
        f && this.levels[a].set(n[l].x, n[l].y, f), l++;
      }
  }
  innerClips(t, e, i) {
    const s = [], n = Array.from(g.getAllIntersections(t, i, !0)).concat(Array.from(g.getAllIntersections(t, e, !0)));
    n.sort((a, l) => a.par0 - l.par0);
    const r = [t.parStart];
    for (let a = 0; a < n.length; a++) {
      const l = n[a];
      l.par0 > r[r.length - 1] + m.distanceEpsilon && r.push(l.par0);
    }
    if (t.parEnd > r[r.length - 1] + m.distanceEpsilon && r.push(t.parEnd), r.length <= 2)
      return s.push(t), s;
    for (let a = 0; a < r.length - 1; a++)
      s.push(t.trim(r[a], r[a + 1]));
    return s;
  }
  generateOneSubtileExceptEdgeClips(t, e) {
    const i = new er(e);
    for (const s of t.nodes)
      s.boundingBox.intersects(e) && i.nodes.push(s);
    for (const s of t.labels)
      s.boundingBox.intersects(e) && i.labels.push(s);
    for (const s of t.arrowheads) {
      const n = T.mkPP(s.base, s.tip), a = s.tip.sub(s.base).div(3).rotate90Cw();
      n.add(s.base.add(a)), n.add(s.base.sub(a)), n.intersects(e) && i.arrowheads.push(s);
    }
    return i.isEmpty() ? null : i;
  }
}
class An extends ie {
  constructor(t, e) {
    super(), this.SetEdges(t, e);
  }
}
class Ag {
  *RegularMultiedges() {
    for (const [t, e] of this.Multiedges.keyValues())
      t.x !== t.y && (yield e);
  }
  *AllIntEdges() {
    for (const t of this.Multiedges.values())
      for (const e of t)
        yield e;
  }
  addFeedbackSet(t) {
    for (const e of t) {
      const i = new U(e.source, e.target), s = new U(e.target, e.source), n = this.Multiedges.get(i.x, i.y);
      for (const r of n)
        r.reverse();
      if (this.Multiedges.has(s.x, s.y)) {
        const r = this.Multiedges.get(s.x, s.y);
        for (const a of n)
          r.push(a);
      } else
        this.Multiedges.set(s.x, s.y, n);
      this.Multiedges.delete(i.x, i.y);
    }
  }
  constructor(t) {
    this.MultipleMiddles = /* @__PURE__ */ new Set(), this.Multiedges = new Ji();
  }
  registerOriginalEdgeInMultiedges(t) {
    let e = this.Multiedges.get(t.source, t.target);
    e == null && this.Multiedges.set(t.source, t.target, e = []), e.push(t);
  }
  *SkeletonEdges() {
    for (const [t, e] of this.Multiedges.keyValues())
      t.x !== t.y && (yield e[0]);
  }
  GetMultiedge(t, e) {
    return this.GetMultiedgeI(new U(t, e));
  }
  GetMultiedgeI(t) {
    return this.Multiedges.has(t.x, t.y) ? this.Multiedges.get(t.x, t.y) : new Array();
  }
}
function qo(o, t) {
  for (let e = 0; e < o.length; e++)
    t[e] = o[e];
}
class Ni {
  constructor(t) {
    this.initialize(t);
  }
  initialize(t) {
    this.y = t, this.verticesToX = null, this.layers = null;
  }
  // Returns the same arrays but with no empty layers.
  DropEmptyLayers() {
    const t = new Array(this.Layers.length);
    let e = 0;
    for (let r = 0; r < this.Layers.length; r++)
      t[r] = e, this.Layers[r].length === 0 && e++;
    if (e === 0)
      return this;
    const i = new Array(this.y.length);
    for (let r = 0; r < i.length; r++)
      i[r] = this.y[r] - t[this.y[r]];
    const s = new Array(this.layers.length - e);
    for (let r = 0; r < this.layers.length; r++)
      this.layers[r].length > 0 && (s[r - t[r]] = Array.from(this.layers[r]));
    const n = new Ni(i);
    return n.layers = s, n;
  }
  updateLayers(t) {
    this.layers == null && this.InitLayers();
    for (let e = 0; e < this.layers.length; e++)
      qo(t[e], this.layers[e]);
    this.UpdateXFromLayers();
  }
  UpdateXFromLayers() {
    this.layers == null && this.InitLayers(), this.verticesToX == null && (this.verticesToX = new Array(this.y.length));
    for (const t of this.layers) {
      let e = 0;
      for (const i of t)
        this.verticesToX[i] = e++;
    }
  }
  // gives the order of the vertices in the y-layer
  // <value></value>
  get x() {
    return this.verticesToX != null ? this.verticesToX : (this.verticesToX = new Array(this.y.length), this.UpdateXFromLayers(), this.verticesToX);
  }
  // returns the layer hierarchy where the order of the layers is reversed
  ReversedClone() {
    const t = new Array(this.y.length), e = this.Layers.length - 1;
    for (let i = 0; i < this.y.length; i++)
      t[i] = e - this.y[i];
    return new Ni(t);
  }
  // Layers[i] is the array of vertices of i-th layer
  get Layers() {
    return this.layers != null ? this.layers : (this.InitLayers(), this.layers);
  }
  set Layers(t) {
    this.layers = t;
  }
  InitLayers() {
    let t = 0;
    for (const i of this.y)
      i + 1 > t && (t = i + 1);
    const e = new Array(t).fill(0);
    for (const i of this.y)
      e[i]++;
    this.layers = new Array(t);
    for (let i = 0; i < t; i++)
      this.layers[i] = new Array(e[i]), e[i] = 0;
    for (let i = 0; i < this.y.length; i++) {
      const s = this.y[i];
      this.layers[s][e[s]++] = i;
    }
  }
}
class Ia extends lt {
  static Balance(t, e, i, s) {
    new Ia(t, e, i, s).run();
  }
  constructor(t, e, i, s) {
    super(s), this.jumpers = /* @__PURE__ */ new Set(), this.possibleJumperFeasibleIntervals = /* @__PURE__ */ new Map(), this.nodeCount = i, this.dag = t, this.layering = e, this.Init();
  }
  run() {
    for (; this.jumpers.size > 0; )
      this.Jump(this.ChooseJumper());
  }
  Init() {
    this.CalculateLayerCounts(), this.InitJumpers();
  }
  Jump(t) {
    this.jumpers.delete(t);
    const e = this.possibleJumperFeasibleIntervals.get(t), i = this.CalcJumpInfo(e.x, e.y, t);
    if (i == null)
      return;
    this.layering[t] = i.layerToJumpTo;
    const s = this.nodeCount[t];
    this.vertsCounts[i.jumperLayer] -= s, this.vertsCounts[i.layerToJumpTo] += s, this.UpdateRegionsForPossibleJumpersAndInsertJumpers(i.jumperLayer, t);
  }
  IsJumper(t) {
    return this.possibleJumperFeasibleIntervals.has(t);
  }
  // some other jumpers may stop being ones if the jump
  // was just in to their destination layer, so before the actual
  // jump we have to recheck if the jump makes sense
  //
  UpdateRegionsForPossibleJumpersAndInsertJumpers(t, e) {
    const i = /* @__PURE__ */ new Set();
    for (const n of this.dag.pred(e))
      this.IsJumper(n) && (this.CalculateRegionAndInsertJumper(n), i.add(n));
    for (const n of this.dag.succ(e))
      this.IsJumper(n) && (this.CalculateRegionAndInsertJumper(n), i.add(n));
    const s = new Array();
    for (const n of this.possibleJumperFeasibleIntervals)
      i.has(n[0]) || n[1].x > t && n[1].y < t && s.push(n[0]);
    for (const n of s)
      this.CalculateRegionAndInsertJumper(n);
  }
  InitJumpers() {
    const t = new Array(this.dag.nodeCount).fill(0);
    for (const e of this.dag.edges)
      t[e.source] -= e.weight, t[e.target] += e.weight;
    this.possibleJumperFeasibleIntervals = /* @__PURE__ */ new Map();
    for (let e = 0; e < this.dag.nodeCount; e++)
      t[e] === 0 && this.CalculateRegionAndInsertJumper(e);
  }
  CalculateRegionAndInsertJumper(t) {
    const e = new U(this.Up(t), this.Down(t));
    this.possibleJumperFeasibleIntervals.set(t, e), this.InsertJumper(e.x, e.y, t);
  }
  InsertJumper(t, e, i) {
    this.CalcJumpInfo(t, e, i) != null && this.jumpers.add(i);
  }
  // layerToJumpTo is -1 if there is no jump
  CalcJumpInfo(t, e, i) {
    const s = this.layering[i];
    let n = -1, r = this.vertsCounts[s] - 2 * this.nodeCount[i];
    for (let a = t - 1; a > s; a--)
      this.vertsCounts[a] < r && (r = this.vertsCounts[a], n = a);
    for (let a = s - 1; a > e; a--)
      this.vertsCounts[a] < r && (r = this.vertsCounts[a], n = a);
    if (n !== -1)
      return { jumperLayer: s, layerToJumpTo: n };
  }
  // Up returns the first infeasible layer up from i that i cannot jump to
  Up(t) {
    let e = Number.MAX_SAFE_INTEGER;
    for (const i of this.dag.inEdges[t]) {
      const s = this.layering[i.source] - i.separation + 1;
      s < e && (e = s);
    }
    return e === Number.MAX_SAFE_INTEGER && (e = this.layering[t] + 1), e;
  }
  // Returns the first infeasible layer down from i that i cannot jump to
  Down(t) {
    let e = Number.NEGATIVE_INFINITY;
    for (const i of this.dag.outEdges[t]) {
      const s = this.layering[i.target] + i.separation - 1;
      s > e && (e = s);
    }
    return e === Number.NEGATIVE_INFINITY && (e = this.layering[t] - 1), e;
  }
  CalculateLayerCounts() {
    this.vertsCounts = new Array(Math.max(...this.layering) + 1).fill(0);
    for (const t of this.layering)
      this.vertsCounts[t] += this.nodeCount[t];
  }
  ChooseJumper() {
    for (const t of this.jumpers)
      return t;
    throw new Error("there are no jumpers to choose");
  }
}
class gs {
  constructor(t) {
    this.Initialize(t);
  }
  Initialize(t) {
    this.BaseGraph = t, this.totalNumberOfNodes = t.nodeCount;
    for (const e of this.BaseGraph.edges)
      if (e.LayerEdges != null)
        for (const i of e.LayerEdges) {
          const s = Math.max(i.Source, i.Target) + 1;
          s > this.totalNumberOfNodes && (this.totalNumberOfNodes = s);
        }
    this.firstVirtualNode = Number.POSITIVE_INFINITY;
    for (const e of this.BaseGraph.edges)
      if (e.LayerEdges != null)
        for (let i = 1; i < e.LayerEdges.length; i++) {
          const s = e.LayerEdges[i];
          this.firstVirtualNode = Math.min(this.firstVirtualNode, s.Source);
        }
    this.firstVirtualNode === Number.POSITIVE_INFINITY && (this.firstVirtualNode = this.BaseGraph.nodeCount, this.totalNumberOfNodes = this.BaseGraph.nodeCount), this.virtualNodesToInEdges = new Array(this.totalNumberOfNodes - this.firstVirtualNode), this.virtualNodesToOutEdges = new Array(this.totalNumberOfNodes - this.firstVirtualNode);
    for (const e of this.BaseGraph.edges)
      if (e.LayerSpan > 0)
        for (const i of e.LayerEdges)
          i.Target !== e.target && (this.virtualNodesToInEdges[i.Target - this.firstVirtualNode] = i), i.Source !== e.source && (this.virtualNodesToOutEdges[i.Source - this.firstVirtualNode] = i);
  }
  // enumerates over the graph edges
  *edges_() {
    for (const t of this.BaseGraph.edges)
      if (t.LayerSpan > 0)
        for (const e of t.LayerEdges)
          yield e;
  }
  get Edges() {
    return this.edges_();
  }
  // enumerates over edges of a node
  *InEdges(t) {
    if (t < this.BaseGraph.nodeCount)
      for (const e of this.BaseGraph.inEdges[t])
        e.source !== e.target && e.LayerEdges != null && (yield gs.LastEdge(e));
    else t >= this.firstVirtualNode && (yield this.InEdgeOfVirtualNode(t));
  }
  static LastEdge(t) {
    return t.LayerEdges[t.LayerEdges.length - 1];
  }
  InEdgeOfVirtualNode(t) {
    return this.virtualNodesToInEdges[t - this.firstVirtualNode];
  }
  // enumerates over the node outcoming edges
  *OutEdges(t) {
    if (t < this.BaseGraph.nodeCount)
      for (const e of this.BaseGraph.outEdges[t])
        e.source !== e.target && e.LayerEdges != null && (yield gs.FirstEdge(e));
    else t >= this.firstVirtualNode && (yield this.OutEdgeOfVirtualNode(t));
  }
  OutDegreeIsMoreThanOne(t) {
    return t < this.BaseGraph.nodeCount ? this.BaseGraph.outEdges[t].length > 1 : !1;
  }
  InDegreeIsMoreThanOne(t) {
    return t < this.BaseGraph.nodeCount ? this.BaseGraph.inEdges[t].length > 1 : !1;
  }
  OutEdgeOfVirtualNode(t) {
    return this.virtualNodesToOutEdges[t - this.firstVirtualNode];
  }
  static FirstEdge(t) {
    return t.LayerEdges[0];
  }
  // returns the number of incoming edges for an edge
  InEdgesCount(t) {
    return this.RealInEdgesCount(t);
  }
  RealInEdgesCount(t) {
    return t < this.BaseGraph.nodeCount ? this.BaseGraph.inEdges[t].filter((e) => e.LayerEdges != null).length : 1;
  }
  // returns the number of outcoming edges for an edge
  OutEdgesCount(t) {
    return this.RealOutEdgesCount(t);
  }
  RealOutEdgesCount(t) {
    return t < this.BaseGraph.nodeCount ? this.BaseGraph.outEdges[t].filter((e) => e.LayerEdges != null).length : 1;
  }
  // returns the node count
  get NodeCount() {
    return this.totalNumberOfNodes;
  }
  IsRealNode(t) {
    return t < this.BaseGraph.nodeCount;
  }
  IsVirtualNode(t) {
    return !this.IsRealNode(t);
  }
  ReversedClone() {
    const t = this.CreateReversedEdges();
    return new gs(new An(t, this.BaseGraph.nodeCount));
  }
  CreateReversedEdges() {
    const t = new Array();
    for (const e of this.BaseGraph.edges)
      e.isSelfEdge() || t.push(e.reversedClone());
    return t;
  }
  *Succ(t) {
    for (const e of this.OutEdges(t))
      yield e.Target;
  }
  *Pred(t) {
    for (const e of this.InEdges(t))
      yield e.Source;
  }
}
class Wn {
  constructor(t, e, i, s) {
    this.la = e, this.database = i, this.layeredGraph = t, this.intGraph = s;
  }
  // the entry point of the class
  static InsertLayers(t, e, i, s) {
    const n = new Wn(t, e, i, s);
    return n.InsertLayers(), {
      layeredGraph: n.nLayeredGraph,
      la: n.Nla.DropEmptyLayers()
    };
  }
  // new Y-layering
  get NLayering() {
    return this.Nla.y;
  }
  // does the main work
  InsertLayers() {
    this.EditOldLayering(), this.CreateFullLayeredGraph(), this.InitNewLayering(), this.MapVirtualNodesToEdges(), this.FillUnsortedNewOddLayers(), this.WidenOriginalLayers(), this.SortNewOddLayers();
  }
  // virtual nodes inside of an edge should be of the form i,i+1, ....
  EditOldLayering() {
    let t = this.intGraph.nodeCount;
    for (const e of this.database.RegularMultiedges()) {
      let i = 0;
      const s = e[0];
      if (i = s.LayerSpan * 2, i > 0) {
        for (const n of s.LayerEdges)
          n.Target !== s.target && (t++, this.UpdateOldLayer(t++, n.Target));
        t += (i - 1) * (e.length - 1) + 1;
      }
    }
  }
  UpdateOldLayer(t, e) {
    const i = this.la.x[e], s = this.la.y[e], n = this.la.Layers[s];
    n[i] = t;
  }
  // Original layers are represented by even layers of the new layering.
  // Here we add new virtices of such layers and
  // set new x-offsets of original and dummy vertices of these layers.
  WidenOriginalLayers() {
    for (let t = 0; t < this.la.Layers.length; t++) {
      const e = this.Nla.Layers[t * 2];
      let i = 0;
      for (const s of this.la.Layers[t]) {
        const n = this.virtNodesToIntEdges[s];
        if (n != null) {
          const r = this.NLayering[n.source] - this.NLayering[s], a = this.database.Multiedges.get(n.source, n.target);
          for (const l of a)
            if (l !== n) {
              const h = l.LayerEdges[r].Source;
              e[i] = h, this.Nla.x[h] = i++;
            } else
              e[i] = s, this.Nla.x[s] = i++;
        } else
          e[i] = s, this.Nla.x[s] = i++;
      }
    }
  }
  // filling new layers not corresponding to the original layers
  FillUnsortedNewOddLayers() {
    const t = new Array(this.Nla.Layers.length).fill(0);
    for (let e = this.intGraph.nodeCount; e < this.nLayeredGraph.NodeCount; e++) {
      const i = this.NLayering[e];
      i % 2 === 1 && (this.Nla.Layers[i][t[i]++] = e);
    }
  }
  // create the mapping from the vertices to edges to which they belong
  MapVirtualNodesToEdges() {
    this.virtNodesToIntEdges = new Array(this.NLayering.length);
    for (const t of this.database.AllIntEdges())
      if (t.source !== t.target && t.LayerEdges != null)
        for (const e of t.LayerEdges)
          e.Target !== t.target && (this.virtNodesToIntEdges[e.Target] = t);
  }
  // Creating buckets for multi edges and allocating the graph.
  CreateFullLayeredGraph() {
    this.totalNodes = this.intGraph.nodeCount;
    for (const t of this.database.RegularMultiedges()) {
      let e = 0, i = !0;
      for (const s of t)
        if (i && (i = !1, e = s.LayerSpan * 2), e > 0) {
          s.LayerEdges = new Array(e);
          for (let n = 0; n < e; n++) {
            const r = { currentVV: this.totalNodes }, a = ps.GetSource(r, s, n);
            this.totalNodes = r.currentVV;
            const l = ps.GetTarget(this.totalNodes, s, n, e);
            s.LayerEdges[n] = new ji(a, l, s.CrossingWeight);
          }
          Wn.RegisterDontStepOnVertex(this.database, s);
        }
    }
    this.nLayeredGraph = new gs(this.intGraph);
  }
  // Sort new odd layers by the sum of x-coordinatates of predecessors and the successors of
  // dummy nodes.
  SortNewOddLayers() {
    for (let t = 1; t < this.Nla.Layers.length; t += 2) {
      const e = /* @__PURE__ */ new Map(), i = this.Nla.Layers[t];
      for (const r of i) {
        let a = -1;
        for (const c of this.nLayeredGraph.InEdges(r))
          a = c.Source;
        let l = -1;
        for (const c of this.nLayeredGraph.OutEdges(r))
          l = c.Target;
        const h = this.Nla.x[a] + this.Nla.x[l];
        if (e.has(h)) {
          const c = e.get(h);
          if (typeof c == "number") {
            const d = new Array();
            d.push(c), d.push(r), e.set(h, d);
          } else
            c.push(r);
        } else
          e.set(h, r);
      }
      const s = Array.from(e.entries()).sort((r, a) => r[0] - a[0]);
      let n = 0;
      for (const r of s.map((a) => a[1]))
        if (typeof r == "number")
          i[n++] = r;
        else
          for (const a of r)
            i[n++] = a;
      for (let r = 0; r < i.length; r++)
        this.Nla.x[i[r]] = r;
    }
  }
  // Allocating new layering and filling its y-layers
  InitNewLayering() {
    this.Nla = new Ni(new Array(this.totalNodes));
    for (let i = 0; i < this.layeredGraph.NodeCount; i++)
      this.NLayering[i] = this.la.y[i] * 2;
    for (const [i, s] of this.database.Multiedges.keyValues())
      if (i.x !== i.y && this.la.y[i.x] !== this.la.y[i.y]) {
        const n = this.la.y[i.x] * 2;
        for (const r of s) {
          let a = n - 1;
          for (const l of r.LayerEdges)
            l.Target !== r.target && (this.NLayering[l.Target] = a--);
        }
      }
    const t = new Array(2 * this.la.Layers.length - 1), e = new Array(t.length).fill(0);
    for (const i of this.NLayering)
      e[i]++;
    for (let i = 0; i < e.length; i++)
      t[i] = new Array(e[i]);
    this.Nla = new Ni(this.NLayering), this.Nla.Layers = t;
  }
  // mark the vertex as one representing a label
  // or a middle of a multi edge
  static RegisterDontStepOnVertex(t, e) {
    if (t.Multiedges.get(e.source, e.target).length > 1) {
      const i = e.LayerEdges[Math.floor(e.LayerEdges.length / 2)];
      t.MultipleMiddles.add(i.Source);
    }
  }
}
class ps {
  get NLayering() {
    return this.Nla.y;
  }
  static InsertPaths(t, e, i, s) {
    const n = new ps(t, e, i, s);
    return n.InsertPaths(), {
      layeredGraph: n.NLayeredGraph,
      la: n.Nla
    };
  }
  constructor(t, e, i, s) {
    this.virtNodesToIntEdges = /* @__PURE__ */ new Map(), this.la = e, this.database = i, this.layeredGraph = t, this.intGraph = s;
  }
  InsertPaths() {
    this.CreateFullLayeredGraph(), this.InitNewLayering(), this.MapVirtualNodesToEdges(), this.WidenOriginalLayers();
  }
  WidenOriginalLayers() {
    for (let t = 0; t < this.la.Layers.length; t++) {
      const e = this.Nla.Layers[t];
      let i = 0;
      for (const s of this.la.Layers[t]) {
        const n = this.virtNodesToIntEdges.get(s);
        if (n != null) {
          const r = this.NLayering[n.source] - this.NLayering[s], a = this.database.Multiedges.get(n.source, n.target);
          for (const l of a)
            if (!this.EdgeIsFlat(l))
              if (l !== n) {
                const h = l.LayerEdges[r].Source;
                e[i] = h, this.Nla.x[h] = i++;
              } else
                e[i] = s, this.Nla.x[s] = i++;
        } else
          e[i] = s, this.Nla.x[s] = i++;
      }
    }
  }
  EdgeIsFlat(t) {
    return this.la.y[t.source] === this.la.y[t.target];
  }
  MapVirtualNodesToEdges() {
    for (const t of this.database.RegularMultiedges())
      for (const e of t)
        if (!this.EdgeIsFlat(e))
          for (const i of e.LayerEdges)
            i.Target !== e.target && this.virtNodesToIntEdges.set(i.Target, e);
  }
  CreateFullLayeredGraph() {
    let t = this.layeredGraph.NodeCount;
    for (const [e, i] of this.database.Multiedges.keyValues())
      if (e.x !== e.y) {
        let s = !0, n = 0;
        for (const r of i) {
          if (s)
            s = !1, n = r.LayerSpan;
          else if (r.LayerEdges = new Array(n), n === 1)
            r.LayerEdges[0] = new ji(r.source, r.target, r.CrossingWeight);
          else
            for (let a = 0; a < n; a++) {
              const l = { currentVV: t }, h = ps.GetSource(l, r, a);
              t = l.currentVV;
              const c = ps.GetTarget(t, r, a, n);
              r.LayerEdges[a] = new ji(h, c, r.CrossingWeight);
            }
          Wn.RegisterDontStepOnVertex(this.database, r);
        }
      }
    this.NLayeredGraph = new gs(this.intGraph);
  }
  static GetTarget(t, e, i, s) {
    return i < s - 1 ? t : e.target;
  }
  static GetSource(t, e, i) {
    return i === 0 ? e.source : t.currentVV++;
  }
  InitNewLayering() {
    this.Nla = new Ni(new Array(this.NLayeredGraph.NodeCount));
    for (let i = 0; i < this.layeredGraph.NodeCount; i++)
      this.NLayering[i] = this.la.y[i];
    for (const [i, s] of this.database.Multiedges.keyValues())
      if (i.x !== i.y && this.la.y[i.x] !== this.la.y[i.y]) {
        let n = 0, r = !0;
        for (const a of s) {
          r && (r = !1, n = this.la.y[a.source]);
          let l = n - 1;
          for (const h of a.LayerEdges)
            this.NLayering[h.Target] = l--;
        }
      }
    const t = new Array(this.la.Layers.length), e = new Array(t.length).fill(0);
    for (const i of this.NLayering)
      e[i]++;
    for (let i = 0; i < e.length; i++)
      t[i] = new Array(e[i]);
    this.Nla = new Ni(this.NLayering), this.Nla.Layers = t;
  }
}
class fn {
  constructor(t, e, i) {
    this.numberOfCrossings = e, this.la = t, this.virtVertexStart = i;
  }
  LayerGroupDisbalance(t, e, i) {
    return e === 1 ? this.LayerGroupDisbalanceWithOrigSeparators(t, i) : this.LayerGroupDisbalanceWithVirtSeparators(t, e);
  }
  LayerGroupDisbalanceWithVirtSeparators(t, e) {
    let i = 0;
    for (let s = 0; s < t.length; ) {
      const n = this.CurrentOrigGroupDelta(s, t, e);
      s = n.i, i += n.ret;
    }
    return i;
  }
  CurrentOrigGroupDelta(t, e, i) {
    let s = 0, n = t;
    for (; n < e.length && e[n] < this.virtVertexStart; n++)
      s++;
    return t = n + 1, { ret: Math.abs(i - s), i: t };
  }
  LayerGroupDisbalanceWithOrigSeparators(t, e) {
    let i = 0;
    for (let s = 0; s < t.length; ) {
      const n = this.CurrentVirtGroupDelta(s, t, e);
      i += n.ret, s = n.i;
    }
    return i;
  }
  CurrentVirtGroupDelta(t, e, i) {
    let s = 0, n = t;
    for (; n < e.length && e[n] >= this.virtVertexStart; n++)
      s++;
    return t = n + 1, { ret: Math.abs(i - s), i: t };
  }
  static less(t, e) {
    return t.numberOfCrossings < e.numberOfCrossings;
  }
  static greater(t, e) {
    return t.numberOfCrossings > e.numberOfCrossings;
  }
  IsPerfect() {
    return this.numberOfCrossings === 0;
  }
}
class Tg {
  constructor(t) {
    this.x = t;
  }
  Compare(t, e) {
    const i = this.x[t.Source] - this.x[e.Source];
    return i !== 0 ? i : this.x[t.Target] - this.x[e.Target];
  }
}
class Og {
  constructor(t) {
    this.x = t;
  }
  Compare(t, e) {
    const i = this.x[t.Target] - this.x[e.Target];
    return i !== 0 ? i : this.x[t.Source] - this.x[e.Source];
  }
}
function ar() {
  return Us(2) === 0;
}
function xg(o, t, e) {
  const i = e.Layers[o + 1], s = e.Layers[o];
  return s.length <= i.length ? Rg(s, t, e) : Lg(i, s, t, e);
}
function Lg(o, t, e, i) {
  const s = nc(t, e), n = new Og(i.x);
  s.sort((h, c) => n.Compare(h, c));
  let r = 1;
  for (; r < o.length; )
    r *= 2;
  const a = new Array(2 * r - 1).fill(0);
  r--;
  let l = 0;
  for (const h of s) {
    let c = r + i.x[h.Source];
    const d = h.CrossingWeight;
    for (a[c] += d; c > 0; )
      c % 2 !== 0 && (l += d * a[c + 1]), c = Math.floor((c - 1) / 2), a[c] += d;
  }
  return l;
}
function Rg(o, t, e) {
  const i = nc(o, t), s = new Tg(e.x);
  i.sort((l, h) => s.Compare(l, h));
  let n = 1;
  for (; n < o.length; )
    n *= 2;
  const r = new Array(2 * n - 1).fill(0);
  n--;
  let a = 0;
  for (const l of i) {
    let h = n + e.x[l.Target];
    const c = l.CrossingWeight;
    for (r[h] += c; h > 0; )
      h % 2 !== 0 && (a += c * r[h + 1]), h = Math.floor((h - 1) / 2), r[h] += c;
  }
  return a;
}
function nc(o, t) {
  return Yn(o, (e) => t.InEdges(e));
}
function Rl(o, t) {
  let e = 0;
  for (let i = 0; i < t.Layers.length - 1; i++)
    e += xg(i, o, t);
  return e;
}
class Fs extends lt {
  get NoGainStepsBound() {
    return this.SugSettings.NoGainAdjacentSwapStepsBound * this.SugSettings.NoGainStepsForOrderingMultiplier;
  }
  // gets the random seed for some random choices inside of layer ordering
  get SeedOfRandom() {
    return Us(100);
  }
  constructor(t, e, i, s, n, r, a) {
    super(a), this.tryReverse = !0, this.MaxNumberOfAdjacentExchanges = 50, this.cancelToken = a, this.tryReverse = e, this.startOfVirtNodes = s, this.layerArrays = i, this.layering = i.y, this.nOfLayers = i.Layers.length, this.layers = i.Layers, this.properLayeredGraph = t, this.hasCrossWeights = n, this.SugSettings = r;
  }
  // an upper limit on a number of passes in layer ordering
  get MaxOfIterations() {
    return this.SugSettings.MaxNumberOfPassesInOrdering * this.SugSettings.NoGainStepsForOrderingMultiplier;
  }
  static OrderLayers(t, e, i, s, n) {
    let r = !1;
    for (const l of t.Edges)
      if (l.CrossingWeight !== 1) {
        r = !0;
        break;
      }
    new Fs(t, !0, e, i, r, s, n).run();
  }
  run() {
    if (this.Calculate(), /*orderingMeasure.x>0 &&*/
    this.tryReverse) {
      const t = this.layerArrays.ReversedClone(), e = new Fs(this.properLayeredGraph.ReversedClone(), !1, t, this.startOfVirtNodes, this.hasCrossWeights, this.SugSettings, this.cancelToken);
      if (e.run(), fn.less(e.measure, this.measure)) {
        for (let i = 0; i < this.nOfLayers; i++)
          qo(t.Layers[i], this.layerArrays.Layers[this.nOfLayers - 1 - i]);
        this.layerArrays.UpdateXFromLayers();
      }
    }
  }
  Calculate() {
    this.Init(), this.layerArraysCopy = Fs.CloneLayers(this.layers, this.layerArraysCopy);
    let t = 0;
    this.measure = new fn(this.layerArraysCopy, Rl(this.properLayeredGraph, this.layerArrays), this.startOfVirtNodes);
    for (let e = 0; e < this.MaxOfIterations && t < this.NoGainStepsBound && !this.measure.IsPerfect(); e++) {
      const i = e % 2 === 0;
      this.LayerByLayerSweep(i), this.AdjacentExchange();
      const s = new fn(this.layerArrays.Layers, Rl(this.properLayeredGraph, this.layerArrays), this.startOfVirtNodes);
      fn.less(this.measure, s) ? (this.Restore(), t++) : (fn.less(s, this.measure) || ar()) && (t = 0, this.layerArraysCopy = Fs.CloneLayers(this.layers, this.layerArraysCopy), this.measure = s);
    }
  }
  static CloneLayers(t, e) {
    if (e == null) {
      e = new Array(t.length);
      for (let i = 0; i < t.length; i++)
        e[i] = t[i].map((s) => s);
    } else
      for (let i = 0; i < t.length; i++)
        qo(t[i], e[i]);
    return e;
  }
  Restore() {
    this.layerArrays.updateLayers(this.layerArraysCopy);
  }
  LayerByLayerSweep(t) {
    if (t)
      for (let e = 1; e < this.nOfLayers; e++)
        this.SweepLayer(e, !0);
    else
      for (let e = this.nOfLayers - 2; e >= 0; e--)
        this.SweepLayer(e, !1);
  }
  // the layer layer-1 is fixed if
  // upperLayer us true and layer+1 is fixed in
  // the opposite case
  // the layer with index "layer" is updated
  // of the strip</param>
  SweepLayer(t, e) {
    const i = this.layers[t], s = new Array(i.length);
    for (let r = 0; r < s.length; r++)
      s[r] = this.WMedian(i[r], e);
    this.Sort(t, s);
    const n = this.layerArrays.Layers[t];
    for (let r = 0; r < n.length; r++)
      this.layerArrays.x[n[r]] = r;
  }
  // sorts layerToSort according to medianValues
  // if medianValues[i] is -1 then layer[i] does not move
  Sort(t, e) {
    const i = /* @__PURE__ */ new Map(), s = this.layers[t];
    let n = 0;
    for (const l of e) {
      const h = s[n++];
      if (l !== -1)
        if (!i.has(l))
          i.set(l, h);
        else {
          const c = i.get(l);
          if (typeof c != "number") {
            const d = c;
            if (ar())
              d.push(h);
            else {
              const f = Us(d.length), p = d[f];
              d[f] = h, d.push(p);
            }
          } else {
            const d = c, f = new Array();
            i.set(l, f), ar() ? (f.push(d), f.push(h)) : (f.push(h), f.push(d));
          }
        }
    }
    const r = Array.from(i).sort((l, h) => l[0] - h[0]).map((l) => l[1]);
    let a = 0;
    for (n = 0; n < s.length; )
      if (e[n] !== -1) {
        const l = r[a++];
        if (typeof l == "number")
          s[n++] = l;
        else {
          const h = l;
          for (const c of h) {
            for (; e[n] === -1; )
              n++;
            s[n++] = c;
          }
        }
      } else
        n++;
  }
  WMedian(t, e) {
    let i, s;
    if (e ? (i = this.properLayeredGraph.OutEdges(t), s = this.properLayeredGraph.OutEdgesCount(t)) : (i = this.properLayeredGraph.InEdges(t), s = this.properLayeredGraph.InEdgesCount(t)), s === 0)
      return -1;
    const n = new Array(s);
    let r = 0;
    if (e)
      for (const c of i)
        n[r++] = this.X[c.Target];
    else
      for (const c of i)
        n[r++] = this.X[c.Source];
    n.sort((c, d) => c - d);
    const a = Math.floor(s / 2);
    if (s % 2 === 1)
      return n[a];
    if (s === 2)
      return 0.5 * (n[0] + n[1]);
    const l = n[a - 1] - n[0], h = n[s - 1] - n[a];
    return Math.floor((n[a - 1] * l + n[a] * h) / (l + h));
  }
  // Just depth search and assign the index saying when the node was visited
  Init() {
    const t = new Array(this.nOfLayers).fill(0), e = new mt.Stack();
    for (let s = 0; s < this.properLayeredGraph.NodeCount; s++)
      this.properLayeredGraph.InEdgesCount(s) === 0 && e.push(s);
    const i = new Array(this.properLayeredGraph.NodeCount).fill(!1);
    for (; e.size > 0; ) {
      const s = e.pop(), n = this.layerArrays.y[s];
      this.layerArrays.Layers[n][t[n]] = s, this.layerArrays.x[s] = t[n], t[n]++;
      for (const r of this.properLayeredGraph.Succ(s))
        i[r] || (i[r] = !0, e.push(r));
    }
    this.X = this.layerArrays.x;
  }
  AdjacentExchange() {
    this.InitArrays();
    let t = 0, e = !0;
    for (; e && t++ < this.MaxNumberOfAdjacentExchanges; ) {
      e = !1;
      for (let i = 0; i < this.layers.length; i++)
        e = this.AdjExchangeLayer(i) || e;
      for (let i = this.layers.length - 2; i >= 0; i--)
        e = this.AdjExchangeLayer(i) || e;
    }
  }
  AllocArrays() {
    const t = this.properLayeredGraph.NodeCount;
    this.predecessors = new Array(t), this.successors = new Array(t), this.pOrder = new Array(t), this.sOrder = new Array(t), this.hasCrossWeights && (this.outCrossingCount = new Array(t), this.inCrossingCount = new Array(t));
    for (let e = 0; e < t; e++) {
      let i = this.properLayeredGraph.InEdgesCount(e);
      if (this.predecessors[e] = new Array(i), this.hasCrossWeights) {
        const s = this.inCrossingCount[e] = /* @__PURE__ */ new Map();
        for (const n of this.properLayeredGraph.InEdges(e))
          s.set(n.Source, n.CrossingWeight);
      }
      if (this.pOrder[e] = /* @__PURE__ */ new Map(), i = this.properLayeredGraph.OutEdgesCount(e), this.successors[e] = new Array(i), this.sOrder[e] = /* @__PURE__ */ new Map(), this.hasCrossWeights) {
        const s = this.outCrossingCount[e] = /* @__PURE__ */ new Map();
        for (const n of this.properLayeredGraph.OutEdges(e))
          s.set(n.Target, n.CrossingWeight);
      }
    }
  }
  // Is called just after median layer swap is done
  InitArrays() {
    this.successors == null && this.AllocArrays();
    for (let t = 0; t < this.properLayeredGraph.NodeCount; t++)
      this.pOrder[t] = /* @__PURE__ */ new Map(), this.sOrder[t] = /* @__PURE__ */ new Map();
    for (const t of this.layers)
      this.InitPsArraysForLayer(t);
  }
  // calculates the number of intersections between edges adjacent to u and v
  CalcPair(t, e) {
    const i = this.successors[t], s = this.successors[e], n = this.predecessors[t], r = this.predecessors[e];
    if (this.hasCrossWeights) {
      const a = this.outCrossingCount[t], l = this.outCrossingCount[e], h = this.inCrossingCount[t], c = this.inCrossingCount[e];
      return {
        cuv: this.CountOnArraysUV(i, s, a, l) + this.CountOnArraysUV(n, r, h, c),
        cvu: this.CountOnArraysUV(s, i, l, a) + this.CountOnArraysUV(r, n, c, h)
      };
    } else
      return {
        cuv: this.CountOnArrays(i, s) + this.CountOnArrays(n, r),
        cvu: this.CountOnArrays(s, i) + this.CountOnArrays(r, n)
      };
  }
  // Sweep layer from left to right and fill S,P arrays as we go.
  // The arrays P and S will be sorted according to X. Note that we will not keep them sorted
  // as we doing adjacent swaps. Initial sorting only needed to calculate initial clr,crl values.
  InitPsArraysForLayer(t) {
    for (const e of t) {
      for (const i of this.properLayeredGraph.Pred(e)) {
        const s = this.sOrder[i], n = s.size;
        this.successors[i][n] = e, s.set(e, n);
      }
      for (const i of this.properLayeredGraph.Succ(e)) {
        const s = this.pOrder[i], n = s.size;
        this.predecessors[i][n] = e, s.set(e, n);
      }
    }
  }
  CountOnArrays(t, e) {
    let i = 0;
    const s = e.length - 1;
    let n = -1, r = 0;
    for (const a of t) {
      const l = this.X[a];
      for (; n < s && this.X[e[n + 1]] < l; n++)
        r++;
      i += r;
    }
    return i;
  }
  // every inversion between unbs and vnbs gives an intersecton
  CountOnArraysUV(t, e, i, s) {
    let n = 0;
    const r = e.length - 1;
    let a = -1, l = 0;
    for (const h of t) {
      const c = this.X[h];
      let d;
      for (; a < r && this.X[d = e[a + 1]] < c; a++)
        l += s.get(d);
      n += l * i.get(h);
    }
    return n;
  }
  AdjExchangeLayer(t) {
    const e = this.layers[t];
    return this.ExchangeWithGainWithNoDisturbance(e) ? !0 : (this.DisturbLayer(e), this.ExchangeWithGainWithNoDisturbance(e));
  }
  //in this routine u and v are adjacent, and u is to the left of v before the swap
  Swap(t, e) {
    const i = this.X[t], s = this.X[e], n = this.layering[t], r = this.layers[n];
    r[i] = e, r[s] = t, this.X[t] = s, this.X[e] = i, this.UpdateSsContainingUv(t, e), this.UpdatePsContainingUv(t, e);
  }
  UpdatePsContainingUv(t, e) {
    if (this.successors[t].length <= this.successors[e].length)
      for (const i of this.successors[t]) {
        const s = this.pOrder[i];
        if (s.has(e)) {
          const n = s.get(e), r = this.predecessors[i];
          r[n - 1] = e, r[n] = t, s.set(e, n - 1), s.set(t, n);
        }
      }
    else
      for (const i of this.successors[e]) {
        const s = this.pOrder[i];
        if (s.has(t)) {
          const n = s.get(e), r = this.predecessors[i];
          r[n - 1] = e, r[n] = t, s.set(e, n - 1), s.set(t, n);
        }
      }
  }
  UpdateSsContainingUv(t, e) {
    if (this.predecessors[t].length <= this.predecessors[e].length)
      for (const i of this.predecessors[t]) {
        const s = this.sOrder[i];
        if (s.has(e)) {
          const n = s.get(e), r = this.successors[i];
          r[n - 1] = e, r[n] = t, s.set(e, n - 1), s.set(t, n);
        }
      }
    else
      for (const i of this.predecessors[e]) {
        const s = this.sOrder[i];
        if (s.has(t)) {
          const n = s.get(e), r = this.successors[i];
          r[n - 1] = e, r[n] = t, s.set(e, n - 1), s.set(t, n);
        }
      }
  }
  DisturbLayer(t) {
    for (let e = 0; e < t.length - 1; e++)
      this.AdjacentSwapToTheRight(t, e);
  }
  ExchangeWithGainWithNoDisturbance(t) {
    let e = !1, i;
    do
      i = this.ExchangeWithGain(t), e = e || i;
    while (i);
    return e;
  }
  ExchangeWithGain(t) {
    for (let e = 0; e < t.length - 1; e++)
      if (this.SwapWithGain(t[e], t[e + 1]))
        return this.SwapToTheLeft(t, e), this.SwapToTheRight(t, e + 1), !0;
    return !1;
  }
  SwapToTheLeft(t, e) {
    for (let i = e - 1; i >= 0; i--)
      this.AdjacentSwapToTheRight(t, i);
  }
  SwapToTheRight(t, e) {
    for (let i = e; i < t.length - 1; i++)
      this.AdjacentSwapToTheRight(t, i);
  }
  // swaps i-th element with i+1
  AdjacentSwapToTheRight(t, e) {
    const i = t[e], s = t[e + 1], n = this.SwapGain(i, s);
    (n > 0 || n === 0 && ar()) && this.Swap(i, s);
  }
  SwapGain(t, e) {
    const i = this.CalcPair(t, e);
    return i.cuv - i.cvu;
  }
  UvAreOfSameKind(t, e) {
    return t < this.startOfVirtNodes && e < this.startOfVirtNodes || t >= this.startOfVirtNodes && e >= this.startOfVirtNodes;
  }
  NeighborsForbidTheSwap(t, e) {
    return this.UpperNeighborsForbidTheSwap(t, e) || this.LowerNeighborsForbidTheSwap(t, e);
  }
  LowerNeighborsForbidTheSwap(t, e) {
    let i, s;
    return (i = this.properLayeredGraph.OutEdgesCount(t)) === 0 || (s = this.properLayeredGraph.OutEdgesCount(e)) === 0 ? !1 : this.X[this.successors[t][i >> 1]] < this.X[this.successors[e][s >> 1]];
  }
  UpperNeighborsForbidTheSwap(t, e) {
    const i = this.properLayeredGraph.InEdgesCount(t), s = this.properLayeredGraph.InEdgesCount(e);
    return i === 0 || s === 0 ? !1 : this.X[this.predecessors[t][i >> 1]] < this.X[this.predecessors[e][s >> 1]];
  }
  CalcDeltaBetweenGroupsToTheLeftAndToTheRightOfTheSeparator(t, e, i) {
    const s = this.GetKindDelegate(i);
    let n = 0;
    for (let a = e - 1; a >= 0 && !s(t[a]); a--)
      n++;
    let r = 0;
    for (let a = e + 1; a < t.length && !s(t[a]); a++)
      r++;
    return n - r;
  }
  IsOriginal(t) {
    return t < this.startOfVirtNodes;
  }
  IsVirtual(t) {
    return t >= this.startOfVirtNodes;
  }
  GetKindDelegate(t) {
    return this.IsVirtual(t) ? this.IsVirtual : this.IsOriginal;
  }
  // swaps two vertices only if reduces the number of intersections
  SwapWithGain(t, e) {
    return this.SwapGain(t, e) > 0 ? (this.Swap(t, e), !0) : !1;
  }
}
class zr {
  constructor(t, e, i) {
    this.properLayeredGraph = t, this.layerArrays = e, this.nodePositions = i;
  }
  // Reorder only points having identical nodePositions
  static UpdateLayerArrays0(t, e, i) {
    new zr(t, e, i).UpdateLayerArrays();
  }
  // Reorder virtual nodes between the same pair of real nodes
  static UpdateLayerArrays1(t, e) {
    const i = zr.BuildInitialNodePositions(t, e);
    this.UpdateLayerArrays0(t, e, i);
  }
  static BuildInitialNodePositions(t, e) {
    const i = /* @__PURE__ */ new Map();
    for (let s = 0; s < e.Layers.length; s++) {
      let n = 0, r = 0;
      for (; n < e.Layers[s].length; ) {
        for (; n < e.Layers[s].length && t.IsVirtualNode(e.Layers[s][n]); )
          n++;
        for (let a = r; a < n; a++)
          i.set(e.Layers[s][a], new u(s, r));
        n < e.Layers[s].length && i.set(e.Layers[s][n], new u(s, n)), n++, r = n;
      }
    }
    return i;
  }
  UpdateLayerArrays() {
    let t = this.CreateInitialOrdering();
    t = this.BuildOrdering(t), this.RestoreLayerArrays(t);
  }
  CreateInitialOrdering() {
    const t = new ii();
    for (const e of this.layerArrays.Layers)
      for (const i of e) {
        const s = this.nodePositions.get(i);
        t.hasxy(s.x, s.y) || t.setxy(s.x, s.y, []), t.getxy(s.x, s.y).push(i);
      }
    return t;
  }
  BuildOrdering(t) {
    const e = new ii(), i = /* @__PURE__ */ new Map();
    for (const s of this.layerArrays.Layers)
      for (const n of s) {
        const r = this.nodePositions.get(n);
        e.hasxy(r.x, r.y) || (this.BuildNodeOrdering(t.get(r), i), e.set(r, t.get(r)));
      }
    return e;
  }
  BuildNodeOrdering(t, e) {
    t.sort(this.Comparison(e));
    for (let i = 0; i < t.length; i++)
      e.set(t[i], i);
  }
  firstSucc(t) {
    for (const e of this.properLayeredGraph.Succ(t))
      return e;
  }
  firstPred(t) {
    for (const e of this.properLayeredGraph.Pred(t))
      return e;
  }
  Comparison(t) {
    return (e, i) => {
      const s = this.firstSucc(e), n = this.firstSucc(i);
      let r = this.firstPred(e), a = this.firstPred(i);
      const l = this.nodePositions.get(s), h = this.nodePositions.get(n), c = this.nodePositions.get(r), d = this.nodePositions.get(a);
      if (!l.equal(h))
        return c.equal(d) ? l.compareTo(h) : c.compareTo(d);
      if (this.properLayeredGraph.IsVirtualNode(s)) {
        if (!c.equal(d))
          return c.compareTo(d);
        const f = t.get(s), p = t.get(n);
        return yt(f, p);
      }
      for (; this.nodePositions.get(r).equal(this.nodePositions.get(a)) && this.properLayeredGraph.IsVirtualNode(r); )
        r = this.firstPred(r), a = this.firstPred(a);
      return this.nodePositions.get(r).equal(this.nodePositions.get(a)) ? yt(e, i) : this.nodePositions.get(r).compareTo(this.nodePositions.get(a));
    };
  }
  RestoreLayerArrays(t) {
    for (const e of this.layerArrays.Layers) {
      let i = 0, s = 0;
      for (; i < e.length; ) {
        for (; i < e.length && this.nodePositions.get(e[s]).equal(this.nodePositions.get(e[i])); )
          i++;
        const n = t.get(this.nodePositions.get(e[s]));
        for (let r = s; r < i; r++)
          e[r] = n[r - s];
        s = i;
      }
    }
    this.layerArrays.UpdateXFromLayers();
  }
}
class ro {
  // Topological sort of a list of int edge tuples
  static getOrder(t, e) {
    const i = fi(e.map(([s, n]) => new U(s, n)), t);
    return ro.getOrderOnGraph(i);
  }
  // The function returns an array arr such that
  // every edge points forward in the array. The input has to be a DAG
  static getOrderOnGraph(t) {
    const e = new Array(t.nodeCount).fill(!1), i = new mt.Stack(), s = [];
    let n;
    for (let r = 0; r < t.nodeCount; r++) {
      if (e[r])
        continue;
      let a = r;
      e[a] = !0;
      let l = 0;
      n = t.outEdges[r];
      do {
        for (; l < n.length; l++) {
          const h = n[l].target;
          e[h] || (e[h] = !0, i.push({ edges: n, index: l + 1, current_u: a }), a = h, n = t.outEdges[a], l = -1);
        }
        if (s.push(a), i.length > 0) {
          const h = i.pop();
          n = h.edges, l = h.index, a = h.current_u;
        } else
          break;
      } while (!0);
    }
    return s.reverse();
  }
}
class Ng {
  GetLayers() {
    const t = ro.getOrderOnGraph(this.graph), e = new Array(this.graph.nodeCount).fill(0);
    let i = this.graph.nodeCount;
    for (; i-- > 0; ) {
      const s = t[i];
      for (const n of this.graph.inEdges[s]) {
        const r = n.source, a = e[s] + n.separation;
        e[r] < a && (e[r] = a);
      }
    }
    return e;
  }
  checkTopoOrder(t) {
    for (const e of this.graph.edges)
      if (Bg(e, t))
        return !1;
    return !0;
  }
  constructor(t) {
    this.graph = t;
  }
}
function Bg(o, t) {
  const e = t.findIndex((s) => s === o.source), i = t.findIndex((s) => s === o.target);
  return e === -1 || i === -1 || e >= i;
}
class oe {
  constructor(t) {
    this.inTree = !1, this.cut = oe.infinity, this.iedge = t;
  }
  get source() {
    return this.iedge.source;
  }
  get target() {
    return this.iedge.target;
  }
  get separation() {
    return this.iedge.separation;
  }
  get crossingWeight() {
    return this.iedge.CrossingWeight;
  }
  get weight() {
    return this.iedge.weight;
  }
}
oe.infinity = Number.MAX_SAFE_INTEGER;
function Mg(o) {
  const t = new Array();
  for (const e of o.edges)
    t.push(new oe(e));
  return fi(t, o.nodeCount);
}
class Io {
  constructor(t, e, i, s, n) {
    this.v = t, this.outEnum = e, this.i = i, this.inEnum = s, this.j = n;
  }
}
class rc {
  get weight() {
    return this.graph.edges.map((t) => t.weight * (this.layers[t.source] - this.layers[t.target])).reduce((t, e) => t + e, 0);
  }
  get nodeCount() {
    return this.vertices.length;
  }
  setLow(t, e) {
    this.vertices[t].low = e;
  }
  setLim(t, e) {
    this.vertices[t].lim = e;
  }
  setParent(t, e) {
    this.vertices[t].parent = e;
  }
  constructor(t, e) {
    this.layers = null, this.treeVertices = [], this.vertices = [], this.leaves = [], this.graph = Mg(t), this.networkCancelToken = e;
    for (let i = 0; i < this.graph.nodeCount; i++)
      this.vertices.push({
        inTree: !1,
        lim: -1,
        low: -1,
        parent: null
      });
  }
  GetLayers() {
    return this.layers == null && this.run(), this.layers;
  }
  shiftLayerToZero() {
    const t = Math.min(...this.layers);
    for (let e = 0; e < this.layers.length; e++)
      this.layers[e] -= t;
  }
  addVertexToTree(t) {
    this.vertices[t].inTree = !0;
  }
  vertexInTree(t) {
    return this.vertices[t].inTree;
  }
  lim(t) {
    return this.vertices[t].lim;
  }
  low(t) {
    return this.vertices[t].low;
  }
  parent(t) {
    return this.vertices[t].parent;
  }
  // The function feasibleTree constructs an initial feasible spanning tree.
  feasibleTree() {
    for (this.initLayers(); this.tightTree() < this.nodeCount; ) {
      const t = this.getNonTreeEdgeIncidentToTheTreeWithMinimalAmountOfSlack();
      if (t == null)
        break;
      let e = this.slack(t);
      this.vertexInTree(t.source) && (e = -e);
      for (const i of this.treeVertices)
        this.layers[i] += e;
    }
    this.initCutValues();
  }
  // A treeEdge, belonging to the tree, divides the vertices to source and target components
  // If v belongs to the source component we return 1
  // otherwise we return 0
  vertexSourceTargetVal(t, e) {
    const i = e.source, s = e.target;
    return this.lim(i) > this.lim(s) ? this.lim(t) <= this.lim(s) && this.low(s) <= this.lim(t) ? 0 : 1 : this.lim(t) <= this.lim(i) && this.low(i) <= this.lim(t) ? 1 : 0;
  }
  // a convenient wrapper of IncEdges incident to v
  incidentEdges(t) {
    return this.graph.incidentEdges(t);
  }
  allLowCutsHaveBeenDone(t) {
    for (const e of this.incidentEdges(t))
      if (e.inTree && e.cut === oe.infinity && e !== this.parent(t))
        return !1;
    return !0;
  }
  // treeEdge, belonging to the tree, divides the vertices to source and target components
  // e does not belong to the tree . If e goes from the source component to target component
  // then the return value is 1,
  // if e goes from the target component ot the source then the return value is -1
  // otherwise return zero
  edgeSourceTargetVal(t, e) {
    return this.vertexSourceTargetVal(t.source, e) - this.vertexSourceTargetVal(t.target, e);
  }
  // initCutValues computes the cut values of the tree edges.
  // For each tree edge, this is computed by marking the nodes as belonging to the source or
  // target component, and then performing the sum of the signed weights of all
  // edges whose source and target are in different components, the sign being negative for those edges
  // going from the source to the target component.
  // To reduce this cost, we note that the cut values can be computed using information local to an edge
  // if the search is ordered from the leaves of the feasible tree inward. It is trivial to compute the
  // cut value of a tree edge with one of its endpoints a leaf in the tree,
  // since either the source or the target component consists of a single node.
  // Now, assuming the cut values are known for all the edges incident on a given
  // node except one, the cut value of the remaining edge is the sum of the known cut
  // values plus a term dependent only on the edges incident to the given node.
  initCutValues() {
    this.initLimLowAndParent();
    let t = new mt.Stack();
    for (const i of this.leaves)
      t.push(i);
    let e = new mt.Stack();
    for (; t.length > 0; ) {
      for (; t.length > 0; ) {
        const s = t.pop(), n = this.parent(s);
        if (n == null)
          continue;
        let r = 0;
        for (const l of this.incidentEdges(s))
          if (l.inTree === !1) {
            const h = this.edgeSourceTargetVal(l, n);
            h !== 0 && (r += h * l.weight);
          } else if (l === n)
            r += l.weight;
          else {
            const h = n.source === l.target || n.target === l.source ? 1 : -1, c = this.edgeContribution(l, s);
            r += c * h;
          }
        n.cut = r;
        const a = n.source === s ? n.target : n.source;
        this.allLowCutsHaveBeenDone(a) && e.push(a);
      }
      const i = t;
      t = e, e = i;
    }
  }
  // e is a tree edge for which the cut has been calculted already.
  // EdgeContribution gives an amount that edge e brings to the cut of parent(w).
  // The contribution is the cut value minus the weight of e. Let S be the component of e source.
  // We should also substruct W(ie) for every ie going from S to w and add W(ie) going from w to S.
  // These numbers appear in e.cut but with opposite signs.
  edgeContribution(t, e) {
    let i = t.cut - t.weight;
    for (const s of this.incidentEdges(e))
      if (s.inTree === !1) {
        const n = this.edgeSourceTargetVal(s, t);
        n === -1 ? i += s.weight : n === 1 && (i -= s.weight);
      }
    return i;
  }
  // A quote:
  // Another valuable optimization, similar to a technique described in [Ch],
  // is to perform a postorder traversal of the tree, starting from some fixed
  // root node vroot, and labeling each node v with its postorder
  // traversal number lim(v), the least number low(v) of any descendant in the search,
  // and the edge parent(v) by which the node was reached (see figure 2-5).
  // This provides an inexpensive way to test whether a node lies in the
  // source or target component of a tree edge, and thus whether a non-tree edge
  // crosses between the two components. For example, if e = (u,v) is a
  // tree edge and vroot is in the source component of the edge (i.e., lim(u) less lim(v)),
  // then a node w is in the target component of e if and only if low(u) is less or equal than lim(w)
  // is less or equal than lim(u). These numbers can also be used to update the tree efficiently
  // during the network simplex iterations. If f = (w,x) is the entering edge, the
  // only edges whose cut values must be adjusted are those in the path
  // connecting w and x in the tree. This path is determined by following
  // the parent edges back from w and x until the least common ancestor is reached,
  // i.e., the first node l such that low(l) is less or equal lim(w) than ,
  // lim(x) is less or equal than lim(l).
  // Of course, these postorder parameters must also be adjusted when
  // exchanging tree edges, but only for nodes below l.
  initLimLowAndParent() {
    this.initLowLimParentAndLeavesOnSubtree(1, 0);
  }
  // initializes lim and low in the subtree
  initLowLimParentAndLeavesOnSubtree(t, e) {
    const i = new mt.Stack();
    let s = this.graph.outEdges[e], n = -1, r = this.graph.inEdges[e], a = -1;
    for (i.push(new Io(e, s, n, r, a)), this.vertices[e].low = t; i.length > 0; ) {
      const l = i.pop();
      e = l.v, s = l.outEnum, n = l.i, r = l.inEnum, a = l.j;
      let h;
      do {
        for (h = !0; ++n < s.length; ) {
          const c = s[n];
          !c.inTree || this.vertices[c.target].low > 0 || (i.push(new Io(e, s, n, r, a)), e = c.target, this.setParent(e, c), this.setLow(e, t), s = this.graph.outEdges[e], n = -1, r = this.graph.inEdges[e], a = -1);
        }
        for (; ++a < r.length; ) {
          const c = r[a];
          if (!(!c.inTree || this.vertices[c.source].low > 0)) {
            i.push(new Io(e, s, n, r, a)), e = c.source, this.setLow(e, t), this.setParent(e, c), s = this.graph.outEdges[e], n = -1, r = this.graph.inEdges[e], a = -1, h = !1;
            break;
          }
        }
      } while (!h);
      this.setLim(e, t++), this.lim(e) === this.low(e) && this.leaves.push(e);
    }
  }
  // here we update values lim and low for the subtree with the root l
  updateLimLowLeavesAndParentsUnderNode(t) {
    const e = this.vertices[t].low, i = this.vertices[t].lim;
    this.leaves = [];
    for (let s = 0; s < this.nodeCount; s++)
      e <= this.vertices[s].lim && this.vertices[s].lim <= i ? this.setLow(s, 0) : this.low(s) === this.lim(s) && this.leaves.push(s);
    this.initLowLimParentAndLeavesOnSubtree(e, t);
  }
  slack(t) {
    return this.layers[t.source] - this.layers[t.target] - t.separation;
  }
  // one of the returned edge vertices does not belong to the tree but another does
  getNonTreeEdgeIncidentToTheTreeWithMinimalAmountOfSlack() {
    let t = null, e = oe.infinity;
    for (const i of this.treeVertices) {
      for (const s of this.graph.outEdges[i]) {
        if (this.vertexInTree(s.source) && this.vertexInTree(s.target))
          continue;
        const n = this.slack(s);
        if (n < e && (t = s, e = n, n === 1))
          return s;
      }
      for (const s of this.graph.inEdges[i]) {
        if (this.vertexInTree(s.source) && this.vertexInTree(s.target))
          continue;
        const n = this.slack(s);
        if (n < e && (t = s, e = n, n === 1))
          return s;
      }
    }
    return t;
  }
  // The function TightTree finds a maximal tree of tight edges containing
  // some fixed node and returns the number of nodes in the tree.
  // Note that such a maximal tree is just a spanning tree for the subgraph
  // induced by all nodes reachable from the fixed node in the underlying
  // undirected graph using only tight edges. In particular, all such trees have the same number of nodes.
  // The function also builds the tree. It returns the number of verices in the tight tree
  tightTree() {
    this.treeVertices = [];
    for (const e of this.graph.edges)
      e.inTree = !1;
    for (let e = 1; e < this.nodeCount; e++)
      this.vertices[e].inTree = !1;
    this.vertices[0].inTree = !0, this.treeVertices.push(0);
    const t = new mt.Stack();
    for (t.push(0); t.length > 0; ) {
      const e = t.pop();
      for (const i of this.graph.outEdges[e])
        this.vertexInTree(i.target) || this.layers[i.source] - this.layers[i.target] === i.separation && (t.push(i.target), this.addVertexToTree(i.target), this.treeVertices.push(i.target), i.inTree = !0);
      for (const i of this.graph.inEdges[e])
        this.vertexInTree(i.source) || this.layers[i.source] - this.layers[i.target] === i.separation && (t.push(i.source), this.addVertexToTree(i.source), this.treeVertices.push(i.source), i.inTree = !0);
    }
    return this.treeVertices.length;
  }
  // leaveEnterEdge finds a non-tree edge to replace e.
  // This is done by breaking the tree, by removing e, into
  // the source and the target componentx.
  // All edges going from the source component to the
  // target are considered for the replacement, and an edge with the minimum
  // slack being chosen. This maintains feasibility.
  leaveEnterEdge() {
    let t, e, i = 0;
    for (const r of this.graph.edges)
      r.inTree && r.cut < i && (i = r.cut, t = r);
    if (t == null)
      return null;
    let s = !1, n = oe.infinity;
    for (const r of this.graph.edges) {
      const a = this.slack(r);
      if (r.inTree === !1 && this.edgeSourceTargetVal(r, t) === -1 && (a < n || a === n && (s = Us(2) === 1))) {
        if (n = a, e = r, n === 0 && !s)
          break;
        s = !1;
      }
    }
    if (e == null)
      throw new Error();
    return { leaving: t, entering: e };
  }
  // If f = (w,x) is the entering edge, the
  // only edges whose cut values must be adjusted are those in the path
  // connecting w and x in the tree, excluding e. This path is determined by
  // following the parent edges back from w and x until the least common ancestor is
  // reached, i.e., the first node l such that low(l) less or equal lim(w) ,lim(x) less or equal lim(l).
  // Of course, these postorder parameters must also be adjusted when
  // exchanging tree edges, but only for nodes below l.
  // e - exiting edge, f - entering edge
  exchange(t, e) {
    const i = this.commonPredecessorOfSourceAndTargetOfF(e);
    this.createPathForCutUpdates(t, e, i), this.updateLimLowLeavesAndParentsUnderNode(i), this.updateCuts(t), this.updateLayersUnderNode(i);
  }
  updateLayersUnderNode(t) {
    const e = new mt.Stack();
    e.push(t);
    for (let i = 0; i < this.nodeCount; i++)
      this.low(t) <= this.lim(i) && this.lim(i) <= this.lim(t) && i !== t && (this.layers[i] = oe.infinity);
    for (; e.length > 0; ) {
      const i = e.pop();
      for (const s of this.graph.outEdges[i])
        s.inTree && this.layers[s.target] === oe.infinity && (this.layers[s.target] = this.layers[i] - s.separation, e.push(s.target));
      for (const s of this.graph.inEdges[i])
        s.inTree && this.layers[s.source] === oe.infinity && (this.layers[s.source] = this.layers[i] + s.separation, e.push(s.source));
    }
  }
  updateCuts(t) {
    let e = new mt.Stack(), i = new mt.Stack();
    for (e.push(t.source), e.push(t.target); e.length > 0; ) {
      for (; e.length > 0; ) {
        const n = e.pop(), r = this.parent(n);
        if (r == null || r.cut !== oe.infinity)
          continue;
        let a = 0;
        for (const h of this.incidentEdges(n))
          if (h.inTree === !1)
            a += this.edgeSourceTargetVal(h, r) * h.weight;
          else if (h === r)
            a += h.weight;
          else {
            const c = r.source === h.target || r.target === h.source ? 1 : -1, d = this.edgeContribution(h, n);
            a += d * c;
          }
        r.cut = a;
        const l = r.source === n ? r.target : r.source;
        this.allLowCutsHaveBeenDone(l) && i.push(l);
      }
      const s = e;
      e = i, i = s;
    }
  }
  createPathForCutUpdates(t, e, i) {
    let s = e.target;
    for (; s !== i; ) {
      const n = this.parent(s);
      n.cut = oe.infinity, s = n.source === s ? n.target : n.source;
    }
    e.cut = oe.infinity, t.inTree = !1, e.inTree = !0;
  }
  commonPredecessorOfSourceAndTargetOfF(t) {
    let e, i;
    this.lim(t.source) < this.lim(t.target) ? (e = this.lim(t.source), i = this.lim(t.target)) : (e = this.lim(t.target), i = this.lim(t.source));
    let s = t.source;
    for (; !(this.low(s) <= e && i <= this.lim(s)); ) {
      const n = this.parent(s);
      n.cut = oe.infinity, s = n.source === s ? n.target : n.source;
    }
    return s;
  }
  checkCutValues() {
    for (const t of this.graph.edges)
      if (t.inTree) {
        let e = 0;
        for (const i of this.graph.edges)
          e += this.edgeSourceTargetVal(i, t) * i.weight;
        t.cut !== e && console.log(Bt.String.format("cuts are wrong for {0}; should be {1} but is {2}", t, e, t.cut));
      }
  }
  initLayers() {
    const t = new Ng(this.graph);
    return this.layers = t.GetLayers();
  }
  run() {
    if (this.graph.edges.length === 0 && this.graph.nodeCount === 0)
      this.layers = [];
    else {
      this.feasibleTree();
      let t;
      for (; (t = this.leaveEnterEdge()) != null; )
        this.exchange(t.leaving, t.entering);
      this.shiftLayerToZero();
    }
  }
}
class Gg {
  GetLayers() {
    return new rc(this.graph, this.Cancel).GetLayers();
  }
  ShrunkComponent(t) {
    const e = [];
    for (const i of t) {
      const s = i[0], n = i[1];
      for (const r of this.graph.outEdges[s]) {
        const a = new Ye(n, t.get(r.target), r.edge);
        a.separation = r.separation, a.weight = r.weight, e.push(a);
      }
    }
    return new An(e, t.size);
  }
  constructor(t, e) {
    this.graph = t, this.Cancel = e;
  }
}
class Pe {
  // ToString
  toString() {
    return "la:ra " + this.la + " " + this.ra + " ta:ba " + this.ta + " " + this.ba + " x:y " + this.x_ + " " + this.y_;
  }
  // distance for the center of the node to its left boundary
  get leftAnchor() {
    return this.la;
  }
  set leftAnchor(t) {
    this.la = Math.max(t, 0);
  }
  // distance from the center of the node to its right boundary
  get rightAnchor() {
    return this.ra;
  }
  set rightAnchor(t) {
    this.ra = Math.max(t, 0);
  }
  // distance from the center of the node to its top boundary
  get topAnchor() {
    return this.ta;
  }
  set topAnchor(t) {
    this.ta = Math.max(t, 0);
  }
  get bottomAnchor() {
    return this.ba;
  }
  set bottomAnchor(t) {
    this.ba = Math.max(t, 0);
  }
  // Left boundary of the node
  get left() {
    return this.x_ - this.la;
  }
  // right boundary of the node
  get right() {
    return this.x_ + this.ra;
  }
  // top boundary of the node
  get top() {
    return this.y_ + this.ta;
  }
  set top(t) {
    this.y_ += t - this.ta;
  }
  // bottom of the node
  get bottom() {
    return this.y_ - this.ba;
  }
  set bottom(t) {
    this.y_ += t - this.ba;
  }
  get leftTop() {
    return new u(this.left, this.top);
  }
  get leftBottom() {
    return new u(this.left, this.bottom);
  }
  // this.right bottom of the node
  get rightBottom() {
    return new u(this.right, this.bottom);
  }
  get node() {
    return this.node_;
  }
  set node(t) {
    this.node_ = t, this.polygonalBoundary_ = null;
  }
  // Right top of the node
  get rightTop() {
    return new u(this.right, this.top);
  }
  constructor(t) {
    this.padding = 0, this.alreadySitsOnASpline = !1, this.labelIsToTheLeftOfTheSpline = !1, this.labelIsToTheRightOfTheSpline = !1, this.labelCornersPreserveCoefficient = t;
  }
  // constructor
  static mkAnchor(t, e, i, s, n, r) {
    const a = new Pe(r);
    return a.la = t, a.ra = e, a.ta = i, a.ba = s, a.node = n, a;
  }
  // the x position
  get x() {
    return this.x_;
  }
  set x(t) {
    this.polygonalBoundary_ = null, this.x_ = t;
  }
  get y() {
    return this.y_;
  }
  set y(t) {
    this.polygonalBoundary_ = null, this.y_ = t;
  }
  // Center of the node
  get origin() {
    return new u(this.x, this.y);
  }
  get width() {
    return this.la + this.ra;
  }
  get height() {
    return this.ta + this.ba;
  }
  // set to true if the anchor has been introduced for a label
  get hasLabel() {
    return this.labelIsToTheLeftOfTheSpline || this.labelIsToTheLeftOfTheSpline;
  }
  get LabelWidth() {
    if (this.labelIsToTheLeftOfTheSpline)
      return this.leftAnchor;
    if (this.labelIsToTheRightOfTheSpline)
      return this.rightAnchor;
    throw new Error();
  }
  // the polygon representing the boundary of a node
  get polygonalBoundary() {
    return this.polygonalBoundary_ != null ? this.polygonalBoundary_ : this.polygonalBoundary_ = Pe.pad(this.creatPolygonalBoundaryWithoutPadding(), this.padding);
  }
  static pad(t, e) {
    return e === 0 ? t : Pe.curveIsConvex(t) ? Pe.padConvexCurve(t, e) : Pe.padConvexCurve(t.boundingBox.perimeter(), e);
  }
  static padCorner(t, e, i, s, n) {
    const r = Pe.getPaddedCorner(e, i, s, n);
    t.addPoint(r.a), r.numberOfPoints === 2 && t.addPoint(r.b);
  }
  static padConvexCurve(t, e) {
    const i = new B();
    Pe.padCorner(i, t.endPoint.prev, t.endPoint, t.startPoint, e), Pe.padCorner(i, t.endPoint, t.startPoint, t.startPoint.next, e);
    for (let s = t.startPoint; s.next.next != null; s = s.next)
      Pe.padCorner(i, s, s.next, s.next.next, e);
    return i.closed = !0, i;
  }
  static getPaddedCorner(t, e, i, s) {
    const n = t.point, r = e.point, a = i.point, l = u.getTriangleOrientation(n, r, a) === L.Counterclockwise, h = r.sub(n), c = h.rotate((l ? -Math.PI : Math.PI) / 2).normalize(), d = h.normalize().add(r.sub(a).normalize());
    if (d.length < m.intersectionEpsilon)
      return {
        a: r.add(c.mul(s)),
        b: null,
        numberOfPoints: 1
      };
    const f = d.normalize().mul(s), p = f.rotate(Math.PI / 2), P = (s - f.dot(c)) / p.dot(c);
    return {
      a: f.add(p.mul(P)).add(r),
      b: f.sub(p.mul(P)).add(r),
      numberOfPoints: 2
      //number of points to add
    };
  }
  static *orientations(t) {
    yield u.getTriangleOrientation(t.endPoint.point, t.startPoint.point, t.startPoint.next.point), yield u.getTriangleOrientation(t.endPoint.prev.point, t.endPoint.point, t.startPoint.point);
    let e = t.startPoint;
    for (; e.next.next != null; )
      yield u.getTriangleOrientation(e.point, e.next.point, e.next.next.point), e = e.next;
  }
  static curveIsConvex(t) {
    let e = L.Collinear;
    for (const i of Pe.orientations(t))
      if (i !== L.Collinear) {
        if (e === L.Collinear)
          e = i;
        else if (i !== e)
          return !1;
      }
    return !0;
  }
  //private static number TurnAfterSeg(Curve curve, int i) {
  //   return Point.SignedDoubledTriangleArea(curve.segs[i].start, curve.segs[i].End, curve.segs[(i + 1) / curve.segs.Count].End);
  //}
  creatPolygonalBoundaryWithoutPadding() {
    return this.hasLabel ? this.labelIsToTheLeftOfTheSpline ? this.polygonOnLeftLabel() : this.polygonOnRightLabel() : this.nodeBoundary == null ? this.standardRectBoundary() : g.polylineAroundClosedCurve(this.nodeBoundary);
  }
  get nodeBoundary() {
    return this.node == null ? null : this.node.boundaryCurve;
  }
  standardRectBoundary() {
    const t = new B();
    return t.addPoint(this.leftTop), t.addPoint(this.rightTop), t.addPoint(this.rightBottom), t.addPoint(this.leftBottom), t.closed = !0, t;
  }
  polygonOnLeftLabel() {
    const t = this.left + (1 - this.labelCornersPreserveCoefficient) * this.LabelWidth;
    return B.mkClosedFromPoints([
      new u(t, this.top),
      this.rightTop,
      this.rightBottom,
      new u(t, this.bottom),
      new u(this.left, this.y)
    ]);
  }
  polygonOnRightLabel() {
    const t = this.right - (1 - this.labelCornersPreserveCoefficient) * this.LabelWidth;
    return B.mkClosedFromPoints([
      new u(t, this.top),
      new u(this.right, this.y),
      new u(t, this.bottom),
      this.leftBottom,
      this.leftTop
    ]);
  }
  move(t) {
    this.x += t.x, this.y += t.y;
  }
}
class cs {
  get CurrentEnumRightUp() {
    return (this.LR ? 0 : 1) + 2 * (this.BT ? 0 : 1);
  }
  // Returns true if v is a virtual vertex
  IsVirtual(t) {
    return t >= this.nOfOriginalVertices;
  }
  Source(t) {
    return this.BT ? t.Source : t.Target;
  }
  Target(t) {
    return this.BT ? t.Target : t.Source;
  }
  static CalculateXCoordinates(t, e, i, s, n) {
    new cs(t, e, i, s, n).Calculate();
  }
  Calculate() {
    this.SortInAndOutEdges(), this.RightUpSetup(), this.CalcBiasedAlignment(), this.LeftUpSetup(), this.CalcBiasedAlignment(), this.RightDownSetup(), this.CalcBiasedAlignment(), this.LeftDownSetup(), this.CalcBiasedAlignment(), this.HorizontalBalancing();
  }
  // We need to find a median of a vertex neighbors from a specific layer. That is, if we have a vertex v and edges (v,coeff), (v,side1), (v,cornerC)
  // going down, and X[coeff]<X[side1]<X[cornerC], then side1 is the median.
  // There is an algorithm that finds the median with expected linear number of steps,
  // see for example http://www.ics.uci.edu/~eppstein/161/960125.html. However, I think we are better off
  // with sorting, since we are taking median at least twice.
  // Notice, that the sorting should be done only for original vertices since dummy vertices
  // have only one incoming edge and one outcoming edge.
  // Consider here reusing the sorting that comes from the ordering step,
  // if it is not broken by layer insertions.
  SortInAndOutEdges() {
    this.FillLowMedians(), this.FillUpperMedins();
  }
  FillUpperMedins() {
    this.upperMedians = new Array(this.graph.NodeCount);
    for (let t = 0; t < this.graph.NodeCount; t++)
      this.FillUpperMediansForNode(t);
  }
  CompareByX(t, e) {
    return this.la.x[t] - this.la.x[e];
  }
  FillUpperMediansForNode(t) {
    let e = this.graph.InEdgesCount(t);
    if (e > 0) {
      const i = new Array(e);
      e = 0;
      for (const n of this.graph.InEdges(t))
        i[e++] = n.Source;
      i.sort((n, r) => this.CompareByX(n, r));
      const s = Math.floor(e / 2);
      s * 2 === e ? this.upperMedians[t] = new U(i[s - 1], i[s]) : this.upperMedians[t] = i[s];
    } else
      this.upperMedians[t] = -1;
  }
  FillLowMedians() {
    this.lowMedians = new Array(this.graph.NodeCount);
    for (let t = 0; t < this.graph.NodeCount; t++)
      this.FillLowMediansForNode(t);
  }
  FillLowMediansForNode(t) {
    let e = this.graph.OutEdgesCount(t);
    if (e > 0) {
      const i = new Array(e);
      e = 0;
      for (const n of this.graph.OutEdges(t))
        i[e++] = n.Target;
      i.sort((n, r) => this.CompareByX(n, r));
      const s = Math.floor(e / 2);
      s * 2 === e ? this.lowMedians[t] = new U(i[s - 1], i[s]) : this.lowMedians[t] = i[s];
    } else
      this.lowMedians[t] = -1;
  }
  HorizontalBalancing() {
    let t = -1;
    const e = new Array(4), i = new Array(4);
    let s = Number.MAX_VALUE;
    for (let r = 0; r < 4; r++) {
      const a = { a: 0, b: 0 };
      this.AssignmentBounds(r, a), e[r] = a.a, i[r] = a.b;
      const l = i[r] - e[r];
      l < s && (t = r, s = l);
    }
    for (let r = 0; r < 4; r++) {
      let a;
      if (cs.IsLeftMostAssignment(r) ? a = e[t] - e[r] : a = i[t] - i[r], this.x = this.xCoords[r], a !== 0)
        for (let l = 0; l < this.nOfVertices; l++)
          this.x[l] = this.x[l] + a;
    }
    const n = new Array(4);
    for (let r = 0; r < this.nOfVertices; r++)
      n[0] = this.xCoords[0][r], n[1] = this.xCoords[1][r], n[2] = this.xCoords[2][r], n[3] = this.xCoords[3][r], n.sort((a, l) => a - l), this.anchors[r].x = (n[1] + n[2]) / 2;
  }
  static IsLeftMostAssignment(t) {
    return t === 0 || t === 2;
  }
  AssignmentBounds(t, e) {
    if (this.nOfVertices === 0)
      e.a = 0, e.b = 0;
    else {
      this.x = this.xCoords[t], e.a = e.b = this.x[0];
      for (let i = 1; i < this.nOfVertices; i++) {
        const s = this.x[i];
        s < e.a ? e.a = s : s > e.b && (e.b = s);
      }
    }
  }
  CalcBiasedAlignment() {
    this.ConflictElimination(), this.Align();
  }
  LeftUpSetup() {
    this.LR = !1, this.BT = !0;
  }
  LeftDownSetup() {
    this.LR = !1, this.BT = !1;
  }
  RightDownSetup() {
    this.LR = !0, this.BT = !1;
  }
  RightUpSetup() {
    this.LR = !0, this.BT = !0;
  }
  // The code is written as if we go left up, but in fact the settings define the directions.
  //
  // We need to create a subgraph for alignment:
  // where no edge segments intersect, and every vertex has
  // at most one incoming and at most one outcoming edge.
  // This function marks edges to resolve conflicts with only one inner segment.
  // An inner segment is a segment between two dummy nodes.
  // We mark edges that later will not participate in the alignment.
  // Inner segments are preferred to other ones. So, in a conflict with one inner and one
  // non-inner edges we leave the inner edge to participate in the alignment.
  // At the moment we mark as not participating both of the two intersecting inner segments
  ConflictElimination() {
    this.RemoveMarksFromEdges(), this.MarkConflictingEdges();
  }
  // iterator
  *UpperEdgeMedians(t) {
    const e = this.BT ? this.upperMedians[t] : this.lowMedians[t];
    if (typeof e != "number") {
      const s = e;
      this.LR ? (yield s.x, yield s.y) : (yield s.y, yield s.x);
    } else {
      const s = e;
      s >= 0 && (yield s);
    }
  }
  // here we eliminate all constraints
  MarkConflictingEdges() {
    let t = this.LowerOf(0, this.h - 1);
    const e = t, i = this.UpperOf(0, this.h - 1), s = this.NextLower(i);
    for (; this.IsBelow(t, i); t = this.NextUpper(t))
      this.IsBelow(e, t) && this.IsBelow(t, s) && this.ConflictsWithAtLeastOneInnerEdgeForALayer(t);
  }
  // parameterized next upper
  NextUpper(t) {
    return this.BT ? t + 1 : t - 1;
  }
  // parameterized next lower
  NextLower(t) {
    return this.BT ? t - 1 : t + 1;
  }
  // parameterize highest of two numbers
  UpperOf(t, e) {
    return this.BT ? Math.max(t, e) : Math.min(t, e);
  }
  // parameterized lowest of a pair
  LowerOf(t, e) {
    return this.BT ? Math.min(t, e) : Math.max(t, e);
  }
  // returns parameterized below
  IsBelow(t, e) {
    return this.BT ? t < e : e < t;
  }
  // returns the "parameterized" left of the two positions
  LeftMost(t, e) {
    return this.LR ? Math.min(t, e) : Math.max(t, e);
  }
  // returns the "parameterized" right of the two positions
  RightMost(t, e) {
    return this.LR ? Math.max(t, e) : Math.min(t, e);
  }
  // Return true if i is to the left or equal to pos in a "parameterized" fasion
  IsNotRightFrom(t, e) {
    return this.LR ? t <= e : e <= t;
  }
  // Parameterized left relation
  IsLeftFrom(t, e) {
    return this.LR ? t < e : e < t;
  }
  // parameterized next right
  NextRight(t) {
    return this.LR ? t + 1 : t - 1;
  }
  // parameterized next left
  NextLeft(t) {
    return this.LR ? t - 1 : t + 1;
  }
  // // Eliminates conflicts with at least one inner edge inside of one layer
  // // <
  ConflictsWithAtLeastOneInnerEdgeForALayer(t) {
    if (t >= 0 && t < this.la.Layers.length) {
      const e = this.la.Layers[t];
      let i = null, s = this.LeftMost(0, e.length - 1);
      const n = this.RightMost(0, e.length - 1);
      for (; this.IsNotRightFrom(s, n) && i == null; s = this.NextRight(s))
        i = this.InnerEdgeByTarget(e[s]);
      if (i != null) {
        const r = this.Pos(this.Source(i));
        for (let l = this.LeftMost(0, e.length - 1); this.IsLeftFrom(l, s); l = this.NextRight(l))
          for (const h of this.InEdges(e[l]))
            this.IsLeftFrom(r, this.Pos(this.Source(h))) && this.MarkEdge(h);
        let a = this.Pos(this.Source(i));
        for (; this.IsNotRightFrom(s, n); ) {
          const l = this.AlignmentToTheRightOfInner(e, s, r);
          if (s = this.NextRight(s), l != null) {
            const h = this.Pos(this.Source(l));
            this.MarkEdgesBetweenInnerAndNewInnerEdges(e, i, l, a, h), i = l, a = h;
          }
        }
        for (let l = this.NextRight(this.Pos(this.Target(i))); this.IsNotRightFrom(l, n); l = this.NextRight(l))
          for (const h of this.InEdges(e[l]))
            this.IsLeftFrom(this.Pos(this.Source(h)), this.Pos(this.Source(i))) && this.MarkEdge(h);
      }
    }
  }
  InEdgeOfVirtualNode(t) {
    return this.BT ? this.graph.InEdgeOfVirtualNode(t) : this.graph.OutEdgeOfVirtualNode(t);
  }
  InEdges(t) {
    return this.BT ? this.graph.InEdges(t) : this.graph.OutEdges(t);
  }
  // // This function marks conflicting edges with targets positioned between innerEdge and newInnerEdge targets.
  // // <
  MarkEdgesBetweenInnerAndNewInnerEdges(t, e, i, s, n) {
    let r = this.NextRight(this.Pos(this.Target(e)));
    for (; this.IsLeftFrom(r, this.Pos(this.Target(i))); r = this.NextRight(r))
      for (const a of this.InEdges(t[r])) {
        const l = this.Pos(this.Source(a));
        this.IsLeftFrom(l, s) ? this.MarkEdge(a) : this.IsLeftFrom(n, l) && this.MarkEdge(a);
      }
  }
  // // Returns the inner non-conflicting edge incoming into i-th position
  // // of the layer or null if there is no such edge
  // // <
  AlignmentToTheRightOfInner(t, e, i) {
    if (this.NumberOfInEdges(t[e]) === 1) {
      let n = null;
      for (const r of this.InEdges(t[e]))
        n = r;
      return this.IsInnerEdge(n) && this.IsLeftFrom(i, this.Pos(n.Source)) ? n : null;
    }
    return null;
  }
  NumberOfInEdges(t) {
    return this.BT ? this.graph.InEdgesCount(t) : this.graph.OutEdgesCount(t);
  }
  Pos(t) {
    return this.la.x[t];
  }
  InnerEdgeByTarget(t) {
    if (this.IsVirtual(t)) {
      const e = this.InEdgeOfVirtualNode(t);
      if (this.IsVirtual(this.Source(e)))
        return e;
    }
    return null;
  }
  IsInnerEdge(t) {
    return this.IsVirtual(t.Source) && this.IsVirtual(t.Target);
  }
  RemoveMarksFromEdges() {
    this.markedEdges.clear();
  }
  // // private constructor
  // // <
  constructor(t, e, i, s, n) {
    this.xCoords = new Array(4), this.la = t, this.graph = e, this.nOfOriginalVertices = i, this.nOfVertices = this.graph.NodeCount, this.markedEdges = new ti(), this.h = this.la.Layers.length, this.root = new Array(this.nOfVertices), this.align = new Array(this.nOfVertices), this.anchors = s, this.nodeSep = n;
  }
  // Calculate the alignment based on the marked edges and greedily resolve the remaining conflicts on the fly, without marking
  Align() {
    this.CreateBlocks(), this.AssignCoordinatesByLongestPath();
  }
  AssignCoordinatesByLongestPath() {
    this.x = this.xCoords[this.CurrentEnumRightUp] = new Array(this.nOfVertices);
    const t = new Array();
    for (let s = 0; s < this.nOfVertices; s++)
      if (s === this.root[s]) {
        let n = s;
        do {
          const r = { neighbor: 0 };
          this.TryToGetRightNeighbor(n, r) && t.push(new Ye(s, this.root[r.neighbor], null)), n = this.align[n];
        } while (n !== s);
      }
    const e = fi(t, this.nOfVertices), i = ro.getOrderOnGraph(e);
    for (const s of i)
      if (s === this.root[s]) {
        let n = 0, r = !0, a = s;
        do {
          const l = { neighbor: 0 };
          this.TryToGetLeftNeighbor(a, l) && (r ? (n = this.x[this.root[l.neighbor]] + this.DeltaBetweenVertices(l.neighbor, a), r = !1) : n = this.RightMost(n, this.x[this.root[l.neighbor]] + this.DeltaBetweenVertices(l.neighbor, a))), a = this.align[a];
        } while (a !== s);
        this.x[s] = n;
      }
    for (const s of i)
      if (s === this.root[s] && e.inEdges[s].length === 0) {
        let n = s, r = this.RightMost(-cs.infinity, cs.infinity);
        const a = r;
        do {
          const l = { neighbor: 0 };
          this.TryToGetRightNeighbor(n, l) && (r = this.LeftMost(r, this.x[this.root[l.neighbor]] - this.DeltaBetweenVertices(n, l.neighbor))), n = this.align[n];
        } while (n !== s);
        a !== r && (this.x[s] = r);
      }
    for (let s = 0; s < this.nOfVertices; s++)
      s !== this.root[s] && (this.x[s] = this.x[this.root[s]]);
  }
  // returns true is u has a right neighbor on its layer
  TryToGetRightNeighbor(t, e) {
    const i = this.NextRight(this.Pos(t)), s = this.la.Layers[this.la.y[t]];
    return i >= 0 && i < s.length ? (e.neighbor = s[i], !0) : !1;
  }
  // returns true is u has a right neighbor on its layer
  TryToGetLeftNeighbor(t, e) {
    const i = this.NextLeft(this.Pos(t)), s = this.la.Layers[this.la.y[t]];
    return i >= 0 && i < s.length ? (e.neighbor = s[i], !0) : !1;
  }
  // Organizes the vertices into blocks. A block is a maximal path in the alignment subgraph.
  // The alignment is defined by array align. Every vertex is connected to the top vertex of
  // the block by using root array. The alignment is cyclic. If we start from a root vertex v and
  // apply align then we return to v at some point.
  CreateBlocks() {
    for (let e = 0; e < this.nOfVertices; e++)
      this.root[e] = this.align[e] = e;
    const t = this.LowerOf(0, this.h - 1);
    for (let e = this.NextLower(this.UpperOf(0, this.h - 1)); !this.IsBelow(e, t); e = this.NextLower(e)) {
      const i = this.la.Layers[e];
      let s = this.LeftMost(-1, this.la.Layers[this.NextUpper(e)].length);
      const n = this.RightMost(0, i.length - 1);
      for (let r = this.LeftMost(0, i.length - 1); this.IsNotRightFrom(r, n); r = this.NextRight(r)) {
        const a = i[r];
        for (const l of this.UpperEdgeMedians(a))
          if (!this.IsMarked(a, l) && this.IsLeftFrom(s, this.Pos(l))) {
            this.align[l] = a, this.root[a] = this.root[l], this.align[a] = this.root[l], s = this.Pos(l);
            break;
          }
      }
    }
  }
  IsMarked(t, e) {
    return this.BT ? this.markedEdges.hasxy(e, t) : this.markedEdges.hasxy(t, e);
  }
  MarkEdge(t) {
    this.markedEdges.addNN(t.Source, t.Target);
  }
  // Calculates the minimum separation between two neighboring vertices: if u is to the left of v on the same layer return positive
  // number, otherwise negative.
  DeltaBetweenVertices(t, e) {
    let i;
    if (this.Pos(t) > this.Pos(e)) {
      const s = t;
      t = e, e = s, i = -1;
    } else
      i = 1;
    return (this.anchors[t].rightAnchor + this.anchors[e].leftAnchor + this.nodeSep) * i;
  }
}
cs.infinity = 1e7;
class Fg extends ie {
  // weight multiplier for edges with two virtual nodes
  /* internal */
  constructor(t, e, i, s, n) {
    super(), this.weightMultiplierOfOriginalOriginal = 1, this.weightMultOfOneVirtual = 3, this.weightMultiplierOfTwoVirtual = 8, this.SetEdges(s, n), this.virtualVerticesStart = t.nodeCount, this.virtualVerticesEnd = e.NodeCount - 1, this.layeredGraph = e, this.layerArrays = i;
  }
  // following Gansner etc 93 returning weight multplier bigger if there are virtual nodes
  EdgeWeightMultiplier(t) {
    const e = t.source, i = t.target;
    if (e < this.layeredGraph.NodeCount && this.layerArrays.y[e] === this.layerArrays.y[i] && this.layerArrays.x[e] === this.layerArrays.x[i] + 1)
      return 0;
    let s = 0, n = -1, r = -1;
    for (const l of this.outEdges[e])
      r === -1 ? r = l.target : n = l.target;
    return r >= this.virtualVerticesStart && r <= this.virtualVerticesEnd && s++, n >= this.virtualVerticesStart && n <= this.virtualVerticesEnd && s++, s === 0 ? this.weightMultiplierOfOriginalOriginal : s === 1 ? this.weightMultOfOneVirtual : this.weightMultiplierOfTwoVirtual;
  }
  // caching edges weights
  SetEdgeWeights() {
    for (const t of this.edges)
      t.weight = t.weight * this.EdgeWeightMultiplier(t);
  }
}
var _t;
(function(o) {
  o[o.Top = 0] = "Top", o[o.Internal = 1] = "Internal", o[o.Bottom = 2] = "Bottom";
})(_t || (_t = {}));
class Vs {
  static Calculate(t, e = 0) {
    return new Vs(t, e).Calculate();
  }
  constructor(t, e) {
    this.groupSplitThreshold = 2, this.initialNodes = t, this.groupSplitThreshold = e;
  }
  Calculate() {
    return this.Calc(this.initialNodes);
  }
  Calc(t) {
    if (t.length === 0)
      return null;
    if (t.length === 1)
      return t[0];
    const e = t[0].parallelogram;
    let i = 1, s = Q.parallelogramOfTwo(e, t[i].parallelogram).area;
    for (let c = 2; c < t.length; c++) {
      const d = Q.parallelogramOfTwo(e, t[c].parallelogram).area;
      d > s && (i = c, s = d);
    }
    let n;
    for (let c = 0; c < t.length; c++)
      if (c !== i) {
        n = c;
        break;
      }
    s = Q.parallelogramOfTwo(t[i].parallelogram, t[n].parallelogram).area;
    for (let c = 0; c < t.length; c++) {
      if (c === i)
        continue;
      const d = Q.parallelogramOfTwo(t[i].parallelogram, t[c].parallelogram).area;
      d > s && (n = c, s = d);
    }
    const r = new Array(), a = new Array();
    r.push(t[i]), a.push(t[n]);
    let l = t[i].parallelogram, h = t[n].parallelogram;
    for (let c = 0; c < t.length; c++) {
      if (c === i || c === n)
        continue;
      const d = Q.parallelogramOfTwo(l, t[c].parallelogram), f = d.area - l.area, p = Q.parallelogramOfTwo(h, t[c].parallelogram), P = p.area - h.area;
      r.length * this.groupSplitThreshold < a.length ? (r.push(t[c]), l = d) : a.length * this.groupSplitThreshold < r.length ? (a.push(t[c]), h = p) : f < P ? (r.push(t[c]), l = d) : (a.push(t[c]), h = p);
    }
    return {
      parallelogram: Q.parallelogramOfTwo(l, h),
      node: { children: [this.Calc(r), this.Calc(a)] },
      seg: void 0,
      leafBoxesOffset: void 0
    };
  }
}
class pe {
  constructor(t, e, i, s, n, r, a, l) {
    this.topNode = t, this.bottomNode = e, this.topSite = i, this.bottomSite = i.next, this.currentTopSite = i, this.currentBottomSite = i.next, this.layerArrays = s, this.layeredGraph = n, this.originalGraph = r, this.anchors = a, this.layerSeparation = l;
  }
  static Refine(t, e, i, s, n, r, a, l) {
    new pe(t, e, i, n, r, a, s, l).Refine();
  }
  Refine() {
    for (this.Init(); this.InsertSites(); )
      ;
  }
  FixCorner(t, e, i) {
    if (t.equal(e))
      return e;
    const s = u.ClosestPointAtLineSegment(e, t, i);
    let n = e.sub(s);
    const r = Math.abs(n.y), a = this.layerSeparation / 2;
    return r > a && (n = n.mul(a / (r * 2))), n.add(e);
  }
  InsertSites() {
    return Us(2) === 0 ? this.CalculateNewTopSite() || this.CalculateNewBottomSite() : this.CalculateNewBottomSite() || this.CalculateNewTopSite();
  }
  // circimvating from the side
  CalculateNewBottomSite() {
    const t = this.currentBottomSite.point.sub(this.currentTopSite.point);
    let e = pe.absCotan(t), i, s = !1;
    for (const n of this.bottomCorners()) {
      const r = pe.absCotan(n.sub(this.currentBottomSite.point));
      r < e && (e = r, i = n, s = !0);
    }
    return s ? D(e, pe.absCotan(t)) ? !1 : (this.currentBottomSite = St.mkSiteSPS(this.currentTopSite, this.FixCorner(this.currentTopSite.point, i, this.currentBottomSite.point), this.currentBottomSite), !0) : !1;
  }
  static absCotan(t) {
    return Math.abs(t.x / t.y);
  }
  CalculateNewTopSite() {
    const t = this.currentBottomSite.point.sub(this.currentTopSite.point);
    let e = pe.absCotan(t), i, s = !1;
    for (const n of this.topCorners()) {
      const r = pe.absCotan(n.sub(this.currentTopSite.point));
      r < e && (e = r, i = n, s = !0);
    }
    return s ? D(e, pe.absCotan(t)) ? !1 : (this.currentTopSite = St.mkSiteSPS(this.currentTopSite, this.FixCorner(this.currentTopSite.point, i, this.currentBottomSite.point), this.currentBottomSite), !0) : !1;
  }
  // private CornerSite AvoidBottomLayer() {
  //    Point corner;
  //    if (StickingCornerFromTheBottomLayer(out corner)) {
  //        corner = FixCorner(this.currentTopSite.v, corner, this.currentBottomSite.v);
  //        return new CornerSite(this.currentTopSite, corner, this.currentBottomSite);
  //    } else
  //        return null;
  // }
  // private CornerSite AvoidTopLayer() {
  //    Point corner;
  //    if (StickingCornerFromTheTopLayer(out corner)) {
  //        corner = FixCorner(this.currentTopSite.v, corner, this.currentBottomSite.v);
  //        return new CornerSite(this.currentTopSite, corner, this.currentBottomSite);
  //    } else
  //        return null;
  // }
  // private bool StickingCornerFromTheTopLayer(out Point corner) {
  //    corner = this.currentBottomSite.v;
  //    foreach (Point l of this.topCorners()) {
  //        Point p = l;
  //        if (this.counterClockwise(ref currentTopSite.v, ref p, ref corner))
  //            corner = p;
  //    }
  //    return corner !== this.currentBottomSite.v;
  // }
  // private bool StickingCornerFromTheBottomLayer(out Point corner) {
  //    corner = this.currentTopSite.v;
  //    foreach (Point l of this.bottomCorners()) {
  //        Point p = l;
  //        if (this.counterClockwise(ref currentBottomSite.v, ref p, ref corner))
  //            corner = p;
  //    }
  //    return corner !== this.currentTopSite.v;
  // }
  Init() {
    this.IsTopToTheLeftOfBottom() ? (this.topCorners = () => this.CornersToTheRightOfTop(), this.bottomCorners = () => this.CornersToTheLeftOfBottom()) : (this.topCorners = () => this.CornersToTheLeftOfTop(), this.bottomCorners = () => this.CornersToTheRightOfBottom());
  }
  IsTopToTheLeftOfBottom() {
    return this.topSite.point.x < this.topSite.next.point.x;
  }
  *NodeCorners(t) {
    for (const e of this.anchors[t].polygonalBoundary.polylinePoints())
      yield e.point;
  }
  *CornersToTheLeftOfBottom() {
    const t = this.layerArrays.x[this.bottomNode], e = this.currentTopSite.point.x, i = this.currentBottomSite.point.x;
    for (const s of this.LeftFromTheNode(this.NodeLayer(this.bottomNode), t, _t.Bottom, e, i))
      for (const n of this.NodeCorners(s))
        n.y > this.currentBottomSite.point.y && pe.PossibleCorner(e, i, n) && (yield n);
  }
  *CornersToTheLeftOfTop() {
    const t = this.layerArrays.x[this.topNode], e = this.currentBottomSite.point.x, i = this.currentTopSite.point.x;
    for (const s of this.LeftFromTheNode(this.NodeLayer(this.topNode), t, _t.Top, e, i))
      for (const n of this.NodeCorners(s))
        n.y < this.currentTopSite.point.y && pe.PossibleCorner(e, i, n) && (yield n);
  }
  *CornersToTheRightOfBottom() {
    const t = this.layerArrays.x[this.bottomNode], e = this.currentBottomSite.point.x, i = this.currentTopSite.point.x;
    for (const s of this.RightFromTheNode(this.NodeLayer(this.bottomNode), t, _t.Bottom, e, i))
      for (const n of this.NodeCorners(s))
        n.y > this.currentBottomSite.point.y && pe.PossibleCorner(e, i, n) && (yield n);
  }
  *CornersToTheRightOfTop() {
    const t = this.layerArrays.x[this.topNode], e = this.currentTopSite.point.x, i = this.currentBottomSite.point.x;
    for (const s of this.RightFromTheNode(this.NodeLayer(this.topNode), t, _t.Top, e, i))
      for (const n of this.NodeCorners(s))
        n.y < this.currentTopSite.point.y && pe.PossibleCorner(e, i, n) && (yield n);
  }
  static PossibleCorner(t, e, i) {
    return i.x > t && i.x < e;
  }
  NodeLayer(t) {
    return this.layerArrays.Layers[this.layerArrays.y[t]];
  }
  IsLabel(t) {
    return this.anchors[t].hasLabel;
  }
  NodeUCanBeCrossedByNodeV(t, e) {
    return this.IsLabel(t) || this.IsLabel(e) ? !1 : !!(this.IsVirtualVertex(t) && this.IsVirtualVertex(e) && this.AdjacentEdgesIntersect(t, e));
  }
  AdjacentEdgesIntersect(t, e) {
    return this.Intersect(this.IncomingEdge(t), this.IncomingEdge(e)) || this.Intersect(this.OutcomingEdge(t), this.OutcomingEdge(e));
  }
  Intersect(t, e) {
    return (this.layerArrays.x[t.Source] - this.layerArrays.x[e.Source]) * (this.layerArrays.x[t.Target] - this.layerArrays.x[e.Target]) < 0;
  }
  IncomingEdge(t) {
    for (const e of this.layeredGraph.InEdges(t))
      return e;
    throw new Error();
  }
  // here u is a virtual vertex
  OutcomingEdge(t) {
    for (const e of this.layeredGraph.OutEdges(t))
      return e;
    throw new Error();
  }
  IsVirtualVertex(t) {
    return t >= this.originalGraph.shallowNodeCount;
  }
  *RightFromTheNode(t, e, i, s, n) {
    let r = 0, a = 0;
    i === _t.Bottom && (r = Number.MAX_VALUE), i === _t.Top && (a = Number.MAX_VALUE);
    const l = t[e];
    for (let h = e + 1; h < t.length; h++) {
      const c = t[h];
      if (this.NodeUCanBeCrossedByNodeV(c, l))
        continue;
      const d = this.anchors[c];
      if (d.left >= n)
        break;
      d.right > s && (d.topAnchor > a + m.distanceEpsilon ? (a = d.topAnchor, yield c) : d.bottomAnchor > r + m.distanceEpsilon && (r = d.bottomAnchor, yield c));
    }
  }
  *LeftFromTheNode(t, e, i, s, n) {
    let r = 0, a = 0;
    i === _t.Bottom && (r = Number.MAX_VALUE), i === _t.Top && (a = Number.MAX_VALUE);
    const l = t[e];
    for (let h = e - 1; h > -1; h--) {
      const c = t[h];
      if (this.NodeUCanBeCrossedByNodeV(c, l))
        continue;
      const d = this.anchors[c];
      if (d.right <= s)
        break;
      d.left < n && (d.topAnchor > a + m.distanceEpsilon ? (a = d.topAnchor, yield c) : d.bottomAnchor > r + m.distanceEpsilon && (r = d.bottomAnchor, yield c));
    }
  }
}
class qt {
  // Creates a smoothed polyline
  constructor(t, e, i, s, n, r, a) {
    this.thinRightNodes = new Array(), this.thinWestNodes = new Array(), this.database = a, this.edgePath = t, this.anchors = e, this.layerArrays = n, this.originalGraph = i, this.settings = s, this.layeredGraph = r, this.eastHierarchy = this.BuildEastHierarchy(), this.westHierarchy = this.BuildWestHierarchy();
  }
  BuildEastHierarchy() {
    const t = this.FindEastBoundaryAnchorCurves(), e = new Array();
    for (const i of t)
      e.push(i.pNodeOverICurve());
    return this.thinEastHierarchy = Vs.Calculate(this.thinRightNodes), Vs.Calculate(e);
  }
  BuildWestHierarchy() {
    const t = this.FindWestBoundaryAnchorCurves(), e = new Array();
    for (const i of t)
      e.push(i.pNodeOverICurve());
    return this.thinWestHierarchy = Vs.Calculate(this.thinWestNodes), Vs.Calculate(e);
  }
  FindEastBoundaryAnchorCurves() {
    const t = new Array();
    let e = 0;
    for (const i of this.edgePath) {
      let s = null;
      for (const n of this.EastBoundaryNodesOfANode(i, Ui.GetNodeKind(e, this.edgePath))) {
        const r = this.anchors[n];
        (s == null || s.origin.x > r.origin.x) && (s = r), t.push(r.polygonalBoundary);
      }
      s != null && this.thinRightNodes.push(v.mkLinePXY(s.origin, this.originalGraph.right, s.y).pNodeOverICurve()), e++;
    }
    return t;
  }
  FindWestBoundaryAnchorCurves() {
    const t = [];
    let e = 0;
    for (const i of this.edgePath.nodes()) {
      let s = -1;
      for (const n of this.LeftBoundaryNodesOfANode(i, Ui.GetNodeKind(e, this.edgePath)))
        (s === -1 || this.layerArrays.x[n] > this.layerArrays.x[s]) && (s = n), t.push(this.anchors[n].polygonalBoundary);
      if (s !== -1) {
        const n = this.anchors[s];
        this.thinWestNodes.push(v.mkLinePXY(n.origin, this.originalGraph.left, n.origin.y).pNodeOverICurve());
      }
      e++;
    }
    return t;
  }
  *FillRightTopAndBottomVerts(t, e, i) {
    let s = 0, n = 0;
    i === _t.Bottom ? s = Number.MAX_VALUE : i === _t.Top && (n = Number.MAX_VALUE);
    const r = t[e];
    for (let a = e + 1; a < t.length; a++) {
      const l = t[a], h = this.anchors[l];
      h.topAnchor > n ? this.NodeUCanBeCrossedByNodeV(l, r) || (n = h.topAnchor, h.bottomAnchor > s && (s = h.bottomAnchor), yield l) : h.bottomAnchor > s && (this.NodeUCanBeCrossedByNodeV(l, r) || (s = h.bottomAnchor, h.topAnchor > n && (n = h.topAnchor), yield l));
    }
  }
  *FillLeftTopAndBottomVerts(t, e, i) {
    let s = 0, n = 0;
    i === _t.Top ? n = Number.MAX_VALUE : i === _t.Bottom && (s = Number.MAX_VALUE);
    const r = t[e];
    for (let a = e - 1; a >= 0; a--) {
      const l = t[a], h = this.anchors[l];
      h.topAnchor > n + m.distanceEpsilon ? this.NodeUCanBeCrossedByNodeV(l, r) || (n = h.topAnchor, s = Math.max(s, h.bottomAnchor), yield l) : h.bottomAnchor > s + m.distanceEpsilon && (this.NodeUCanBeCrossedByNodeV(l, r) || (n = Math.max(n, h.topAnchor), s = h.bottomAnchor, yield l));
    }
  }
  IsVirtualVertex(t) {
    return t >= this.originalGraph.shallowNodeCount;
  }
  IsLabel(t) {
    return this.anchors[t].hasLabel;
  }
  NodeUCanBeCrossedByNodeV(t, e) {
    return this.IsLabel(t) || this.IsLabel(e) ? !1 : !!(this.IsVirtualVertex(t) && this.IsVirtualVertex(e) && this.EdgesIntersectSomewhere(t, e));
  }
  EdgesIntersectSomewhere(t, e) {
    return this.UVAreMiddlesOfTheSameMultiEdge(t, e) ? !1 : this.IntersectAbove(t, e) || this.IntersectBelow(t, e);
  }
  UVAreMiddlesOfTheSameMultiEdge(t, e) {
    return !!(this.database.MultipleMiddles.has(t) && this.database.MultipleMiddles.has(e) && this.SourceOfTheOriginalEdgeContainingAVirtualNode(t) === this.SourceOfTheOriginalEdgeContainingAVirtualNode(e));
  }
  SourceOfTheOriginalEdgeContainingAVirtualNode(t) {
    for (; this.IsVirtualVertex(t); )
      t = this.IncomingEdge(t).Source;
    return t;
  }
  IntersectBelow(t, e) {
    do {
      const i = this.OutcomingEdge(t), s = this.OutcomingEdge(e);
      if (this.Intersect(i, s))
        return !0;
      t = i.Target, e = s.Target;
    } while (this.IsVirtualVertex(t) && this.IsVirtualVertex(e));
    return t === e;
  }
  IntersectAbove(t, e) {
    do {
      const i = this.IncomingEdge(t), s = this.IncomingEdge(e);
      if (this.Intersect(i, s))
        return !0;
      t = i.Source, e = s.Source;
    } while (this.IsVirtualVertex(t) && this.IsVirtualVertex(e));
    return t === e;
  }
  Intersect(t, e) {
    const i = this.layerArrays.x[t.Source] - this.layerArrays.x[e.Source], s = this.layerArrays.x[t.Target] - this.layerArrays.x[e.Target];
    return i > 0 && s < 0 || i < 0 && s > 0;
  }
  IncomingEdge(t) {
    return this.layeredGraph.InEdgeOfVirtualNode(t);
  }
  // here u is a virtual vertex
  OutcomingEdge(t) {
    return this.layeredGraph.OutEdgeOfVirtualNode(t);
  }
  EastBoundaryNodesOfANode(t, e) {
    return this.FillRightTopAndBottomVerts(this.NodeLayer(t), this.layerArrays.x[t], e);
  }
  NodeLayer(t) {
    return this.layerArrays.Layers[this.layerArrays.y[t]];
  }
  LeftBoundaryNodesOfANode(t, e) {
    return this.FillLeftTopAndBottomVerts(this.NodeLayer(t), this.layerArrays.x[t], e);
  }
  getSpline(t) {
    return this.createRefinedPolyline(t), this.createSmoothedPolyline();
  }
  // Poly(): Curve {
  //  const c: Curve = new Curve()
  //  for (let s = this.headSite; s.next != null; s = s.next) {
  //    c.addSegment(
  //      new BezierSeg(s.point, Point.convSum(1 / 3, s.point, s.next.point), Point.convSum(2 / 3, s.point, s.next.point), s.next.point),
  //    )
  //  }
  //  return c
  // }
  get GetPolyline() {
    return new Tt(this.headSite);
  }
  LineSegIntersectBound(t, e) {
    const i = v.mkPP(t, e);
    return qt.CurveIntersectsHierarchy(i, this.westHierarchy) || qt.CurveIntersectsHierarchy(i, this.thinWestHierarchy) || qt.CurveIntersectsHierarchy(i, this.eastHierarchy) || qt.CurveIntersectsHierarchy(i, this.thinEastHierarchy);
  }
  SegIntersectWestBound(t, e) {
    return qt.SegIntersectsBound(t, e, this.westHierarchy) || qt.SegIntersectsBound(t, e, this.thinWestHierarchy);
  }
  SegIntersectEastBound(t, e) {
    return qt.SegIntersectsBound(t, e, this.eastHierarchy) || qt.SegIntersectsBound(t, e, this.thinEastHierarchy);
  }
  TryToRemoveInflectionCorner(t) {
    if (!t.s.next || !t.s.prev || t.s.turn === L.Counterclockwise && this.SegIntersectEastBound(t.s.prev, t.s.next) || t.s.turn === L.Clockwise && this.SegIntersectWestBound(t.s.prev, t.s.next)) {
      t.cut = !1, t.s = t.s.next;
      return;
    }
    const e = t.s.next;
    t.s.prev.next = e, e.prev = t.s.prev, t.s = e, t.cut = !0;
  }
  static SegIntersectsBound(t, e, i) {
    return qt.CurveIntersectsHierarchy(v.mkPP(t.point, e.point), i);
  }
  static CurveIntersectsHierarchy(t, e) {
    if (e == null || !Q.intersect(t.pNodeOverICurve().parallelogram, e.parallelogram))
      return !1;
    if (e.node.hasOwnProperty("children")) {
      const i = e.node;
      return qt.CurveIntersectsHierarchy(t, i.children[0]) || qt.CurveIntersectsHierarchy(t, i.children[1]);
    }
    return g.intersectionOne(t, e.seg, !1) != null;
  }
  static Flat(t) {
    return u.getTriangleOrientation(t.prev.point, t.point, t.next.point) === L.Collinear;
  }
  Reverse() {
    const t = new qt(this.edgePath, this.anchors, this.originalGraph, this.settings, this.layerArrays, this.layeredGraph, this.database);
    let e = this.headSite, i = null;
    for (; e != null; )
      t.headSite = e.clone(), t.headSite.next = i, i != null && (i.prev = t.headSite), i = t.headSite, e = e.next;
    return t;
  }
  createRefinedPolyline(t) {
    this.CreateInitialListOfSites();
    let e = this.headSite, i;
    for (let s = 0; s < this.edgePath.count; s++)
      i = e.next, this.RefineBeetweenNeighborLayers(e, this.EdgePathNode(s), this.EdgePathNode(s + 1)), e = i;
    this.TryToRemoveInflections(), t && this.OptimizeShortPath();
  }
  RefineBeetweenNeighborLayers(t, e, i) {
    pe.Refine(e, i, t, this.anchors, this.layerArrays, this.layeredGraph, this.originalGraph, this.settings.LayerSeparation);
  }
  CreateInitialListOfSites() {
    let t = this.headSite = St.mkSiteP(this.EdgePathPoint(0));
    for (let e = 1; e <= this.edgePath.count; e++)
      t = St.mkSiteSP(t, this.EdgePathPoint(e));
  }
  get TailSite() {
    let t = this.headSite;
    for (; t.next != null; )
      t = t.next;
    return t;
  }
  OptimizeForThreeSites() {
    const t = this.EdgePathNode(0), e = this.EdgePathNode(2), i = this.anchors[t], s = this.anchors[e];
    if (D(i.x, s.x))
      return;
    const n = { ax: i.x, bx: s.x, sign: 0 };
    if (!this.FindLegalPositions(i, s, n))
      return;
    const r = (i.y - s.y) / (i.bottom - s.top), a = 0.5 * (n.ax + n.bx), l = n.sign * ((n.ax - n.bx) * 0.5);
    n.ax = a + r * (l * n.sign), n.bx = a - r * (l * n.sign), this.headSite.point = new u(n.ax, i.y);
    const h = this.headSite.next, c = h.point.y;
    h.point = new u(this.MiddlePos(n.ax, n.bx, i, s, c), c), h.next.point = new u(n.bx, s.y);
    const d = this.anchors[this.EdgePathNode(1)];
    d.x = h.point.x;
  }
  OptimizeForTwoSites() {
    const t = this.EdgePathNode(0), e = this.EdgePathNode(1), i = this.anchors[t], s = this.anchors[e];
    if (D(i.x, s.x))
      return;
    const n = { ax: i.x, bx: s.x, sign: 0 };
    if (!this.FindPositions(i, s, n))
      return;
    const r = (i.y - s.y) / (i.bottom - s.top), a = 0.5 * (n.ax + n.bx), l = n.sign * ((n.ax - n.bx) * 0.5);
    n.ax = a + r * (l * n.sign), n.bx = a - r * (l * n.sign), this.headSite.point = new u(n.ax, i.y), this.headSite.next.point = new u(n.bx, s.y);
  }
  FindLegalPositions(t, e, i) {
    return this.FindPositions(t, e, i) ? this.PositionsAreLegal(i.ax, i.bx, i.sign, t, e, this.EdgePathNode(1)) : !1;
  }
  FindPositions(t, e, i) {
    let s, n;
    if (i.ax < i.bx ? (i.sign = 1, n = Math.max(i.ax, e.left), s = Math.min(t.right, i.bx)) : (i.sign = -1, n = Math.max(t.left, i.bx), s = Math.min(e.right, i.ax)), n <= s)
      i.bx = 0.5 * (n + s), i.ax = 0.5 * (n + s);
    else {
      if (this.OriginToOriginSegCrossesAnchorSide(t, e))
        return !1;
      i.sign === 1 ? (i.ax = t.right - 0.1 * t.rightAnchor, i.bx = e.left) : (i.ax = t.left + 0.1 * t.leftAnchor, i.bx = e.right);
    }
    return !0;
  }
  OriginToOriginSegCrossesAnchorSide(t, e) {
    const i = v.mkPP(t.origin, e.origin);
    return t.x < e.x && g.CurvesIntersect(i, v.mkPP(t.rightBottom, t.rightTop)) || g.CurvesIntersect(i, v.mkPP(e.leftBottom, t.leftTop)) || t.x > e.x && g.CurvesIntersect(i, v.mkPP(t.leftBottom, t.leftTop)) || g.CurvesIntersect(i, v.mkPP(e.rightBottom, t.rightTop));
  }
  OptimizeShortPath() {
    this.edgePath.count > 2 || (this.edgePath.count === 2 && this.headSite.next.next != null && this.headSite.next.next.next == null && this.anchors[this.EdgePathNode(1)].node == null ? this.OptimizeForThreeSites() : this.edgePath.count === 1 && this.OptimizeForTwoSites());
  }
  PositionsAreLegal(t, e, i, s, n, r) {
    if (!D(t, e) && (t - e) * i > 0)
      return !1;
    const a = this.anchors[r], l = this.MiddlePos(t, e, s, n, a.y);
    return this.MiddleAnchorLegal(l, r, a) ? !this.LineSegIntersectBound(new u(t, s.bottom), new u(e, n.top)) : !1;
  }
  MiddleAnchorLegal(t, e, i) {
    const s = this.NodeLayer(e), n = this.layerArrays.x[e], r = t - i.x;
    return !(n > 0 && this.anchors[s[n - 1]].right > r + i.left || n < s.length - 1 && this.anchors[s[n + 1]].left < r + i.right);
  }
  MiddlePos(t, e, i, s, n) {
    const r = i.y - n, a = n - s.y;
    return (t * r + e * a) / (r + a);
  }
  TryToRemoveInflections() {
    if (this.TurningAlwaySameDirection())
      return;
    let t = !0;
    for (; t; ) {
      t = !1;
      for (const e = { s: this.headSite, cut: !1 }; e.s; )
        this.TryToRemoveInflectionCorner(e), t = e.cut || t;
    }
  }
  TurningAlwaySameDirection() {
    let t = 0;
    for (let e = this.headSite.next; e != null && e.next != null; e = e.next) {
      const i = e.turn;
      if (t === 0)
        i > 0 ? t = 1 : i < 0 && (t = -1);
      else if (t * i < 0)
        return !1;
    }
    return !0;
  }
  EdgePathPoint(t) {
    return this.anchors[this.EdgePathNode(t)].origin;
  }
  EdgePathNode(t) {
    return t === this.edgePath.count ? this.edgePath.LayerEdges[this.edgePath.count - 1].Target : this.edgePath.LayerEdges[t].Source;
  }
  createSmoothedPolyline() {
    this.RemoveVerticesWithNoTurns();
    let t = new g();
    const e = this.headSite, i = g.findCorner(e);
    return i !== void 0 ? (this.createFilletCurve(t, { a: e, b: i.b, c: i.c }), t = this.ExtendCurveToEndpoints(t)) : t.addSegment(v.mkPP(this.headSite.point, this.TailSite.point)), t;
  }
  curveIsLegal(t) {
    return !0;
  }
  RemoveVerticesWithNoTurns() {
    for (; this.RemoveVerticesWithNoTurnsOnePass(); )
      ;
  }
  RemoveVerticesWithNoTurnsOnePass() {
    let t = !1;
    for (let e = this.headSite; e.next != null && e.next.next != null; e = e.next)
      qt.Flat(e.next) && (t = !0, e.next = e.next.next, e.next.prev = e);
    return t;
  }
  ExtendCurveToEndpoints(t) {
    let e = this.headSite.point;
    if (!u.closeDistEps(e, t.start)) {
      const i = new g();
      i.addSegs([v.mkPP(e, t.start), t]), t = i;
    }
    return e = this.TailSite.point, u.closeDistEps(e, t.end) || t.addSegment(v.mkPP(t.end, e)), t;
  }
  createFilletCurve(t, e) {
    for (; this.AddSmoothedCorner(e.a, e.b, e.c, t), e.a = e.b, e.b = e.c, e.b.next != null; )
      e.c = e.b.next;
  }
  AddSmoothedCorner(t, e, i, s) {
    let n = 0.5, r;
    do
      r = g.createBezierSeg(n, n, t, e, i), e.previouisBezierCoefficient = n, n /= 2;
    while (this.BezierSegIntersectsBoundary(r));
    if (n *= 2, n < 0.5) {
      n = 0.5 * (n + n * 2);
      const a = g.createBezierSeg(n, n, t, e, i);
      this.BezierSegIntersectsBoundary(a) || (e.nextBezierCoefficient = n, e.previouisBezierCoefficient = n, r = a);
    }
    s.segs.length > 0 && !u.closeDistEps(s.end, r.start) && s.addSegment(v.mkPP(s.end, r.start)), s.addSegment(r);
  }
  // getDebugCurvesForCorner(
  //  a: CornerSite,
  //  b: CornerSite,
  //  c: CornerSite,
  // ): //import{('../../math/geometry/debugCurve').}DebugCurve[] {
  //  let r = []
  //  r = r.concat(getHierDC(this.thinWestHierarchy, 'Red'))
  //  r = r.concat(getHierDC(this.westHierarchy, 'Orange'))
  //  r = r.concat(getHierDC(this.eastHierarchy, 'Blue'))
  //  r = r.concat(getHierDC(this.thinEastHierarchy, 'Green'))
  //  for (const a of this.anchors) {
  //    r.push(DebugCurve.mkDebugCurveTWCI(100, 0.3, 'Gray', a.polygonalBoundary))
  //  }
  //  r.push(
  //    DebugCurve.mkDebugCurveTWCI(
  //      100,
  //      2,
  //      'Blue',
  //      LineSegment.mkPP(a.point, b.point),
  //    ),
  //  )
  //  r.push(
  //    DebugCurve.mkDebugCurveTWCI(
  //      100,
  //      2,
  //      'Blue',
  //      LineSegment.mkPP(b.point, c.point),
  //    ),
  //  )
  //  const p = new Polyline()
  //  for (let i = 0; i <= this.edgePath.count; i++) {
  //    p.addPoint(this.EdgePathPoint(i))
  //  }
  //  r.push(DebugCurve.mkDebugCurveTWCI(100, 1, 'Yellow', p))
  //  return r
  // }
  BezierSegIntersectsBoundary(t) {
    return u.signedDoubledTriangleArea(t.B(0), t.B(1), t.B(2)) < 0 ? this.BezierSegIntersectsTree(t, this.thinWestHierarchy) || this.BezierSegIntersectsTree(t, this.westHierarchy) : this.BezierSegIntersectsTree(t, this.thinEastHierarchy) || this.BezierSegIntersectsTree(t, this.eastHierarchy);
  }
  BezierSegIntersectsTree(t, e) {
    if (e == null)
      return !1;
    if (Q.intersect(t.pNodeOverICurve().parallelogram, e.parallelogram))
      if (e.node.hasOwnProperty("children")) {
        const i = e.node;
        return this.BezierSegIntersectsTree(t, i.children[0]) || this.BezierSegIntersectsTree(t, i.children[1]);
      } else
        return qt.BezierSegIntersectsBoundary(t, e.seg);
    else
      return !1;
  }
  static BezierSegIntersectsBoundary(t, e) {
    for (const i of g.getAllIntersections(t, e, !1))
      if (e instanceof g) {
        const s = e;
        if (g.realCutWithClosedCurve(i, s, !1))
          return !0;
      } else
        return !0;
    return !1;
  }
}
class Ui extends lt {
  constructor(t, e, i, s, n, r) {
    super(null), this.settings = t, this.OriginalGraph = e, this.Database = i, this.ProperLayeredGraph = n, this.LayerArrays = s, this.IntGraph = r;
  }
  // Executes the actual algorithm.
  run() {
    this.createSplines();
  }
  // The method does the main work.
  createSplines() {
    this.createRegularSplines(), this.createSelfSplines(), this.IntGraph != null && this.RouteFlatEdges(), this.OriginalGraph.graph.parent == null && this.RouteUnroutedEdges();
  }
  RouteUnroutedEdges() {
    const t = [];
    for (const r of this.OriginalGraph.deepEdges)
      r.curve || t.push(r);
    if (t.length == 0)
      return;
    const i = (this.OriginalGraph.layoutSettings ? this.OriginalGraph.layoutSettings : new en()).commonSettings.edgeRoutingSettings;
    new it(this.OriginalGraph, t, i.padding, i.polylinePadding, i.coneAngle, i.bundlingSettings, this.cancelToken).run(), z.constructorGA(this.OriginalGraph, t).run();
  }
  RouteFlatEdges() {
  }
  createRegularSplines() {
    for (const t of this.Database.RegularMultiedges()) {
      if (Vg(t))
        continue;
      const e = t.length, i = e === 1 && this.MayOptimizeEdge(t[0]);
      for (let s = Math.floor(e / 2); s < e; s++)
        this.createSplineForNonSelfEdge(t[s], i);
      for (let s = Math.floor(e / 2) - 1; s >= 0; s--)
        this.createSplineForNonSelfEdge(t[s], i);
    }
  }
  MayOptimizeEdge(t) {
    return !(this.ProperLayeredGraph.OutDegreeIsMoreThanOne(t.source) || this.ProperLayeredGraph.InDegreeIsMoreThanOne(t.target) || Nl(t.edge.source) || Nl(t.edge.target));
  }
  createSelfSplines() {
    for (const [t, e] of this.Database.Multiedges.keyValues()) {
      const i = t;
      if (i.x === i.y) {
        const s = this.Database.Anchors[i.x];
        let n = s.leftAnchor;
        for (const r of e) {
          const a = this.settings.NodeSeparation + (this.settings.MinNodeWidth + n), l = s.bottomAnchor / 2, h = s.origin, c = h.add(new u(0, l)), d = h.add(new u(a, l)), f = h.add(new u(a, -l)), p = h.add(new u(0, -l));
          let P = St.mkSiteP(h);
          const y = new Tt(P);
          P = St.mkSiteSP(P, c), P = St.mkSiteSP(P, d), P = St.mkSiteSP(P, f), P = St.mkSiteSP(P, p), St.mkSiteSP(P, h);
          const C = y.createCurve();
          if (r.curve = C, n = a, r.edge.label != null) {
            n += r.edge.label.width;
            const E = C.value((C.parStart + C.parEnd) / 2), N = new u(E.x + r.labelWidth / 2, s.y), I = new u(r.edge.label.width / 2, r.edge.label.height / 2), x = T.mkPP(N.add(I), N.sub(I));
            r.edge.label.width = x.width, r.edge.label.height = x.height, r.edge.label.positionCenter(N);
          }
          vt.trimSplineAndCalculateArrowheadsII(r.edge, r.edge.source.boundaryCurve, r.edge.target.boundaryCurve, C, !1);
        }
      }
    }
  }
  createSplineForNonSelfEdge(t, e) {
    t.LayerEdges != null && (this.drawSplineBySmothingThePolyline(t, e), t.IsVirtualEdge || (t.updateEdgeLabelPosition(this.Database.Anchors), vt.trimSplineAndCalculateArrowheadsII(t.edge, t.edge.source.boundaryCurve, t.edge.target.boundaryCurve, t.curve, !0)));
  }
  drawSplineBySmothingThePolyline(t, e) {
    const s = new qt(t, this.Database.Anchors, this.OriginalGraph, this.settings, this.LayerArrays, this.ProperLayeredGraph, this.Database).getSpline(e);
    t.reversed ? t.curve = s.reverse() : t.curve = s;
  }
  // void UpdateEdgeLabelPosition(LayerEdge[][] list, int i) {
  //    IntEdge e;
  //    int labelNodeIndex;
  //    if (Engine.GetLabelEdgeAndVirtualNode(list, i, out e, out labelNodeIndex)) {
  //        UpdateLabel(e, labelNodeIndex, db.Anchors);
  //    }
  // }
  static UpdateLabel(t, e) {
    let i = null;
    e.labelIsToTheRightOfTheSpline ? (t.label.positionCenter(new u(e.x + e.rightAnchor / 2, e.y)), i = v.mkPP(t.label.boundingBox.leftTop, t.label.boundingBox.leftBottom)) : e.labelIsToTheLeftOfTheSpline && (t.label.positionCenter(new u(e.x - e.leftAnchor / 2, e.y)), i = v.mkPP(t.label.boundingBox.rightTop, t.label.boundingBox.rightBottom));
    const s = Ui.GetSegmentInFrontOfLabel(t.curve, t.label.center.y);
    if (s != null && g.getAllIntersections(t.curve, g.polyFromBox(t.label.boundingBox), !1).length === 0) {
      const n = {
        curveClosestPoint: void 0,
        labelSideClosest: void 0
      };
      if (Ui.FindClosestPoints(n, s, i))
        Ui.ShiftLabel(t, n);
      else {
        const r = s.closestParameter(i.start), a = s.closestParameter(i.end);
        s.value(r).sub(i.start).length < s.value(a).sub(i.end).length ? (n.curveClosestPoint = s.value(r), n.labelSideClosest = i.start) : (n.curveClosestPoint = s.value(a), n.labelSideClosest = i.end), Ui.ShiftLabel(t, n);
      }
    }
  }
  static ShiftLabel(t, e) {
    const i = t.lineWidth / 2, s = e.curveClosestPoint.sub(e.labelSideClosest), n = s.length;
    n > i && t.label.positionCenter(t.label.center.add(s.div(n * (n - i))));
  }
  static FindClosestPoints(t, e, i) {
    const s = g.minDistWithinIntervals(e, i, e.parStart, e.parEnd, i.parStart, i.parEnd, (e.parStart + e.parEnd) / 2, (i.parStart + i.parEnd) / 2);
    return s ? (t.curveClosestPoint = s.aX, t.labelSideClosest = s.bX, !0) : !1;
  }
  static GetSegmentInFrontOfLabel(t, e) {
    if (t instanceof g) {
      const i = t;
      for (const s of i.segs)
        if ((s.start.y - e) * (s.end.y - e) <= 0)
          return s;
    }
    return null;
  }
  static GetNodeKind(t, e) {
    return t === 0 ? _t.Top : t < e.count ? _t.Internal : _t.Bottom;
  }
}
function Vg(o) {
  if (o.length < 4)
    return !1;
  for (const t of o)
    if (t.edge.label)
      return !1;
  return !0;
}
function Nl(o) {
  return o.node.selfEdges.size > 0;
}
class oc extends lt {
  /** return true if the ratio is less than 1/50 or greater than 50 */
  get extremeAspectRatio() {
    const t = this.originalGraph.boundingBox, e = t.width / t.height;
    return e < 1 / 50 || e > 50;
  }
  get verticalConstraints() {
    return this.sugiyamaSettings.verticalConstraints;
  }
  get HorizontalConstraints() {
    return this.sugiyamaSettings.horizontalConstraints;
  }
  constructor(t, e, i) {
    if (super(i), this.LayersAreDoubled = !1, t == null)
      return;
    this.originalGraph = t, this.sugiyamaSettings = e;
    const s = Array.from(t.shallowNodes);
    this.nodeIdToIndex = /* @__PURE__ */ new Map();
    let n = 0;
    for (const a of s)
      this.nodeIdToIndex.set(a.id, n++);
    const r = [];
    for (const a of this.originalGraph.shallowEdges) {
      const l = this.nodeIdToIndex.get(a.source.id);
      if (l == null)
        continue;
      const h = this.nodeIdToIndex.get(a.target.id);
      if (h == null)
        continue;
      const c = new Ye(l, h, a);
      r.push(c);
    }
    this.IntGraph = new An(r, t.shallowNodeCount), this.IntGraph.nodes = s, this.database = new Ag(s.length);
    for (const a of this.IntGraph.edges)
      this.database.registerOriginalEdgeInMultiedges(a);
    this.cycleRemoval();
  }
  run() {
    if (this.originalGraph.shallowNodeCount === 0) {
      this.originalGraph.boundingBox = T.mkEmpty();
      return;
    }
    Zg(this.originalGraph, this.sugiyamaSettings.transform), this.engineLayerArrays = this.calculateLayers(), this.sugiyamaSettings.edgeRoutingSettings.EdgeRoutingMode === Kt.SugiyamaSplines && this.runPostLayering(), $g(this.originalGraph, this.sugiyamaSettings.transform);
  }
  runPostLayering() {
    const t = this.sugiyamaSettings.commonSettings.edgeRoutingSettings, e = this.constrainedOrdering != null ? Kt.Spline : t.EdgeRoutingMode;
    this.extremeAspectRatio ? Yh(this.originalGraph, Array.from(this.originalGraph.deepEdges), this.cancelToken) : e === Kt.SugiyamaSplines ? this.calculateEdgeSplines() : tc(this.originalGraph, Array.from(this.originalGraph.deepEdges), this.cancelToken);
  }
  SetLabels() {
    throw new Error("not implementedt");
  }
  cycleRemoval() {
    const t = this.sugiyamaSettings.verticalConstraints, e = t.isEmpty ? Zi.getFeedbackSet(this.IntGraph) : t.getFeedbackSetExternal(this.IntGraph, this.nodeIdToIndex);
    this.database.addFeedbackSet(e);
  }
  calculateLayers() {
    this.CreateGluedDagSkeletonForLayering();
    const t = this.CalculateLayerArrays();
    return this.UpdateNodePositionData(), t;
  }
  UpdateNodePositionData() {
    for (let t = 0; t < this.IntGraph.nodeCount && t < this.database.Anchors.length; t++)
      this.IntGraph.nodes[t].center = this.database.Anchors[t].origin;
    if (this.sugiyamaSettings.GridSizeByX > 0)
      for (let t = 0; t < this.originalGraph.shallowNodeCount; t++)
        this.SnapLeftSidesOfTheNodeToGrid(t, this.sugiyamaSettings.GridSizeByX);
  }
  SnapLeftSidesOfTheNodeToGrid(t, e) {
    const i = this.IntGraph.nodes[t], s = this.database.Anchors[t];
    s.leftAnchor -= e / 2, s.rightAnchor -= e / 2;
    const n = i.boundingBox.left, r = Math.floor(n / e), a = n - r * e;
    Math.abs(a) < 1e-3 || (Math.abs(a) <= e / 2 ? i.center = i.center.add(new u(-a, 0)) : i.center = i.center.add(new u(e - a, 0)), s.x = i.center.x);
  }
  GetCurrentHeight() {
    const t = new zi();
    for (const e of this.NodeAnchors())
      t.AddValue(e.top), t.AddValue(e.bottom);
    return t.length;
  }
  *NodeAnchors() {
    const t = Math.min(this.IntGraph.nodeCount, this.anchors.length);
    for (let e = 0; e < t; e++)
      yield this.anchors[e];
  }
  GetCurrentWidth() {
    const t = new zi();
    for (const e of this.NodeAnchors())
      t.AddValue(e.left), t.AddValue(e.right);
    return t.length;
  }
  ExtendLayeringToUngluedSameLayerVertices(t) {
    const e = this.verticalConstraints;
    for (let i = 0; i < t.length; i++)
      t[i] = t[e.nodeToRepr(i)];
    return t;
  }
  calculateEdgeSplines() {
    new Ui(this.sugiyamaSettings, this.originalGraph, this.database, this.engineLayerArrays, this.properLayeredGraph, this.IntGraph).run();
  }
  YLayeringAndOrdering(t) {
    let e = t.GetLayers();
    Ia.Balance(this.gluedDagSkeletonForLayering, e, this.GetNodeCountsOfGluedDag(), null), e = this.ExtendLayeringToUngluedSameLayerVertices(e);
    let i = new Ni(e);
    if (this.HorizontalConstraints == null || this.HorizontalConstraints.IsEmpty)
      return i = this.YLayeringAndOrderingWithoutHorizontalConstraints(i), i;
    throw new Error("not implemented");
  }
  // Creating a proper layered graph, a graph where each
  // edge goes only one layer down from the i+1-th layer to the i-th layer.
  CreateProperLayeredGraph(t) {
    const e = t.length;
    let i = 0;
    for (const n of this.database.SkeletonEdges()) {
      const r = Hg(t, n);
      r > 0 && (n.LayerEdges = new Array(r));
      let a = 0;
      if (r > 1) {
        let l = e + i++, h = new ji(n.source, l, n.CrossingWeight, n.weight);
        n.LayerEdges[a++] = h;
        for (let c = 0; c < r - 2; c++)
          l++, i++, h = new ji(l - 1, l, n.CrossingWeight, n.weight), n.LayerEdges[a++] = h;
        h = new ji(l, n.target, n.CrossingWeight, n.weight), n.LayerEdges[a] = h;
      } else if (r === 1) {
        const l = new ji(n.source, n.target, n.CrossingWeight, n.weight);
        n.LayerEdges[a] = l;
      }
    }
    const s = new Array(this.originalGraph.shallowNodeCount + i).fill(0);
    for (const n of this.database.SkeletonEdges())
      if (n.LayerEdges != null) {
        let r = t[n.source];
        s[n.source] = r--;
        for (const a of n.LayerEdges)
          s[a.Target] = r--;
      } else
        s[n.source] = t[n.source], s[n.target] = t[n.target];
    return this.properLayeredGraph = new gs(new An(Array.from(this.database.SkeletonEdges()), t.length)), this.properLayeredGraph.BaseGraph.nodes = this.IntGraph.nodes, new Ni(s);
  }
  YLayeringAndOrderingWithoutHorizontalConstraints(t) {
    const e = this.CreateProperLayeredGraph(t.y);
    return Fs.OrderLayers(this.properLayeredGraph, e, this.originalGraph.shallowNodeCount, this.sugiyamaSettings, this.cancelToken), zr.UpdateLayerArrays1(this.properLayeredGraph, e), e;
  }
  CalculateYLayers() {
    const t = this.YLayeringAndOrdering(new Gg(this.gluedDagSkeletonForLayering, this.cancelToken));
    return this.constrainedOrdering != null ? t : this.InsertLayersIfNeeded(t);
  }
  InsertLayersIfNeeded(t) {
    this.InsertVirtualEdgesIfNeeded(t);
    const e = this.AnalyzeNeedToInsertLayersAndHasMultiedges(t);
    if (e.needToInsertLayers) {
      const i = Wn.InsertLayers(this.properLayeredGraph, t, this.database, this.IntGraph);
      this.properLayeredGraph = i.layeredGraph, t = i.la, this.LayersAreDoubled = !0;
    } else if (e.multipleEdges) {
      const i = ps.InsertPaths(this.properLayeredGraph, t, this.database, this.IntGraph);
      this.properLayeredGraph = i.layeredGraph, t = i.la;
    }
    return this.RecreateIntGraphFromDataBase(), t;
  }
  RecreateIntGraphFromDataBase() {
    let t = new Array();
    for (const e of this.database.Multiedges.values())
      t = t.concat(e);
    this.IntGraph.SetEdges(t, this.IntGraph.nodeCount);
  }
  InsertVirtualEdgesIfNeeded(t) {
    if (this.constrainedOrdering == null) {
      for (const [e, i] of this.database.Multiedges.keyValues())
        if (i.length % 2 === 0 && t.y[e.x] - 1 === t.y[e.y]) {
          const s = new Zt(null), n = new Ye(e.x, e.y, s);
          n.IsVirtualEdge = !0, i.splice(i.length / 2, 0, n), this.IntGraph.addEdge(n);
        }
    }
  }
  AnalyzeNeedToInsertLayersAndHasMultiedges(t) {
    let e = !1, i = !1;
    for (const s of this.IntGraph.edges)
      if (s.hasLabel && t.y[s.source] !== t.y[s.target]) {
        e = !0;
        break;
      }
    if (e === !1 && this.constrainedOrdering == null) {
      for (const [s, n] of this.database.Multiedges.keyValues())
        if (n.length > 1 && (i = !0, t.y[s.x] - t.y[s.y] === 1)) {
          e = !0;
          break;
        }
    }
    return {
      needToInsertLayers: e,
      multipleEdges: i
    };
  }
  UseBrandesXCalculations(t) {
    return t.x.length >= this.sugiyamaSettings.BrandesThreshold;
  }
  CalculateAnchorsAndYPositions(t) {
    this.anchors = kg(this.database, this.properLayeredGraph, this.originalGraph, this.IntGraph, this.sugiyamaSettings), _g(t, 500, this.originalGraph, this.database, this.IntGraph, this.sugiyamaSettings, this.LayersAreDoubled);
  }
  // put some labels to the left of the splines if it makes sense
  OptimizeEdgeLabelsLocations() {
    for (let t = 0; t < this.anchors.length; t++) {
      const e = this.anchors[t];
      if (e.labelIsToTheRightOfTheSpline) {
        const i = this.GetSuccessorAndPredecessor(t);
        if (!Ug(e, i.predecessor, i.successor)) {
          const s = i.predecessor.origin.sub(e.origin).length + i.successor.origin.sub(e.origin).length, n = e.right - e.leftAnchor, r = new u(n, e.y);
          i.predecessor.origin.sub(r).length + i.successor.origin.sub(r).length < s && ac(e);
        }
      }
    }
  }
  GetSuccessorAndPredecessor(t) {
    let e;
    for (const s of this.properLayeredGraph.InEdges(t))
      e = s.Source;
    let i;
    for (const s of this.properLayeredGraph.OutEdges(t))
      i = s.Target;
    return {
      predecessor: this.anchors[e],
      successor: this.anchors[i]
    };
  }
  CalculateLayerArrays() {
    const t = this.CalculateYLayers();
    return this.constrainedOrdering == null ? (this.CalculateAnchorsAndYPositions(t), this.UseBrandesXCalculations(t) ? this.CalculateXPositionsByBrandes(t) : this.CalculateXLayersByGansnerNorth(t)) : this.anchors = this.database.Anchors, this.OptimizeEdgeLabelsLocations(), this.engineLayerArrays = t, this.StraightensShortEdges(), this.CalculateOriginalGraphBox(), t;
  }
  StretchToDesiredAspectRatio(t, e) {
    t > e ? this.StretchInYDirection(t / e) : t < e && this.StretchInXDirection(e / t);
  }
  StretchInYDirection(t) {
    const e = (this.originalGraph.boundingBox.top + this.originalGraph.boundingBox.bottom) / 2;
    for (const s of this.database.Anchors)
      s.bottomAnchor = s.bottomAnchor * t, s.topAnchor = s.topAnchor * t, s.y = e + t * (s.y - e);
    const i = this.originalGraph.height * t;
    this.originalGraph.boundingBox = new T({
      left: this.originalGraph.boundingBox.left,
      top: e + i / 2,
      right: this.originalGraph.boundingBox.right,
      bottom: e - i / 2
    });
  }
  StretchInXDirection(t) {
    const e = (this.originalGraph.boundingBox.left + this.originalGraph.boundingBox.right) / 2;
    for (const s of this.database.Anchors)
      s.leftAnchor = s.leftAnchor * t, s.rightAnchor = s.rightAnchor * t, s.x = e + t * (s.x - e);
    const i = this.originalGraph.width * t;
    this.originalGraph.boundingBox = new T({
      left: e - i / 2,
      top: this.originalGraph.boundingBox.top,
      right: e + i / 2,
      bottom: this.originalGraph.boundingBox.bottom
    });
  }
  CalculateOriginalGraphBox() {
    if (this.anchors.length === 0)
      return;
    const t = new T({
      left: this.anchors[0].left,
      top: this.anchors[0].top,
      right: this.anchors[0].right,
      bottom: this.anchors[0].bottom
    });
    for (let e = 1; e < this.anchors.length; e++) {
      const i = this.anchors[e];
      t.add(i.leftTop), t.add(i.rightBottom);
    }
    this.originalGraph.labelSize && this.originalGraph.addLabelToGraphBB(t), t.padEverywhere(this.originalGraph.margins), this.originalGraph.boundingBox = t;
  }
  StraightensShortEdges() {
    if (!(this.anchors.length < 20))
      for (; this.StraightenEdgePaths(); )
        ;
  }
  StraightenEdgePaths() {
    let t = !1;
    for (const e of this.database.AllIntEdges())
      e.LayerSpan === 2 && (t = this.ShiftVertexWithNeighbors(e.LayerEdges[0].Source, e.LayerEdges[0].Target, e.LayerEdges[1].Target) || t);
    return t;
  }
  ShiftVertexWithNeighbors(t, e, i) {
    const s = this.database.Anchors[t], n = this.database.Anchors[i], r = this.database.Anchors[e], a = (r.y - s.y) * ((n.x - s.x) / (n.y - s.y)) + s.x, l = 1e-4;
    return a > r.x + l ? this.TryShiftToTheRight(a, e) : a < r.x - l ? this.TryShiftToTheLeft(a, e) : !1;
  }
  TryShiftToTheLeft(t, e) {
    const i = this.engineLayerArrays.Layers[this.engineLayerArrays.y[e]], s = this.engineLayerArrays.x[e];
    if (s > 0) {
      const n = this.database.Anchors[i[s - 1]], r = Math.max(n.right + (this.sugiyamaSettings.NodeSeparation + this.database.Anchors[e].leftAnchor), t);
      return r < this.database.Anchors[e].x - 1 ? (this.database.Anchors[e].x = r, !0) : !1;
    }
    return this.database.Anchors[e].x = t, !0;
  }
  TryShiftToTheRight(t, e) {
    const i = this.engineLayerArrays.Layers[this.engineLayerArrays.y[e]], s = this.engineLayerArrays.x[e];
    if (s < i.length - 1) {
      const n = this.database.Anchors[i[s + 1]], r = Math.min(n.left - (this.sugiyamaSettings.NodeSeparation - this.database.Anchors[e].rightAnchor), t);
      return r > this.database.Anchors[e].x + 1 ? (this.database.Anchors[e].x = r, !0) : !1;
    }
    return this.database.Anchors[e].x = t, !0;
  }
  CalculateXLayersByGansnerNorth(t) {
    this.xLayoutGraph = this.CreateXLayoutGraph(t), this.CalculateXLayersByGansnerNorthOnProperLayeredGraph();
  }
  CalculateXLayersByGansnerNorthOnProperLayeredGraph() {
    const t = new rc(this.xLayoutGraph, null).GetLayers();
    for (let e = 0; e < this.database.Anchors.length; e++)
      this.anchors[e].x = t[e];
  }
  // // A quote from Gansner93.
  // // The method involves constructing an auxiliary graph as illustrated in figure 4-2.
  // // This transformation is the graphical analogue of the algebraic
  // // transformation mentioned above for removing the absolute values
  // // from the optimization problem. The nodes of the auxiliary graph G^ are the nodes of
  // // the original graph G plus, for every edge e in G, there is a new node ne.
  // // There are two kinds of edges in G^. One edge class encodes the
  // // cost of the original edges. Every edge e = (u,v) in G is replaced by two edges (ne ,u)
  // // and (ne, v) with d = 0 and w = w(e)W(e). The other class of edges separates nodes in the same layer.
  // // If v is the left neighbor of w, then G^ has an edge f = e(v,w) with d( f ) = r(v,w) and
  // // w( f ) = 0. This edge forces the nodes to be sufficiently
  // // separated but does not affect the cost of the layout.
  CreateXLayoutGraph(t) {
    let e = this.properLayeredGraph.NodeCount;
    const i = new Array();
    for (const n of this.properLayeredGraph.Edges) {
      const r = new Ye(e, n.Source, null), a = new Ye(e, n.Target, null);
      a.weight = n.Weight, r.weight = n.Weight, r.separation = 0, a.separation = 0, e++, i.push(r), i.push(a);
    }
    for (const n of t.Layers)
      for (let r = n.length - 1; r > 0; r--) {
        const a = n[r], l = n[r - 1], h = new Ye(a, l, null), c = this.database.Anchors[a], d = this.database.Anchors[l], f = c.leftAnchor + (d.rightAnchor + this.sugiyamaSettings.NodeSeparation);
        h.separation = Math.ceil(f + 0.5), i.push(h);
      }
    const s = new Fg(this.IntGraph, this.properLayeredGraph, t, i, e);
    return s.SetEdgeWeights(), s;
  }
  CalculateXPositionsByBrandes(t) {
    cs.CalculateXCoordinates(t, this.properLayeredGraph, this.originalGraph.shallowNodeCount, this.database.Anchors, this.sugiyamaSettings.NodeSeparation);
  }
  GluedDagSkeletonEdges() {
    const t = new Ji();
    for (const [i, s] of this.database.Multiedges.keyValues()) {
      if (i.isDiagonal())
        continue;
      const n = this.verticalConstraints.gluedIntEdge(s[0]);
      n.source !== n.target && t.set(n.source, n.target, n);
    }
    const e = Array.from(this.verticalConstraints.gluedUpDownIntConstraints.values()).map((i) => Wg(i, null));
    for (const i of e)
      t.set(i.source, i.target, i);
    return Array.from(t.values());
  }
  static CalcAnchorsForOriginalNode(t, e, i, s, n) {
    const r = {
      leftAnchor: 0,
      rightAnchor: 0,
      topAnchor: 0,
      bottomAnchor: 0
    };
    if (e.nodes != null) {
      const h = e.nodes[t];
      Yg(r, h, n);
    }
    Jg(t, r, s, n);
    const a = n.MinNodeWidth / 2;
    r.leftAnchor < a && (r.leftAnchor = a), r.rightAnchor < a && (r.rightAnchor = a);
    const l = n.MinNodeHeight / 2;
    r.topAnchor < l && (r.topAnchor = l), r.bottomAnchor < l && (r.bottomAnchor = l), i[t] = Pe.mkAnchor(r.leftAnchor, r.rightAnchor, r.topAnchor, r.bottomAnchor, e.nodes[t], n.LabelCornersPreserveCoefficient), i[t].padding = 1;
  }
  CreateGluedDagSkeletonForLayering() {
    this.gluedDagSkeletonForLayering = new An(this.GluedDagSkeletonEdges(), this.originalGraph.shallowNodeCount), this.SetGluedEdgesWeights();
  }
  SetGluedEdgesWeights() {
    const t = new Ji();
    for (const e of this.gluedDagSkeletonForLayering.edges)
      t.set(e.source, e.target, e);
    for (const [e, i] of this.database.Multiedges.keyValues())
      if (e.x !== e.y) {
        const s = this.verticalConstraints.gluedIntPair(e);
        if (s.x === s.y)
          continue;
        const n = t.get(s.x, s.y);
        for (const r of i)
          n.weight += r.weight;
      }
  }
  GetNodeCountsOfGluedDag() {
    return this.verticalConstraints.isEmpty ? new Array(this.IntGraph.nodeCount).fill(1) : this.verticalConstraints.getGluedNodeCounts();
  }
}
function Bl(o, t) {
  if (t === 0)
    return 0;
  const e = Math.floor(o / t), i = o - e * t;
  return Math.abs(i) < 1e-4 ? 0 : t - i;
}
function Dg(o, t) {
  for (const e of o)
    if (e < t)
      return !0;
  return !1;
}
function kg(o, t, e, i, s) {
  const n = o.Anchors = new Array(t.NodeCount);
  for (let r = 0; r < n.length; r++)
    n[r] = new Pe(s.LabelCornersPreserveCoefficient);
  for (let r = 0; r < e.shallowNodeCount; r++)
    oc.CalcAnchorsForOriginalNode(r, i, n, o, s);
  for (const r of o.AllIntEdges())
    if (r.LayerEdges != null) {
      for (const a of r.LayerEdges) {
        const l = a.Target;
        if (l !== r.target) {
          const h = n[l];
          o.MultipleMiddles.has(l) ? (h.leftAnchor = h.rightAnchor = wo() * 4, h.topAnchor = h.bottomAnchor = Ml(s) / 2) : (h.leftAnchor = h.rightAnchor = wo() / 2, h.topAnchor = h.bottomAnchor = Ml(s) / 2);
        }
      }
      if (r.hasLabel) {
        const a = r.LayerEdges[r.LayerEdges.length / 2].Source, l = n[a], h = r.labelWidth, c = r.labelHeight;
        l.rightAnchor = h, l.leftAnchor = wo() * 8, l.topAnchor < c / 2 && (l.topAnchor = l.bottomAnchor = c / 2), l.labelIsToTheRightOfTheSpline = !0;
      }
    }
  return n;
}
function wo() {
  return 1;
}
function Ml(o) {
  return o.MinNodeHeight * 1.5 / 8;
}
function Gl(o, t, e, i, s, n) {
  let r = 0;
  if (e > 0) {
    const a = Xg(t.Layers[e - 1], t.y, i);
    if (a.length) {
      const l = s.LayerSeparation / 3, h = n;
      r = Math.max(...a.map((c) => Qg(c, h, l, o)));
    }
  }
  return r;
}
function _g(o, t, e, i, s, n, r) {
  const a = i.Anchors;
  let l = e.margins.top + t, h = 0;
  for (const c of o.Layers) {
    let d = 0, f = 0;
    for (const E of c) {
      const N = a[E];
      N.bottomAnchor > d && (d = N.bottomAnchor), N.topAnchor > f && (f = N.topAnchor);
    }
    zg(c, d, f, e.shallowNodeCount, i.Anchors);
    const p = Gl(i, o, h, s, n, l), P = l + d + p;
    let y = P + f;
    if (jg(n)) {
      y += Bl(y, n.GridSizeByY);
      for (const E of c)
        a[E].top = y;
    } else if (qg(n)) {
      let E = P - d;
      E += Bl(E, E);
      for (const N of c)
        a[N].bottom = E, y = Math.max(a[N].top, y);
    } else
      for (const E of c)
        a[E].y = P;
    const C = n.ActualLayerSeparation(r);
    l = y + C, h++;
  }
  Gl(i, o, h, s, n, l);
}
function Wg(o, t) {
  const e = new Ye(o.x, o.y, t);
  return e.weight = 0, e.separation = 1, e;
}
function Hg(o, t) {
  return o[t.source] - o[t.target];
}
function zg(o, t, e, i, s) {
  if (Dg(o, i)) {
    for (const n of o)
      if (n >= i) {
        const r = s[n];
        r.bottomAnchor = t, r.topAnchor = e;
      }
  }
}
function jg(o) {
  return o.SnapToGridByY === Js.Top;
}
function qg(o) {
  return o.SnapToGridByY === Js.Bottom;
}
function Ug(o, t, e) {
  if (o.labelIsToTheRightOfTheSpline) {
    if (u.getTriangleOrientation(t.origin, o.origin, e.origin) === L.Clockwise)
      return !0;
    const i = o.leftAnchor, s = o.rightAnchor, n = o.x;
    return ac(o), u.getTriangleOrientation(t.origin, o.origin, e.origin) === L.Counterclockwise ? !0 : (o.x = n, o.leftAnchor = i, o.rightAnchor = s, o.labelIsToTheRightOfTheSpline = !0, o.labelIsToTheLeftOfTheSpline = !1, !1);
  }
  return !1;
}
function ac(o) {
  const t = o.right, e = o.leftAnchor;
  o.leftAnchor = o.rightAnchor, o.rightAnchor = e, o.x = t - o.rightAnchor, o.labelIsToTheLeftOfTheSpline = !0, o.labelIsToTheRightOfTheSpline = !1;
}
function Xg(o, t, e) {
  const i = new ti();
  for (const s of o)
    if (!(s >= e.nodeCount))
      for (const n of e.outEdges[s])
        t[n.source] === t[n.target] && i.addNN(n.source, n.target);
  return Array.from(i.values());
}
function Qg(o, t, e, i) {
  let s = 0;
  const n = i.GetMultiedgeI(o);
  for (const r of n) {
    s += e;
    const a = r.edge.label;
    a != null && (a.positionCenter(new u(a.center.x, t + s + a.height / 2)), s += a.height);
  }
  return s;
}
function Yg(o, t, e) {
  o.rightAnchor = o.leftAnchor = (t.width + e.GridSizeByX) / 2, o.topAnchor = o.bottomAnchor = t.height / 2;
}
function Jg(o, t, e, i) {
  const s = Kg(e, o, t, i);
  t.rightAnchor += s;
}
function Kg(o, t, e, i) {
  let s = 0;
  const n = o.GetMultiedge(t, t);
  if (n.length > 0) {
    for (const r of n)
      r.edge.label != null && (e.rightAnchor += r.edge.label.width, e.topAnchor < r.edge.label.height / 2 && (e.topAnchor = e.bottomAnchor = r.edge.label.height / 2));
    s += (i.NodeSeparation + i.MinNodeWidth) * n.length;
  }
  return s;
}
function Zg(o, t) {
  if (t.isIdentity())
    return;
  const e = t.inverse();
  for (const i of o.shallowNodes)
    i.transform(e);
  for (const i of o.shallowEdges)
    if (i.label != null) {
      const s = T.mkPP(e.multiplyPoint(new u(0, 0)), e.multiplyPoint(new u(i.label.width, i.label.height)));
      i.label.width = s.width, i.label.height = s.height;
    }
}
function $g(o, t) {
  if (!t.isIdentity()) {
    for (const e of o.shallowNodes)
      e.transform(t);
    for (const e of o.shallowEdges)
      if (e.label != null) {
        const i = T.mkPP(t.multiplyPoint(new u(0, 0)), t.multiplyPoint(new u(e.label.width, e.label.height)));
        e.label.width = i.width, e.label.height = i.height;
      }
    tp(o, t), o.graph.parent == null && (o.boundingBox = null);
  }
}
function tp(o, t) {
  for (const e of o.shallowEdges)
    e.label && e.label.transform(t), ep(t, e);
}
function ep(o, t) {
  if (t.curve != null) {
    t.curve = t.curve.transform(o);
    const e = t;
    e.sourceArrowhead != null && (e.sourceArrowhead.tipPosition = o.multiplyPoint(e.sourceArrowhead.tipPosition)), e.targetArrowhead != null && (e.targetArrowhead.tipPosition = o.multiplyPoint(e.targetArrowhead.tipPosition)), ip(t, o);
  }
}
function ip(o, t) {
  if (o.smoothedPolyline != null)
    for (let e = o.smoothedPolyline.headSite; e != null; e = e.next)
      e.point = t.multiplyPoint(e.point);
}
var fe = 63710088e-1, lc = {
  centimeters: fe * 100,
  centimetres: fe * 100,
  degrees: 360 / (2 * Math.PI),
  feet: fe * 3.28084,
  inches: fe * 39.37,
  kilometers: fe / 1e3,
  kilometres: fe / 1e3,
  meters: fe,
  metres: fe,
  miles: fe / 1609.344,
  millimeters: fe * 1e3,
  millimetres: fe * 1e3,
  nauticalmiles: fe / 1852,
  radians: 1,
  yards: fe * 1.0936
};
function sp(o, t, e = {}) {
  const i = { type: "Feature" };
  return (e.id === 0 || e.id) && (i.id = e.id), e.bbox && (i.bbox = e.bbox), i.properties = t || {}, i.geometry = o, i;
}
function Fl(o, t, e = {}) {
  if (!o)
    throw new Error("coordinates is required");
  if (!Array.isArray(o))
    throw new Error("coordinates must be an Array");
  if (o.length < 2)
    throw new Error("coordinates must be at least 2 numbers long");
  if (!Vl(o[0]) || !Vl(o[1]))
    throw new Error("coordinates must contain numbers");
  return sp({
    type: "Point",
    coordinates: o
  }, t, e);
}
function np(o, t = "kilometers") {
  const e = lc[t];
  if (!e)
    throw new Error(t + " units is invalid");
  return o * e;
}
function rp(o, t = "kilometers") {
  const e = lc[t];
  if (!e)
    throw new Error(t + " units is invalid");
  return o / e;
}
function Uo(o) {
  return o % (2 * Math.PI) * 180 / Math.PI;
}
function Ke(o) {
  return o % 360 * Math.PI / 180;
}
function Vl(o) {
  return !isNaN(o) && o !== null && !Array.isArray(o);
}
function Hn(o) {
  if (!o)
    throw new Error("coord is required");
  if (!Array.isArray(o)) {
    if (o.type === "Feature" && o.geometry !== null && o.geometry.type === "Point")
      return [...o.geometry.coordinates];
    if (o.type === "Point")
      return [...o.coordinates];
  }
  if (Array.isArray(o) && o.length >= 2 && !Array.isArray(o[0]) && !Array.isArray(o[1]))
    return [...o];
  throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
function hc(o, t, e = {}) {
  if (e.final === !0)
    return op(o, t);
  const i = Hn(o), s = Hn(t), n = Ke(i[0]), r = Ke(s[0]), a = Ke(i[1]), l = Ke(s[1]), h = Math.sin(r - n) * Math.cos(l), c = Math.cos(a) * Math.sin(l) - Math.sin(a) * Math.cos(l) * Math.cos(r - n);
  return Uo(Math.atan2(h, c));
}
function op(o, t) {
  let e = hc(t, o);
  return e = (e + 180) % 360, e;
}
function ap(o, t, e, i = {}) {
  const s = Hn(o), n = Ke(s[0]), r = Ke(s[1]), a = Ke(e), l = rp(t, i.units), h = Math.asin(
    Math.sin(r) * Math.cos(l) + Math.cos(r) * Math.sin(l) * Math.cos(a)
  ), c = n + Math.atan2(
    Math.sin(a) * Math.sin(l) * Math.cos(r),
    Math.cos(l) - Math.sin(r) * Math.sin(h)
  ), d = Uo(c), f = Uo(h);
  return s[2] !== void 0 ? Fl([d, f, s[2]], i.properties) : Fl([d, f], i.properties);
}
function cc(o, t, e = {}) {
  var i = Hn(o), s = Hn(t), n = Ke(s[1] - i[1]), r = Ke(s[0] - i[0]), a = Ke(i[1]), l = Ke(s[1]), h = Math.pow(Math.sin(n / 2), 2) + Math.pow(Math.sin(r / 2), 2) * Math.cos(a) * Math.cos(l);
  return np(
    2 * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h)),
    e.units
  );
}
var lp = cc;
function hp(o, t) {
  const e = cc(o, t), i = hc(o, t);
  return ap(o, e / 2, i);
}
var cp = hp;
function up(o) {
  return o > 180 ? o - 360 : o < -180 ? o + 360 : o;
}
function dp(o) {
  if (!o?.length)
    return null;
  const t = o[0];
  if (!t || t.length < 2)
    return null;
  const e = t[0];
  return { base: t[1], tip: e };
}
function fp(o) {
  if (!o?.length)
    return null;
  const t = o[o.length - 1];
  if (!t || t.length < 2)
    return null;
  const e = t[t.length - 1];
  return { base: t[t.length - 2], tip: e };
}
function Dl(o, t, e) {
  const [i, s] = o, [n, r] = t;
  if (!e) {
    const c = n - i, d = r - s;
    return Math.atan2(d, c) * 180 / Math.PI;
  }
  let a = up(n - i);
  const l = r - s, h = (s + r) / 2 * Math.PI / 180;
  return a *= Math.cos(h), Math.atan2(l, a) * 180 / Math.PI;
}
function gp(o, t) {
  const e = dp(o), i = fp(o);
  return !e || !i ? null : {
    start: Dl(e.base, e.tip, t),
    end: Dl(i.base, i.tip, t)
  };
}
function Fp(o) {
  return o.sort((t, e) => {
    const i = { Alerting: 1, Pending: 2, Normal: 3 }, s = t.newState.startsWith("Alerting") ? "Alerting" : t.newState.startsWith("Pending") ? "Pending" : "Normal", n = e.newState.startsWith("Alerting") ? "Alerting" : e.newState.startsWith("Pending") ? "Pending" : "Normal";
    return i[s] - i[n];
  });
}
function Vp(o) {
  let { graphA: t, graphB: e, panel: i, parPath: s, layerIdx: n, edgeId: r, dataRecord: a, commentsData: l, theme: h } = o;
  const { isLogic: c, graph: d } = i, { setEdge: f, findNode: p } = t, P = t.nodeCollection.findEdge, y = s[0], C = s.at(-1);
  if (typeof C != "string" || typeof y != "string")
    return;
  let E = p(y);
  if (!p(C) || !E)
    return;
  const I = [], x = [], V = [];
  if (s.forEach((ht, zt) => {
    if (typeof ht == "string") {
      const Gt = p(ht);
      if (Gt) {
        const te = Gt.data.wasmId;
        I.push(te), x.push(ht), V.push(ht);
      }
    } else !i.isLogic && Array.isArray(ht) && (I.push(void 0), V.push(ht));
  }), !I.length)
    return;
  const G = r ?? y + "-" + C;
  let X = P(G), $t;
  if (!X) {
    const ht = I;
    d.getEdgeVerticeIds.push([ht, n]), $t = d.getEdgeVerticeIds.length - 1;
    const zt = {
      dataRecord: a,
      parPath: V,
      edge_id: $t,
      edgeId: G
    }, Mt = [];
    if (c && x.length > 2) {
      const [Gt, te] = s.length ? uc(V, i.positions, p) : [];
      Gt.forEach((de, mi) => {
        const sn = mi ? "--" + mi : "", oo = G + sn, wa = de[0].item.id, ao = de.at(-1).item.id, nn = f(oo, wa, ao);
        nn && (nn.setData(zt), Mt.push(nn));
      });
    } else {
      if (X = f(G, y, C, e), !X) {
        console.warn("edge from rxdb not found in your datasource. Mixed namespaces? (edgeId, sourceId, targetId)", G, y, C);
        return;
      }
      X?.setData(zt), Mt.push(X);
    }
    d.getWasmId2Edges[$t] = Mt;
  }
  s.forEach((ht, zt) => {
    if (Array.isArray(ht) && ht.length > 2) {
      const Mt = ht[3], Gt = ht[4], te = Gt && h.visualization.getColorByName(Gt), { style: de, layerName: mi } = a || {};
      if (Mt !== void 0 && de) {
        const sn = {
          text: Mt,
          iconColor: te ?? "#4ec2fc",
          style: de,
          root: t,
          layerName: mi,
          index: zt,
          coords: ht.slice(0, 2),
          edge: X
        };
        l[G] || (l[G] = /* @__PURE__ */ new Map()), l[G].set(zt, sn);
      }
    }
  });
}
function uc(o, t, e) {
  if (o.length === 0)
    return [[]];
  const i = o.map((l, h) => typeof l == "string" ? e(l) : l).filter((l) => l), s = [], n = [];
  let r = [], a = [];
  for (let l = 0; l < i.length; l++) {
    const h = i[l], c = t[l];
    if (!c)
      continue;
    h.id && r.length > 0 && (r.push({ item: h, gIdx: l, coords: c }), a.push(t[l]), s.push(r), n.push(a), r = [], a = []), r.push({ item: h, gIdx: l, coords: c }), a.push(c);
  }
  return [s, n];
}
function pp(o) {
  return typeof o == "string";
}
function kl(o) {
  return o.map((t, e) => pp(t) ? e : -1).filter((t) => t !== -1);
}
function mp(o, t, e) {
  const i = kl(o);
  if (i.length < 2)
    return { parPath: o, wasmIds: t };
  e.length !== kl(o).length - 1 && console.warn("Polyline / segment mismatch", { polylines: e, parPath: o });
  const s = [], n = [];
  let r = 0;
  for (let l = 0; l < i.length - 1; l++) {
    const h = i[l];
    i[l + 1], s.push(o[h]), n.push(t[h]);
    const c = e[r++] ?? [];
    for (const d of c)
      s.push(d), n.push(void 0);
  }
  const a = i.at(-1);
  return s.push(o[a]), n.push(t[a]), { parPath: s, wasmIds: n };
}
function Pp(o) {
  const t = Zt.getGeom(o);
  return t?.source ? Array.from(t.getSmoothPolyPoints()).slice(1, -1).map((e) => [e.x, e.y]) : [];
}
function Dp(o) {
  const t = o.graph, e = Rt.getGeom(t);
  e.layoutSettings = new en(), e.layoutSettings.layerDirection = je.RL, e.layoutSettings.LayerSeparation = 60, e.layoutSettings.commonSettings.NodeSeparation = 40, ng(e);
  const { getEdgeVerticeIds: i, wasm2Edges: s } = t;
  s.forEach((n) => {
    const r = n[0], a = r.data.edge_id, l = r.data.parPath, h = i[a][0], c = n.map(Pp), { parPath: d, wasmIds: f } = mp(l, h, c);
    r.data.parPath = d, i[a][0] = f;
  });
  for (const n of e.deepEdges)
    n.source, n.target, n.curve;
  for (const n of e.nodesBreadthFirst) {
    const r = n.node;
    if (!r.data)
      continue;
    const { feature: a, wasmId: l } = r.data;
    o.positions[l * 2] = n.center.x, o.positions[l * 2 + 1] = n.center.y;
  }
}
function Sp(o, t, e, i, s) {
  const n = e - t, r = o * s;
  if (r === 0)
    return t + n * i;
  const a = n / r, l = a * a + 1, h = t, c = i;
  return Math.sqrt(c * (l - c)) * r + h;
}
function yp(o, t, e) {
  return e ? [
    (o[0] + t[0]) / 2,
    (o[1] + t[1]) / 2
  ] : cp(o, t).geometry.coordinates;
}
function kp(o, t, e = !0) {
  if (o.id) {
    const i = o.data.wasmId, s = t.positions[i * 2], n = t.positions[i * 2 + 1];
    if (s !== void 0 && !n !== void 0)
      return [s, n];
  } else if (Array.isArray(o))
    return e ? o.slice(0, 2) : o;
  return null;
}
function bp(o, t, e, i = !0) {
  return o.map((n, r) => {
    if (typeof n == "string") {
      const a = t[r], l = e[a * 2], h = e[a * 2 + 1];
      return l !== void 0 && !h !== void 0 ? [l, h] : [l, h];
    } else if (Array.isArray(n))
      return i ? n.slice(0, 2) : n;
    return null;
  }).filter((n) => n);
}
const _p = "#4ec2fc", vp = 1.5, Cp = "default", Ip = "#0a55a1", Wp = "#000000", Hp = "#299c46", zp = "#9acd32", jp = "#299C46", wp = "#ed8128", Ep = "#f53636", qp = "#ed473b", Ap = Ip, Up = "rgba(154, 205, 50)", Tp = "#9acd32", Xp = {
  color: Tp,
  lineWidth: vp,
  label: Cp
}, Qp = "#f0fc", Yp = "#e034b8cc", Jp = "#ffdd57e6", Kp = "#205299cc", Zp = "#ffd70033", $p = "#20529933", tm = "#ffd70026", em = "#42a4f533", im = "#e6ca5ce6", sm = "#dfff7bcc", nm = "#2fa1deb3", rm = "#f0f0f0", om = "#e0be8b", Eo = { Alerting: "#e0226e", Pending: "#ff9900", Normal: "#1b855e" }, am = "#cfe3d4", lm = 0.5, Ao = {
  255: [Eo.Alerting, "Alerting", [224, 34, 110, 254]],
  222: [Eo.Pending, "Pending", [255, 153, 0, 254]],
  111: [Eo.Normal, "Normal", [27, 133, 94, 254]]
}, hm = { Alerting: Ao[255], Pending: Ao[222], Normal: Ao[111] }, cm = 20, um = "new rule", dm = !0, fm = "", gm = "cisco/atm-switch", pm = -5, mm = 40, Pm = 45, Sm = 16, ym = 2, bm = {}, vm = {
  shape: "binary-feature-collection",
  points: {
    type: "Point",
    positions: { value: new Float64Array([]), size: 2 },
    featureIds: { value: new Uint32Array([]), size: 1 },
    globalFeatureIds: { value: new Uint32Array([]), size: 1 },
    properties: []
  },
  polygons: {
    type: "Polygon",
    positions: { value: new Float32Array(), size: 2 },
    featureIds: { value: new Uint16Array(), size: 1 },
    globalFeatureIds: { value: new Uint16Array(), size: 1 },
    polygonIndices: { value: new Uint16Array(), size: 1 },
    primitivePolygonIndices: { value: new Uint16Array(), size: 1 },
    properties: []
  },
  lines: {
    type: "LineString",
    positions: { value: new Float32Array(), size: 2 },
    featureIds: { value: new Uint16Array(), size: 1 },
    pathIndices: { value: new Uint16Array(), size: 1 },
    globalFeatureIds: { value: new Uint16Array(), size: 1 },
    properties: []
  }
}, Cm = [
  wp,
  Ep,
  Ap
], Im = "fixed", wm = ".", Em = 25, Am = "mapgl", Tm = "xy-namespaces", Om = "cmn", xm = "external", Lm = "annots & alerts query (built-in)", Rm = "source", Nm = {
  longitude: 0,
  latitude: 0,
  zoom: 1,
  yZoom: 2
};
var _l;
(function(o) {
  o.GeoJson = "geojson", o.Polygons = "polygons", o.Path = "path", o.Markers = "markers", o.Nodes = "nodes", o.Edges = "edges", o.Hyperedges = "routed", o.Clusters = "clusters", o.SVG = "icon", o.Circle = "circle", o.Label = "label", o.Comments = "comments", o.Hull = "convex-hull", o.Text = "text", o.Bboxes = "bboxes";
})(_l || (_l = {}));
class be extends pc {
  root;
  isLogic = !1;
  comments = {};
  wasm2Edges = [];
  wasm_edge_vertice_ids = [];
  groupCounts = /* @__PURE__ */ new Map();
  positionRanges = [];
  disposeAutorun = () => {
  };
  /** Version the graph. A version is a number that is incremented every time the graph is updated. */
  version = 0;
  /** Is a panel root graph */
  isRoot = !1;
  constructor(t = "__graph__", e = !1, i = !0) {
    super(t), this.isRoot = e, this.isLogic = i, this.findNode = this.findNode.bind(this), this.addNode = this.addNode.bind(this), this.setEdge = this.setEdge.bind(this), this._bumpVersion = this._bumpVersion.bind(this), this.setRoot = this.setRoot.bind(this), this.findNodeRecursive = this.findNodeRecursive.bind(this), Ch(this, {
      version: It,
      _bumpVersion: Ne,
      getVersion: li,
      getEdgesGeometry: li,
      getComments: li,
      groupCounts: It,
      getGroupCounts: li,
      addNode: Ne,
      setEdge: Ne,
      addToGroup: Ne,
      rmFromGroup: Ne
    });
  }
  addToGroup = (t, e) => {
    const i = this.groupCounts.get(t);
    i ? this.groupCounts.set(t, i + 1) : this.groupCounts.set(t, 1);
  };
  rmFromGroup = (t, e) => {
    const i = this.groupCounts.get(t);
    i && this.groupCounts.set(t, i - 1);
  };
  get getGroupCounts() {
    return this.groupCounts;
  }
  /// Untouched MSAGLJS graph
  remove(t) {
    this.nodeCollection.remove(t);
  }
  /** Removes itself from under the parent.
   *  Also removes all the edges leading out of the graph.
   */
  removeSubgraph() {
    const t = this.parent;
    t && t.removeNode(this);
    for (const e of this.outGoingEdges())
      e.attachedAtSource ? e.node.removeOutEdge(e.edge) : e.node.removeInEdge(e.edge);
  }
  /** returns the objects that show how the edge is adjacent to a node  that is outside of the graph */
  *outGoingEdges() {
    for (const t of this.outEdges) {
      const e = t.target;
      this.isAncestor(e) || (yield { edge: t, node: e, attachedAtSource: !1 });
    }
    for (const t of this.inEdges) {
      const e = t.source;
      this.isAncestor(e) || (yield { edge: t, node: e, attachedAtSource: !0 });
    }
    for (const t of this.nodesBreadthFirst) {
      for (const e of t.outEdges) {
        const i = e.target;
        i !== this && (this.isAncestor(i) || (yield { edge: e, node: i, attachedAtSource: !1 }));
      }
      for (const e of t.inEdges) {
        const i = e.source;
        i !== this && (this.isAncestor(i) || (yield { edge: e, node: i, attachedAtSource: !0 }));
      }
    }
  }
  isAncestor(t) {
    for (const e of t.getAncestors())
      if (e === this)
        return !0;
    return !1;
  }
  /**  Iterates over all connected components of the graph and for each component
   * returns all its nodes with "this" as the parent
   */
  *getClusteredConnectedComponents() {
    const t = /* @__PURE__ */ new Set(), e = new We.Queue();
    for (const i of this.nodesBreadthFirst) {
      if (t.has(i))
        continue;
      t.add(i), e.enqueue(i);
      const s = /* @__PURE__ */ new Set();
      do {
        const n = e.dequeue();
        n.parent === this && s.add(n);
        for (const r of this.reachableFrom(n))
          t.has(r) || (t.add(r), e.enqueue(r));
      } while (e.length > 0);
      yield Array.from(s);
    }
  }
  *reachableFrom(t) {
    for (const e of t.outEdges)
      yield e.target;
    for (const e of t.inEdges)
      yield e.source;
    t instanceof be && (yield* t.shallowNodes), t.parent != this && (yield t.parent);
  }
  hasSomeAttrOnIndex(t) {
    for (const e of this.nodesBreadthFirst)
      if (e.getAttr(t))
        return !0;
    for (const e of this.deepEdges)
      if (e.getAttr(t))
        return !0;
    return !1;
  }
  *graphs() {
    for (const t of this.nodeCollection.graphs)
      yield t;
  }
  noEmptySubgraphs() {
    for (const t of this.subgraphsBreadthFirst())
      if (t.shallowNodeCount === 0)
        return !1;
    return !0;
  }
  hasSubgraphs() {
    for (const t of this.shallowNodes)
      if (t instanceof be)
        return !0;
    return !1;
  }
  /** iterates breadth first  */
  *subgraphsBreadthFirst() {
    for (const t of this.nodesBreadthFirst)
      t instanceof be && (yield t);
  }
  isEmpty() {
    return this.shallowNodeCount === 0;
  }
  setEdge(t, e, i, s) {
    const n = this.nodeCollection.findShallow(e);
    if (n == null)
      return;
    const r = s ? s.nodeCollection.findShallow(i) : this.nodeCollection.findShallow(i);
    if (r == null)
      return;
    const a = new gc(t, n, r);
    return this.isLogic && new Zt(a), this.nodeCollection.addEdge(a), a;
  }
  /** Iterates over the nodes of the current graph but not entering the subgraphs.
  *  Yields the top subgraphs among the nodes as well
  */
  get shallowNodes() {
    return this.nodeCollection.nodesShallow;
  }
  /** Iterates over all the nodes of including the subgraphs.
   * The iteration happens in the breadth first pattern.
   */
  get nodesBreadthFirst() {
    return this.nodesBreadthFirst_();
  }
  /** iterates breadth first  */
  *nodesBreadthFirst_() {
    for (const t of this.nodeCollection.nodesShallow)
      yield t, t instanceof be && (yield* t.nodesBreadthFirst);
  }
  dispose() {
    this.disposeAutorun && this.disposeAutorun();
  }
  setRoot = (t) => {
    this.root = t;
  };
  /**
   * Finds the node with the givin id belonging to a graph or one of its subgraphs.
   */
  findNodeRecursive(t) {
    const e = this.nodeCollection.findShallow(t);
    if (e)
      return e;
    for (const i of this.shallowNodes)
      if (i instanceof be) {
        const s = i.findNodeRecursive(t);
        if (s)
          return s;
      }
    return null;
  }
  /** Returns a node belonging to this graph having the same id.
   * If a node with the given id belongs to a subgraph than it would no be returned.
   * To find such a deeper nested node use findNodeRecursive
   */
  findNode(t) {
    return this.nodeCollection.findShallow(t);
  }
  /** iterates over the edges of the graph which adjacent to the nodes of the graph:
   * not iterating over the subgraphs
   */
  get shallowEdges() {
    return this.nodeCollection.edges;
  }
  /** iterates over the edges of the graph including subgraphs */
  get deepEdges() {
    return this.deepEdgesIt();
  }
  *deepEdgesIt() {
    for (const t of this.nodesBreadthFirst) {
      for (const e of t.outEdges)
        yield e;
      for (const e of t.selfEdges)
        yield e;
      for (const e of t.inEdges)
        this.isAncestor(e.source) || (yield e);
    }
  }
  isConsistent() {
    return this.parent ? this.parent.isConsistent() : this.eachNodeIdIsUnique() && this.nodeCollection.isConsistent();
  }
  nodeIsConsistent(t) {
    return this.nodeCollection.nodeIsConsistent(t);
  }
  /** Detouches all the node's edges and removes the node from the graph.
   * This method does not change the parent of the node.
   */
  removeNode(t) {
    for (const e of t.outEdges)
      e.target.inEdges.delete(e);
    for (const e of t.inEdges)
      e.source.outEdges.delete(e);
    this.nodeCollection.remove(t);
    for (const e of this.subgraphsBreadthFirst())
      e.removeNode(t);
  }
  /** adds a node to the graph */
  addNode(t) {
    return fc.assert(this.findNodeRecursive(t.id) == null), t.parent = this, this.nodeCollection.addNode(t), t;
  }
  /// was private originally
  nodeCollection = new Ua();
  get shallowNodeCount() {
    return this.nodeCollection.nodeShallowCount;
  }
  get nodeCountDeep() {
    let t = this.nodeCollection.size;
    for (const e of this.shallowNodes)
      e instanceof be && (t += e.nodeCountDeep);
    return t;
  }
  get edgeCount() {
    return this.nodeCollection.edgeCount;
  }
  // If n has an ancestor which is the graph child then return it.
  // Otherwise return null
  liftNode(t) {
    for (; t != null && t.parent !== this; )
      t = t.parent;
    return t;
  }
  /** return the number of all edges in the graph, including the subgraphs */
  get deepEdgesCount() {
    let t = 0;
    for (const e of this.nodesBreadthFirst)
      t += e.outDegree + e.selfDegree;
    return t;
  }
  eachNodeIdIsUnique() {
    const t = /* @__PURE__ */ new Set();
    for (const e of this.nodesBreadthFirst) {
      if (t.has(e.id))
        return !1;
      t.add(e.id);
    }
    return !0;
  }
  /** returns all the nodes under graph and the edges with at least one end adjacent to the graph */
  *allElements() {
    for (const t of this.allSuccessorsWidthFirst()) {
      yield t;
      for (const e of t.selfEdges)
        yield e;
      for (const e of t.outEdges)
        yield e;
      for (const e of t.inEdges)
        this.isAncestor(e.source) || (yield e);
    }
    yield* this.edges;
  }
  *allSuccessorsWidthFirst() {
    for (const t of this.shallowNodes)
      yield t;
    for (const t of this.shallowNodes)
      t instanceof be && (yield* t.allSuccessorsWidthFirst());
  }
  *allSuccessorsDepthFirst() {
    for (const t of this.shallowNodes)
      t instanceof be && (yield* t.allSuccessorsDepthFirst()), yield t;
  }
  /**
   * Clean up all the nodes in the graph.
   */
  resetNodes = () => {
    this.nodeCollection = new Ua(), this.positionRanges = [];
  };
  get getNodes() {
    return this.nodeCollection.nodesShallow;
  }
  /**
   * Clean up everything in the graph.
   */
  reset = () => {
    this.resetNodes(), this.groupCounts = /* @__PURE__ */ new Map(), this.wasm2Edges = [], this.wasm_edge_vertice_ids = [];
  };
  /**
   * Trigger an update to the graph.
   */
  triggerUpdate = () => {
    this._bumpVersion();
  };
  /**
   * Check the equality of two graphs data by checking last update time stamp
   * @param  {Object} g Another graph to be compared against itself
   * @return {Bool}   True if the graph is the same as itself.
   */
  equals = (t) => !t || !(t instanceof be) ? !1 : this.version === t.version;
  _bumpVersion() {
    this.version += 1;
  }
  get getVersion() {
    return this.version;
  }
  get getComments() {
    return this.comments;
  }
  get getWasmId2Edges() {
    return this.wasm2Edges;
  }
  get getEdgeVerticeIds() {
    return this.wasm_edge_vertice_ids;
  }
  get getEdgesGeometry() {
    const t = {}, e = {}, s = this.root.panel.positions;
    return this.wasm2Edges.forEach((n, r) => {
      if (!n.length)
        return;
      const a = n[0], { source: l, data: h } = a, c = l.parent, d = this.findNode;
      if (!h)
        return;
      const f = h?.dataRecord;
      h?.edge_id;
      const { parPath: p } = h || {}, P = p[0];
      let y = p;
      const C = this.wasm_edge_vertice_ids[r][0];
      let E = bp(y, C, s, !0);
      const [N, I] = p.length ? uc(y, E, d) : [];
      let x = I;
      N.length || Array.isArray(p) && N.push([{
        item: P,
        gIdx: 0
      }, { item: p.at(-1), gIdx: 1 }]);
      const V = Zt.getGeom(a);
      if (V?.source && (V?.curve?.start ? x.forEach((rn, Jn) => {
        rn.length > 3 && (x[Jn] = rn.slice(1, -1));
      }) : (console.warn("Invalid controlPoints or polyPoints", P, a.id), x = [x])), !x.length)
        return;
      const G = f, X = gp(x, !this.isLogic), $t = {
        //id: counter,
        edgeId: a.id,
        type: "Feature",
        geometry: {
          type: "MultiLineString",
          coordinates: x
        },
        rowIndex: f?.rowIndex,
        // can't pick original index without explicitely stating it
        properties: {
          ...G ?? {},
          locName: P,
          segrPath: N,
          ...X ? { arrowAngles: X } : {}
        }
      }, ht = $t.properties, zt = x[0][0], Mt = x.at(-1).at(-1);
      e[c.id] || (e[c.id] = []), e[c.id].push($t), a.setLineId(e[c.id].length - 1);
      const { arcStyle: Gt } = ht, te = Gt?.arcConfig.height, de = { units: "meters" };
      function mi(rn, Jn) {
        const Ea = Jn[0] - rn[0], Aa = Jn[1] - rn[1];
        return Math.sqrt(Ea * Ea + Aa * Aa);
      }
      const sn = this.isLogic ? mi(zt, Mt) : lp(zt, Mt, de), oo = Sp(sn, 0, 0, 0.5, te !== void 0 ? te : 0.5), ao = [
        ...yp(zt, Mt, this.isLogic),
        oo
      ], nn = {
        sourcePosition: zt,
        targetPosition: Mt,
        midPoint: ao,
        properties: ht,
        edgeId: a.id
      };
      t[c.id] || (t[c.id] = []), t[c.id].push(nn);
    }), [e, t];
  }
}
class Bm {
  colType;
  layerName;
  __state = {};
  frameRefId;
  features = [];
  positionRanges = [];
  colorThresholds;
  useMockData = !1;
  groups = [];
  constructor(t, e) {
    this.colType = t, this.layerName = e, this.getState = this.getState.bind(this), this.setThresholds = this.setThresholds.bind(this), this.setFeatures = this.setFeatures.bind(this), this.setPositionRanges = this.setPositionRanges.bind(this), this.clear = this.clear.bind(this);
  }
  setGroups = (t) => {
    this.groups = t;
  };
  addGroup = (t) => {
    this.groups.push(t);
  };
  get getGroups() {
    return this.groups;
  }
  setThresholds = (t) => {
    this.colorThresholds = t ?? {};
  };
  setFeatures(t, e) {
    this.frameRefId = e, this.features = t;
  }
  setPositionRanges(t) {
    this.positionRanges = t;
  }
  getState() {
    return this.__state;
  }
  clear() {
    this.features = [];
  }
}
export {
  hm as ALERTING_NUMS,
  Eo as ALERTING_STATES,
  Ao as ALERT_MAP,
  Lm as ANNOTS_LABEL,
  om as ANNOT_CLUSTER_BK_COLOR,
  gr as AttributeRegistry,
  am as BBOX_OUTLINE_COLOR,
  lm as BBOX_OUTLINE_WIDTH,
  xm as CMN_NAMESPACE,
  Om as CMN_NAMESPACE_PREFIX,
  bp as CoordsConvert,
  pt as CurveFactory,
  Zp as DARK_AUTO_HIGHLIGHT,
  Jp as DARK_CENTER_PLOT,
  tm as DARK_HULL_HIGHLIGHT,
  rm as DEFAULT_CLUSTER_BK_COLOR,
  Pm as DEFAULT_CLUSTER_ICON_SIZE,
  Sm as DEFAULT_CLUSTER_MAX_ZOOM,
  mm as DEFAULT_CLUSTER_SCALE,
  Cp as DEFAULT_COLOR_LABEL,
  zp as DEFAULT_COLOR_PICKER,
  _p as DEFAULT_COMMENT_COLOR,
  Ep as DEFAULT_CRITICAL_COLOR,
  Yp as DEFAULT_EDIT_HANDLE_COLOR,
  fm as DEFAULT_ICON_NAME,
  gm as DEFAULT_ICON_NAME2,
  dm as DEFAULT_ICON_RULE_IS_COLLAPSED,
  um as DEFAULT_ICON_RULE_LABEL,
  cm as DEFAULT_ICON_SIZE,
  vp as DEFAULT_LINE_WIDTH,
  Tp as DEFAULT_NO_DATA_COLOR,
  Up as DEFAULT_NO_DATA_COLOR_RGBA,
  Ap as DEFAULT_NO_THRESHOLD_COLOR,
  qp as DEFAULT_NUMS_COLOR,
  Hp as DEFAULT_OK_COLOR,
  jp as DEFAULT_OK_COLOR_SELECTED,
  pm as DEFAULT_SVG_ICON_V_OFFSET,
  wp as DEFAULT_WARNING_COLOR,
  gc as Edge,
  Kt as EdgeRoutingMode,
  Qp as FEATURE_EDIT_HANDLE_COLOR,
  Im as FIXED_COLOR_LABEL,
  Bm as FeatSource,
  Wp as GLOBAL_BORDER_COLOR,
  Ip as GLOBAL_FILL_COLOR,
  Cm as GLOBAL_OVERRIDE_COLORS,
  Rt as GeomGraph,
  Jt as GeomNode,
  be as Graph,
  $p as LIGHT_AUTO_HIGHLIGHT,
  Kp as LIGHT_CENTER_PLOT,
  em as LIGHT_HULL_HIGHLIGHT,
  im as LINES_EDIT_HANDLE_COLOR,
  sm as LINES_SNAP_SOURCE_COLOR,
  nm as LINES_SNAP_TARGET_COLOR,
  je as LayerDirectionEnum,
  Rm as MOC_LOC_FIELD,
  Em as NS_PADDING,
  wm as NS_SEPARATOR,
  pc as Node,
  u as Point,
  Tm as RXDB_LOGIC_NAMESPACES,
  Am as RXDB_NS_PREFIX,
  ym as SEL_LINE_WIDTH_MULTIPLIER,
  kp as SingleCoordsConvert,
  en as SugiyamaLayoutSettings,
  Gp as TileMap,
  bm as blankHoverInfo,
  _l as colTypes,
  Nm as defViewState,
  Xp as defaultThreshold,
  vm as emptyBiCol,
  gp as getArrowAngles,
  hp as getMiddleCoords,
  ng as layoutGeomGraph,
  Vp as pushPath,
  Dp as runLayout,
  Fp as sortAnnotations
};
